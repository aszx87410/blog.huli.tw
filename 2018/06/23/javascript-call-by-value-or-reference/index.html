<!DOCTYPE html>
<html class="has-navbar-fixed-top" lang="zh-tw">
<head>
    <meta charset="utf-8">
<title>深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？ - Huli&#39;s blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1">


<link href="https://blog.huli.tw/2018/06/23/javascript-call-by-value-or-reference/" rel="alternate" hreflang="zh-TW" />


<link href="https://blog.huli.tw/2018/06/23/javascript-call-by-value-or-reference/" rel="alternate" hreflang="x-default" />


<link href="https://blog.huli.tw/2018/06/23/en/javascript-call-by-value-or-reference/" rel="alternate" hreflang="en" />
    




    
<link rel="canonical" href="https://blog.huli.tw/2018/06/23/javascript-call-by-value-or-reference/">
    





    <meta name="description" content="前言其實這週原本是要來寫淺拷貝跟深拷貝的差異以及實作，但在找資料的時候無意間又看到 call by value 與 call by reference 相關的文章，越研究發現越有趣。原本以為自己已經搞懂了這個問題，但沒想到看的資料越多，卻把自己弄的越糊塗。 要寫這篇文章其實有兩個不同的方式，一個是詳實記錄我研究這個問題的過程以及心中的疑惑，以及最後如何得到解答，簡單來說就是按照時間軸來寫；另外一個">
<meta property="og:type" content="article">
<meta property="og:title" content="深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？">
<meta property="og:url" content="https://blog.huli.tw/2018/06/23/javascript-call-by-value-or-reference/index.html">
<meta property="og:site_name" content="Huli&#39;s blog">
<meta property="og:description" content="前言其實這週原本是要來寫淺拷貝跟深拷貝的差異以及實作，但在找資料的時候無意間又看到 call by value 與 call by reference 相關的文章，越研究發現越有趣。原本以為自己已經搞懂了這個問題，但沒想到看的資料越多，卻把自己弄的越糊塗。 要寫這篇文章其實有兩個不同的方式，一個是詳實記錄我研究這個問題的過程以及心中的疑惑，以及最後如何得到解答，簡單來說就是按照時間軸來寫；另外一個">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351722-bfc86c80-f6ef-11e8-97c5-efac22512139.gif">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351704-af17f680-f6ef-11e8-9686-6698f354c1da.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351736-c6ef7a80-f6ef-11e8-8c60-806ac95221f5.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351744-cfe04c00-f6ef-11e8-8599-dd0bb4eecd95.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351745-d373d300-f6ef-11e8-9978-cc13dc959ec5.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351752-d79ff080-f6ef-11e8-8dec-7c8395fd1988.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351766-ea1a2a00-f6ef-11e8-8ea4-f6a04b5997be.png">
<meta property="article:published_time" content="2018-06-23T13:10:00.000Z">
<meta property="article:modified_time" content="2025-02-28T13:04:02.897Z">
<meta property="article:author" content="Huli">
<meta property="article:tag" content="Front-end">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/2755720/49351722-bfc86c80-f6ef-11e8-97c5-efac22512139.gif">



<link rel="alternative" href="/atom.xml" title="深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？" type="application/atom+xml">



<link rel="icon" href="/img/lidemy_logo.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">


<link rel="stylesheet" href="/css/bulma.css?v=2.css">



<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />


<link rel="stylesheet" href="/css/style.css?v=4.css">





    
    
    
    
    
    
    
    
    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1393J2EVCZ"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-1393J2EVCZ');
</script>


    


<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <script>
        if (localStorage.getItem('dark-mode')) {
            if (localStorage.getItem('dark-mode') === 'true') {
                document.body.classList.add('dark-mode')
            }
        } else {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.body.classList.add('dark-mode')
            }
        }
    </script>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                    
                    Huli&#39;s blog
                    
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">文章列表</a>
            
            <a class="navbar-item "
               href="/categories">分類</a>
            
            <a class="navbar-item "
               href="/recommend">推薦閱讀</a>
            
            <a class="navbar-item "
               href="/about">關於我</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            <div class="navbar-item is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only toc">
                <a class="navbar-item" title="目錄">
                    目錄
                </a>
                <div class="navbar-dropdown">
                    
                    
                    
                    
                    <a class="navbar-item" href="#前言">1&nbsp;&nbsp;<b>前言</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#美麗的錯誤">2&nbsp;&nbsp;<b>美麗的錯誤</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#function-的參數傳遞方式">3&nbsp;&nbsp;<b>Function 的參數傳遞方式</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#javascript-只有-call-by-value">4&nbsp;&nbsp;<b>JavaScript 只有 call by value</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#探索聖經的路程">5&nbsp;&nbsp;<b>探索聖經的路程</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#java-is-always-pass-by-value">6&nbsp;&nbsp;<b>Java is always pass-by-value</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#c-與-c-的參數傳遞">7&nbsp;&nbsp;<b>C 與 C++ 的參數傳遞</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#結論">8&nbsp;&nbsp;<b>結論</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#心得">9&nbsp;&nbsp;<b>心得</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#參考資料">10&nbsp;&nbsp;<b>參考資料</b></a>
                    
                </div>
            </div>
            
            
            <a class="navbar-item" target="_blank" title="Medium" href="https://hulitw.medium.com/">
                
                <i class="fab fa-medium"></i>
                
            </a>
               
            <a class="navbar-item" target="_blank" title="Facebook" href="https://www.facebook.com/huli.blog">
                
                <i class="fab fa-facebook"></i>
                
            </a>
               
            <a class="navbar-item" target="_blank" title="RSS" href="/atom-ch.xml">
                
                <i class="fas fa-rss"></i>
                
            </a>
               
            
            <a class="navbar-item btn-dark-mode" title="dark-mode" href="#">
                <div>
                    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="15" height="15" viewBox="0 0 256 256" xml:space="preserve">
                    <defs>
                    </defs>
                    <g style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill: none; fill-rule: nonzero; opacity: 1;" transform="translate(1.4065934065934016 1.4065934065934016) scale(2.81 2.81)" >
                        <path d="M 87.823 60.7 c -0.463 -0.423 -1.142 -0.506 -1.695 -0.214 c -15.834 8.398 -35.266 2.812 -44.232 -12.718 c -8.966 -15.53 -4.09 -35.149 11.101 -44.665 c 0.531 -0.332 0.796 -0.963 0.661 -1.574 c -0.134 -0.612 -0.638 -1.074 -1.259 -1.153 c -9.843 -1.265 -19.59 0.692 -28.193 5.66 C 13.8 12.041 6.356 21.743 3.246 33.35 S 1.732 57.08 7.741 67.487 c 6.008 10.407 15.709 17.851 27.316 20.961 C 38.933 89.486 42.866 90 46.774 90 c 7.795 0 15.489 -2.044 22.42 -6.046 c 8.601 -4.966 15.171 -12.43 18.997 -21.586 C 88.433 61.79 88.285 61.123 87.823 60.7 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill: #ffa716; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
                    </g>
                    </svg>
                </div>
            </a>
            
                <a class="navbar-item" href="/2018/06/23/en/javascript-call-by-value-or-reference/">English</a>
            
            

        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
      
      <div data-nosnippet class="self-notice">
        如果有什麼想回饋的（如對文章或部落格的感想），除了留言以外也能填表單跟我說：<a href="https://forms.gle/XuWyRC5qtSd2ANta8" target="_blank">表單連結</a>。若是對更多 JavaScript 知識有興趣，歡迎參考我的新書<a target="_blank" rel="noopener" href="https://www.tenlong.com.tw/products/9786267757048">《JavaScript 重修就好》</a>
      </div>
      
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-06-23T13:10:00.000Z" itemprop="datePublished">2018年6月23日</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
        </span>
        
        
        
    </div>
    
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1><span id="前言">前言</span></h1><p>其實這週原本是要來寫淺拷貝跟深拷貝的差異以及實作，但在找資料的時候無意間又看到 call by value 與 call by reference 相關的文章，越研究發現越有趣。原本以為自己已經搞懂了這個問題，但沒想到看的資料越多，卻把自己弄的越糊塗。</p>
<p>要寫這篇文章其實有兩個不同的方式，一個是詳實記錄我研究這個問題的過程以及心中的疑惑，以及最後如何得到解答，簡單來說就是按照時間軸來寫；另外一個是當我研究完以後，再重新以自己的方式整理，並且用更簡單易懂的方式來表達。</p>
<p>以往我的文章大多數都走第二種路線，重新歸納整理過後再寫出一篇相對上更容易理解的文章，用我的方式帶著大家一步步跟著我的脈絡去探討問題最後得出解答。</p>
<p>但這次我想嘗試第一種，帶大家看看我平常寫文章的時候都看了哪些資料，以及發想的過程為何，這樣應該也滿有趣的。</p>
<p>Let’s go!</p>
<span id="more"></span>

<h1><span id="美麗的錯誤">美麗的錯誤</span></h1><p>開頭有講過了，我會再重新回來研究參數傳遞這個問題完全是個美麗的錯誤，我本來要寫的主題是深拷貝跟淺拷貝。</p>
<p>在找資料的時候，我查到了這篇文：<a target="_blank" rel="noopener" href="https://web.archive.org/web/20200220061943/http://larry850806.github.io/2016/09/20/shallow-vs-deep-copy//">[Javascript] 關於 JS 中的淺拷貝和深拷貝
</a>，我看了看之後發現如果我要來講深拷貝，我就必須先講解為什麼我們需要深拷貝，就要講到 Object 跟其他 Primitive types 的不同之處。</p>
<p>想到這邊，我就想到了一個老問題：JavaScript 的 Object 到底是 pass by value 還是 pass by referece？</p>
<p>我依稀記得答案是前者，或者兩者都不是，而是有個新的名詞叫作 pass by sharing。</p>
<p>為了驗證自己的印象沒錯，我繼續動手搜尋，最後找到了<a target="_blank" rel="noopener" href="https://pjchender.blogspot.com/2016/03/javascriptby-referenceby-value.html">[筆記] 談談JavaScript中by reference和by value的重要觀念</a>以及<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10191057">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a>，後者我有印象我看過，而且驗證了我的印象是正確的。</p>
<p>好，話說到這裡，必須先跟大家介紹一下這三者以及之間的差異，否則沒辦法繼續往下講。</p>
<h1><span id="function-的參數傳遞方式">Function 的參數傳遞方式</span></h1><p>先來一個很簡單的範例：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>
  a <span class="token operator">=</span> b<span class="token punctuation">;</span>
  b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
  
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token function">swap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token comment">// 10, 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>當你執行完<code>swap</code>之後，<code>x</code>跟<code>y</code>的值並沒有交換，為什麼？因為你傳進去的東西「不是真的 x 跟 y」，而是「x 跟 y 的值的拷貝」。</p>
<p>也就是說<code>a</code>跟<code>b</code>其實就是另外兩個新的變數，然後存的值跟<code>x</code>和<code>y</code>一樣，但你改變了<code>a</code>不會改變<code>x</code>，因為他們是兩個不同的變數。</p>
<p>可以參考下面的精美小動畫：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351722-bfc86c80-f6ef-11e8-97c5-efac22512139.gif" alt="value 1"></p>
<p>上面這種方式就叫做：call by value（或是 pass by value），在呼叫 function 的時候把「值」給複製一份。</p>
<p>到這邊應該還滿好懂的，接下來要開始慢慢進入到複雜的部分了。有另外一種方法，叫做 call by reference，意思是「你傳進去的東西就是真的 x 跟 y，function 裡面的 a 跟 b 只是別名（alias）而已，改變 a 就會改變 x」</p>
<p>很顯然的，在 JavaScript 裡面對於像數字這種的 Primitive type，是沒有 call by reference 的，因為你絕對不可能透過 function 內的引數去改變 function 外面的變數。</p>
<p>對於數字不可能，那對 object 呢？</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  obj<span class="token punctuation">.</span>number<span class="token operator">++</span>
<span class="token punctuation">&#125;</span>
  
<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">number</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">&#125;</span>
<span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>number<span class="token punctuation">)</span> <span class="token comment">// 11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>哪泥！居然在 function 裡面成功改變外面的東西了！難道這就是 call by reference 嗎？</p>
<p>先別急，乍看之下很像，可是有一個操作會露出破綻：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 讓 obj 變成一個新的 object</span>
  obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">number</span><span class="token operator">:</span> obj<span class="token punctuation">.</span>number <span class="token operator">+</span> <span class="token number">1</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
  
<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">number</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">&#125;</span>
<span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>number<span class="token punctuation">)</span> <span class="token comment">// 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果是真的 call by reference，那你在 function 裡面把 obj 的值改掉了，外面的 o 也會一起被改掉，變成那個新的 object，可是從上面這段範例看起來並沒有，所以這樣做不是 call by reference。</p>
<p>既不是 call by value 也不是 call by reference，那這樣應該叫做什麼呢？</p>
<p>有人把這種方式叫做 call by sharing，意思就是我們讓 function 裡面的那個<code>obj</code>跟外面的<code>o</code>「共享」同一個 object，所以透過裡面的 obj，你可以去修改「共享到的那個 object」的資料。</p>
<p>上面都跟 call by reference 看起來沒兩樣，但最大的差異是如果你在 function 裡面把 obj 重新賦值，就代表你要讓這個 obj 指向一個新的 object，所以外面的 o 依舊還是原來的值。</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351704-af17f680-f6ef-11e8-9686-6698f354c1da.png" alt="ref"></p>
<p>引入了一個新名詞之後，看起來所有問題都得到了解答，結論就是：「在 JavaScript，primitive types 是 call by value，object 是 call by sharing」</p>
<p>不過，這一切只是我天真的想法而已，某天我看到一句話…</p>
<h1><span id="javascript-只有-call-by-value">JavaScript 只有 call by value</span></h1><p>這句話乍看之下完全沒道理，剛剛不是說是 call by sharing 嗎？怎麼又變成 call by value 了？</p>
<p>但其實這句話是要這樣解讀的：</p>
<p>當你在宣告一個 object 的時候，在底層實作上，其實這個 object 存的是一個記憶體位置，或如果用 C 的方式來講，object 的底層就是一個指標。</p>
<p>先幫大家複習一下指標，你可以把指標看成是變數型態的一種，差別在於它所儲存的值是「記憶體位置」。</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351736-c6ef7a80-f6ef-11e8-8c60-806ac95221f5.png" alt="p1 2"></p>
<blockquote>
<p>o 這個變數的值是什麼？</p>
</blockquote>
<p>這個問題的答案是我認為理解「JavaScript 只有 call by value」這句話的關鍵。</p>
<p>如果從上層來看，答案理所當然會是：「o 的值是 {number: 10}」。可是如果你從底層實作的角度來看，答案就會是：「o 的值是 0x01」</p>
<p>我們用第二個答案繼續往下講，假設 o 的值是 0x01 的話，那你在呼叫 function 的時候，傳進去的值其實就是 0x01，所以在 function 裡面的變數才可以透過這個記憶體位置去操作同樣的東西。</p>
<p>就是我們前面那張圖畫的，o 跟 obj 兩個變數會「指向」同一個地方。而底層實作原理就是把 o 的記憶體位置傳給 obj 嘛，不然怎麼能指向同個地方。</p>
<p>如果以這個角度來看，call by sharing（傳記憶體位置進去）其實就是 call by value 的一種，解釋的方式為：其實一樣是傳值的拷貝進去，只是這個值是記憶體位置。</p>
<p>乍聽之下有點道理，可是有個點我怎麼想都想不通：</p>
<blockquote>
<p>如果你要從底層實作的原理來看，那 call by reference 不也是 call by value 的一種嗎？</p>
</blockquote>
<p>因為以底層來看，call by reference 一樣也是傳記憶體位置進去啊，那不就全世界都只有 call by value？</p>
<p>後來我查到了一篇文章跟我有類似的想法：<a target="_blank" rel="noopener" href="https://www.ptt.cc/bbs/C_and_CPP/M.1245595402.A.2A1.html">Re: [問題] 請問傳參考到底是什麼?</a></p>
<p>不過看完之後還是沒有得到解答，只有個模糊的概念，覺得這可能是一個名詞定義的問題。</p>
<p>抱著追根究柢的精神，我決定來看看 ECMAScript 怎麼說。</p>
<h1><span id="探索聖經的路程">探索聖經的路程</span></h1><p>ECMAScript 的 spec 就是 JavaScript 的聖經，在裡面你可以找到更底層的實作，而且內容絕對不會出錯。</p>
<p>目前能找到的相關文章，大部分的參考資料來源都是這裡：<a target="_blank" rel="noopener" href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/">ECMA-262-3 in detail. Chapter 8. Evaluation strategy.</a></p>
<p>我原本以為這篇是 ECMA-262-3 的節錄，看完之後發現根本不是，其實只是某個人看完 ECMA-262-3 之後的筆記而已。</p>
<p>不過這篇其實寫得很不錯，我們可以直接看結論的部分：</p>
<blockquote>
<p>It can be either “call by value”, with specifying that the special case of call by value is meant — when the value is the address copy. From this position it is possible to say that everything in ECMAScript are passed by value.</p>
</blockquote>
<blockquote>
<p>Or, “call by sharing”, which makes this distinction from “by reference”, and “by value”. In this case it is possible to separate passing types: primitive values are passed by value and objects — by sharing.</p>
</blockquote>
<blockquote>
<p>The statement “objects are passed by reference” formally is not related to ECMAScript and is incorrect.</p>
</blockquote>
<p>但可惜的是沒有說 ECMA-262 裡面到底哪個部分有提到這些，而且我怎麼查都查不到有任何人的文章有附上 ECMA-262 的參考來源。</p>
<p>沒辦法，只好自己找了。</p>
<p>我從<a target="_blank" rel="noopener" href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">ecma international</a>上面下載了<code>ECMA-262 edition 8</code>，並且利用幾個關鍵字來找：</p>
<ol>
<li>call by reference</li>
<li>call by value</li>
<li>pass by reference</li>
<li>pass by value</li>
</ol>
<p>結果呢？結果一無所獲，完全搜尋不到這些字。接著只好把關鍵字縮小一點，利用：<code>reference</code>、<code>sharing</code>等等的關鍵字去找，找到<code>6.2.4 The Reference Specification Type</code>，雖然看似相關，但沒有找到最關鍵的部分。</p>
<p>八百多頁的文章，這樣慢慢找實在是很累，而這樣子找下來，依舊沒有任何收穫。接著我轉個念頭：「那我來搜尋 arguments 好了」，找到兩個看似相關的章節（<code>9.4.4 ArgumentsExoticObjects</code> 與 <code>9.2 ECMAScript Function Objects</code>），但依舊沒有詳細說明。</p>
<p>用上面的關鍵字都找不到，我決定再換個念頭：「那我來查等號的定義好了，要比較 object 的話，應該會寫說如何比較兩個 object 是否相同，應該就會提到 reference 之類的相關詞彙了！」</p>
<p>最後查到了這段：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351744-cfe04c00-f6ef-11e8-8599-dd0bb4eecd95.png" alt="ecma1"></p>
<blockquote>
<ol start="8">
<li>If x and y are the same Object value, return true. Otherwise, return false.</li>
</ol>
</blockquote>
<p>好，有說跟沒說一樣。查了一兩個小時發現幾乎沒進展以後，我決定放棄這個接近九百頁的版本。</p>
<p>後來我去下載了<a target="_blank" rel="noopener" href="https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">ECMA-262 的第一版</a>，篇幅少很多，只有 200 頁不到，在搜尋了幾個關鍵字發現還是沒什麼結果之後，我決定把整本快速掃過一遍。</p>
<p>先講結論，我還是沒有找到任何跟 call by value&#x2F;reference 有關的地方，可是看到一些滿有趣的東西。</p>
<p>例如說判斷是否相等的地方寫的不太一樣：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351745-d373d300-f6ef-11e8-9978-cc13dc959ec5.png" alt="ecma2"></p>
<blockquote>
<p>11.9.3 The Abstract Equality Comparison Algorithm</p>
<p>13.Return true if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return false.</p>
</blockquote>
<p>提到了一個叫做 joined objects 的東西：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351752-d79ff080-f6ef-11e8-8dec-7c8395fd1988.png" alt="ecma3"></p>
<p>不過跟我們想找的地方還是不太一樣。</p>
<p>於是，我放棄了從 ECMAScript 去找答案的這個想法。</p>
<p>在覺得無助的同時，想起了一個也有著相似問題（到底是 call by value 還是 call by reference）的程式語言：Java。</p>
<h1><span id="java-is-always-pass-by-value">Java is always pass-by-value</span></h1><p>以前在寫 Java 的時候也有碰過這個問題，而且跟 JavaScript 的其實一模一樣，就是你傳一般的值進去是 by value，可是你傳 object 進去的時候又表現的像 call by reference，但是賦值的時候又不會改變外面的 object。</p>
<p>但看起來 Java 永遠都是 pass by value 已經是個共識了，可參考 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">Is Java “pass-by-reference” or “pass-by-value”?</a>、<a target="_blank" rel="noopener" href="http://www.yoda.arachsys.com/java/passing.html">Parameter passing in Java - by reference or by value?</a> 跟 <a target="_blank" rel="noopener" href="http://www.javadude.com/articles/passbyvalue.htm">Java is Pass-by-Value, Dammit!</a>。</p>
<p>理由其實跟我們最開始說的一樣，讓我節錄 Java is Pass-by-Value, Dammit! 的其中一句：</p>
<blockquote>
<p>However, Objects are not passed by reference. A correct statement would be Object references are passed by value.</p>
</blockquote>
<p>以及 Parameter passing in Java - by reference or by value? 的其中一段：</p>
<blockquote>
<p>Now that we have some definitions of terms we can return to the question. Does Java pass objects by reference or by value?</p>
</blockquote>
<blockquote>
<p>The answer is NO! The fact is that Java has no facility whatsoever to pass an object to any function! The reason is that Java has no variables that contain objects.</p>
</blockquote>
<blockquote>
<p>The reason there is so much confusion is people tend to blur the distinction between an object reference variable and an object instance. All object instances in Java are allocated on the heap and can only be accessed through object references. So if I have the following:</p>
</blockquote>
<blockquote>
<p>StringBuffer g &#x3D; new StringBuffer( “Hello” );</p>
<p>The variable g does not contain the string “Hello”, it contains a reference (or pointer) to an object instance that contains the string “Hello”.</p>
</blockquote>
<p>g 這個變數的值並不是字串<code>Hello</code>，而是<code>一個指到字串 Hello 的 reference</code>，所以你在呼叫 function 的時候，傳進去的就是這個 reference。</p>
<blockquote>
<p>我傳進去的是 reference，可是這樣並不叫 call by reference？</p>
</blockquote>
<p>聽起來超級無敵奇怪，但根本原因其實是「此 reference 非彼 reference」，我節錄一段<a target="_blank" rel="noopener" href="https://openhome.cc/Gossip/JavaEssence/CallByValue.html">Call by value？</a>中的內容：</p>
<blockquote>
<p>Java 中 Call by value，指的是傳遞參數時，一律傳遞變數所儲存的值，無論是基本型態或是類別宣告的型態都一樣，Java 中不允許處理記憶體位址，所以用了「參考」這個名稱來作為解釋類別型態所宣告的變數之行為，但這邊的「參考」與 C++ 中所稱之「參考」，是完全不相同的行為，更不會有 C++ 中參數的傳值、傳參考、return 的傳值、傳參考的 Call by reference 行為。 </p>
</blockquote>
<p>就是呢，我們傳進去的的確是 reference，但這個 reference 跟 C++ 裡面所稱的「call by reference」其實是不一樣的，所以不能稱作「call by reference」。</p>
<p>這一段其實跟犀牛書裡面<a target="_blank" rel="noopener" href="https://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm">11.2. By Value Versus by Reference</a>提到的是差不多的：</p>
<blockquote>
<p>Before we leave the topic of manipulating objects and arrays by reference, we need to clear up a point of nomenclature.</p>
</blockquote>
<blockquote>
<p>The phrase “pass by reference” can have several meanings. To some readers, the phrase refers to a function invocation technique that allows a function to assign new values to its arguments and to have those modified values visible outside the function.</p>
<p>This is not the way the term is used in this book. Here, we mean simply that a reference to an object or array – not the object itself – is passed to a function. A function can use the reference to modify properties of the object or elements of the array. But if the function overwrites the reference with a reference to a new object or array, that modification is not visible outside of the function. </p>
<p>Readers familiar with the other meaning of this term may prefer to say that objects and arrays are passed by value, but the value that is passed is actually a reference rather than the object itself</p>
</blockquote>
<p>不過這個時候我有了另外一個疑問：那 C++ 裡面的 call by reference 到底是怎樣？</p>
<p>嗯，看來是時候複習一下很久沒碰的 C 跟 C++了。</p>
<h1><span id="c-與-c-的參數傳遞">C 與 C++ 的參數傳遞</span></h1><p>先從 C 開始吧，C 裡面就只有一種：call by value。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
  
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> temp <span class="token operator">=</span> b<span class="token punctuation">;</span>
  b <span class="token operator">=</span> a<span class="token punctuation">;</span>
  a <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
  <span class="token function">swap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10, 20</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>就像我們一開始所說的，這樣子並不會把<code>x</code>跟<code>y</code>的值交換，因為<code>a</code>跟<code>b</code>只是儲存的值跟<code>x</code>與<code>y</code>一樣而已，除此之外一點關係都沒有。</p>
<p>可是呢，我們之前有提到，C 裡面有個東西叫做「指標」，能夠儲存記憶體位置。透過指標我們其實可以在 function 裡面更改外部變數的值。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
  
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 印出 a 跟 b 所存的值</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld, %ld"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//0x44, 0x40</span>
  <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
  <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
  <span class="token operator">*</span>a <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
  <span class="token comment">// 印出 x 跟 y 的記憶體位置</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld %ld\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0x44, 0x40</span>
  <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 傳記憶體位置進去</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20, 10</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我們這次傳進去 function 的不是一個變數，而是一個記憶體位置，在<code>swap</code>裡面用指標來接受這個記憶體位置，接著就可以透過指標的操作把外面<code>x</code>與<code>y</code>的值改掉。</p>
<p>這樣依然叫做 call by value，如果你還是不清楚為什麼，可以參考下面這個範例。跟上面的差別在於我先宣告兩個指標指向<code>x</code>跟<code>y</code>：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
  
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  
  <span class="token comment">// 印出 a 跟 b 所存的值</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld, %ld"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//0x44, 0x40</span>
  <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
  <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
  <span class="token operator">*</span>a <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    
  <span class="token comment">// 兩個指標指向 x 跟 y</span>
  <span class="token keyword">int</span><span class="token operator">*</span> ptr_x <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">*</span> ptr_y <span class="token operator">=</span> <span class="token operator">&amp;</span>y<span class="token punctuation">;</span>
  
  <span class="token comment">// 印出 x 跟 y 的記憶體位置（就是 ptr_x 跟 ptr_y 存的值）</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld %ld\n"</span><span class="token punctuation">,</span> ptr_x<span class="token punctuation">,</span> ptr_y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0x44, 0x40</span>
  <span class="token function">swap</span><span class="token punctuation">(</span>ptr_x<span class="token punctuation">,</span> ptr_y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 傳記憶體位置進去</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20, 10</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>還記得前面說過的 call by value 的定義嗎？就是把變數的值複製一份傳進去。這邊也是一樣的，我們傳進去的兩個變數<code>ptr_x</code>跟<code>ptr_y</code>儲存了<code>x</code>跟<code>y</code>的記憶體位置，而我們在呼叫 function 的時候就把這兩個「值」給複製一份傳進去，所以 function 裡面的<code>a</code>跟<code>b</code>印出來的值就會跟<code>ptr_x</code>以及<code>ptr_y</code>存的值一樣。</p>
<p>簡單來說就是以前我們 call by value 的「value」可能是數字，可能是字串，而現在的範例這個 value 是「記憶體位置」，也是資料型態的一種。</p>
<p>不過，也有人把這樣子稱為 call by pointer 或是 call by address，但原則上都是 call by value 的一種。</p>
<p>在這邊還有一個可以特別注意的地方，那就是儘管<code>a</code>跟<code>ptr_x</code>的「值」一樣，但這兩個還是不一樣的變數，有著不同的記憶體位置。</p>
<p>再來我們看 C++ 中的 call by reference 到底是怎樣，只要在 function 的引數那裡加上<code>&amp;</code>，就會變成 call by reference：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;
  
&#x2F;&#x2F; 注意到這邊多了 &amp;，其他都跟 call by value 一模一樣
void swap(int &amp;a, int &amp;b) &#123;
  
  &#x2F;&#x2F; 印出 a 跟 b 所存的值與記憶體位置
  printf(&quot;%ld, %ld\n&quot;, a, b); &#x2F;&#x2F; 10, 20
  printf(&quot;%ld, %ld\n&quot;, &amp;a, &amp;b); &#x2F;&#x2F; 0x44, 0x40
  int temp &#x3D; b;
  b &#x3D; a;
  a &#x3D; temp;
&#125;
  
int main()&#123;
  int x &#x3D; 10;
  int y &#x3D; 20;
  
  &#x2F;&#x2F; 印出 x 跟 y 的記憶體位置
  printf(&quot;%ld %ld\n&quot;, &amp;x, &amp;y); &#x2F;&#x2F; 0x44, 0x40
  swap(x, y); &#x2F;&#x2F; 傳記憶體位置進去
  printf(&quot;%d %d\n&quot;, x, y); &#x2F;&#x2F; 20, 10
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在這裡<code>a</code>跟<code>b</code>的記憶體位置與<code>x</code>跟<code>y</code>一模一樣，說明了在裡面操作<code>a</code>這個變數的時候，就是在操作<code>x</code>這個變數，兩者是一模一樣的，只是有了不同的名稱。當<code>a</code>重新賦值的時候，也會一併把外面<code>x</code>的值一起改掉。</p>
<p>看完了 C 跟 C++ 裡面 pass by value 跟 pass by reference 的區別，我開頭的疑惑：「如果你要從底層實作的原理來看，那 call by reference 不也是 call by value 的一種嗎？」就被解決了。</p>
<p>我認為這兩個最大的差異就在於一件事情：複製。</p>
<p>call by value 會把傳進去的值複製（無論那個值是數字也好，記憶體位置也好，都會複製一份），call by reference 在「最底層的實作」上當然也會有類似的行為，但是你感覺不出來。</p>
<p>就像我上面 call by reference 舉例的那段程式碼一樣，<code>x</code>的記憶體位置跟<code>a</code>一樣，<code>y</code>的記憶體位置跟<code>b</code>一樣，因此你可以說他們兩者是「一模一樣」的東西。</p>
<p>可是在 call by value 的範例中，就算你傳的是指標好了，只有「指標裡面存的值（也就是指到的記憶體位置）」是一樣的，但指標本身還是有不同的記憶體位置。</p>
<p>換句話說，在 call by value 的時候我們是「新建了一個變數<code>a</code>，並且讓<code>a</code>存的值跟傳進來的參數一樣」。在 call by reference 的時候，我們只是「讓<code>a</code>作為<code>x</code>的 alias，兩個是同樣的變數」，這是我認為這兩間之間最大的差異。</p>
<h1><span id="結論">結論</span></h1><p>我們從各個程式語言裡面看到了每一種程式語言的實現，那到底有沒有一種明確的定義，能夠區分 pass by value 以及 pass by reference 呢？</p>
<p>我想了想，其實可以從「行為」上面來判別到底是屬於哪一種。與其由定義來看，不如直接從行為來加以區分，不同種類能夠達成的行為都不一樣。第一個條件用來區分到底是 pass by value 還是 pass by reference：「在函式裡對引數重新賦值，外面變數是否會改變？」</p>
<p>以 JavaScript 跟 Java 為例，在函式裡面重新賦值，外面的變數都不會變，所以就是屬於 pass by value。</p>
<p>如果你還想分得更細，來可以透過第二個條件來區分這個 pass by value 是真・pass by value 還是一個叫做 pass by sharing 的分支：「能否透過引數，改變外部變數的值」（我們這邊所指的「值」跟地址或引用無關，純粹在講像<code>&#123;numer:1&#125;</code>這樣子的值）</p>
<p>在 JavaScript 跟 Java 你都可以透過<code>obj.number = 10</code>之類的操作改變外部變數的值（obj.number 從 1 變成了 10），所以也能說是 pass by sharing。</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351766-ea1a2a00-f6ef-11e8-8ea4-f6a04b5997be.png" alt="con"></p>
<p>根據第一個定義：「在函式裡對引數重新賦值，外面變數是否會改變？」，有人可能會發現如果是 C 裡面的指標，不是也可以達成嗎？可是 C 又說只有 call by value，不就衝突了嗎？</p>
<p>但其實在指標的範例裡面，我們重新賦值的對象是<code>*a</code>而不是<code>a</code>（意思就是，我們是讓<code>*a=10</code>而不是<code>a=10</code>），但後者才叫對引數重新賦值（給<code>a</code>一個新的地址），前者是「對指標所指向的記憶體位置重新賦值」。所以照這個定義來看，指標的範例依舊是 pass by value。</p>
<p>依據細分程度的不同，下面幾句話都是正確的：</p>
<ol>
<li>JavaScript 裡面只有 pass by value</li>
<li>JavaScript 的 primitive type 是 pass by value，object 是 pass by sharing</li>
</ol>
<h1><span id="心得">心得</span></h1><p>說實在的，其實我查了這麼一大堆資料之後，發現大家對 call by reference 以及 call by value 的「定義」其實都不盡相同，而且也沒有一個權威性的出處能夠保證這個定義是正確的（或許有但我沒找到，如果你知道的話請一定要告訴我在哪裡，拜託），才造成這麼多的歧異性。</p>
<p>有關技術名詞的解釋，我最喜歡引用這篇：<a target="_blank" rel="noopener" href="https://www.ithome.com.tw/voice/94877">技術名詞紛爭多</a>：</p>
<blockquote>
<p>程式開發的世界中，名詞的創造經常是隨意的，曾經在 Java 中爭執不斷的考古題之一是：「Java 中有沒有 Pass by reference」，就現今來說，大家公認的答案是沒有，Java 只有 Pass by value，不過還是有人面對 Java 文件中經常出現 reference，而搞不清楚。</p>
</blockquote>
<blockquote>
<p>說穿了，這個名詞與 C++ 中的 reference 定義不同，只不過 Java 最初不知道為什麼，也用了 reference 一詞，重點也不在搞清楚 Pass by value，重點是搞清楚透過參數操作物件時，會有什麼樣的行為。</p>
</blockquote>
<p>我們從 JavaScript 研究到 Java，再從 Java 研究到 C 與 C++，為的就是想要搞清楚「pass by reference」的定義為何，但追根究底，會造成這樣子的誤會是因為對於「reference」一詞的定義不同。</p>
<p>如果你把 pass by reference 理解成像 C++ 那樣子的定義，那 Java 跟 JavaScript 都不會有 pass by reference。但如果你把 pass by reference 的「reference」理解成「對於物件的參考」，那 JavaScript 把 object 傳進去，其實就是把「對物件的參考」傳進去，那就可以解釋成是 pass by reference。</p>
<p>都是 reference 這個名詞太好用了，導致不同地方有不同的定義，但那些定義往往相似卻又不全然相同。</p>
<p>可是別忘了，重點其實不在這個，而是搞清楚到底參數在操作的時候會有怎樣的行為。你要知道 JavaScript 傳 object 進去的時候，可以更改原本物件的值，但重新賦值並不會影響到外部的 object。只要知道這一點，其他的我覺得都沒那麼重要了。</p>
<p>這次寫了一個很容易引戰的主題，但也覺得滿有趣的，如果你對這問題有不同的見解，覺得我有哪邊寫錯的話，歡迎指正，感謝。</p>
<h1><span id="參考資料">參考資料</span></h1><ol>
<li><a target="_blank" rel="noopener" href="https://web.archive.org/web/20200220061943/http://larry850806.github.io/2016/09/20/shallow-vs-deep-copy//">[Javascript] 關於 JS 中的淺拷貝和深拷貝
</a></li>
<li><a target="_blank" rel="noopener" href="https://pjchender.blogspot.com/2016/03/javascriptby-referenceby-value.html">[筆記] 談談JavaScript中by reference和by value的重要觀念</a></li>
<li><a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10191057">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ptt.cc/bbs/C_and_CPP/M.1245595402.A.2A1.html">Re: [問題] 請問傳參考到底是什麼?</a></li>
<li><a target="_blank" rel="noopener" href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/">ECMA-262-3 in detail. Chapter 8. Evaluation strategy.</a></li>
<li><a target="_blank" rel="noopener" href="https://www.slideshare.net/YiTaiLin/java-script-63031051">簡單介紹JavaScript參數傳遞</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/nodejh/nodejh.github.io/issues/32">JavaScript 是传值调用还是传引用调用？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/getify/You-Dont-Know-JS/issues/160">Values vs References semantics #160</a></li>
<li><a target="_blank" rel="noopener" href="http://www.yoda.arachsys.com/java/passing.html">Parameter passing in Java - by reference or by value?</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">Is Java “pass-by-reference” or “pass-by-value”?</a></li>
<li><a target="_blank" rel="noopener" href="https://openhome.cc/Gossip/Java/PassByValue.html">傳值呼叫</a></li>
<li><a target="_blank" rel="noopener" href="https://openhome.cc/Gossip/JavaEssence/CallByValue.html">Call by value？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiangnan2014/article/details/22944075">java中的经典问题：传值与传引用</a></li>
<li><a target="_blank" rel="noopener" href="http://www.javadude.com/articles/passbyvalue.htm">Java is Pass-by-Value, Dammit!</a></li>
<li><a target="_blank" rel="noopener" href="https://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm">11.2. By Value Versus by Reference</a></li>
</ol>

    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Front-end/">#Front-end</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/JavaScript/">#JavaScript</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2018/08/18/cors-is-hard/">原來 CORS 沒有我想像中的簡單</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2018/03/31/react-fiber-and-lifecycles/">淺談 React Fiber 及其對 lifecycles 造成的影響</a>
            
        </span>
    </div>
    
</article>




<div class="comments">
    <h3 class="title is-4">評論</h3>
    <script src="https://utteranc.es/client.js"
        repo="aszx87410/huli-blog"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</div>

    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2026 Huli&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow" title="GitHub" target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
<div class="column is-narrow has-text-centered">
    <div class="dropdown is-up is-right is-hoverable" style="margin-top: -0.2em;">
        <div class="dropdown-trigger">
            <button class="button is-small" aria-haspopup="true">
                <span class="icon">
                    <i class="fas fa-globe"></i>
                </span>
                <span>繁體中文</span>
                <span class="icon is-small">
            <i class="fas fa-angle-down" aria-hidden="true"></i>
          </span>
            </button>
        </div>
        <div class="dropdown-menu has-text-left" role="menu" style="top:100%">
            <div class="dropdown-content">
            <!-- NOTE: 永遠回到首頁 -->
            
                <a href="/2018/06/23/en/javascript-call-by-value-or-reference/" class="dropdown-item">
                    English
                </a>
            
            </div>
        </div>
    </div>
</div>

        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>



    
    
    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="/js/script.js?v=3.js"></script>


    
</body>
</html>