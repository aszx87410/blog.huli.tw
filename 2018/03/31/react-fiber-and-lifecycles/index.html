<!DOCTYPE html>
<html class="has-navbar-fixed-top" lang="zh-tw">
<head>
    <meta charset="utf-8">
<title>淺談 React Fiber 及其對 lifecycles 造成的影響 - Huli&#39;s blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1">



            
<link href="https://blog.huli.tw/2018/03/31/en/react-fiber-and-lifecycles/" rel="alternate" hreflang="en" />
            
    




    
<link rel="canonical" href="https://blog.huli.tw/2018/03/31/react-fiber-and-lifecycles/">
    





    <meta name="description" content="前言雖然說從以前就一直聽到 React 要把內部的 reconciler 換成一個叫做 Fiber 的東西，但從沒仔細研究過，也不知道這樣子的改變會對上層造成什麼影響。 真正開始比較深入理解，是在某一次使用 Redux Form 時踩到一個相關的 bug，才知道 React 自從正式改用 Fiber 之後，其實對上層也有一些改變。 這篇的標題「淺談」不是騙你的，這篇真的很淺，我不會談到 Fiber">
<meta property="og:type" content="article">
<meta property="og:title" content="淺談 React Fiber 及其對 lifecycles 造成的影響">
<meta property="og:url" content="https://blog.huli.tw/2018/03/31/react-fiber-and-lifecycles/index.html">
<meta property="og:site_name" content="Huli&#39;s blog">
<meta property="og:description" content="前言雖然說從以前就一直聽到 React 要把內部的 reconciler 換成一個叫做 Fiber 的東西，但從沒仔細研究過，也不知道這樣子的改變會對上層造成什麼影響。 真正開始比較深入理解，是在某一次使用 Redux Form 時踩到一個相關的 bug，才知道 React 自從正式改用 Fiber 之後，其實對上層也有一些改變。 這篇的標題「淺談」不是騙你的，這篇真的很淺，我不會談到 Fiber">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351561-fea9f280-f6ee-11e8-834a-89bd7937b17f.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351564-02d61000-f6ef-11e8-8b36-6323ed4d7620.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351571-06699700-f6ef-11e8-916a-a100a6c17974.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351577-09fd1e00-f6ef-11e8-8cc5-9e0f849ad52a.png">
<meta property="article:published_time" content="2018-03-31T14:10:00.000Z">
<meta property="article:modified_time" content="2023-05-07T01:15:16.488Z">
<meta property="article:author" content="Huli">
<meta property="article:tag" content="React">
<meta property="article:tag" content="Front-end">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/2755720/49351561-fea9f280-f6ee-11e8-834a-89bd7937b17f.png">



<link rel="alternative" href="/atom.xml" title="淺談 React Fiber 及其對 lifecycles 造成的影響" type="application/atom+xml">



<link rel="icon" href="/img/lidemy_logo.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">


<link rel="stylesheet" href="/css/bulma.css?v=2.css">



<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />


<link rel="stylesheet" href="/css/style.css?v=4.css">





    
    
    
    
    
    
    
    
    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1393J2EVCZ"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-1393J2EVCZ');
</script>


    


<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <script>
        if (localStorage.getItem('dark-mode')) {
            if (localStorage.getItem('dark-mode') === 'true') {
                document.body.classList.add('dark-mode')
            }
        } else {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.body.classList.add('dark-mode')
            }
        }
    </script>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                    
                    Huli&#39;s blog
                    
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">文章列表</a>
            
            <a class="navbar-item "
               href="/categories">分類</a>
            
            <a class="navbar-item "
               href="/recommend">推薦閱讀</a>
            
            <a class="navbar-item "
               href="/about">關於我</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            <div class="navbar-item is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only toc">
                <a class="navbar-item" title="目錄">
                    目錄
                </a>
                <div class="navbar-dropdown">
                    
                    
                    
                    
                    <a class="navbar-item" href="#前言">1&nbsp;&nbsp;<b>前言</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#萬里之行始於-bug">2&nbsp;&nbsp;<b>萬里之行，始於 Bug</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#fiber-到底是什麼">3&nbsp;&nbsp;<b>Fiber 到底是什麼？</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#fiber-所帶來的改變">3.1&nbsp;&nbsp;Fiber 所帶來的改變</a>
                    
                    
                    
                    <a class="navbar-item" href="#第一階段">3.1.1&nbsp;&nbsp;第一階段</a>
                    
                    
                    
                    <a class="navbar-item" href="#第二階段">3.1.2&nbsp;&nbsp;第二階段</a>
                    
                    
                    
                    <a class="navbar-item" href="#react-的未來">3.2&nbsp;&nbsp;React 的未來</a>
                    
                    
                    
                    <a class="navbar-item" href="#結論">3.3&nbsp;&nbsp;結論</a>
                    
                </div>
            </div>
            
            
            <a class="navbar-item" target="_blank" title="Medium" href="https://hulitw.medium.com/">
                
                <i class="fab fa-medium"></i>
                
            </a>
               
            <a class="navbar-item" target="_blank" title="Facebook" href="https://www.facebook.com/huli.blog">
                
                <i class="fab fa-facebook"></i>
                
            </a>
               
            <a class="navbar-item" target="_blank" title="RSS" href="/atom-ch.xml">
                
                <i class="fas fa-rss"></i>
                
            </a>
               
            
            <a class="navbar-item btn-dark-mode" title="dark-mode" href="#">
                <div>
                    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="15" height="15" viewBox="0 0 256 256" xml:space="preserve">
                    <defs>
                    </defs>
                    <g style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill: none; fill-rule: nonzero; opacity: 1;" transform="translate(1.4065934065934016 1.4065934065934016) scale(2.81 2.81)" >
                        <path d="M 87.823 60.7 c -0.463 -0.423 -1.142 -0.506 -1.695 -0.214 c -15.834 8.398 -35.266 2.812 -44.232 -12.718 c -8.966 -15.53 -4.09 -35.149 11.101 -44.665 c 0.531 -0.332 0.796 -0.963 0.661 -1.574 c -0.134 -0.612 -0.638 -1.074 -1.259 -1.153 c -9.843 -1.265 -19.59 0.692 -28.193 5.66 C 13.8 12.041 6.356 21.743 3.246 33.35 S 1.732 57.08 7.741 67.487 c 6.008 10.407 15.709 17.851 27.316 20.961 C 38.933 89.486 42.866 90 46.774 90 c 7.795 0 15.489 -2.044 22.42 -6.046 c 8.601 -4.966 15.171 -12.43 18.997 -21.586 C 88.433 61.79 88.285 61.123 87.823 60.7 z" style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill: #ffa716; fill-rule: nonzero; opacity: 1;" transform=" matrix(1 0 0 1 0 0) " stroke-linecap="round" />
                    </g>
                    </svg>
                </div>
            </a>
            
                <a class="navbar-item" href="/2018/03/31/en/react-fiber-and-lifecycles/">English</a>
            
            

        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
      
      <div data-nosnippet class="self-notice">
        最近開了一個讀者回饋表單，無論是對文章的感想或是對部落格的感想，有什麼想回饋的都可以填表單跟我說：<a href="https://forms.gle/XuWyRC5qtSd2ANta8" target="_blank">表單連結</a>
      </div>
      
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            淺談 React Fiber 及其對 lifecycles 造成的影響
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-31T14:10:00.000Z" itemprop="datePublished">2018年3月31日</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/React/">React</a>
        </span>
        
        
        
    </div>
    
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1><span id="前言">前言</span></h1><p>雖然說從以前就一直聽到 React 要把內部的 reconciler 換成一個叫做 Fiber 的東西，但從沒仔細研究過，也不知道這樣子的改變會對上層造成什麼影響。</p>
<p>真正開始比較深入理解，是在某一次使用 Redux Form 時踩到一個相關的 bug，才知道 React 自從正式改用 Fiber 之後，其實對上層也有一些改變。</p>
<p>這篇的標題「淺談」不是騙你的，這篇真的很淺，我不會談到 Fiber 底層的運作（因為我也還沒認真研究過），只會用白話文跟你說 Fiber 大概是怎樣，是為了解決什麼樣子的問題而誕生。</p>
<span id="more"></span>

<h1><span id="萬里之行始於-bug">萬里之行，始於 Bug</span></h1><p>每一次能踩到 Bug 的機會，我都會好好把握。</p>
<p>為什麼？因為這是一次強迫你學習的機會。Bug 解不掉，你就沒辦法繼續下去，所以為了要解決 Bug，你必須去探究原因，必須知道這個問題為什麼產生，以及應該要怎麼解決。</p>
<p>當然，你也可以直接從 Stack Overflow 找答案然後複製貼上，覆蓋這張牌結束這回合。可是工作久了你會發現，不是所有問題都可以從那上面找到解答。</p>
<p>舉例來說，我一年前寫的<a target="_blank" rel="noopener" href="https://blog.techbridge.cc/2017/03/24/difficult-problem-of-cookie/">我遇過的最難的 Cookie 問題</a>對我來說就是一個很好的學習機會。</p>
<p>好，那這次我又是遇到什麼 Bug 呢？</p>
<p>我們公司的產品有用到redux-form，而問題是這樣的，我有兩個頁面，都用了同一個 component，叫做<code>FormBlock</code>好了。</p>
<p>我先去 A 頁面，再去 B 頁面，再回來 A 頁面，我的 redux-form 的 validation 就失效了，在表單 submit 的時候並不會執行 validation。</p>
<p>那時候搜到了幾個相關的 issue，但還是想自己查個清楚，就跑去找了 redux-form 的原始碼，研究了幾個小時終於找到出問題的地方。</p>
<p>在 redux-form <a target="_blank" rel="noopener" href="https://github.com/erikras/redux-form/blob/5c13be079476cb0d0430ca88fd3e1abbd09e674a/src/selectors/isValid.js#L37">執行 validation</a> 的時候，會先檢查 fields 是不是有被註冊過，如果沒被註冊的話，就直接回傳<code>true</code>，不會進行任何驗證，我自己加了幾個 console.log 之後，發現問題就是出在這邊，field 沒有被註冊到。</p>
<p>接著就來找一下是在哪邊註冊的，發現在<code>componentWillMount</code>的時候，會 dispatch 一個 action 來註冊所有的表單欄位（<code>REGISTER_FIELD</code>）。</p>
<p>然後在<code>componentWillUnmount</code>的時候，redux-form 會 dispatch 一個 action 叫做<code>DESTROY</code>（<a target="_blank" rel="noopener" href="https://github.com/erikras/redux-form/blob/5c13be079476cb0d0430ca88fd3e1abbd09e674a/src/createReduxForm.js#L556">相關程式碼</a>），把所有註冊的 field 給清掉。</p>
<p>到目前為止，一切看似都很合理。我在離開 B 頁面的時候，觸發<code>FormBlock</code>的<code>componentWillUnmount</code>，取消註冊所有的 field，在進入 A 頁面時，觸發<code>FormBlock</code>的<code>componentWillMount</code>，把所有的 field 重新註冊回來。</p>
<p>可是如果你打開 redux-devtool，會發現順序跟你想像中不太一樣：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351561-fea9f280-f6ee-11e8-834a-89bd7937b17f.png" alt="form"></p>
<p>咦？怎麼會先註冊再刪除？而且因為刪除了，所以驗證就失效了，不會執行任何驗證的邏輯。</p>
<p>再仔細找了一下相關的資料，看到這篇 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/9214#issuecomment-287763538">Browser back button not working with react-router@4.0.0-beta.7 and react@16-alpha.4</a> Issue 以及 Redux 以及 React 的開發者 gaearon 在下面的回答：</p>
<blockquote>
<p>In React 15, if A is replaced by B, we unmount A, and then create and mount B:</p>
</blockquote>
<blockquote>
<ol>
<li>A.componentWillUnmount</li>
<li>B.constructor</li>
<li>B.componentWillMount</li>
<li>B.componentDidMount</li>
</ol>
</blockquote>
<blockquote>
<p>In Fiber, we create B first, and only later unmount A and mount B:</p>
</blockquote>
<blockquote>
<ol>
<li>B.constructor</li>
<li>B.componentWillMount</li>
<li>A.componentWillUnmount</li>
<li>B.componentDidMount</li>
</ol>
</blockquote>
<p>在 React 16 以後，由於這樣子的順序改變，導致了上面 redux-form 的 lifecycle 執行順序跟預期中不符，也間接導致了我開頭所說的那個 Bug。</p>
<p>到了這邊，問題產生的原因一路從 redux-form 本身追到了 React，又更細節的追到了 Fiber，看來，沒辦法再繼續逃避 Fiber 了。</p>
<p>先一併奉上跟 redux-form 以及執行順序相關的其他參考資料，再讓我們好好看看 Fiber。</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/erikras/redux-form/issues/3566">Re-mounting a Field component erases the field-level validation function</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/12233">Ordering of componentWillMount&#x2F;Unmount in React 16</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/11106">Asynchronous ComponentWillUnmount in React 16</a></li>
</ol>
<h1><span id="fiber-到底是什麼">Fiber 到底是什麼？</span></h1><p>要瞭解一個新的東西，最快的方式就是回答以下問題：</p>
<ol>
<li>它是拿來解決什麼問題的？</li>
<li>解決方法是什麼？</li>
</ol>
<p>只要能了解這兩個問題，就能對這個新的東西有初步的概念，儘管你還是不知道實作細節，但至少你知道它帶來的影響及改變是什麼。</p>
<p>我們先來看一下一直存在於 React 的一個問題。</p>
<p>假設你現在有一個超級多功能的 App，有著超級多的 Component，然後你改變了最上層的 Component（假設它叫<code>&lt;App /&gt;</code>） 的 state。</p>
<p>因為 state 變了，所以就會來執行這個<code>&lt;App /&gt;</code>的 render function，然後執行<code>App</code>底下的 component 的 render function，就這樣一直往下執行下去，直到碰到最底層為止。</p>
<p>你如果去看 call stack，就會發現這個 call stack 超大一個：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351564-02d61000-f6ef-11e8-8b36-6323ed4d7620.png" alt="call"></p>
<p>（圖片來源：<a target="_blank" rel="noopener" href="http://blog.koba04.com/post/2017/04/25/a-state-of-react-fiber/">React Fiber現状確認</a>）</p>
<p>這樣會造成什麼問題呢？因為你的 call stack 太深而且東西太多，再加上這個過程又是不能被中斷的，會導致 main thread 被 block 住，在這時間之內你做任何事情，瀏覽器都不會有反應。</p>
<p>簡單來說呢，就是因為要做的事太多，所以 main thread 就會 block 住了，這就是 React 在效能上會碰到的一個問題。</p>
<p>到這邊，我們已經回答第一個問題了，Fiber 就是為了解決這個問題而產生的解法。接著我們來回答第二個問題：解決方法是什麼？</p>
<blockquote>
<p>既然問題的成因是：「要做的事情太多又不能中斷」，那我們只要發明一個「可以中斷」的機制就好啦！不要一次全部更新，而是增量更新（incremental rendering），就可以解決這個問題了！</p>
</blockquote>
<p>比起原本的一次性更新，假如我們能夠把要更新的工作切成一個個小的工作，每次只執行一個小工作，那這樣 main thread 就不會被 block 住了，因為每個小工作之間都可以有空檔去做別的事情（響應使用者的點擊、繪製新的畫面等等）。</p>
<p>就像下面這張示意圖一樣，每次完成一點點的工作，而不是一次完成全部的：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351571-06699700-f6ef-11e8-916a-a100a6c17974.png" alt="cartoon"></p>
<p>（圖片來源：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017
</a>）</p>
<p>好了，你已經知道什麼是 Fiber 了，這就是 Fiber。每一個小工作就叫做 Fiber，而 Fiber 在英文裡面是纖維的意思，所以又有人把這個機制稱作「纖程」。</p>
<p>或是換個角度想，原本的問題是因為程式裡面這樣子一層層執行 render function 的方法是透過 call stack，每次 call 一個 function 就把一個新的任務丟到 stack frame 去，可是這樣子的機制會導致任務無法中斷。</p>
<p>於是 Fiber 就實作出了 virtual stack frame，簡單來說就是自己用 js 再模擬出一個 call stack 的感覺，但好處就是自己有完全的掌控權，而不是被 js 的運行機制給綁住。</p>
<p>再幫大家重新整理一次，沒有 Fiber 之前，你要更新的時候都是「一次性」的更新，中間無法中斷，導致 main thread 在這期間會被 block 住。</p>
<p>有了 Fiber 這個機制之後，我們把一個大更新切成很多塊小的更新，每次只更新一點點，這樣子在更新的空檔 main thread 就能去做其他事情，而不會被綁住。</p>
<p>聽起來十分美好，問題迎刃而解，可是副作用是什麼呢？</p>
<h2><span id="fiber-所帶來的改變">Fiber 所帶來的改變</span></h2><p>把核心換成 Fiber 之後，是要付出一些代價的。在 Fiber 裡面的工作其實分成兩個階段：</p>
<ol>
<li>render&#x2F;reconciliation</li>
<li>commit</li>
</ol>
<p>簡單來說呢，第一階段就是找出需要改變的部分，而第二階段是真正的把這些改變應用到 DOM 上面去。第一階段是可以被中斷，也可以被重新執行的，而第二階段跟以前一樣，必須一口氣做完。</p>
<p>而這兩個階段也對應到不同的生命週期：</p>
<h3><span id="第一階段">第一階段</span></h3><ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
</ul>
<h3><span id="第二階段">第二階段</span></h3><ul>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
<p>因為第一階段是可以中斷並且之後再重新執行的，所以會導致在第一階段裡的這些函數，有可能被 call 很多次。</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351577-09fd1e00-f6ef-11e8-8cc5-9e0f849ad52a.png" alt="life"></p>
<p>（圖片來源：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017
</a>）</p>
<p>所以，假設你之前習慣在<code>componentWillMount</code>裡面就呼叫 API 拿資料的話，就會導致你 call 了不只一次的 API，會浪費一些頻寬，要改變的話就要把這些 code 移到<code>componentDidMount</code>去，就只會保證被 call 一次而已。</p>
<p>總之呢，自從內部機制改成 Fiber 之後（從 React 16 開始，所以如果你是用 16 以上的版本，已經是 Fiber 了），React 的生命週期函數被呼叫的次數跟方式會跟以前不太一樣。</p>
<p>除此之外就是我開頭提的那個順序的不一樣，這點也是值得注意的一個部分。雖然看起來不是什麼大問題，但如果不知道這點的話可能會生出一些莫名其妙的 Bug。</p>
<h2><span id="react-的未來">React 的未來</span></h2><p>React 16.3 在昨天<a target="_blank" rel="noopener" href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html">正式發佈</a>了，伴隨而來的是正式的 context API 以及 lifecycle 的改變。</p>
<p>隨著 Fiber 的正式上線，未來可以期待會有更多令人興奮的新功能。比如說在<a target="_blank" rel="noopener" href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Sneak Peek: Beyond React 16</a>這篇提到的<code>time slicing</code>，把整個 App 的體驗變得更順暢。</p>
<p>而<a target="_blank" rel="noopener" href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html">Update on Async Rendering</a>這篇文章也提到了非同步渲染的進展。</p>
<p>自從內部的機制改成 Fiber 之後，就讓 async rendering 得以發揮最大的效能。</p>
<p>但為了 async rendering，是需要付出一些代價的。原本的 lifecycle API 在這種場景底下可能會有一些問題，官方有給出許多常見的例子，也包含我們上面所說到的，<code>componentWillMount</code>會被呼叫多次的問題：</p>
<p>（忽略原本的範例程式碼，但大意就是在<code>componentWillMount</code>裡面 call API）</p>
<blockquote>
<p>The above code is problematic for both server rendering (where the external data won’t be used) and the upcoming async rendering mode (where the request might be initiated multiple times).</p>
</blockquote>
<blockquote>
<p>The recommended upgrade path for most use cases is to move data-fetching into componentDidMount</p>
</blockquote>
<p>對於 async rendering，會引起問題的是以下三個生命週期：</p>
<ol>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>componentWillUpdate</li>
</ol>
<p>這三個 lifecycle 會在 React 17 裡面被拿掉（如果你還是想用的話可以加上<code>UNSAFE_</code>，例如說改成<code>UNSAFE_componentWillMount</code>就一樣可以用），但既然都說是 UNSAFE 了，沒有理由繼續使用下去。</p>
<p>舊的不去新的不來，在最新發佈的 16.3 中，引入了兩個新的 lifecycle 來解決上面的那些問題：</p>
<ol>
<li>getDerivedStateFromProps</li>
<li>getSnapshotBeforeUpdate</li>
</ol>
<p>第一個很顯然是要來取代<code>componentWillReceiveProps</code>的，而第二個是拿來取代<code>componentWillUpdate</code>的。或其實有些場景底下，用<code>componentDidUpdate</code>也可以取代原本那兩個生命週期。</p>
<p>至於最前面所提到的<code>componentWillMount</code>，則建議把裡面的程式碼搬到<code>componentDidMount</code>去。</p>
<p>接著讓我們快速來看一下新的生命週期如何替代舊的，以下我就直接使用官方給的範例了。這個範例會偵測 props 來決定要不要改變 state，是很常見的應用場景：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Before</span>
<span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">&#123;</span>
  state <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">isScrollingDown</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  
  <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>currentRow <span class="token operator">!==</span> nextProps<span class="token punctuation">.</span>currentRow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
        <span class="token literal-property property">isScrollingDown</span><span class="token operator">:</span>
          nextProps<span class="token punctuation">.</span>currentRow <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>currentRow<span class="token punctuation">,</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而新的生命週期<code>static getDerivedStateFromProps</code>，會在 component 被建立還有收到新的 props 的時候被呼叫，但只會傳入新的 props 跟舊的 state，因此我們可以這樣改：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// After</span>
<span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 初始化 state</span>
  state <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">isScrollingDown</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">lastRow</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  
  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 把新的 props 跟舊的 state 做比較</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>currentRow <span class="token operator">!==</span> prevState<span class="token punctuation">.</span>lastRow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 回傳新的 state</span>
      <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
        <span class="token literal-property property">isScrollingDown</span><span class="token operator">:</span> nextProps<span class="token punctuation">.</span>currentRow <span class="token operator">></span> prevState<span class="token punctuation">.</span>lastRow<span class="token punctuation">,</span>
        <span class="token literal-property property">lastRow</span><span class="token operator">:</span> nextProps<span class="token punctuation">.</span>currentRow<span class="token punctuation">,</span> <span class="token comment">// 同步一下 state</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  
    <span class="token comment">// return null 代表不用改變 state</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其實說穿了就只是你自己把以前<code>componentWillReceiveProps</code>會傳來的<code>prevProps</code>存到 state 裡面，改成跟 state 來比較而已。</p>
<p>看到這邊你可能會很疑惑：「那為什麼 getDerivedStateFromProps 不直接把 prevProps 傳進來就好？」</p>
<p>React 官方給的理由有兩個：</p>
<ol>
<li>因為 getDerivedStateFromProps 在初始化的時候也會被 call，所以第一次的 prevProps 會是 null，代表你每次都要做一次 null check，這樣不好</li>
<li>不傳 prevProps 就代表 React 不用幫你記住 prevProps 了，對未來在記憶體上面的優化有幫助</li>
</ol>
<p>總之呢，以後就不會有<code>componentWillReceiveProps</code>可以用了，你要自己把需要的<code>prevProps</code>保存在 state 裡面，並且在<code>getDerivedStateFromProps</code>裡面進行比較。</p>
<p>再看另外一個例子，這個例子的目的是要在新增 item 的時候維持捲軸的位置，所以必須在 update 之前保存舊的高度，在 update 之後去調整捲軸的位置：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">ScrollingList</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">&#123;</span>
  listRef <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  previousScrollHeight <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  
  <span class="token function">componentWillUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 有新增 item 的話，記住現在的高度</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> nextProps<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>previousScrollHeight <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  
  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果 previousScrollHeight 不是 null，代表有新增 item</span>
    <span class="token comment">// 調整捲軸位置</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>previousScrollHeight <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>scrollTop <span class="token operator">+=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>scrollHeight <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>previousScrollHeight<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>previousScrollHeight <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>setListRef<span class="token punctuation">&#125;</span><span class="token operator">></span>
        <span class="token punctuation">&#123;</span><span class="token comment">/* ...contents... */</span><span class="token punctuation">&#125;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  
  <span class="token function-variable function">setListRef</span> <span class="token operator">=</span> <span class="token parameter">ref</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>listRef <span class="token operator">=</span> ref<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>那這樣子會帶來的問題是什麼呢？還記得我們前面有提過 Fiber 有兩個階段嗎？render 跟 commit。這兩個階段會有時間差，而<code>componentWillUpdate</code>是處於第一個階段，<code>componentDidUpdate</code>是屬於第二個階段。</p>
<p>假如使用者在這兩個階段之間做了一些事情，例如說調整視窗的尺寸，那你存的高度就不會是正確的了，而是會拿到舊的值。</p>
<p>解決方法就是利用新的生命週期<code>getSnapshotBeforeUpdate</code>，這個會在 DOM 被更新之前呼叫，可以保證你拿到的東西一定是最新的。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">ScrollingList</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">&#123;</span>
  listRef <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  
  <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果 list 有變動，就回傳現在的捲軸高度</span>
    <span class="token comment">// 這個回傳值會被當作 componentDidUpdate 的第三個參數</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevProps<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  
  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> snapshot</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// snapshot 就是上面回傳的那個值</span>
    <span class="token comment">// 如果不是 null，就利用 snapshot 來調整捲軸高度</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>snapshot <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>scrollTop <span class="token operator">+=</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>scrollHeight <span class="token operator">-</span> snapshot<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>setListRef<span class="token punctuation">&#125;</span><span class="token operator">></span>
        <span class="token punctuation">&#123;</span><span class="token comment">/* ...contents... */</span><span class="token punctuation">&#125;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  
  <span class="token function-variable function">setListRef</span> <span class="token operator">=</span> <span class="token parameter">ref</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>listRef <span class="token operator">=</span> ref<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>總之呢，結合搭配使用 commit phase 的 lifecycle（<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount </code>）以及新引進的<code>getDerivedStateFromProps</code>與<code>getSnapshotBeforeUpdate </code>，就可以取代掉舊的那些有可能會造成問題的 lifecycle。</p>
<p>如果想要看更多範例的話，這篇很值得參考：<a target="_blank" rel="noopener" href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html">Update on Async Rendering</a>。</p>
<h2><span id="結論">結論</span></h2><p>效能一直是 Web App 很注重的一個點，而需要把握的原則就只有一個：不要 block main thread。只要 main thread 可以做事，它就可以去處理其他事情，例如說響應使用者的 click 或是繪製新的畫面等等。</p>
<p>而 React 原本的機制會造成問題，因此將內部核心用 Fiber 改寫，把一大個不可中斷的任務切割成許多小的、可以中斷的工作，而可以切割之後也使得以後有平行化的可能，render 的速度可能又會更快一點。</p>
<p>但也因為這樣機制的改變，影響到原本的生命週期，一個不小心就會出狀況，而官方也發布了新的兩個生命週期來解決這個問題。</p>
<p>身為 React 長期的使用者，對這種大的改變雖然覺得要改 code 很煩，但長期來看其實是利多，畢竟可以做的事情又更多了，效能也會愈來愈好。</p>
<p>這篇總結了近期我研究 Fiber 跟關注 React 新的變化的一些心得，Fiber 底層的實作機制因為我也不是很理解，所以不敢出來班門弄斧，只希望能透過白話文讓大家理解這個機制大概是長怎樣。</p>
<p>如果有哪邊有講錯，還麻煩不吝指正，感謝。</p>
<p>參考資料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/acdlite/react-fiber-architecture">React Fiber Architecture</a></li>
<li><a target="_blank" rel="noopener" href="https://giamir.com/what-is-react-fiber">What is React Fiber ?</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/xieyu/blog/blob/master/React/from-jsx-to-dom.md">React中state render到html dom的流程分析</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ayqy.net/blog/dive-into-react-fiber/">完全理解React Fiber</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@_cybai/%E7%BF%BB%E8%AD%AF-react-fiber-%E7%8F%BE%E7%8B%80%E7%A2%BA%E8%AA%8D-fd3808072279">[翻譯] React Fiber 現狀確認</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html">React v16.3.0: New lifecycles and context API</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/design-principles.html#scheduling">React Docs - Scheduling</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.youzan.com/react-fiber/">浅谈React 16中的Fiber机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017</a></li>
</ol>

    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/React/">#React</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Front-end/">#Front-end</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2018/06/23/javascript-call-by-value-or-reference/">深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2018/03/12/css-keylogger/">CSS keylogger：攻擊與防禦</a>
            
        </span>
    </div>
    
</article>




<div class="comments">
    <h3 class="title is-4">評論</h3>
    <script src="https://utteranc.es/client.js"
        repo="aszx87410/huli-blog"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</div>

    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2024 Huli&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow" title="GitHub" target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
<div class="column is-narrow has-text-centered">
    <div class="dropdown is-up is-right is-hoverable" style="margin-top: -0.2em;">
        <div class="dropdown-trigger">
            <button class="button is-small" aria-haspopup="true">
                <span class="icon">
                    <i class="fas fa-globe"></i>
                </span>
                <span>繁體中文</span>
                <span class="icon is-small">
            <i class="fas fa-angle-down" aria-hidden="true"></i>
          </span>
            </button>
        </div>
        <div class="dropdown-menu has-text-left" role="menu" style="top:100%">
            <div class="dropdown-content">
            <!-- NOTE: 永遠回到首頁 -->
            
                <a href="/2018/03/31/en/react-fiber-and-lifecycles/" class="dropdown-item">
                    English
                </a>
            
            </div>
        </div>
    </div>
</div>

        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>



    
    
    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="/js/script.js?v=3.js"></script>


    
</body>
</html>